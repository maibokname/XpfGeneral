var tipuesearch = {"pages":[{"title":" eXPerimental Fortran Library (XpfLib) Documentation ","text":"eXPerimental Fortran Library (XpfLib) Documentation XpfHashFunc: eXPerimental Fortran HashFunc Package XpfHashFunc is an experimenal package written in Fortran.   It is a sub-package of the XpfGeneral package (a larger package within the XpfLib library), which contains a large collection of general-purpose modules.  The XpfHashFunc package consists of a large number of modules that implement many hash function algorithms.  The package provides both non-secure hash functions and secure (cryptographic)  hash functions. The source code of the XpfHashFunc package is organized into 3 main subfolders of the XpfHashFunc folder.   A brief overview of the source code is given below. The HashUtil subfolder contains two auxiliary modules for hash-function computations.  The MBase_BytePack module provides utility routines for conversion of bit patterns between a byte array (an array of 8-bit integers) and other integer types.  Similarly, the MClass_ByteConverter module provides the ByteConverter type that can be used to perform a conversion of bit patterns between a byte array (an array of 8-bit integers) and other integer types. The HashGeneral subfolder consists of four subfolders for various non-secure hash function implementations. The Experimental subfolder contains two modules (and several submodules) that provide an experimental implementation of the non-secure hash function algorithms (one for 32-bit hash output and one for 64-bit hash output). Similary, the Reference subfolder provides a reference implementation whereas the Optimal subfolder provides an optimal implementation of the non-secure hash function algorithms. The Hasher subfolder contains a number of modules where each particular module provides an object-oriented implementation of a hasher that represents an incremental non-secure hash function for one particular algorithm. The HashSecure subfolder contains seven subfolders that provide an object-oriented implementation of various secure hash function algorithms. The Base subfolder consists of three modules where each module contains an abstract data type representing a message digest object, which is an incremental cryptographic hash function .  The BaseDigest type is a base type that defines the application programming interface (API) for a message digest object.  The other two types are subtypes of the BaseDigest type that define additional methods and implement some deferred procedures.  All other derived types are extended from these abstract types. The Blake subfolder contains several modules and submodules that provide a family of message digest objects based on the BLAKE message-digest algorithms. The Keccak subfolder contains several modules that provide a family of message digest objects based on the Keccak message-digest algorithms. The MD subfolder contains several modules that provide a family of message digest objects based on the MD message-digest algorithms. The SHA subfolder contains several modules that provide a family of message digest objects based on the SHA message-digest algorithms. The NIST_Final subfolder contains several modules that provide several message digest objects based on various message-digest algorithms that were accepted for the final round of the NIST hash function competition . The NIST_Round2 subfolder contains a number of modules that provide a number of message digest objects based on various message-digest algorithms that were accepted for round two in the NIST competition. Dependencies The XpfHashFunc pacakge is primarily dependent on the XpfBase and XpfRandom packages. Documentation The FORD program can be used to automatically generate the documentation of the XpfHashFunc package via ford XpfHashFuncDoc.md . Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"HamsiB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: HamsiB HamsiB is a concrete digest type that implements an incremental\n cryptographic hash function based on the Hamsi hash algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => HamsiB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (HamsiB-512). private  subroutine HamsiB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object procedure, public :: Reset => HamsiB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine HamsiB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object procedure, public :: GetClone => HamsiB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine HamsiB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => HamsiB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function HamsiB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(in) :: MD 'HamsiB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: InsertBytes => HamsiB_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine HamsiB_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => HamsiB_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine HamsiB_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => HamsiB_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine HamsiB_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => HamsiB_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine HamsiB_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: GetDigestLen => HamsiB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function HamsiB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(in) :: MD 'HamsiB' object Return Value integer(kind=kInt32) the digest length generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Hamsi-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the Hamsi-384 algorithm --->    CALL MD%Create(IsHamsi384=.TRUE.) private  subroutine HamsiB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object private  subroutine HamsiB_Initialize_wFlag(MD, IsHamsi384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object logical, intent(in) :: IsHamsi384 flag indicating whether the Hamsi-384 algorithm is employed or not. - If true, use the Hamsi-384 algorithm. - Otherwise, use the Hamsi-512 algorithm. generic, public :: AddBitsNDigest => HamsiB_ByteDigest_AddBits, HamsiB_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine HamsiB_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HamsiB_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( HamsiB ), intent(inout) :: MD 'HamsiB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , EXTENDS ( BaseDigest ) :: HamsiB PRIVATE !% state tInteger :: State ( 0 : 15 ) = IV512 ( 0 : 15 ) !% buffer tByte :: Partial ( 0 : 7 ) = 0_kInt8 !% number of bytes used in the buffer tIndex :: PartialLen = 0_kIndex !% bit count tLong :: BitCount = 0_kInt64 !% flag indicating whether the Hamsi-384 algorithm is employed or not. tLogical :: IsHamsi384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: HamsiB_ByteDigest_AddBits PROCEDURE , PRIVATE :: HamsiB_HexDigest_AddBits !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => HamsiB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (HamsiB-512). PROCEDURE :: Initialize => HamsiB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => HamsiB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => HamsiB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => HamsiB_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => HamsiB_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => HamsiB_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => HamsiB_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => HamsiB_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => HamsiB_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Hamsi-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Hamsi-384 algorithm <br> !   --->    CALL MD%Create(IsHamsi384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => HamsiB_ByteDigest_AddBits , & HamsiB_HexDigest_AddBits ! --------------------------------------------------------------------- END TYPE HamsiB","tags":"","loc":"type\\hamsib.html"},{"title":"FarmUoHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: FarmUoHasher64 FarmUoHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the FarmUo hash algorithm by Google Inc. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => FarmUo_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function FarmUo_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => FarmUo_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function FarmUo_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => FarmUo_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine FarmUo_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => FarmUo_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine FarmUo_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => FarmUo_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with one seed. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine FarmUo_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSeeds => FarmUo_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value private  subroutine FarmUo_Initialize_WithSeeds(HS, Seed1, Seed2, RemoveSign) To initialize the hasher with two seeds. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => FarmUo_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function FarmUo_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => FarmUo_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally)\n               without seed or with one seed. Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function FarmUo_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: HashDirectWSeeds => FarmUo_HashDirect_WithSeeds Type-Bound Function : HashDirectWSeeds Purpose :  To compute the hash value directly (non-incrementally)\n               with two seeds. Usage : --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function FarmUo_HashDirect_WithSeeds(HS, Input, InpSize, Seed1, Seed2, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) with two seeds. Arguments Type Intent Optional Attributes Name class( FarmUoHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: FarmUoHasher64 PRIVATE !% seeds tUInt64 :: Seed ( 2 ) = 0_kInt64 !% state tUInt64 :: State ( 8 ) = 0_kInt64 !% multiplier tUInt64 :: Mul = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => FarmUo_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => FarmUo_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => FarmUo_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => FarmUo_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with one seed. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => FarmUo_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => FarmUo_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => FarmUo_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                without seed or with one seed. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => FarmUo_HashDirect !> **Type-Bound Function**: HashDirectWSeeds <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                with two seeds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSeeds => FarmUo_HashDirect_WithSeeds END TYPE FarmUoHasher64","tags":"","loc":"type\\farmuohasher64.html"},{"title":"EChoS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: EChoS EChoS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the ECHO-224 or the ECHO-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => EChoS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (ECHO-256). private  subroutine EChoS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object procedure, public :: Reset => EChoS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine EChoS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object procedure, public :: GetClone => EChoS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine EChoS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => EChoS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function EChoS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(in) :: MD 'EChoS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => EChoS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function EChoS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( EChoS ), intent(in) :: MD 'EChoS' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => EChoS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function EChoS_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(in) :: MD 'EChoS' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => EChoS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine EChoS_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout), TARGET :: MD 'EChoS' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => EChoS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine EChoS_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => EChoS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine EChoS_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => EChoS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine EChoS_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (ECHO-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the ECHO-224 algorithm --->    CALL MD%Create(IsECHO224=.TRUE.) private  subroutine EChoS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object private  subroutine EChoS_Initialize_wFlag(MD, IsECHO224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( EChoS ), intent(inout) :: MD 'EChoS' object logical, intent(in) :: IsECHO224 flag indicating whether the ECHO-224 algorithm is employed or not. - If true, use the ECHO-224 algorithm. - Otherwise, use the ECHO-256 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: EChoS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: V ( 0 : 15 ) = 0 tInteger :: C ( 0 : 3 ) = 0 !% flag indicating whether the ECHO-224 algorithm is employed or not. tLogical :: IsECHO224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => EChoS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (ECHO-256). PROCEDURE :: Initialize => EChoS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => EChoS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => EChoS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => EChoS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => EChoS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => EChoS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => EChoS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => EChoS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => EChoS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => EChoS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (ECHO-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the ECHO-224 algorithm <br> !   --->    CALL MD%Create(IsECHO224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE EChoS","tags":"","loc":"type\\echos.html"},{"title":"WaterHasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher32 ) :: WaterHasher32 WaterHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the Water hash algorithm by Tommy Ettinger. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Water_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Water_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Water_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Water_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Water_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Water_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Water_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Water_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Water_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Water_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Water_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Water_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure, public :: HashDirect => Water_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Water_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( WaterHasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( Hasher32 ) :: WaterHasher32 PRIVATE !% state tUInt64 :: State = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 15 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Water_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Water_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Water_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Water_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Water_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Water_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Water_HashDirect END TYPE WaterHasher32","tags":"","loc":"type\\waterhasher32.html"},{"title":"Blake2Core – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseDigest ) :: Blake2Core Blake2Core is an abstract digest type provided to be a parent type\n for other Blake2-based digest types to implement incremental cryptographic\n hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. subroutine MDCreate(MD) Prototype MDCreate is a deferred procedure to perform any essential initialization\n of a digest object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() subroutine MDReset(MD) Prototype MDReset is a deferred procedure to reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) subroutine MDClone(Src, Dst) Prototype MDClone is a deferred procedure to clone the current state. The returned\n object evolves independently of this object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: Src a source digest object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination (clone) digest object procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() function MDName(MD) result(Name) Prototype MDName is a deferred procedure to get the display name for this hash\n function (e.g. \"SHA-1\" for SHA-1). Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(in) :: MD 'BaseDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure(BCSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the BCSetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine BCSetPtr(MD, BufPtr) Prototype BCSetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout), TARGET :: MD Blake2Core object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(BCProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the BCProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine BCProcess(MD, BytesIn, LastBlock) Prototype BCProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD Blake2Core object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block logical, intent(in) :: LastBlock true if input block is the last one procedure(BCEncode), public, deferred :: EncodeOutput EncodeOutput is a binding name of the BCEncode deferred procedure. This procedure is NOT intended to be used by a user. subroutine BCEncode(MD, BytesOut) Prototype BCEncode is a deferred procedure to perform the encoding of the output data\n (e.g. unpacking the state variables into the output data). Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Blake2Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Blake2Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Blake2Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Blake2Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. private  subroutine Blake2Core_Init(MD, BlockLen, DigestLen, Key) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt32), intent(in) :: BlockLen block length integer(kind=kInt32), intent(in) :: DigestLen digest length integer(kind=kInt8), intent(in), optional :: Key (0:) key procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: SrcMD source object class( Blake2Core ), intent(inout) :: DstMD destination object procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function Blake2Core_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) number of bytes procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. private  function Blake2Core_KeyLen(MD) result(Length) To get key length (in bytes). Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Key' object Return Value integer(kind=kInt32) the key length procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Blake2Core_DigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) digest length Source Code TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: Blake2Core PRIVATE !% the number of bytes of input currently stored in the buffer array tIndex :: BufLen = 0_kIndex !% the size in bytes of hash output tIndex :: DigestLen = 32_kIndex !% the size in bytes of the buffer array tIndex :: BlockLen = 64_kIndex !% a copy of the specified key for keyed hashing tByte , ALLOCATABLE :: Key (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Additional Deferred Procedures            ----- ! --------------------------------------------------------------------- !> *SetBufPtr* is a binding name of the *BCSetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCSetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *BCProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCProcess ), DEFERRED :: ProcessBlock !> *EncodeOutput* is a binding name of the *BCEncode* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCEncode ), DEFERRED :: EncodeOutput ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Blake2Core_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Blake2Core_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Blake2Core_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *CoreInit* is a procedure to initialize the Blake2Core's components. <br> !  This procedure is NOT intended to be used by a user but all initialization procedures !  implemented by a *concrete* digest type should call this method. PROCEDURE :: CoreInit => Blake2Core_Init !> *CoreReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: CoreReset => Blake2Core_Reset !> *CoreClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: CoreClone => Blake2Core_Clone !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => Blake2Core_BufLen !> *GetKeyLen* is a procedure to get the length of the specified key. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetKeyLen => Blake2Core_KeyLen !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the hash output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake2Core_DigestLen ! --------------------------------------------------------------------- END TYPE Blake2Core","tags":"","loc":"type\\blake2core.html"},{"title":"Blake1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: Blake1B Blake1B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BLAKE-384 or the BLAKE-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Blake1B_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BLAKE-512). private  subroutine Blake1B_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object procedure, public :: Reset => Blake1B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Blake1B_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object procedure, public :: GetClone => Blake1B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Blake1B_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Blake1B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Blake1B_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(in) :: MD 'Blake1B' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => Blake1B_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Blake1B_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(in) :: MD 'Blake1B' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => Blake1B_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function Blake1B_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(in) :: MD 'Blake1B' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Blake1B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Blake1B_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout), TARGET :: MD 'Blake1B' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Blake1B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1B_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => Blake1B_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1B_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => Blake1B_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1B_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BLAKE-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the BLAKE-384 algorithm --->    CALL MD%Create(IsBLAKE384=.TRUE.) private  subroutine Blake1B_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object private  subroutine Blake1B_Initialize_wFlag(MD, IsBLAKE384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( Blake1B ), intent(inout) :: MD 'Blake1B' object logical, intent(in) :: IsBLAKE384 flag indicating whether the BLAKE-384 algorithm is employed or not. - If true, use the BLAKE-384 algorithm. - Otherwise, use the BLAKE-512 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: Blake1B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tLong :: H ( 0 : 7 ) = IV512 ( 0 : 7 ) tLong :: S ( 0 : 3 ) = 0_kInt64 tLong :: T ( 0 : 1 ) = 0_kInt64 !% flag indicating whether the BLAKE-384 algorithm is employed or not. tLogical :: IsBLAKE384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => Blake1B_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BLAKE-512). PROCEDURE :: Initialize => Blake1B_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake1B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake1B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake1B_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake1B_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Blake1B_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake1B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake1B_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Blake1B_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Blake1B_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BLAKE-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BLAKE-384 algorithm <br> !   --->    CALL MD%Create(IsBLAKE384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE Blake1B","tags":"","loc":"type\\blake1b.html"},{"title":"Luffa – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: Luffa Luffa is a concrete digest type that implements an incremental\n cryptographic hash function based on the Luffa hash functions. Finalization Procedures final :: Luffa_Finalize private  subroutine Luffa_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( Luffa ), intent(inout) :: MD 'Luffa' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Luffa_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Luffa-256). private  subroutine Luffa_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object procedure, public :: Reset => Luffa_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Luffa_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object procedure, public :: GetClone => Luffa_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Luffa_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Luffa_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Luffa_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(in) :: MD 'Luffa' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => Luffa_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Luffa_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Luffa ), intent(in) :: MD 'Luffa' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => Luffa_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function Luffa_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(in) :: MD 'Luffa' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Luffa_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Luffa_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout), TARGET :: MD 'Luffa' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Luffa_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Luffa_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => Luffa_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Luffa_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => Luffa_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Luffa_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Luffa-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Luffa-512 algorithm --->    CALL MD%Create(512) private  subroutine Luffa_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout) :: MD 'Luffa' object private  subroutine Luffa_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( Luffa ), intent(inout), TARGET :: MD 'Luffa' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. Source Code TYPE , EXTENDS ( MDEngine ) :: Luffa PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and its storage tInteger :: Store ( 0 : 7 , 0 : 4 ) = 0 tInteger , POINTER :: State (:,:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => Luffa_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Luffa-256). PROCEDURE :: Initialize => Luffa_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Luffa_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Luffa_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Luffa_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Luffa_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Luffa_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Luffa_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Luffa_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Luffa_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Luffa_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Luffa-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Luffa-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity ! --------------------------------------------------------------------- FINAL :: Luffa_Finalize ! --------------------------------------------------------------------- END TYPE Luffa","tags":"","loc":"type\\luffa.html"},{"title":"XXHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: XXHasher64 XXHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the XX hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => XX_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function XX_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => XX_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function XX_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => XX_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => XX_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => XX_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine XX_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => XX_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function XX_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => XX_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XXHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: XXHasher64 PRIVATE !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX_HashDirect END TYPE XXHasher64","tags":"","loc":"type\\xxhasher64.html"},{"title":"Kangaroo – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: Kangaroo Kangaroo is a concrete Keccak-based digest type that implements an incremental\n cryptographic hash function by employing either the KangarooTwelve or the MarsupilamiFourteen message-digest algorithm. Finalization Procedures final :: Kangaroo_Finalize private  subroutine Kangaroo_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( Kangaroo ), intent(inout) :: MD 'Kangaroo' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Kangaroo_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (KangarooTwelve)\n and default hash output length. private  subroutine Kangaroo_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object procedure, public :: GetClone => Kangaroo_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Kangaroo_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Kangaroo_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Kangaroo_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(in) :: MD 'Kangaroo' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Reset => Kangaroo_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Kangaroo_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object procedure, public :: InsertBytes => Kangaroo_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Kangaroo_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Kangaroo_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Kangaroo_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Kangaroo_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Kangaroo_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Kangaroo_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Kangaroo_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: GetDigestLen => Kangaroo_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Kangaroo_GetDigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(in) :: MD 'KP1600_Core' object Return Value integer(kind=kInt32) digest length generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (KangarooTwelve) algorithm and default output length --->    CALL MD%Create() ! employ the MarsupilamiFourteen algorithm and default output length --->    CALL MD%Create(IsMarsupilami14=.TRUE.) ! employ the KangarooTwelve algorithm with specified output length --->    CALL MD%Create(IsMarsupilami14=.FALSE., OutputLen=32) ! employ the KMarsupilamiFourteen algorithm with specified output length --->    CALL MD%Create(IsMarsupilami14=.TRUE., OutputLen=64) private  subroutine Kangaroo_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object private  subroutine Kangaroo_Initialize_wOption(MD, IsMarsupilami14, OutputLen, Custom) To perform initialization of the digest object with the specified options. Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object logical, intent(in) :: IsMarsupilami14 flag indicating whether the MarsupilamiFourteen algorithm is employed or not. - If true, use the MarsupilamiFourteen algorithm. - Otherwise, use the KangarooTwelve algorithm. integer(kind=kInt32), intent(in), optional :: OutputLen the hash output length in bytes (must be positive; otherwise,\n the default length produced). integer(kind=kInt8), intent(in), optional, TARGET :: Custom (:) an array of (8-bit integers) bytes representing the customization bit string (S) generic, public :: DigestWOutLen => Kangaroo_ByteDigest_wOutLen, Kangaroo_ByteDigest_wInputNOutLen, Kangaroo_HexDigest_wOutLen, Kangaroo_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored. private  subroutine Kangaroo_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Kangaroo_ByteDigest_wInputNOutLen(MD, Input, InpSize, ByteArr, OutputLen) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'Kangaroo' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Kangaroo_HexDigest_wOutLen(MD, HexStr, OutputLen) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Kangaroo_HexDigest_wInputNOutLen(MD, Input, InpSize, HexStr, OutputLen) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( Kangaroo ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes Source Code TYPE , EXTENDS ( BaseDigest ) :: Kangaroo PRIVATE !% sponge instance for queue node TYPE ( KP1600Sponge ) :: QueueNode ! sponge instance for final node TYPE ( KP1600Sponge ) :: FinalNode !% customization string tByte , POINTER :: Custom (:) => NULL () !% block number tIndex :: BlockNumber = 0_kIndex !% length of input queue absorbed tIndex :: QueueAbsorbedLen = 0_kIndex !% the value of the capacity in bits tInteger :: Capacity = 256 !% the length of output message in bytes tIndex :: DigestLen = 16_kIndex !% the number of permutation rounds tInteger :: NRounds = 12 !% flag indicating whether the MarsupilamiFourteen algorithm is employed or not. tLogical :: IsMarsupilami14 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: DoInit => Kangaroo_DoInit PROCEDURE , PRIVATE :: DoUpdate => Kangaroo_DoUpdate PROCEDURE , PRIVATE :: DoFinal => Kangaroo_DoFinal !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => Kangaroo_Initialize_wOption PROCEDURE , PRIVATE :: Kangaroo_ByteDigest_wOutLen PROCEDURE , PRIVATE :: Kangaroo_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: Kangaroo_HexDigest_wOutLen PROCEDURE , PRIVATE :: Kangaroo_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (KangarooTwelve) !  and default hash output length. PROCEDURE :: Initialize => Kangaroo_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Kangaroo_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Kangaroo_GetName !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Kangaroo_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Kangaroo_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Kangaroo_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Kangaroo_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Kangaroo_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Kangaroo_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (KangarooTwelve) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the MarsupilamiFourteen algorithm and default output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.TRUE.) <br> !   ! employ the KangarooTwelve algorithm with specified output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.FALSE., OutputLen=32) <br> !   ! employ the KMarsupilamiFourteen algorithm with specified output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.TRUE., OutputLen=64) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => Kangaroo_ByteDigest_wOutLen , & Kangaroo_ByteDigest_wInputNOutLen , & Kangaroo_HexDigest_wOutLen , & Kangaroo_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- FINAL :: Kangaroo_Finalize ! --------------------------------------------------------------------- END TYPE Kangaroo","tags":"","loc":"type\\kangaroo.html"},{"title":"cSHAKE – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( KP1600Core ) :: cSHAKE cSHAKE is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function by employing either the cSHAKE-128 or the cSHAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine KP1600Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine KP1600Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine KP1600Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine KP1600Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine KP1600Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. private  subroutine KP1600Core_Initialize(MD, Capacity, Suffix, DigestLen, NRounds) To initialize components of the 'KP1600Core' object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt32), intent(in) :: Capacity the value of the capacity C integer(kind=kInt8), intent(in) :: Suffix suffix for padding integer(kind=kInt32), intent(in) :: DigestLen the desired length of output in bytes integer(kind=kInt32), intent(in), optional :: NRounds number of permutation rounds procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. private  subroutine KP1600Core_CopyState(SrcMD, DstMD) To copy essential components of the source digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: SrcMD source object class( KP1600Core ), intent(inout) :: DstMD destination object procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). private  subroutine KP1600Core_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function KP1600Core_GetDigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in) :: MD 'KP1600_Core' object Return Value integer(kind=kInt32) digest length procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() private  function KP1600Core_GetSponge(MD) result(Sponge) To return the sponge component of the digest object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in), TARGET :: MD 'KP1600_Core' object Return Value type( KP1600Sponge ), POINTER sponge object generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits private  subroutine KP1600Core_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine KP1600Core_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => cSHAKE_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (cSHAKE-128)\n and default hash output length, and without customization parameters. private  subroutine cSHAKE_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length, and\n without customization parameters. Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'cSHAKE' object procedure, public :: GetClone => cSHAKE_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine cSHAKE_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => cSHAKE_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function cSHAKE_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(in) :: MD 'cSHAKE' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (cSHAKE-256) algorithm and default output length --->    CALL MD%Create() ! employ the cSHAKE-256 algorithm and default output length --->    CALL MD%Create(IscSHAKE256=.TRUE.) ! employ the cSHAKE-128 algorithm with specified output length --->    CALL MD%Create(IscSHAKE256=.FALSE., OutputLen=64) ! employ the cSHAKE-256 algorithm with specified output length --->    CALL MD%Create(IscSHAKE256=.TRUE., OutputLen=128) ! employ the cSHAKE-128 algorithm with customization parameters --->    CALL MD%Create(IscSHAKE256=.FALSE., Name=FuncStr, Custom=CustomStr) private  subroutine cSHAKE_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length, and\n without customization parameters. Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'cSHAKE' object private  subroutine cSHAKE_Initialize_wOption(MD, IscSHAKE256, OutputLen, Name, Custom, CustomBitLen) To perform initialization of the digest object with the specified\n options and customization parameters. Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'cSHAKE' object logical, intent(in) :: IscSHAKE256 flag indicating whether the cSHAKE-256 algorithm is employed or not. - If true, use the cSHAKE-256 algorithm. - Otherwise, use the cSHAKE-128 algorithm. integer(kind=kInt32), intent(in), optional :: OutputLen the hash output length in bytes (must be positive; otherwise,\n the default length produced). integer(kind=kInt8), intent(in), optional :: Name (:) an array of (8-bit integer) bytes representing the function-name bit string (N);\n if not present, N is an empty string. integer(kind=kInt8), intent(in), optional :: Custom (:) an array of (8-bit integer) bytes representing the customization bit string (S);\n if not present, S is an empty string. integer(kind=kInt32), intent(in), optional :: CustomBitLen the length of the customization string in bits generic, public :: DigestWOutLen => cSHAKE_ByteDigest_wOutLen, cSHAKE_ByteDigest_wInputNOutLen, cSHAKE_HexDigest_wOutLen, cSHAKE_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored. private  subroutine cSHAKE_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'cSHAKE' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine cSHAKE_ByteDigest_wInputNOutLen(MD, Input, InpSize, ByteArr, OutputLen) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'cSHAKE' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine cSHAKE_HexDigest_wOutLen(MD, HexStr, OutputLen) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine cSHAKE_HexDigest_wInputNOutLen(MD, Input, InpSize, HexStr, OutputLen) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( cSHAKE ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes Source Code TYPE , EXTENDS ( KP1600Core ) :: cSHAKE PRIVATE !% flag indicating whether the cSHAKE-256 algorithm is employed or not. tLogical :: IscSHAKE256 = FalseVal !% flag indicating whether both function and customization strings are empty or not. tLogical :: EmptyNS CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ReInit => cSHAKE_ReInit !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options and customization !  parameters. PROCEDURE , PRIVATE :: InitializeWOption => cSHAKE_Initialize_wOption PROCEDURE , PRIVATE :: cSHAKE_ByteDigest_wOutLen PROCEDURE , PRIVATE :: cSHAKE_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: cSHAKE_HexDigest_wOutLen PROCEDURE , PRIVATE :: cSHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (cSHAKE-128) !  and default hash output length, and without customization parameters. PROCEDURE :: Initialize => cSHAKE_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => cSHAKE_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => cSHAKE_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (cSHAKE-256) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the cSHAKE-256 algorithm and default output length <br> !   --->    CALL MD%Create(IscSHAKE256=.TRUE.) <br> !   ! employ the cSHAKE-128 algorithm with specified output length <br> !   --->    CALL MD%Create(IscSHAKE256=.FALSE., OutputLen=64) <br> !   ! employ the cSHAKE-256 algorithm with specified output length <br> !   --->    CALL MD%Create(IscSHAKE256=.TRUE., OutputLen=128) <br> !   ! employ the cSHAKE-128 algorithm with customization parameters <br> !   --->    CALL MD%Create(IscSHAKE256=.FALSE., Name=FuncStr, Custom=CustomStr) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => cSHAKE_ByteDigest_wOutLen , & cSHAKE_ByteDigest_wInputNOutLen , & cSHAKE_HexDigest_wOutLen , & cSHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE cSHAKE","tags":"","loc":"type\\cshake.html"},{"title":"HamsiS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: HamsiS HamsiS is a concrete digest type that implements an incremental\n cryptographic hash function based on the Hamsi hash algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => HamsiS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (HamsiS-256). private  subroutine HamsiS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object procedure, public :: Reset => HamsiS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine HamsiS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object procedure, public :: GetClone => HamsiS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine HamsiS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => HamsiS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function HamsiS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(in) :: MD 'HamsiS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: InsertBytes => HamsiS_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine HamsiS_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => HamsiS_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine HamsiS_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => HamsiS_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine HamsiS_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => HamsiS_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine HamsiS_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: GetDigestLen => HamsiS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function HamsiS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(in) :: MD 'HamsiS' object Return Value integer(kind=kInt32) the digest length generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Hamsi-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Hamsi-224 algorithm --->    CALL MD%Create(IsHamsi224=.TRUE.) private  subroutine HamsiS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object private  subroutine HamsiS_Initialize_wFlag(MD, IsHamsi224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object logical, intent(in) :: IsHamsi224 flag indicating whether the Hamsi-224 algorithm is employed or not. - If true, use the Hamsi-224 algorithm. - Otherwise, use the Hamsi-256 algorithm. generic, public :: AddBitsNDigest => HamsiS_ByteDigest_AddBits, HamsiS_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine HamsiS_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HamsiS_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( HamsiS ), intent(inout) :: MD 'HamsiS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , EXTENDS ( BaseDigest ) :: HamsiS PRIVATE !% state tInteger :: State ( 0 : 7 ) = IV256 ( 0 : 7 ) !% buffer tByte :: Partial ( 0 : 3 ) = 0_kInt8 !% number of bytes used in the buffer tIndex :: PartialLen = 0_kIndex !% bit count tLong :: BitCount = 0_kInt64 !% flag indicating whether the Hamsi-224 algorithm is employed or not. tLogical :: IsHamsi224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: HamsiS_ByteDigest_AddBits PROCEDURE , PRIVATE :: HamsiS_HexDigest_AddBits !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => HamsiS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (HamsiS-256). PROCEDURE :: Initialize => HamsiS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => HamsiS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => HamsiS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => HamsiS_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => HamsiS_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => HamsiS_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => HamsiS_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => HamsiS_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => HamsiS_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Hamsi-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Hamsi-224 algorithm <br> !   --->    CALL MD%Create(IsHamsi224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => HamsiS_ByteDigest_AddBits , & HamsiS_HexDigest_AddBits ! --------------------------------------------------------------------- END TYPE HamsiS","tags":"","loc":"type\\hamsis.html"},{"title":"Keccak – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( KP1600Core ) :: Keccak Keccak is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function based on the so-called Keccak\n hash functions, which is a family of message-digest algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine KP1600Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine KP1600Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine KP1600Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine KP1600Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine KP1600Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. private  subroutine KP1600Core_Initialize(MD, Capacity, Suffix, DigestLen, NRounds) To initialize components of the 'KP1600Core' object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt32), intent(in) :: Capacity the value of the capacity C integer(kind=kInt8), intent(in) :: Suffix suffix for padding integer(kind=kInt32), intent(in) :: DigestLen the desired length of output in bytes integer(kind=kInt32), intent(in), optional :: NRounds number of permutation rounds procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. private  subroutine KP1600Core_CopyState(SrcMD, DstMD) To copy essential components of the source digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: SrcMD source object class( KP1600Core ), intent(inout) :: DstMD destination object procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). private  subroutine KP1600Core_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function KP1600Core_GetDigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in) :: MD 'KP1600_Core' object Return Value integer(kind=kInt32) digest length procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() private  function KP1600Core_GetSponge(MD) result(Sponge) To return the sponge component of the digest object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in), TARGET :: MD 'KP1600_Core' object Return Value type( KP1600Sponge ), POINTER sponge object generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits private  subroutine KP1600Core_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine KP1600Core_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Keccak_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Keccak-256). private  subroutine Keccak_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Keccak ), intent(inout) :: MD 'Keccak' object procedure, public :: GetClone => Keccak_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Keccak_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Keccak ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Keccak_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Keccak_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Keccak ), intent(in) :: MD 'Keccak' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Keccak-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA3-256 algorithm --->    CALL MD%Create(IsSHA3=.TRUE.) ! initialize the object to employ the Keccak-384 algorithm --->    CALL MD%Create(IsSHA3=.FALSE., Security=384) ! initialize the object to employ the SHA3-512 algorithm --->    CALL MD%Create(IsSHA3=.TRUE., Security=512) private  subroutine Keccak_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Keccak ), intent(inout) :: MD 'Keccak' object private  subroutine Keccak_Initialize_wOption(MD, IsSHA3, Security) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( Keccak ), intent(inout) :: MD 'Keccak' object logical, intent(in) :: IsSHA3 flag indicating whether the SHA-3 family is employed or not. - If true, use the SHA-3 family. - Otherwise, use the Keccak algorithm. integer(kind=kInt32), intent(in), optional :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. Source Code TYPE , EXTENDS ( KP1600Core ) :: Keccak PRIVATE !% flag indicating whether the SHA-3 family is employed or not. tLogical :: IsSHA3 = FalseVal !% security strength in bits tInteger :: Security = 256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => Keccak_Initialize_wOption ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Keccak-256). PROCEDURE :: Initialize => Keccak_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Keccak_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Keccak_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Keccak-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA3-256 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.TRUE.) <br> !   ! initialize the object to employ the Keccak-384 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.FALSE., Security=384) <br> !   ! initialize the object to employ the SHA3-512 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.TRUE., Security=512) <br> GENERIC :: Create => InitializeWOption END TYPE Keccak","tags":"","loc":"type\\keccak.html"},{"title":"ShaviteB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: ShaviteB ShaviteB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SHAvite-384 or the SHAvite-512 message-digest algorithm. Finalization Procedures final :: ShaviteB_Finalize private  subroutine ShaviteB_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( ShaviteB ), intent(inout) :: MD 'ShaviteB' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => ShaviteB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAvite-512). private  subroutine ShaviteB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object procedure, public :: Reset => ShaviteB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine ShaviteB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object procedure, public :: GetClone => ShaviteB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine ShaviteB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => ShaviteB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function ShaviteB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(in) :: MD 'ShaviteB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => ShaviteB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function ShaviteB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(in) :: MD 'ShaviteB' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => ShaviteB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function ShaviteB_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(in) :: MD 'ShaviteB' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => ShaviteB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteB_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout), TARGET :: MD 'ShaviteB' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => ShaviteB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteB_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => ShaviteB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteB_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => ShaviteB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteB_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHAvite-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHAvite-384 algorithm --->    CALL MD%Create(IsSHAvite384=.TRUE.) private  subroutine ShaviteB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object private  subroutine ShaviteB_Initialize_wFlag(MD, IsSHAvite384, BigEndian) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( ShaviteB ), intent(inout) :: MD 'ShaviteB' object logical, intent(in) :: IsSHAvite384 flag indicating whether the SHAvite-384 algorithm is employed or not. - If true, use the SHAvite-384 algorithm. - Otherwise, use the SHAvite-512 algorithm. logical, intent(in), optional :: BigEndian flag indicating whether to use the big-endian order for initial values and AES tables. - If true, use the big-endian order. - Otherwise, use little-endian order. default value: false. Source Code TYPE , EXTENDS ( MDEngine ) :: ShaviteB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 15 ) = IV512_LE !% flag indicating whether the SHAvite-384 algorithm is employed or not. tLogical :: IsSHAvite384 = FalseVal !> flag indicating whether to use little-endian order for initial values !  and AES tables. tLogical :: LittleEndian = TrueVal !% pointer to a procedure that processes a block of data PROCEDURE ( ProcessData ), POINTER , NOPASS :: Process => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => ShaviteB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAvite-512). PROCEDURE :: Initialize => ShaviteB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => ShaviteB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => ShaviteB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => ShaviteB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => ShaviteB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => ShaviteB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => ShaviteB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => ShaviteB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => ShaviteB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => ShaviteB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHAvite-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHAvite-384 algorithm <br> !   --->    CALL MD%Create(IsSHAvite384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- FINAL :: ShaviteB_Finalize ! --------------------------------------------------------------------- END TYPE ShaviteB","tags":"","loc":"type\\shaviteb.html"},{"title":"CubeHash – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: CubeHash CubeHash is a concrete digest type that implements an incremental\n cryptographic hash function based on the CubeHash hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => CubeHash_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (CubeHash-512). private  subroutine CubeHash_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object procedure, public :: Reset => CubeHash_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine CubeHash_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object procedure, public :: GetClone => CubeHash_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine CubeHash_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => CubeHash_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function CubeHash_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(in) :: MD 'CubeHash' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => CubeHash_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function CubeHash_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(in) :: MD 'CubeHash' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => CubeHash_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function CubeHash_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(in) :: MD 'CubeHash' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => CubeHash_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine CubeHash_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout), TARGET :: MD 'CubeHash' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => CubeHash_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine CubeHash_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => CubeHash_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine CubeHash_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => CubeHash_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine CubeHash_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (CubeHash-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the CubeHash-256 algorithm --->    CALL MD%Create(256) private  subroutine CubeHash_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object private  subroutine CubeHash_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( CubeHash ), intent(inout) :: MD 'CubeHash' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (512) value. Source Code TYPE , EXTENDS ( MDEngine ) :: CubeHash PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 31 ) = IV512 ( 0 : 31 ) !% security strength in bits tInteger :: Security = 512 !% length of hash output in bytes tIndex :: DigestLen = DLen512 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => CubeHash_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (CubeHash-512). PROCEDURE :: Initialize => CubeHash_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => CubeHash_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => CubeHash_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => CubeHash_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => CubeHash_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => CubeHash_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => CubeHash_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => CubeHash_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => CubeHash_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => CubeHash_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (CubeHash-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the CubeHash-256 algorithm <br> !   --->    CALL MD%Create(256) <br> GENERIC :: Create => InitializeWSecurity END TYPE CubeHash","tags":"","loc":"type\\cubehash.html"},{"title":"MetroHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: MetroHasher64 MetroHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Metro hash algorithm by J. Andrew Rogers. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Metro_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Metro_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Metro_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Metro_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Metro_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Metro_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Metro_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Metro_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Metro_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Metro_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Metro_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Metro_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Metro_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Metro_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( MetroHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: MetroHasher64 PRIVATE tUInt64 :: InitHash = 0_kInt64 !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Metro_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Metro_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Metro_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Metro_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Metro_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Metro_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Metro_HashDirect END TYPE MetroHasher64","tags":"","loc":"type\\metrohasher64.html"},{"title":"MD2 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: MD2 MD2 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD2 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => MD2_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. private  subroutine MD2_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: MD 'MD2' object procedure, public :: Reset => MD2_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine MD2_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: MD 'MD2' object procedure, public :: GetClone => MD2_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine MD2_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => MD2_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function MD2_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(in) :: MD 'MD2' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => MD2_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function MD2_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( MD2 ), intent(in) :: MD 'MD2' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => MD2_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function MD2_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(in) :: MD 'MD2' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => MD2_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine MD2_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout), TARGET :: MD 'MD2' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => MD2_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine MD2_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: MD 'MD2' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => MD2_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD2_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: MD 'MD2' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => MD2_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD2_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( MD2 ), intent(inout) :: MD 'MD2' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset Source Code TYPE , EXTENDS ( MDEngine ) :: MD2 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: X ( 0 : 47 ) = 0_kInt32 tInteger :: C ( 0 : 15 ) = 0_kInt32 tInteger :: L = 0_kInt32 CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD2_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD2_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD2_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD2_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD2_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD2_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD2_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD2_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD2_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD2_AddBitsNPad END TYPE MD2","tags":"","loc":"type\\md2.html"},{"title":"GroestlS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: GroestlS GroestlS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the Groestl-224 or the Groestl-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => GroestlS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Groestl-256). private  subroutine GroestlS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object procedure, public :: Reset => GroestlS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine GroestlS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object procedure, public :: GetClone => GroestlS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine GroestlS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => GroestlS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function GroestlS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(in) :: MD 'GroestlS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => GroestlS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function GroestlS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(in) :: MD 'GroestlS' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => GroestlS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function GroestlS_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(in) :: MD 'GroestlS' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => GroestlS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine GroestlS_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout), TARGET :: MD 'GroestlS' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => GroestlS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlS_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => GroestlS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlS_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => GroestlS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlS_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Groestl-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Groestl-224 algorithm --->    CALL MD%Create(IsGroestl224=.TRUE.) private  subroutine GroestlS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object private  subroutine GroestlS_Initialize_wFlag(MD, IsGroestl224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( GroestlS ), intent(inout) :: MD 'GroestlS' object logical, intent(in) :: IsGroestl224 flag indicating whether the Groestl-224 algorithm is employed or not. - If true, use the Groestl-224 algorithm. - Otherwise, use the Groestl-256 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: GroestlS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 7 ) = 0_kInt64 !% flag indicating whether the Groestl-224 algorithm is employed or not. tLogical :: IsGroestl224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => GroestlS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Groestl-256). PROCEDURE :: Initialize => GroestlS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => GroestlS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => GroestlS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => GroestlS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => GroestlS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => GroestlS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => GroestlS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => GroestlS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => GroestlS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => GroestlS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Groestl-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Groestl-224 algorithm <br> !   --->    CALL MD%Create(IsGroestl224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE GroestlS","tags":"","loc":"type\\groestls.html"},{"title":"ByteConverter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ByteConverter The ByteConverter type is a converter type that performs a conversion\n of bit patterns between a byte (an array of 8-bit integers) array and\n an other integer type (i.e. a 16-bit, 32-bit or 64-bit integer). Components Type Visibility Attributes Name Initial procedure(PackShort), public, POINTER, NOPASS :: Pack_I16 => NULL() Function Pointer : Pack_I16 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 16-bit integer. Usage : --->    IntVal = Pack_I16(ByteArr, Offset) procedure(PackInt), public, POINTER, NOPASS :: Pack_I32 => NULL() Function Pointer : Pack_I32 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 32-bit integer. Usage : --->    IntVal = Pack_I32(ByteArr, Offset) procedure(PackLong), public, POINTER, NOPASS :: Pack_I64 => NULL() Function Pointer : Pack_I64 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 64-bit integer. Usage : --->    IntVal = Pack_I64(ByteArr, Offset) procedure(UnpackShort), public, POINTER, NOPASS :: Unpack_I16 => NULL() Subroutine Pointer : Unpack_I16 Purpose :  To convert a 16-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I16(IntVal, ByteArr, Offset) procedure(UnpackInt), public, POINTER, NOPASS :: Unpack_I32 => NULL() Subroutine Pointer : Unpack_I32 Purpose :  To convert a 32-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I32(IntVal, ByteArr, Offset) procedure(UnpackLong), public, POINTER, NOPASS :: Unpack_I64 => NULL() Subroutine Pointer : Unpack_I64 Purpose :  To convert a 64-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I64(IntVal, ByteArr, Offset) Type-Bound Procedures procedure, public :: Initialize => ByteConverter_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the ByteConverter object according to the\n              optionally specified endianess flag. Usage : --->    CALL ByteConv%Initialize()          ! machine endian --->    CALL ByteConv%Initialize(.TRUE.)    ! big endian --->    CALL ByteConv%Initialize(.FALSE.)   ! little endian private  subroutine ByteConverter_Initialize(BC, IsBigEndian) To initialize the ByteConverter object according to the optionally\n specified endianess flag. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(inout) :: BC byte converter logical, intent(in), optional :: IsBigEndian the endianess flag indicating whether the byte array is stored in big-endian\n order or not. - True if the byte array is stored in big-endian order. - False if the byte array is stored in little-endian order. - If not present, the byte array is stored in machine-endian order. procedure, public :: Reset => ByteConverter_Reset Type-Bound Subroutine : Reset Purpose :  To reset the ByteConverter object. Usage : --->    CALL ByteConv%Reset() private  subroutine ByteConverter_Reset(BC) To reset the ByteConverter object. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(inout) :: BC byte converter procedure, public :: Get_I8 => Get_Byte Type-Bound Function : Get_I8 Purpose :  To get a single byte at the specified offset of the given byte\n              array and return the result widened to default integer type. Usage : --->    IntVal = ByteConv%Get_I8(ByteArr, Offset) private  function Get_Byte(BC, Buf, Offset) result(OutVal) To get a single byte at the given 'Offset' in the specified byte sequence 'Buf'\n and return the result widened to default integer type. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) byte sequence integer(kind=kInt32), intent(in) :: Offset offset to the byte to read within the byte sequence Return Value integer(kind=kInt32) the requested byte, widened to default integer type procedure, public :: Get_U8 => Get_Unsigned_Byte Type-Bound Function : Get_U8 Purpose :  To get a single byte at the specified offset of the given byte\n              array and return the result widened to default integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Get_U8(ByteArr, Offset) private  function Get_Unsigned_Byte(BC, Buf, Offset) result(OutVal) To get a single byte at the given 'Offset' in the specified byte sequence 'Buf'\n and return the result widened to default integer type with the signed of the\n requested byte removed. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) byte sequence integer(kind=kInt32), intent(in) :: Offset offset to the byte to read within the byte sequence Return Value integer(kind=kInt32) the requested byte, widened to default integer type procedure, public :: Pack_U16 => Pack_Unsigned_Short Type-Bound Function : Pack_U16 Purpose :  To get two bytes starting at the specified offset of the given byte\n              array and return the result widened to default integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Pack_U16(ByteArr, Offset) private  function Pack_Unsigned_Short(BC, Buf, Offset) result(OutVal) To get two bytes at Offset and Offset+1 positions in the specified byte sequence\n 'Buf' and return the result widened to default integer type with the signed of the\n requested result removed. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) byte sequence integer(kind=kInt32), intent(in) :: Offset offset to the byte to read within the byte sequence Return Value integer(kind=kInt32) the requested result, widened to default integer type procedure, public :: Pack_U32 => Pack_Unsigned_Integer Type-Bound Function : Pack_U32 Purpose :  To get four bytes starting at the specified offset of the given byte\n              array and return the result widened to 64-bit integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Pack_U32(ByteArr, Offset) private  function Pack_Unsigned_Integer(BC, Buf, Offset) result(OutVal) To get four bytes starting at Offset positions in the specified byte sequence\n 'Buf' and return the result widened to long integer type with the signed of the\n requested result removed. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) byte sequence integer(kind=kInt32), intent(in) :: Offset offset to the byte to read within the byte sequence Return Value integer(kind=kInt64) the requested result, widened to long integer type procedure, public :: Pack_I32_Partial => Pack_Integer_Partial Type-Bound Function : Pack_I32_Partial Purpose :  To get three or fewer bytes of the given byte array starting at\n              the specified offset and return the result as 32-bit integer. Usage : --->    IntVal = ByteConv%Pack_I32_Partial(ByteArr, Offset, Length) Note : Length must be between 1 and 3. private  function Pack_Integer_Partial(BC, Buf, Offset, Length) result(OutVal) To pack three or fewer bytes of the array 'Buf' starting at Offset positions\n in the specified byte sequence 'Buf' into the 32-bit word 'OutVal'. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) buffer integer(kind=kInt32), intent(in) :: Offset offset integer(kind=kInt32), intent(in) :: Length the number of bytes to pack (between 1 to 3) Return Value integer(kind=kInt32) result procedure, public :: Pack_I64_Partial => Pack_Long_Partial Type-Bound Function : Pack_I64_Partial Purpose :  To get seven or fewer bytes of the given byte array starting at\n              the specified offset and return the result as 64-bit integer. Usage : --->    IntVal = ByteConv%Pack_I64_Partial(ByteArr, Offset, Length) Note : Length must be between 1 and 7. private  function Pack_Long_Partial(BC, Buf, Offset, Length) result(OutVal) To pack seven or fewer bytes of the array 'Buf' starting at Offset positions\n in the specified byte sequence 'Buf' into the 64-bit word 'OutVal'. Arguments Type Intent Optional Attributes Name class( ByteConverter ), intent(in) :: BC byte converter integer(kind=kInt8), intent(in) :: Buf (0:) buffer integer(kind=kInt32), intent(in) :: Offset offset integer(kind=kInt32), intent(in) :: Length the number of bytes to pack (between 1 to 7) Return Value integer(kind=kInt64) result Source Code TYPE :: ByteConverter !> **Function Pointer**: Pack_I16 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 16-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I16(ByteArr, Offset) PROCEDURE ( PackShort ), POINTER , NOPASS :: Pack_I16 => NULL () !> **Function Pointer**: Pack_I32 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 32-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I32(ByteArr, Offset) PROCEDURE ( PackInt ), POINTER , NOPASS :: Pack_I32 => NULL () !> **Function Pointer**: Pack_I64 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 64-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I64(ByteArr, Offset) PROCEDURE ( PackLong ), POINTER , NOPASS :: Pack_I64 => NULL () !> **Subroutine Pointer**: Unpack_I16 <br> ! **Purpose**:  To convert a 16-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I16(IntVal, ByteArr, Offset) PROCEDURE ( UnpackShort ), POINTER , NOPASS :: Unpack_I16 => NULL () !> **Subroutine Pointer**: Unpack_I32 <br> ! **Purpose**:  To convert a 32-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I32(IntVal, ByteArr, Offset) PROCEDURE ( UnpackInt ), POINTER , NOPASS :: Unpack_I32 => NULL () !> **Subroutine Pointer**: Unpack_I64 <br> ! **Purpose**:  To convert a 64-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I64(IntVal, ByteArr, Offset) PROCEDURE ( UnpackLong ), POINTER , NOPASS :: Unpack_I64 => NULL () CONTAINS !> **Type-Bound Subroutine**: Initialize <br> ! **Purpose**:  To initialize the *ByteConverter* object according to the !               optionally specified endianess flag. <br> !  **Usage**: <br> !   --->    CALL ByteConv%Initialize()          ! machine endian <br> !   --->    CALL ByteConv%Initialize(.TRUE.)    ! big endian <br> !   --->    CALL ByteConv%Initialize(.FALSE.)   ! little endian PROCEDURE :: Initialize => ByteConverter_Initialize !> **Type-Bound Subroutine**: Reset <br> ! **Purpose**:  To reset the *ByteConverter* object. <br> !  **Usage**: <br> !   --->    CALL ByteConv%Reset() PROCEDURE :: Reset => ByteConverter_Reset !> **Type-Bound Function**: Get_I8 <br> ! **Purpose**:  To get a single byte at the specified offset of the given byte !               array and return the result widened to default integer type. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Get_I8(ByteArr, Offset) PROCEDURE :: Get_I8 => Get_Byte !> **Type-Bound Function**: Get_U8 <br> ! **Purpose**:  To get a single byte at the specified offset of the given byte !               array and return the result widened to default integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Get_U8(ByteArr, Offset) PROCEDURE :: Get_U8 => Get_Unsigned_Byte !> **Type-Bound Function**: Pack_U16 <br> ! **Purpose**:  To get two bytes starting at the specified offset of the given byte !               array and return the result widened to default integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_U16(ByteArr, Offset) PROCEDURE :: Pack_U16 => Pack_Unsigned_Short !> **Type-Bound Function**: Pack_U32 <br> ! **Purpose**:  To get four bytes starting at the specified offset of the given byte !               array and return the result widened to 64-bit integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_U32(ByteArr, Offset) PROCEDURE :: Pack_U32 => Pack_Unsigned_Integer !> **Type-Bound Function**: Pack_I32_Partial <br> ! **Purpose**:  To get three or fewer bytes of the given byte array starting at !               the specified offset and return the result as 32-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_I32_Partial(ByteArr, Offset, Length) <br> !  **Note**: Length must be between 1 and 3. PROCEDURE :: Pack_I32_Partial => Pack_Integer_Partial !> **Type-Bound Function**: Pack_I64_Partial <br> ! **Purpose**:  To get seven or fewer bytes of the given byte array starting at !               the specified offset and return the result as 64-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_I64_Partial(ByteArr, Offset, Length) <br> !  **Note**: Length must be between 1 and 7. PROCEDURE :: Pack_I64_Partial => Pack_Long_Partial END TYPE ByteConverter","tags":"","loc":"type\\byteconverter.html"},{"title":"KomiHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: KomiHasher64 KomiHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Komi hash algorithm by Aleksey Vaneev. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Komi_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Komi_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Komi_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Komi_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Komi_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Komi_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Komi_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Komi_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Komi_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Komi_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Komi_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Komi_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Komi_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Komi_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( KomiHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: KomiHasher64 PRIVATE !% state tUInt64 :: State ( 8 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Komi_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Komi_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Komi_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Komi_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Komi_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Komi_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Komi_HashDirect END TYPE KomiHasher64","tags":"","loc":"type\\komihasher64.html"},{"title":"BaseHasher – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT :: BaseHasher BaseHasher is an abstract type representing a base hasher that\n defines an incomplete application programming interface (API)\n for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() function HSName(HS) result(Name) Prototype HSName is a deferred procedure to return the name of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. function HSBlockLen(HS) result(Length) Prototype HSBlockLen is a deferred procedure to return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSSetPtr(HS, BufPtr) Prototype HSSetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSProcess(HS, BytesIn) Prototype HSProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) Source Code TYPE , ABSTRACT :: BaseHasher PRIVATE !% the number of blocks of input processed tIndex :: BlockCount = 0_kIndex !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *GetName* is a binding name of the *HSName* deferred procedure. <br> !  **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE ( HSName ), DEFERRED :: GetName !> *GetBlockLength* is a binding name of the *HSBlockLen* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSBlockLen ), DEFERRED :: GetBlockLength !> *SetBufPtr* is a binding name of the *HSSetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSSetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *HSProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSProcess ), DEFERRED :: ProcessBlock ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *Reset* is a procedure to reset components of the hasher to their initial values. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: Reset => HS_Reset !> *GetBlockCount* is a procedure to get the number of blocks of input processed. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockCount => HS_BlockCount !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => HS_BufLen !> **Type-Bound Subroutine**: Update <br> !  **Purpose**:  To insert input data into the hasher (i.e. temporarily stored in the !                buffer array) and process block(s) of data if necessary. <br> !  **Usage**: <br> !   --->    CALL Hasher%Update(Input, InpSize) <br> !  **Important Note**: The specified input can be any type and any rank where !               its size is the number of bytes of storage used by the input. PROCEDURE :: Update => HS_Update END TYPE BaseHasher","tags":"","loc":"type\\basehasher.html"},{"title":"BmwS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: BmwS BmwS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BMW-224 or the BMW-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => BmwS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BMW-256). private  subroutine BmwS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object procedure, public :: Reset => BmwS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine BmwS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object procedure, public :: GetClone => BmwS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine BmwS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => BmwS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function BmwS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(in) :: MD 'BmwS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => BmwS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function BmwS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( BmwS ), intent(in) :: MD 'BmwS' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => BmwS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function BmwS_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(in) :: MD 'BmwS' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => BmwS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine BmwS_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout), TARGET :: MD 'BmwS' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => BmwS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine BmwS_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => BmwS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine BmwS_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => BmwS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine BmwS_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BMW-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the BMW-224 algorithm --->    CALL MD%Create(IsBMW224=.TRUE.) private  subroutine BmwS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object private  subroutine BmwS_Initialize_wFlag(MD, IsBMW224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( BmwS ), intent(inout) :: MD 'BmwS' object logical, intent(in) :: IsBMW224 flag indicating whether the BMW-224 algorithm is employed or not. - If true, use the BMW-224 algorithm. - Otherwise, use the BMW-256 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: BmwS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: H ( 0 : 15 ) = IV256 ( 0 : 15 ) !% flag indicating whether the BMW-224 algorithm is employed or not. tLogical :: IsBMW224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => BmwS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BMW-256). PROCEDURE :: Initialize => BmwS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => BmwS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => BmwS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => BmwS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => BmwS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => BmwS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => BmwS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => BmwS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => BmwS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => BmwS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BMW-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BMW-224 algorithm <br> !   --->    CALL MD%Create(IsBMW224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE BmwS","tags":"","loc":"type\\bmws.html"},{"title":"MDHelper – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( MDEngine ) :: MDHelper MDHelper is an abstract digest type acting as a helper by\n implementing the padding common to MD4, MD5, and the SHA family. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. subroutine MDCreate(MD) Prototype MDCreate is a deferred procedure to perform any essential initialization\n of a digest object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() subroutine MDReset(MD) Prototype MDReset is a deferred procedure to reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) subroutine MDClone(Src, Dst) Prototype MDClone is a deferred procedure to clone the current state. The returned\n object evolves independently of this object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: Src a source digest object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination (clone) digest object procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() function MDName(MD) result(Name) Prototype MDName is a deferred procedure to get the display name for this hash\n function (e.g. \"SHA-1\" for SHA-1). Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(in) :: MD 'BaseDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure(DEDigestLen), public, deferred :: GetDigestLen GetDigestLen is a binding name of the DEDigestLen deferred procedure. Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() function DEDigestLen(MD) result(Length) Prototype DEDigestLen is a deferred procedure to return the natural hash\n function output length (in bytes). Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) the digest length procedure(DEBlockLen), public, deferred :: GetBlockLen GetBlockLen is a binding name of the DEBlockLen deferred procedure. This procedure is NOT intended to be used by a user. function DEBlockLen(MD) result(Length) Prototype DEBlockLen is a deferred procedure to return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD MDEngine object Return Value integer(kind=kInt32) the block length procedure(DESetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the DESetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine DESetPtr(MD, BufPtr) Prototype DESetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout), TARGET :: MD MDEngine object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(DEProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the DEProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine DEProcess(MD, BytesIn) Prototype DEProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD MDEngine object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure(DEPadding), public, deferred :: DoPadding DoPadding is a binding name of the DEPadding deferred procedure. This procedure is NOT intended to be used by a user. subroutine DEPadding(MD, BytesOut, Offset) Prototype DEPadding is a deferred procedure to perform the final padding and store\n the result in the provided buffer.  This method shall call the Flush method and then the Update method with the appropriate padding data\n in order to get the full input data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure(DEAddBitsNPad), public, deferred :: AddBitsNPad AddBitsNPad is a binding name of the DEAddBitsNPad deferred procedure. This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. subroutine DEAddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) Prototype DEAddBitsNPad is a deferred procedure to add the last byte and then perform\n the final padding and store the result in the provided buffer.  This method\n shall call the Flush and then the Update method with the appropriate\n padding data in order to get the full input data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object Source Code TYPE , ABSTRACT , EXTENDS ( MDEngine ) :: MDHelper PRIVATE !% flag indicating whether the padding is in little-endian order or not tLogical :: LittleEndian = FalseVal !% the length encoding length, in bytes (must be at least 8 and less than MaxLen tIndex :: LenLen = 8_kIndex !% the first padding byte tUInt8 :: FByte = FByte80 CONTAINS ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *HelperInit* is a procedure to initialize components of the *MDHelper* type. <br> !  This procedure is NOT intended to be used by a user but the *Create* method !  implemented by a *concrete* digest type that extends from this type should !  call this method. PROCEDURE :: HelperInit => MDHelper_Init !> *HelperPadding* is a procedure to perform padding required by the hash functions. <br> !  This procedure is NOT intended to be used by a user but the *DoPadding* method !  implemented by a *concrete* digest type that extends from this type should !  call this method. PROCEDURE :: HelperPadding => MDHelper_DoPadding !> *HelperReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: HelperReset => MDHelper_Reset !> *HelperClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: HelperClone => MDHelper_Clone ! --------------------------------------------------------------------- END TYPE MDHelper","tags":"","loc":"type\\mdhelper.html"},{"title":"WyHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: WyHasher64 WyHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the final version 3 of the Wy hash algorithm by Wang Yi. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Wy_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Wy_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Wy_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Wy_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Wy_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Wy_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Wy_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Wy_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Wy_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Wy_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Wy_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Wy_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Wy_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Wy_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( WyHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: WyHasher64 PRIVATE !% state tUInt64 :: State ( 3 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Wy_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Wy_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Wy_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Wy_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Wy_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Wy_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Wy_HashDirect END TYPE WyHasher64","tags":"","loc":"type\\wyhasher64.html"},{"title":"Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseHasher ) :: Hasher32 Hasher32 is an abstract type representing a hasher that outputs the hash value\n as a 32-bit integer for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() function HSName(HS) result(Name) Prototype HSName is a deferred procedure to return the name of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. function HSBlockLen(HS) result(Length) Prototype HSBlockLen is a deferred procedure to return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSSetPtr(HS, BufPtr) Prototype HSSetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSProcess(HS, BytesIn) Prototype HSProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure(HS32Init), public, deferred :: Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value subroutine HS32Init(HS, Seed, RemoveSign) Prototype HS32Init is a deferred procedure to initialize the hasher. Arguments Type Intent Optional Attributes Name class( Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure(HS32Final), public, deferred :: Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() function HS32Final(HS) result(HashCode) Prototype HS32Final is a deferred procedure to finalize the current hash computation\n and return the hash value in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Hasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure(HS32Hash), public, deferred :: HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. function HS32Hash(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) Prototype HS32Hash is a deferred procedure to compute the hash value directly\n (non-incrementally). Arguments Type Intent Optional Attributes Name class( Hasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , ABSTRACT , EXTENDS ( BaseHasher ) :: Hasher32 CONTAINS !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE ( HS32Init ), DEFERRED :: Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE ( HS32Final ), DEFERRED :: Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE ( HS32Hash ), DEFERRED :: HashDirect END TYPE Hasher32","tags":"","loc":"type\\hasher32.html"},{"title":"Murmur3Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: Murmur3Hasher64 Murmur3Hasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Murmur3 hash algorithm by Austin Appleby. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Murmur3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Murmur3_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Murmur3_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Murmur3_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Murmur3_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Murmur3_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: Murmur3Hasher64 PRIVATE !% state tUInt64 :: State ( 2 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% pointer to the buffer array as 64-bit integers tUInt64 , POINTER :: BufLong (:) => NULL () !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Murmur3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Murmur3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Murmur3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Murmur3_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Murmur3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Murmur3_HashDirect END TYPE Murmur3Hasher64","tags":"","loc":"type\\murmur3hasher64.html"},{"title":"Murmur3Hasher128 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Murmur3Hasher64 ) :: Murmur3Hasher128 Murmur3Hasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the Murmur3Hasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Murmur3_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Murmur3_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Murmur3_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Murmur3_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: GetName => Murmur3_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Murmur3_GetName128(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher128 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Finalize128 => Murmur3_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() private  function Murmur3_Finalize128(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 128-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher128 ), intent(inout) :: HS a hasher (HS) object Return Value type(SInt128) hash code procedure, public :: HashDirect128 => Murmur3_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Murmur3_HashDirect128(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher128 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value type(SInt128) hash code Source Code TYPE , EXTENDS ( Murmur3Hasher64 ) :: Murmur3Hasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName128 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => Murmur3_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => Murmur3_HashDirect128 END TYPE Murmur3Hasher128","tags":"","loc":"type\\murmur3hasher128.html"},{"title":"Shabal – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: Shabal Shabal is a concrete digest type that implements an incremental\n cryptographic hash function based on the Shabal hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Shabal_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Shabal-256). private  subroutine Shabal_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object procedure, public :: Reset => Shabal_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Shabal_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object procedure, public :: GetClone => Shabal_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Shabal_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Shabal_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Shabal_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(in) :: MD 'Shabal' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => Shabal_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Shabal_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Shabal ), intent(in) :: MD 'Shabal' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => Shabal_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function Shabal_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(in) :: MD 'Shabal' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Shabal_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Shabal_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout), TARGET :: MD 'Shabal' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Shabal_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Shabal_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => Shabal_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Shabal_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => Shabal_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Shabal_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Shabal-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Shabal-512 algorithm --->    CALL MD%Create(512) private  subroutine Shabal_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout) :: MD 'Shabal' object private  subroutine Shabal_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( Shabal ), intent(inout), TARGET :: MD 'Shabal' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with five possible values: 192, 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. Source Code TYPE , EXTENDS ( MDEngine ) :: Shabal PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% states and counters tInteger :: A ( 0 : 11 ) = AIV_256 ( 0 : 11 ) tInteger :: B ( 0 : 15 ) = BIV_256 ( 0 : 15 ) tInteger :: C ( 0 : 15 ) = CIV_256 ( 0 : 15 ) tInteger :: WLo = 1 tInteger :: WHi = 0 !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => Shabal_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Shabal-256). PROCEDURE :: Initialize => Shabal_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Shabal_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Shabal_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Shabal_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Shabal_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Shabal_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Shabal_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Shabal_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Shabal_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Shabal_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Shabal-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Shabal-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity ! --------------------------------------------------------------------- END TYPE Shabal","tags":"","loc":"type\\shabal.html"},{"title":"ShaviteS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: ShaviteS ShaviteS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SHAvite-224 or the SHAvite-256 message-digest algorithm. Finalization Procedures final :: ShaviteS_Finalize private  subroutine ShaviteS_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( ShaviteS ), intent(inout) :: MD 'ShaviteS' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => ShaviteS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAvite-256). private  subroutine ShaviteS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object procedure, public :: Reset => ShaviteS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine ShaviteS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object procedure, public :: GetClone => ShaviteS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine ShaviteS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => ShaviteS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function ShaviteS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(in) :: MD 'ShaviteS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => ShaviteS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function ShaviteS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(in) :: MD 'ShaviteS' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => ShaviteS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function ShaviteS_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(in) :: MD 'ShaviteS' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => ShaviteS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteS_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout), TARGET :: MD 'ShaviteS' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => ShaviteS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteS_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => ShaviteS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteS_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => ShaviteS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine ShaviteS_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHAvite-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHAvite-224 algorithm --->    CALL MD%Create(IsSHAvite224=.TRUE.) private  subroutine ShaviteS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object private  subroutine ShaviteS_Initialize_wFlag(MD, IsSHAvite224, BigEndian) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( ShaviteS ), intent(inout) :: MD 'ShaviteS' object logical, intent(in) :: IsSHAvite224 flag indicating whether the SHAvite-224 algorithm is employed or not. - If true, use the SHAvite-224 algorithm. - Otherwise, use the SHAvite-256 algorithm. logical, intent(in), optional :: BigEndian flag indicating whether to use the big-endian order for initial values and AES tables. - If true, use the big-endian order. - Otherwise, use little-endian order. default value: false. Source Code TYPE , EXTENDS ( MDEngine ) :: ShaviteS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 7 ) = IV256_LE !% flag indicating whether the SHAvite-224 algorithm is employed or not. tLogical :: IsSHAvite224 = FalseVal !> flag indicating whether to use little-endian order for initial values !  and AES tables. tLogical :: LittleEndian = TrueVal !% pointer to a procedure that processes a block of data PROCEDURE ( ProcessData ), POINTER , NOPASS :: Process => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => ShaviteS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAvite-256). PROCEDURE :: Initialize => ShaviteS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => ShaviteS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => ShaviteS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => ShaviteS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => ShaviteS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => ShaviteS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => ShaviteS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => ShaviteS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => ShaviteS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => ShaviteS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHAvite-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHAvite-224 algorithm <br> !   --->    CALL MD%Create(IsSHAvite224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- FINAL :: ShaviteS_Finalize ! --------------------------------------------------------------------- END TYPE ShaviteS","tags":"","loc":"type\\shavites.html"},{"title":"SHAKE – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( KP1600Core ) :: SHAKE SHAKE is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function by employing either the SHAKE-128 or the SHAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine KP1600Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine KP1600Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine KP1600Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine KP1600Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine KP1600Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. private  subroutine KP1600Core_Initialize(MD, Capacity, Suffix, DigestLen, NRounds) To initialize components of the 'KP1600Core' object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt32), intent(in) :: Capacity the value of the capacity C integer(kind=kInt8), intent(in) :: Suffix suffix for padding integer(kind=kInt32), intent(in) :: DigestLen the desired length of output in bytes integer(kind=kInt32), intent(in), optional :: NRounds number of permutation rounds procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. private  subroutine KP1600Core_CopyState(SrcMD, DstMD) To copy essential components of the source digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: SrcMD source object class( KP1600Core ), intent(inout) :: DstMD destination object procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). private  subroutine KP1600Core_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function KP1600Core_GetDigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in) :: MD 'KP1600_Core' object Return Value integer(kind=kInt32) digest length procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() private  function KP1600Core_GetSponge(MD) result(Sponge) To return the sponge component of the digest object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in), TARGET :: MD 'KP1600_Core' object Return Value type( KP1600Sponge ), POINTER sponge object generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits private  subroutine KP1600Core_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine KP1600Core_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => SHAKE_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAKE-128)\n and default hash output length. private  subroutine SHAKE_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length. Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'SHAKE' object procedure, public :: GetClone => SHAKE_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHAKE_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHAKE_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHAKE_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(in) :: MD 'SHAKE' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (SHAKE-256) algorithm and default output length --->    CALL MD%Create() ! employ the SHAKE-256 algorithm and default output length --->    CALL MD%Create(IsSHAKE256=.TRUE.) ! employ the SHAKE-128 algorithm with specified output length --->    CALL MD%Create(IsSHAKE256=.FALSE., OutputLen=64) ! employ the SHAKE-256 algorithm with specified output length --->    CALL MD%Create(IsSHAKE256=.TRUE., OutputLen=128) private  subroutine SHAKE_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length. Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'SHAKE' object private  subroutine SHAKE_Initialize_wOption(MD, IsSHAKE256, OutputLen) To perform initialization of the digest object with the specified options. Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'SHAKE' object logical, intent(in) :: IsSHAKE256 flag indicating whether the SHAKE-256 algorithm is employed or not. - If true, use the SHAKE-256 algorithm. - Otherwise, use the SHAKE-128 algorithm. integer(kind=kInt32), intent(in), optional :: OutputLen the hash output length in bytes (must be positive; otherwise,\n the default length produced). generic, public :: DigestWOutLen => SHAKE_ByteDigest_wOutLen, SHAKE_ByteDigest_wInputNOutLen, SHAKE_HexDigest_wOutLen, SHAKE_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored. private  subroutine SHAKE_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'SHAKE' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine SHAKE_ByteDigest_wInputNOutLen(MD, Input, InpSize, ByteArr, OutputLen) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'SHAKE' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine SHAKE_HexDigest_wOutLen(MD, HexStr, OutputLen) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine SHAKE_HexDigest_wInputNOutLen(MD, Input, InpSize, HexStr, OutputLen) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string.\n Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( SHAKE ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes Source Code TYPE , EXTENDS ( KP1600Core ) :: SHAKE PRIVATE !% flag indicating whether the SHAKE-256 algorithm is employed or not. tLogical :: IsSHAKE256 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => SHAKE_Initialize_wOption PROCEDURE , PRIVATE :: SHAKE_ByteDigest_wOutLen PROCEDURE , PRIVATE :: SHAKE_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: SHAKE_HexDigest_wOutLen PROCEDURE , PRIVATE :: SHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAKE-128) !  and default hash output length. PROCEDURE :: Initialize => SHAKE_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHAKE_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHAKE_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (SHAKE-256) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the SHAKE-256 algorithm and default output length <br> !   --->    CALL MD%Create(IsSHAKE256=.TRUE.) <br> !   ! employ the SHAKE-128 algorithm with specified output length <br> !   --->    CALL MD%Create(IsSHAKE256=.FALSE., OutputLen=64) <br> !   ! employ the SHAKE-256 algorithm with specified output length <br> !   --->    CALL MD%Create(IsSHAKE256=.TRUE., OutputLen=128) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => SHAKE_ByteDigest_wOutLen , & SHAKE_ByteDigest_wInputNOutLen , & SHAKE_HexDigest_wOutLen , & SHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE SHAKE","tags":"","loc":"type\\shake.html"},{"title":"Blake2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Blake2Core ) :: Blake2B Blake2B is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE2b message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC). Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Blake2Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Blake2Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Blake2Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Blake2Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. private  subroutine Blake2Core_Init(MD, BlockLen, DigestLen, Key) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt32), intent(in) :: BlockLen block length integer(kind=kInt32), intent(in) :: DigestLen digest length integer(kind=kInt8), intent(in), optional :: Key (0:) key procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: SrcMD source object class( Blake2Core ), intent(inout) :: DstMD destination object procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function Blake2Core_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) number of bytes procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. private  function Blake2Core_KeyLen(MD) result(Length) To get key length (in bytes). Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Key' object Return Value integer(kind=kInt32) the key length procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Blake2Core_DigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) digest length procedure, public :: Initialize => Blake2B_InitDefault Use the Create method in place of the Initialize method to\n initialize the digest object with default hash output length. private  subroutine Blake2B_InitDefault(MD) To perform default initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object procedure, public :: Reset => Blake2B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Blake2B_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object procedure, public :: GetClone => Blake2B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Blake2B_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Blake2B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Blake2B_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(in) :: MD 'Blake2B' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: SetBufPtr => Blake2B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Blake2B_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout), TARGET :: MD 'Blake2B' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Blake2B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Blake2B_ProcessBlock(MD, BytesIn, LastBlock) To process one block of data. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the input data block logical, intent(in) :: LastBlock true if the input is the last block procedure, public :: EncodeOutput => Blake2B_EncodeOutput EncodeOutput is a procedure to encode the hash output. This method is NOT intended to be used by a user. private  subroutine Blake2B_EncodeOutput(MD, BytesOut) To perform the encoding of the hash output (i.e.\n unpacking the internal state into the output byte array). Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output array generic, public :: Create => Initialize , InitWOutLen Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object\n               (as a hasher). Usage : ! initialization with default output length --->    CALL MD%Create() ! initialization with specified output length private  subroutine Blake2B_InitDefault(MD) To perform default initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object private  subroutine Blake2B_InitWOutLen(MD, OutputLen) To perform initialization of the digest object with the specified output length. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object integer(kind=kInt32), intent(in) :: OutputLen the desired length of hash output, which must be between 1 and 32 bytes. generic, public :: CreateHMAC => InitWKey Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : ! initialization with default output length --->    CALL MD%CreateHMAC(Key) ! initialization with specified output length --->    CALL MD%CreateHMAC(Key, OutputLen) private  subroutine Blake2B_InitWKey(MD, Key, OutputLen) To perform initialization of the digest object with the specified key and\n the optionally specified length of hash output. Arguments Type Intent Optional Attributes Name class( Blake2B ), intent(inout) :: MD 'Blake2B' object integer(kind=kInt8), intent(in) :: Key (0:) an (8-bit integer) byte array representing a key for a keyed hashing integer(kind=kInt32), intent(in), optional :: OutputLen desired length of hash output; must be between 1 and 32 bytes. Source Code TYPE , EXTENDS ( Blake2Core ) :: Blake2B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% internal state tLong :: H ( 0 : 7 ) = IV ( 0 : 7 ) !% counter's LSB tLong :: T0 = 0_kInt64 !% counter's MSB tLong :: T1 = 0_kInt64 CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitWOutLen* method to !  initialize the *digest* object with the specified hash output length. PROCEDURE , PRIVATE :: InitWOutLen => Blake2B_InitWOutLen !> Use the *Create* method in place of the *InitWKey* method to initialize !  the *digest* object with the specified key for keyed hashing (and the !  optionally specified hash output length). PROCEDURE , PRIVATE :: InitWKey => Blake2B_InitWKey ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default hash output length. PROCEDURE :: Initialize => Blake2B_InitDefault !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake2B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake2B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake2B_GetName !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake2B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake2B_ProcessBlock !> *EncodeOutput* is a procedure to encode the hash output. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: EncodeOutput => Blake2B_EncodeOutput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                (as a hasher). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%Create() <br> !   ! initialization with specified output length <br> GENERIC :: Create => InitWOutLen !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%CreateHMAC(Key) <br> !   ! initialization with specified output length <br> !   --->    CALL MD%CreateHMAC(Key, OutputLen) <br> GENERIC :: CreateHMAC => InitWKey ! --------------------------------------------------------------------- END TYPE Blake2B","tags":"","loc":"type\\blake2b.html"},{"title":"Blake2S – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Blake2Core ) :: Blake2S Blake2S is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE2s message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC). Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Blake2Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Blake2Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Blake2Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Blake2Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. private  subroutine Blake2Core_Init(MD, BlockLen, DigestLen, Key) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object integer(kind=kInt32), intent(in) :: BlockLen block length integer(kind=kInt32), intent(in) :: DigestLen digest length integer(kind=kInt8), intent(in), optional :: Key (0:) key procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(inout) :: MD 'Blake2Core' object procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine Blake2Core_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: SrcMD source object class( Blake2Core ), intent(inout) :: DstMD destination object procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function Blake2Core_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) number of bytes procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. private  function Blake2Core_KeyLen(MD) result(Length) To get key length (in bytes). Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Key' object Return Value integer(kind=kInt32) the key length procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Blake2Core_DigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( Blake2Core ), intent(in) :: MD 'Blake2Core' object Return Value integer(kind=kInt32) digest length procedure, public :: Initialize => Blake2S_InitDefault Use the Create method in place of the Initialize method to\n initialize the digest object with default hash output length. private  subroutine Blake2S_InitDefault(MD) To perform default initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object procedure, public :: Reset => Blake2S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Blake2S_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object procedure, public :: GetClone => Blake2S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Blake2S_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Blake2S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Blake2S_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(in) :: MD 'Blake2S' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: SetBufPtr => Blake2S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Blake2S_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout), TARGET :: MD 'Blake2S' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Blake2S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Blake2S_ProcessBlock(MD, BytesIn, LastBlock) To process one block of data. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the input data block logical, intent(in) :: LastBlock true if the input is the last block procedure, public :: EncodeOutput => Blake2S_EncodeOutput EncodeOutput is a procedure to encode the hash output. This method is NOT intended to be used by a user. private  subroutine Blake2S_EncodeOutput(MD, BytesOut) To perform the encoding of the hash output (i.e.\n unpacking the internal state into the output byte array). Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output array generic, public :: Create => Initialize , InitWOutLen Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object\n               (as a hasher). Usage : ! initialization with default output length --->    CALL MD%Create() ! initialization with specified output length private  subroutine Blake2S_InitDefault(MD) To perform default initialization of the digest object. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object private  subroutine Blake2S_InitWOutLen(MD, OutputLen) To perform initialization of the digest object with the specified output length. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object integer(kind=kInt32), intent(in) :: OutputLen the desired length of hash output, which must be between 1 and 32 bytes. generic, public :: CreateHMAC => InitWKey Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : ! initialization with default output length --->    CALL MD%CreateHMAC(Key) ! initialization with specified output length --->    CALL MD%CreateHMAC(Key, OutputLen) private  subroutine Blake2S_InitWKey(MD, Key, OutputLen) To perform initialization of the digest object with the specified key and\n the optionally specified length of hash output. Arguments Type Intent Optional Attributes Name class( Blake2S ), intent(inout) :: MD 'Blake2S' object integer(kind=kInt8), intent(in) :: Key (0:) an (8-bit integer) byte array representing a key for a keyed hashing integer(kind=kInt32), intent(in), optional :: OutputLen desired length of hash output; must be between 1 and 32 bytes. Source Code TYPE , EXTENDS ( Blake2Core ) :: Blake2S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% internal state tInteger :: H ( 0 : 7 ) = IV ( 0 : 7 ) !% counter's LSB tInteger :: T0 = 0 !% counter's MSB tInteger :: T1 = 0 CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitWOutLen* method to !  initialize the *digest* object with the specified hash output length. PROCEDURE , PRIVATE :: InitWOutLen => Blake2S_InitWOutLen !> Use the *Create* method in place of the *InitWKey* method to initialize !  the *digest* object with the specified key for keyed hashing (and the !  optionally specified hash output length). PROCEDURE , PRIVATE :: InitWKey => Blake2S_InitWKey ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default hash output length. PROCEDURE :: Initialize => Blake2S_InitDefault !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake2S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake2S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake2S_GetName !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake2S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake2S_ProcessBlock !> *EncodeOutput* is a procedure to encode the hash output. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: EncodeOutput => Blake2S_EncodeOutput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                (as a hasher). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%Create() <br> !   ! initialization with specified output length <br> GENERIC :: Create => InitWOutLen !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%CreateHMAC(Key) <br> !   ! initialization with specified output length <br> !   --->    CALL MD%CreateHMAC(Key, OutputLen) <br> GENERIC :: CreateHMAC => InitWKey ! --------------------------------------------------------------------- END TYPE Blake2S","tags":"","loc":"type\\blake2s.html"},{"title":"MD4 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: MD4 MD4 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD4 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => MD4_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. private  subroutine MD4_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: MD 'MD4' object procedure, public :: Reset => MD4_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine MD4_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: MD 'MD4' object procedure, public :: GetClone => MD4_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine MD4_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => MD4_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function MD4_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(in) :: MD 'MD4' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => MD4_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function MD4_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( MD4 ), intent(in) :: MD 'MD4' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => MD4_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function MD4_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(in) :: MD 'MD4' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => MD4_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine MD4_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout), TARGET :: MD 'MD4' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => MD4_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine MD4_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: MD 'MD4' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => MD4_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD4_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: MD 'MD4' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => MD4_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD4_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( MD4 ), intent(inout) :: MD 'MD4' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset Source Code TYPE , EXTENDS ( MDHelper ) :: MD4 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 3 ) = IV ( 0 : 3 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD4_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD4_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD4_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD4_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD4_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD4_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD4_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD4_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD4_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD4_AddBitsNPad END TYPE MD4","tags":"","loc":"type\\md4.html"},{"title":"SipHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: SipHasher64 SipHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Sip hash algorithm by Jean-Philippe Aumasson. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Sip_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Sip_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Sip_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Sip_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Sip_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Sip_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Sip_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Sip_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Sip_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with default keys and rounds (i.e. Sip24). Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Sip_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWKey => Sip_Initialize_wKey Type-Bound Subroutine : InitializeWKey Purpose :  To initialize the hasher with keys and optionally the number of rounds. Usage : ! hash value (with default rounds and sign) --->    CALL Hasher%InitializeWKey(Seed, Key) ! hash value with specified rounds --->    CALL Hasher%InitializeWKey(Seed, Key, cRound=1, dRound=3) ! hash value with specified remove sign flag --->    CALL Hasher%InitializeWKey(Seed, Key, RemoveSign=.TRUE.) private  subroutine Sip_Initialize_wKey(HS, Seed, Key, cRound, dRound, RemoveSign) To initialize the hasher with keys and optionally the number of rounds. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt32), intent(in), optional :: cRound number of C rounds integer(kind=kInt32), intent(in), optional :: dRound number of D rounds logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Sip_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Sip_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Sip_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally) with optional\n               seed and remove sign flag (and default key and number of rounds). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Sip_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: HashDirectWKey => Sip_HashDirect_wKey Type-Bound Function : HashDirectWKey Purpose :  To compute the hash value directly with specified seed and keys\n               and optionally the number of rounds. Usage : --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key) --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, cRound=2, dRound=4) --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Sip_HashDirect_wKey(HS, Input, InpSize, Seed, Key, cRound, dRound, RemoveSign) result(HashCode) To compute the hash value directly with specified seed and keys\n and optionally the number of rounds. Arguments Type Intent Optional Attributes Name class( SipHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt32), intent(in), optional :: cRound number of C rounds integer(kind=kInt32), intent(in), optional :: dRound number of D rounds logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: SipHasher64 PRIVATE !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% number of C rounds tIndex :: cRound = 2_kIndex !% number of D rounds tIndex :: dRound = 4_kIndex !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Sip_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Sip_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Sip_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Sip_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with default keys and rounds (i.e. Sip24). <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Sip_Initialize !> **Type-Bound Subroutine**: InitializeWKey <br> !  **Purpose**:  To initialize the hasher with keys and optionally the number of rounds. <br> !  **Usage**: <br> !   ! hash value (with default rounds and sign) <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key) <br> !   ! hash value with specified rounds <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, cRound=1, dRound=3) <br> !   ! hash value with specified remove sign flag <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, RemoveSign=.TRUE.) <br> PROCEDURE :: InitializeWKey => Sip_Initialize_wKey !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Sip_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) with optional !                seed and remove sign flag (and default key and number of rounds). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Sip_HashDirect !> **Type-Bound Function**: HashDirectWKey <br> !  **Purpose**:  To compute the hash value directly with specified seed and keys !                and optionally the number of rounds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key) <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, cRound=2, dRound=4) <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWKey => Sip_HashDirect_wKey END TYPE SipHasher64","tags":"","loc":"type\\siphasher64.html"},{"title":"SpookyHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: SpookyHasher64 SpookyHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Spooky hash algorithm by Bob Jenkins. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Spooky_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Spooky_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Spooky_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Spooky_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Spooky_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Spooky_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Spooky_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Spooky_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Spooky_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Spooky_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSeeds => Spooky_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value private  subroutine Spooky_Initialize_WithSeeds(HS, Seed1, Seed2, RemoveSign) To initialize the hasher with two seeds. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Spooky_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Spooky_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Spooky_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Spooky_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: SpookyHasher64 PRIVATE !% state tUInt64 :: State ( StateSize ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Spooky_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Spooky_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Spooky_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Spooky_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Spooky_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => Spooky_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Spooky_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Spooky_HashDirect END TYPE SpookyHasher64","tags":"","loc":"type\\spookyhasher64.html"},{"title":"SpookyHasher128 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( SpookyHasher64 ) :: SpookyHasher128 SpookyHasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the SpookyHasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetBlockLength => Spooky_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Spooky_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Spooky_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Spooky_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Spooky_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Spooky_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Spooky_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Spooky_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSeeds => Spooky_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value private  subroutine Spooky_Initialize_WithSeeds(HS, Seed1, Seed2, RemoveSign) To initialize the hasher with two seeds. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Spooky_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Spooky_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => Spooky_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Spooky_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SpookyHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: GetName => Spooky_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Spooky_GetName128(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( SpookyHasher128 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Finalize128 => Spooky_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() private  function Spooky_Finalize128(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 128-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( SpookyHasher128 ), intent(inout) :: HS a hasher (HS) object Return Value type(SInt128) hash code procedure, public :: HashDirect128 => Spooky_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Spooky_HashDirect128(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( SpookyHasher128 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value type(SInt128) hash code Source Code TYPE , EXTENDS ( SpookyHasher64 ) :: SpookyHasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Spooky_GetName128 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => Spooky_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => Spooky_HashDirect128 END TYPE SpookyHasher128","tags":"","loc":"type\\spookyhasher128.html"},{"title":"SHA0 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: SHA0 SHA0 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the SHA-0 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => SHA0_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. private  subroutine SHA0_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: MD 'SHA0' object procedure, public :: Reset => SHA0_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SHA0_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: MD 'SHA0' object procedure, public :: GetClone => SHA0_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHA0_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHA0_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHA0_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(in) :: MD 'SHA0' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SHA0_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SHA0_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(in) :: MD 'SHA0' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SHA0_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SHA0_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(in) :: MD 'SHA0' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SHA0_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SHA0_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout), TARGET :: MD 'SHA0' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SHA0_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SHA0_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: MD 'SHA0' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SHA0_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA0_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: MD 'SHA0' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SHA0_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA0_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SHA0 ), intent(inout) :: MD 'SHA0' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset Source Code TYPE , EXTENDS ( MDHelper ) :: SHA0 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 4 ) = IV ( 0 : 4 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => SHA0_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA0_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA0_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA0_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA0_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA0_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA0_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA0_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA0_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA0_AddBitsNPad END TYPE SHA0","tags":"","loc":"type\\sha0.html"},{"title":"SHA2S – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: SHA2S SHA2B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either the SHA-224 or the SHA-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => SHA2S_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA-256). private  subroutine SHA2S_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object procedure, public :: Reset => SHA2S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SHA2S_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object procedure, public :: GetClone => SHA2S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHA2S_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHA2S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHA2S_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(in) :: MD 'SHA2S' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SHA2S_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SHA2S_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(in) :: MD 'SHA2S' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SHA2S_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SHA2S_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(in) :: MD 'SHA2S' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SHA2S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SHA2S_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout), TARGET :: MD 'SHA2S' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SHA2S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2S_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SHA2S_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2S_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SHA2S_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2S_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA-224 algorithm --->    CALL MD%Create(IsSHA224=.TRUE.) private  subroutine SHA2S_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object private  subroutine SHA2S_Initialize_wFlag(MD, IsSHA224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( SHA2S ), intent(inout) :: MD 'SHA2S' object logical, intent(in) :: IsSHA224 flag indicating whether the SHA-224 algorithm is employed or not. - If true, use the SHA-224 algorithm. - Otherwise, use the SHA-256 algorithm. Source Code TYPE , EXTENDS ( MDHelper ) :: SHA2S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 7 ) = IV256 ( 0 : 7 ) !% flag indicating whether the SHA-224 algorithm is employed or not. tLogical :: IsSHA224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SHA2S_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA-256). PROCEDURE :: Initialize => SHA2S_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA2S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA2S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA2S_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA2S_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA2S_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA2S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA2S_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA2S_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA2S_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA-224 algorithm <br> !   --->    CALL MD%Create(IsSHA224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag END TYPE SHA2S","tags":"","loc":"type\\sha2s.html"},{"title":"GroestlB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: GroestlB GroestlB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the Groestl-384 or the Groestl-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => GroestlB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Groestl-512). private  subroutine GroestlB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object procedure, public :: Reset => GroestlB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine GroestlB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object procedure, public :: GetClone => GroestlB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine GroestlB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => GroestlB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function GroestlB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(in) :: MD 'GroestlB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => GroestlB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function GroestlB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(in) :: MD 'GroestlB' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => GroestlB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function GroestlB_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(in) :: MD 'GroestlB' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => GroestlB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine GroestlB_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout), TARGET :: MD 'GroestlB' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => GroestlB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlB_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => GroestlB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlB_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => GroestlB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine GroestlB_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Groestl-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the Groestl-384 algorithm --->    CALL MD%Create(IsGroestl384=.TRUE.) private  subroutine GroestlB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object private  subroutine GroestlB_Initialize_wFlag(MD, IsGroestl384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( GroestlB ), intent(inout) :: MD 'GroestlB' object logical, intent(in) :: IsGroestl384 flag indicating whether the Groestl-384 algorithm is employed or not. - If true, use the Groestl-384 algorithm. - Otherwise, use the Groestl-512 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: GroestlB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 15 ) = 0_kInt64 !% flag indicating whether the Groestl-384 algorithm is employed or not. tLogical :: IsGroestl384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => GroestlB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Groestl-512). PROCEDURE :: Initialize => GroestlB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => GroestlB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => GroestlB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => GroestlB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => GroestlB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => GroestlB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => GroestlB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => GroestlB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => GroestlB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => GroestlB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Groestl-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Groestl-384 algorithm <br> !   --->    CALL MD%Create(IsGroestl384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE GroestlB","tags":"","loc":"type\\groestlb.html"},{"title":"FarmNaHasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: FarmNaHasher64 FarmNaHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the FarmNa hash algorithm by Google Inc. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => FarmNa_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function FarmNa_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => FarmNa_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function FarmNa_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => FarmNa_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine FarmNa_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => FarmNa_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine FarmNa_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => FarmNa_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with one seed. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine FarmNa_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSeeds => FarmNa_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value private  subroutine FarmNa_Initialize_WithSeeds(HS, Seed1, Seed2, RemoveSign) To initialize the hasher with two seeds. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => FarmNa_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function FarmNa_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => FarmNa_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally)\n               without seed or with one seed. Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function FarmNa_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: HashDirectWSeeds => FarmNa_HashDirect_WithSeeds Type-Bound Function : HashDirectWSeeds Purpose :  To compute the hash value directly (non-incrementally)\n               with two seeds. Usage : --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function FarmNa_HashDirect_WithSeeds(HS, Input, InpSize, Seed1, Seed2, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) with two seeds. Arguments Type Intent Optional Attributes Name class( FarmNaHasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed1 seed1 integer(kind=kInt64), intent(in) :: Seed2 seed2 logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: FarmNaHasher64 PRIVATE !% seeds tUInt64 :: Seed ( 2 ) = 0_kInt64 !% state tUInt64 :: State ( 7 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => FarmNa_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => FarmNa_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => FarmNa_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => FarmNa_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with one seed. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => FarmNa_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => FarmNa_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => FarmNa_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                without seed or with one seed. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => FarmNa_HashDirect !> **Type-Bound Function**: HashDirectWSeeds <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                with two seeds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSeeds => FarmNa_HashDirect_WithSeeds END TYPE FarmNaHasher64","tags":"","loc":"type\\farmnahasher64.html"},{"title":"XXHasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher32 ) :: XXHasher32 XXHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the XX hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => XX_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function XX_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => XX_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function XX_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => XX_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => XX_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => XX_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine XX_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => XX_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function XX_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure, public :: HashDirect => XX_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( XXHasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( Hasher32 ) :: XXHasher32 PRIVATE !% state tUInt32 :: State ( 4 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 15 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX_HashDirect END TYPE XXHasher32","tags":"","loc":"type\\xxhasher32.html"},{"title":"MD5 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: MD5 MD5 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD5 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => MD5_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. private  subroutine MD5_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: MD 'MD5' object procedure, public :: Reset => MD5_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine MD5_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: MD 'MD5' object procedure, public :: GetClone => MD5_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine MD5_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => MD5_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function MD5_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(in) :: MD 'MD5' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => MD5_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function MD5_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( MD5 ), intent(in) :: MD 'MD5' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => MD5_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function MD5_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(in) :: MD 'MD5' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => MD5_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine MD5_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout), TARGET :: MD 'MD5' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => MD5_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine MD5_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: MD 'MD5' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => MD5_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD5_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: MD 'MD5' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => MD5_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine MD5_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( MD5 ), intent(inout) :: MD 'MD5' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset Source Code TYPE , EXTENDS ( MDHelper ) :: MD5 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 3 ) = IV ( 0 : 3 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD5_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD5_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD5_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD5_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD5_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD5_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD5_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD5_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD5_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD5_AddBitsNPad END TYPE MD5","tags":"","loc":"type\\md5.html"},{"title":"KP1600Sponge – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: KP1600Sponge KP1600Sponge is a derived type representing a sponge instance for\n use with the Keccak Sponge functions.  It gathers the state processed\n by the permutation as well as the rate. Finalization Procedures final :: KP1600Sponge_Finalize private  subroutine KP1600Sponge_Finalize(Instance) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( KP1600Sponge ), intent(inout) :: Instance 'Sponge' instance Type-Bound Procedures procedure, public :: Initialize => KP1600Sponge_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the Sponge instance. Usage : --->    CALL Instance%Initialize(Capacity, nRounds) private  subroutine KP1600Sponge_Initialize(Instance, Capacity, NRounds) To initialize the state of the Keccak-p[1600, nRounds] sponge function.\n The phase of the sponge function is set to absorbing. Note: the capacity 'c' is a double of the security strength of a particular\n       cryptographic hash function. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout), TARGET :: Instance 'Sponge' instance integer(kind=kInt32), intent(in) :: Capacity value of the capacity c integer(kind=kInt32), intent(in) :: NRounds the number of rounds to be permuted procedure, public :: Absorb => KP1600Sponge_Absorb Type-Bound Function : Absorb Purpose :  To insert input data in bytes to be absorbed by Sponge instance. Usage : --->    Flag = Instance%Absorb(Input, InpSize) --->    IF (.NOT.Instance%Absorb(Input, InpSize)) DoSomething Note : Must call this method before calling either the AbsorbLastFewBits method or the Squeeze method. private  function KP1600Sponge_Absorb(Instance, InpDat, InpByteLen) result(RetFlag) To insert input data in bytes to be absorbed by the sponge function. The sponge function must be in the absorbing phase, which means that\n the Squeezing flag is currently set to false.  Otherwise, the routine\n return a FAILURE value. This also indicates that this function (i.e. the Absorb method) must be\n called before the AbsorbLastFewBits method or the Squeeze method is\n called. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance 'Sponge' instance integer(kind=kInt8), intent(in) :: InpDat (0:) input data as an array of 8-bit integers integer(kind=kInt32), intent(in) :: InpByteLen size of input data in bytes Return Value integer(kind=kInt8) Returned flag indicating whether the operation is successful or not. - Return the FAILURE value if the Squeezing flag is true. - Otherwise, return the SUCCESS value. procedure, public :: AbsorbLastFewBits => KP1600Sponge_AbsorbLastFewBits Type-Bound Function : AbsorbLastFewBits Purpose :  To insert input data in bits to be absorbed by Sponge instance. Usage : --->    Flag = Instance%AbsorbLastFewBits(LastByte) --->    IF (.NOT.Instance%AbsorbLastFewBits(LastByte)) DoSomething Note : Must call this method only once and before calling the Squeeze method. private  function KP1600Sponge_AbsorbLastFewBits(Instance, DelimitedData) result(RetFlag) To insert input data in bits to be absorbed by the sponge function and\n then switch to the squeezing phase. The sponge function must be in the absorbing phase, which means that\n the Squeezing flag is currently set to false.  Otherwise, the routine\n return a FAILURE value. This also indicates that this function (i.e. the AbsorbLastFewBits method)\n must be called only once and before the Squeeze method is called. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance 'Sponge' instance integer(kind=kInt8), intent(in) :: DelimitedData A single byte containing from 0 to 7 trailing bits that must be absorbed.\n These n bits must be in the least significant bit positions. These bits\n must be delimited with a bit 1 at position n (counting from 0=LSB to 7=MSB)\n and followed by bits 0 from position n +1 to position 7. Some examples: - If no bits are to be absorbed, then DelimitedData must be Z'01'. - If the 2-bit sequence 0,0 is to be absorbed, DelimitedData must be Z'04'. - If the 5-bit sequence 0,1,0,0,1 is to be absorbed, DelimitedData must be Z'32'. - If the 7-bit sequence 1,1,0,1,0,0,0 is to be absorbed, DelimitedData must be Z'8B'. DelimitedData must NOT be zero. Return Value integer(kind=kInt8) Returned flag indicating whether the operation is successful or not. - Return the FAILURE value if the Squeezing flag is true or DelimitedData is zero. - Otherwise, return the SUCCESS value. procedure, public :: Permute => KP1600Sponge_Permute Type-Bound Subroutine : Permute Purpose :  To perform a permutation of the state of the Sponge instance. Usage : --->    CALL Instance%Permute() private  subroutine KP1600Sponge_Permute(Instance) To perform a permutation of the state of the instance. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance 'Sponge' instance procedure, public :: Squeeze => KP1600Sponge_Squeeze Type-Bound Function : Squeeze Purpose :  To retrieve output data from Sponge instance. Usage : --->    Flag = Instance%Squeeze(Output, OutSize) --->    IF (.NOT.Instance%Squeeze(Output, OutSize)) DoSomething private  function KP1600Sponge_Squeeze(Instance, OutDat, OutByteLen) result(RetFlag) To squeeze output data from the sponge function.  If the sponge function\n was in the absorbing phase, this function switches it to the squeezing\n phase as if the AbsorbLastFewBits method was called. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance 'Sponge' instance integer(kind=kInt8), intent(out) :: OutDat (0:) a byte array to store the output data integer(kind=kInt32), intent(in) :: OutByteLen the number of output bytes desired Return Value integer(kind=kInt8) Returned flag indicating whether the operation is successful or not. - Return the FAILURE value if the operation is NOT successful. - Otherwise, return the SUCCESS value. procedure, public :: GetByteIOIndex => KP1600Sponge_GetByteIOIndex Type-Bound Function : GetByteIOIndex Purpose :  To get value of the ByteIOIndex component of the Sponge instance. Usage : --->    Index = Instance%GetByteIOIndex() private  function KP1600Sponge_GetByteIOIndex(Instance) result(Indx) To return the ByteIOIndex variable. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance Return Value integer(kind=kInt32) procedure, public :: SetByteIOIndex => KP1600Sponge_SetByteIOIndex Type-Bound Subroutine : SetByteIOIndex Purpose :  To set value of the ByteIOIndex component of the Sponge instance. Usage : --->    CALL Instance%SetByteIOIndex(Index) private  subroutine KP1600Sponge_SetByteIOIndex(Instance, Indx) To set the ByteIOIndex variable. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Instance integer(kind=kInt32), intent(in) :: Indx procedure, public :: CopyState => KP1600Sponge_CopyState Type-Bound Subroutine : CopyState Purpose :  To copy the current state of the source instance. Usage : --->    CALL Src%CopyState(Dst) private  subroutine KP1600Sponge_CopyState(Src, Dst) To copy the current states of the source instance to the destination instance. Note: Only those that would be changed during various operations are copied.\n       Those that would not be changed are expected to be copied to the\n       destination during its construction. Arguments Type Intent Optional Attributes Name class( KP1600Sponge ), intent(inout) :: Src the source instance class( KP1600Sponge ), intent(inout) :: Dst the destination instance Source Code TYPE KP1600Sponge PRIVATE !% The state in bytes processed by the permutation tByte :: State ( 0 : KP1600SizeInBytes - 1 ) = 0_kInt8 !% The state in words; an alias of the state tLong , POINTER :: StateAsWords (:) => NULL () !% The number of permutation rounds tInteger :: NRounds = 24 !% The value of the rate in bits tInteger :: Rate !% The position in the state of the next byte to be input/output tInteger :: ByteIOIndex = 0 !% The flag for squeezing tLogical :: Squeezing = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AddByte => KP1600Sponge_AddByte PROCEDURE , PRIVATE :: AddBytes => KP1600Sponge_AddBytes PROCEDURE , PRIVATE :: ExtractBytes => KP1600Sponge_ExtractBytes ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%Initialize(Capacity, nRounds) PROCEDURE :: Initialize => KP1600Sponge_Initialize !> **Type-Bound Function**: Absorb <br> !  **Purpose**:  To insert input data in bytes to be absorbed by *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%Absorb(Input, InpSize) <br> !   --->    IF (.NOT.Instance%Absorb(Input, InpSize)) DoSomething <br> !  **Note**: Must call this method before calling either the *AbsorbLastFewBits* !            method or the *Squeeze* method. <br> PROCEDURE :: Absorb => KP1600Sponge_Absorb !> **Type-Bound Function**: AbsorbLastFewBits <br> !  **Purpose**:  To insert input data in bits to be absorbed by *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%AbsorbLastFewBits(LastByte) <br> !   --->    IF (.NOT.Instance%AbsorbLastFewBits(LastByte)) DoSomething <br> !  **Note**: Must call this method only once and before calling the *Squeeze* method. <br> PROCEDURE :: AbsorbLastFewBits => KP1600Sponge_AbsorbLastFewBits !> **Type-Bound Subroutine**: Permute <br> !  **Purpose**:  To perform a permutation of the state of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%Permute() PROCEDURE :: Permute => KP1600Sponge_Permute !> **Type-Bound Function**: Squeeze <br> !  **Purpose**:  To retrieve output data from *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%Squeeze(Output, OutSize) <br> !   --->    IF (.NOT.Instance%Squeeze(Output, OutSize)) DoSomething <br> PROCEDURE :: Squeeze => KP1600Sponge_Squeeze !> **Type-Bound Function**: GetByteIOIndex <br> !  **Purpose**:  To get value of the *ByteIOIndex* component of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    Index = Instance%GetByteIOIndex() PROCEDURE :: GetByteIOIndex => KP1600Sponge_GetByteIOIndex !> **Type-Bound Subroutine**: SetByteIOIndex <br> !  **Purpose**:  To set value of the *ByteIOIndex* component of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%SetByteIOIndex(Index) PROCEDURE :: SetByteIOIndex => KP1600Sponge_SetByteIOIndex !> **Type-Bound Subroutine**: CopyState <br> !  **Purpose**:  To copy the current state of the source instance. <br> !  **Usage**: <br> !   --->    CALL Src%CopyState(Dst) PROCEDURE :: CopyState => KP1600Sponge_CopyState ! --------------------------------------------------------------------- FINAL :: KP1600Sponge_Finalize ! --------------------------------------------------------------------- END TYPE KP1600Sponge","tags":"","loc":"type\\kp1600sponge.html"},{"title":"BmwB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: BmwB BmwB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BMW-384 or the BMW-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => BmwB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BMW-512). private  subroutine BmwB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object procedure, public :: Reset => BmwB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine BmwB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object procedure, public :: GetClone => BmwB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine BmwB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => BmwB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function BmwB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(in) :: MD 'BmwB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => BmwB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function BmwB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( BmwB ), intent(in) :: MD 'BmwB' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => BmwB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function BmwB_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(in) :: MD 'BmwB' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => BmwB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine BmwB_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout), TARGET :: MD 'BmwB' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => BmwB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine BmwB_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => BmwB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine BmwB_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => BmwB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine BmwB_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BMW-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the BMW-384 algorithm --->    CALL MD%Create(IsBMW384=.TRUE.) private  subroutine BmwB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object private  subroutine BmwB_Initialize_wFlag(MD, IsBMW384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( BmwB ), intent(inout) :: MD 'BmwB' object logical, intent(in) :: IsBMW384 flag indicating whether the BMW-384 algorithm is employed or not. - If true, use the BMW-384 algorithm. - Otherwise, use the BMW-512 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: BmwB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 15 ) = IV512 ( 0 : 15 ) !% flag indicating whether the BMW-384 algorithm is employed or not. tLogical :: IsBMW384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => BmwB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BMW-512). PROCEDURE :: Initialize => BmwB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => BmwB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => BmwB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => BmwB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => BmwB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => BmwB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => BmwB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => BmwB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => BmwB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => BmwB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BMW-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BMW-384 algorithm <br> !   --->    CALL MD%Create(IsBMW384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE BmwB","tags":"","loc":"type\\bmwb.html"},{"title":"Blake1S – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: Blake1S Blake1S is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BLAKE-224 or the BLAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Blake1S_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BLAKE-256). private  subroutine Blake1S_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object procedure, public :: Reset => Blake1S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Blake1S_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object procedure, public :: GetClone => Blake1S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Blake1S_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Blake1S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Blake1S_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(in) :: MD 'Blake1S' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => Blake1S_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Blake1S_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(in) :: MD 'Blake1S' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => Blake1S_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function Blake1S_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(in) :: MD 'Blake1S' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Blake1S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine Blake1S_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout), TARGET :: MD 'Blake1S' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Blake1S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1S_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => Blake1S_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1S_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => Blake1S_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine Blake1S_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BLAKE-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the BLAKE-224 algorithm --->    CALL MD%Create(IsBLAKE224=.TRUE.) private  subroutine Blake1S_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object private  subroutine Blake1S_Initialize_wFlag(MD, IsBLAKE224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( Blake1S ), intent(inout) :: MD 'Blake1S' object logical, intent(in) :: IsBLAKE224 flag indicating whether the BLAKE-224 algorithm is employed or not. - If true, use the BLAKE-224 algorithm. - Otherwise, use the BLAKE-256 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: Blake1S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 7 ) = IV256 ( 0 : 7 ) tInteger :: S ( 0 : 3 ) = 0 tInteger :: T ( 0 : 1 ) = 0 !% flag indicating whether the BLAKE-224 algorithm is employed or not. tLogical :: IsBLAKE224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => Blake1S_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BLAKE-256). PROCEDURE :: Initialize => Blake1S_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake1S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake1S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake1S_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake1S_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Blake1S_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake1S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake1S_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Blake1S_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Blake1S_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BLAKE-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BLAKE-224 algorithm <br> !   --->    CALL MD%Create(IsBLAKE224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE Blake1S","tags":"","loc":"type\\blake1s.html"},{"title":"MDEngine – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseDigest ) :: MDEngine MDEngine is an abstract digest type provided to be a template\n (a parent class) for other digest types to implement incremental\n cryptographic hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. subroutine MDCreate(MD) Prototype MDCreate is a deferred procedure to perform any essential initialization\n of a digest object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() subroutine MDReset(MD) Prototype MDReset is a deferred procedure to reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) subroutine MDClone(Src, Dst) Prototype MDClone is a deferred procedure to clone the current state. The returned\n object evolves independently of this object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: Src a source digest object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination (clone) digest object procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() function MDName(MD) result(Name) Prototype MDName is a deferred procedure to get the display name for this hash\n function (e.g. \"SHA-1\" for SHA-1). Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(in) :: MD 'BaseDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure(DEDigestLen), public, deferred :: GetDigestLen GetDigestLen is a binding name of the DEDigestLen deferred procedure. Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() function DEDigestLen(MD) result(Length) Prototype DEDigestLen is a deferred procedure to return the natural hash\n function output length (in bytes). Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) the digest length procedure(DEBlockLen), public, deferred :: GetBlockLen GetBlockLen is a binding name of the DEBlockLen deferred procedure. This procedure is NOT intended to be used by a user. function DEBlockLen(MD) result(Length) Prototype DEBlockLen is a deferred procedure to return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD MDEngine object Return Value integer(kind=kInt32) the block length procedure(DESetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the DESetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine DESetPtr(MD, BufPtr) Prototype DESetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout), TARGET :: MD MDEngine object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(DEProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the DEProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine DEProcess(MD, BytesIn) Prototype DEProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD MDEngine object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure(DEPadding), public, deferred :: DoPadding DoPadding is a binding name of the DEPadding deferred procedure. This procedure is NOT intended to be used by a user. subroutine DEPadding(MD, BytesOut, Offset) Prototype DEPadding is a deferred procedure to perform the final padding and store\n the result in the provided buffer.  This method shall call the Flush method and then the Update method with the appropriate padding data\n in order to get the full input data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure(DEAddBitsNPad), public, deferred :: AddBitsNPad AddBitsNPad is a binding name of the DEAddBitsNPad deferred procedure. This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. subroutine DEAddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) Prototype DEAddBitsNPad is a deferred procedure to add the last byte and then perform\n the final padding and store the result in the provided buffer.  This method\n shall call the Flush and then the Update method with the appropriate\n padding data in order to get the full input data. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: MDEngine PRIVATE !% the number of blocks of input processed tIndex :: BlockCount = 0_kIndex !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                 Additional Deferred Procedures            ----- ! --------------------------------------------------------------------- !> *GetDigestLen* is a binding name of the *DEDigestLen* deferred procedure. <br> !  **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE ( DEDigestLen ), DEFERRED :: GetDigestLen !> *GetBlockLen* is a binding name of the *DEBlockLen* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEBlockLen ), DEFERRED :: GetBlockLen !> *SetBufPtr* is a binding name of the *DESetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DESetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *DEProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEProcess ), DEFERRED :: ProcessBlock !> *DoPadding* is a binding name of the *DEPadding* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEPadding ), DEFERRED :: DoPadding !> *AddBitsNPad* is a binding name of the *DEAddBitsNPad* deferred procedure. <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. PROCEDURE ( DEAddBitsNPad ), DEFERRED :: AddBitsNPad ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => MDEngine_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => MDEngine_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => MDEngine_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => MDEngine_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *EngineReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: EngineReset => MDEngine_Reset !> *EngineClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: EngineClone => MDEngine_Clone !> *GetBlockCount* is a procedure to get the number of blocks of input processed. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockCount => MDEngine_BlockCount !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => MDEngine_BufLen ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: MDEngine_ByteDigest_AddBits PROCEDURE , PRIVATE :: MDEngine_HexDigest_AddBits ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => MDEngine_ByteDigest_AddBits , & MDEngine_HexDigest_AddBits END TYPE MDEngine","tags":"","loc":"type\\mdengine.html"},{"title":"NMHasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher32 ) :: NMHasher32 NMHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the NM hash algorithm by James Z. M. Gao. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => NM_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function NM_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => NM_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function NM_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => NM_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine NM_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => NM_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine NM_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => NM_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine NM_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => NM_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function NM_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure, public :: HashDirect => NM_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function NM_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( Hasher32 ) :: NMHasher32 PRIVATE !% states tUInt32 :: AccX ( 0 : ACC_SIZE - 1 ) = 0_kInt32 tUInt32 :: AccY ( 0 : ACC_SIZE - 1 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => NM_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => NM_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => NM_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => NM_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => NM_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => NM_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => NM_HashDirect END TYPE NMHasher32","tags":"","loc":"type\\nmhasher32.html"},{"title":"NMxHasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( NMHasher32 ) :: NMxHasher32 Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetBlockLength => NM_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function NM_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => NM_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine NM_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => NM_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine NM_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => NM_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine NM_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: HashDirect => NM_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function NM_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( NMHasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code procedure, public :: GetName => NMx_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function NMx_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( NMxHasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Finalize => NMx_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function NMx_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( NMxHasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( NMHasher32 ) :: NMxHasher32 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => NMx_GetName !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => NMx_Finalize END TYPE NMxHasher32","tags":"","loc":"type\\nmxhasher32.html"},{"title":"Murmur3Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher32 ) :: Murmur3Hasher32 Murmur3Hasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the Murmur3 hash algorithm by Austin Appleby. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => Murmur3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function Murmur3_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function Murmur3_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine Murmur3_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine Murmur3_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function Murmur3_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function Murmur3_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( Murmur3Hasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( Hasher32 ) :: Murmur3Hasher32 PRIVATE !% state tUInt32 :: State = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 3 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Murmur3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Murmur3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Murmur3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Murmur3_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Murmur3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Murmur3_HashDirect END TYPE Murmur3Hasher32","tags":"","loc":"type\\murmur3hasher32.html"},{"title":"SIMDS – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: SIMDS SIMDS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SIMD-224 or the SIMD-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => SIMDS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SIMD-256). private  subroutine SIMDS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object procedure, public :: Reset => SIMDS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SIMDS_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object procedure, public :: GetClone => SIMDS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SIMDS_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SIMDS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SIMDS_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(in) :: MD 'SIMDS' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SIMDS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SIMDS_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(in) :: MD 'SIMDS' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SIMDS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SIMDS_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(in) :: MD 'SIMDS' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SIMDS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SIMDS_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout), TARGET :: MD 'SIMDS' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SIMDS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDS_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SIMDS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDS_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SIMDS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDS_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SIMD-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SIMD-224 algorithm --->    CALL MD%Create(IsSIMD224=.TRUE.) private  subroutine SIMDS_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object private  subroutine SIMDS_Initialize_wFlag(MD, IsSIMD224) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( SIMDS ), intent(inout) :: MD 'SIMDS' object logical, intent(in) :: IsSIMD224 flag indicating whether the SIMD-224 algorithm is employed or not. - If true, use the SIMD-224 algorithm. - Otherwise, use the SIMD-256 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: SIMDS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: State ( 0 : 15 ) = IV256 ( 0 : 15 ) !% flag indicating whether the SIMD-224 algorithm is employed or not. tLogical :: IsSIMD224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SIMDS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SIMD-256). PROCEDURE :: Initialize => SIMDS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SIMDS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SIMDS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SIMDS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SIMDS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SIMDS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SIMDS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SIMDS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SIMDS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SIMDS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SIMD-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SIMD-224 algorithm <br> !   --->    CALL MD%Create(IsSIMD224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE SIMDS","tags":"","loc":"type\\simds.html"},{"title":"Blake3 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: Blake3 Blake3 is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE3 message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC).  It can be used as\n a key derivation function (KDF) as well.  In addition, it can be employed as an\n extendable-output function (XOF) to output the hash value with a desired length. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Blake3_Initialize Use the Create method in place of the Initialize method to perform\n default initialization of the digest object. private  subroutine Blake3_Initialize(MD) To perform initialization of the digest object with\n default algorithm and default hash output length. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object procedure, public :: GetClone => Blake3_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Blake3_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Blake3_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Blake3_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(in) :: MD 'Blake3' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Reset => Blake3_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Blake3_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object procedure, public :: InsertBytes => Blake3_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Blake3_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Blake3_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Blake3_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Blake3_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Blake3_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Blake3_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Blake3_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CreateHMAC => Blake3_InitHMAC Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : --->    CALL MD%CreateHMAC(Key) private  subroutine Blake3_InitHMAC(MD, Key) Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD integer(kind=kInt8), intent(in) :: Key (0:BLAKE3_KEY_LEN*4-1) procedure, public :: CreateKDF => Blake3_InitKDF Type-Bound Subroutine : CreateKDF Purpose :  To perform any essential initialization of the digest object\n               as a KDF object (for key derivation). Usage : --->    CALL MD%CreateKDF(ContextString) private  subroutine Blake3_InitKDF(BaseMD, ContextStr) Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: BaseMD character(kind=kChar, len=*), intent(in) :: ContextStr generic, public :: DigestWOutLen => Blake3_ByteDigest_wOutLen, Blake3_ByteDigest_wInputNOutLen, Blake3_HexDigest_wOutLen, Blake3_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) private  subroutine Blake3_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Blake3_ByteDigest_wInputNOutLen(MD, Input, InpSize, ByteArr, OutputLen) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'Blake3' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Blake3_HexDigest_wOutLen(MD, HexStr, OutputLen) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes private  subroutine Blake3_HexDigest_wInputNOutLen(MD, Input, InpSize, HexStr, OutputLen) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( Blake3 ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output as a hexadecimal string integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes Source Code TYPE , EXTENDS ( BaseDigest ) :: Blake3 PRIVATE !% stored key tInteger :: Key ( 0 : BLAKE3_KEY_LEN - 1 ) !% chunk state variable TYPE ( ChunkState ) :: Chunk !% chaining value stack tByte :: CVStack ( 0 :( BLAKE3_MAX_DEPTH + 1 ) * BLAKE3_OUT_LEN - 1 ) !% the number of chaining values occupying the stack tByte :: CVStackLen CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: DoInit => Blake3_InitBase PROCEDURE , PRIVATE :: DoUpdate => Blake3_Update PROCEDURE , PRIVATE :: Blake3_Finalize PROCEDURE , PRIVATE :: Blake3_Finalize_Seek GENERIC , PRIVATE :: DoFinal => Blake3_Finalize , Blake3_Finalize_Seek PROCEDURE , PRIVATE :: MergeCVStack => Blake3_Merge_CVStack PROCEDURE , PRIVATE :: PushCV => Blake3_Push_CV PROCEDURE , PRIVATE :: Blake3_ByteDigest_wOutLen PROCEDURE , PRIVATE :: Blake3_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: Blake3_HexDigest_wOutLen PROCEDURE , PRIVATE :: Blake3_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to perform !  default initialization of the *digest* object. PROCEDURE :: Initialize => Blake3_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake3_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake3_GetName !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake3_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Blake3_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Blake3_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Blake3_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Blake3_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   --->    CALL MD%CreateHMAC(Key) <br> PROCEDURE :: CreateHMAC => Blake3_InitHMAC !> **Type-Bound Subroutine**: CreateKDF <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *KDF* object (for key derivation). <br> !  **Usage**: <br> !   --->    CALL MD%CreateKDF(ContextString) <br> PROCEDURE :: CreateKDF => Blake3_InitKDF ! --------------------------------------------------------------------- ! -----                     Generic Interface                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> GENERIC :: DigestWOutLen => Blake3_ByteDigest_wOutLen , & Blake3_ByteDigest_wInputNOutLen , & Blake3_HexDigest_wOutLen , & Blake3_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE Blake3","tags":"","loc":"type\\blake3.html"},{"title":"XX3Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher64 ) :: XX3Hasher64 XX3Hasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the XX3 hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => XX3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function XX3_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => XX3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function XX3_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => XX3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX3_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => XX3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX3_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => XX3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine XX3_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSecret => XX3_Initialize_wSecret Type-Bound Subroutine : InitializeWSecret Purpose :  To initialize the hasher with specified secret. Usage : --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value private  subroutine XX3_Initialize_wSecret(HS, Seed, Secret, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in), TARGET :: Secret (0:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => XX3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function XX3_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: HashDirect => XX3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: HashDirectWSecret => XX3_HashDirect_wSecret Type-Bound Function : HashDirectWSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect_wSecret(HS, Input, InpSize, Seed, Secret, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , EXTENDS ( Hasher64 ) :: XX3Hasher64 PRIVATE !% seed tUInt64 :: Seed = 0_kInt64 !% state tUInt64 :: State ( 0 : 7 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% pointer to custom secret tUInt8 , POINTER :: Secret (:) => NULL () !% number of stripes processed tIndex :: nStripe = 0_kIndex !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX3_Initialize !> **Type-Bound Subroutine**: InitializeWSecret <br> !  **Purpose**:  To initialize the hasher with specified secret. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value <br> PROCEDURE :: InitializeWSecret => XX3_Initialize_wSecret !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX3_HashDirect !> **Type-Bound Function**: HashDirectWSecret <br> !  **Purpose**:  To compute the hash value directly with specified seed and secret. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) <br> !   --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSecret => XX3_HashDirect_wSecret END TYPE XX3Hasher64","tags":"","loc":"type\\xx3hasher64.html"},{"title":"XX3Hasher128 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( XX3Hasher64 ) :: XX3Hasher128 XX3Hasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the XX3Hasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetBlockLength => XX3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function XX3_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => XX3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX3_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => XX3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine XX3_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => XX3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine XX3_Initialize(HS, Seed, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWSecret => XX3_Initialize_wSecret Type-Bound Subroutine : InitializeWSecret Purpose :  To initialize the hasher with specified secret. Usage : --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value private  subroutine XX3_Initialize_wSecret(HS, Seed, Secret, RemoveSign) To initialize the hasher without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in), TARGET :: Secret (0:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: HashDirect => XX3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: HashDirectWSecret => XX3_HashDirect_wSecret Type-Bound Function : HashDirectWSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect_wSecret(HS, Input, InpSize, Seed, Secret, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code procedure, public :: GetName => XX3_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function XX3_GetName128(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( XX3Hasher128 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: Finalize => XX3_Finalize64 Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function XX3_Finalize64(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( XX3Hasher128 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure, public :: Finalize128 => XX3_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() private  function XX3_Finalize128(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 128-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( XX3Hasher128 ), intent(inout) :: HS a hasher (HS) object Return Value type(SInt128) hash code procedure, public :: HashDirect128 => XX3_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect128(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) without seed or with one seed. Arguments Type Intent Optional Attributes Name class( XX3Hasher128 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value type(SInt128) hash code procedure, public :: HashDirect128WSecret => XX3_HashDirect128_wSecret Type-Bound Function : HashDirect128WSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function XX3_HashDirect128_wSecret(HS, Input, InpSize, Seed, Secret, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental) with seed and secret. Arguments Type Intent Optional Attributes Name class( XX3Hasher128 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value type(SInt128) hash code Source Code TYPE , EXTENDS ( XX3Hasher64 ) :: XX3Hasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX3_GetName128 !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX3_Finalize64 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => XX3_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => XX3_HashDirect128 !> **Type-Bound Function**: HashDirect128WSecret <br> !  **Purpose**:  To compute the hash value directly with specified seed and secret. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret) <br> !   --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128WSecret => XX3_HashDirect128_wSecret END TYPE XX3Hasher128","tags":"","loc":"type\\xx3hasher128.html"},{"title":"SIMDB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: SIMDB SIMDB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SIMD-384 or the SIMD-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => SIMDB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SIMD-512). private  subroutine SIMDB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object procedure, public :: Reset => SIMDB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SIMDB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object procedure, public :: GetClone => SIMDB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SIMDB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SIMDB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SIMDB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(in) :: MD 'SIMDB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SIMDB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SIMDB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(in) :: MD 'SIMDB' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SIMDB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SIMDB_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(in) :: MD 'SIMDB' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SIMDB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SIMDB_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout), TARGET :: MD 'SIMDB' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SIMDB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDB_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SIMDB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDB_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SIMDB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SIMDB_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SIMD-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SIMD-384 algorithm --->    CALL MD%Create(IsSIMD384=.TRUE.) private  subroutine SIMDB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object private  subroutine SIMDB_Initialize_wFlag(MD, IsSIMD384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( SIMDB ), intent(inout) :: MD 'SIMDB' object logical, intent(in) :: IsSIMD384 flag indicating whether the SIMD-384 algorithm is employed or not. - If true, use the SIMD-384 algorithm. - Otherwise, use the SIMD-512 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: SIMDB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: State ( 0 : 31 ) = IV512 ( 0 : 31 ) !% flag indicating whether the SIMD-384 algorithm is employed or not. tLogical :: IsSIMD384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SIMDB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SIMD-512). PROCEDURE :: Initialize => SIMDB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SIMDB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SIMDB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SIMDB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SIMDB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SIMDB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SIMDB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SIMDB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SIMDB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SIMDB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SIMD-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SIMD-384 algorithm <br> !   --->    CALL MD%Create(IsSIMD384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE SIMDB","tags":"","loc":"type\\simdb.html"},{"title":"Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseHasher ) :: Hasher64 Hasher64 is an abstract type representing a hasher that outputs the hash value\n as a 64-bit integer for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() function HSName(HS) result(Name) Prototype HSName is a deferred procedure to return the name of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. function HSBlockLen(HS) result(Length) Prototype HSBlockLen is a deferred procedure to return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSSetPtr(HS, BufPtr) Prototype HSSetPtr is a deferred procedure to set the pointer BufPtr to\n the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. subroutine HSProcess(HS, BytesIn) Prototype HSProcess is a deferred procedure to process one block of data. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure(HS64Init), public, deferred :: Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value subroutine HS64Init(HS, Seed, RemoveSign) Prototype HS64Init is a deferred procedure to initialize the hasher. Arguments Type Intent Optional Attributes Name class( Hasher64 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt64), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign procedure(HS64Final), public, deferred :: Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() function HS64Final(HS) result(HashCode) Prototype HS64Final is a deferred procedure to finalize the current hash computation\n and return the hash value in a 64-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( Hasher64 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt64) hash code procedure(HS64Hash), public, deferred :: HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. function HS64Hash(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) Prototype HS64Hash is a deferred procedure to compute the hash value directly\n (non-incrementally). Arguments Type Intent Optional Attributes Name class( Hasher64 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Source Code TYPE , ABSTRACT , EXTENDS ( BaseHasher ) :: Hasher64 CONTAINS !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE ( HS64Init ), DEFERRED :: Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE ( HS64Final ), DEFERRED :: Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE ( HS64Hash ), DEFERRED :: HashDirect END TYPE Hasher64","tags":"","loc":"type\\hasher64.html"},{"title":"KP1600Core – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseDigest ) :: KP1600Core KP1600Core is an abstract digest type provided to be a parent\n type for other Keccak-based digest types to implement incremental\n cryptographic hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. subroutine MDCreate(MD) Prototype MDCreate is a deferred procedure to perform any essential initialization\n of a digest object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) subroutine MDClone(Src, Dst) Prototype MDClone is a deferred procedure to clone the current state. The returned\n object evolves independently of this object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: Src a source digest object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination (clone) digest object procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() function MDName(MD) result(Name) Prototype MDName is a deferred procedure to get the display name for this hash\n function (e.g. \"SHA-1\" for SHA-1). Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(in) :: MD 'BaseDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine KP1600Core_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine KP1600Core_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine KP1600Core_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine KP1600Core_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine KP1600Core_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. private  subroutine KP1600Core_Initialize(MD, Capacity, Suffix, DigestLen, NRounds) To initialize components of the 'KP1600Core' object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt32), intent(in) :: Capacity the value of the capacity C integer(kind=kInt8), intent(in) :: Suffix suffix for padding integer(kind=kInt32), intent(in) :: DigestLen the desired length of output in bytes integer(kind=kInt32), intent(in), optional :: NRounds number of permutation rounds procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. private  subroutine KP1600Core_CopyState(SrcMD, DstMD) To copy essential components of the source digest. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: SrcMD source object class( KP1600Core ), intent(inout) :: DstMD destination object procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). private  subroutine KP1600Core_ByteDigest_wOutLen(MD, ByteArr, OutputLen) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes. The digest object is reset. Note: The routine will ignore the output length specified during\n initialization if the given OutputLen is valid (>= 1). Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(out) :: ByteArr (OutputLen) an array containing the hash output integer(kind=kInt32), intent(in) :: OutputLen the desired output length in bytes procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function KP1600Core_GetDigestLen(MD) result(Length) To return the output length. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in) :: MD 'KP1600_Core' object Return Value integer(kind=kInt32) digest length procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() private  function KP1600Core_GetSponge(MD) result(Sponge) To return the sponge component of the digest object. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(in), TARGET :: MD 'KP1600_Core' object Return Value type( KP1600Sponge ), POINTER sponge object generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine KP1600Core_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine KP1600Core_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( KP1600Core ), intent(inout) :: MD 'KP1600Core' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: KP1600Core PRIVATE !% The sponge instance TYPE ( KP1600Sponge ) :: Sponge !% The value of the capacity in bits tInteger :: Capacity = 512 !% The number of permutation rounds tInteger :: NRounds = 24 !% The length of output in bytes tIndex :: DigestLen = 32_kIndex !% The initial bits appended to the end of input tByte :: InitSuffix = ToInt8 ( Z '80' ) !% The current bits appended to the end of input tByte :: CurrSuffix = ToInt8 ( Z '80' ) CONTAINS ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => KP1600Core_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => KP1600Core_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => KP1600Core_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => KP1600Core_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *CoreInit* is a procedure to initialize components of the 'KP1600Core' object. <br> !  This procedure is NOT intended to be used by a user but the *Initialize* !  method(s) implemented by a *concrete* digest type should call this method. PROCEDURE :: CoreInit => KP1600Core_Initialize !> *CopyState* is a procedure to copy components of the source to the destination. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method !  implemented by a *concrete* digest type should call this method. PROCEDURE :: CopyState => KP1600Core_CopyState !> *DoFinalWOutLen* is a procedure to finalize the digest object with a specified !  hash output length. <br> !  This procedure is NOT intended to be used by a user.  It is provided to aid the !  development and implementation of the *Keccak-based digest* types that can be !  used as an extendable-output function (XOF). PROCEDURE :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => KP1600Core_GetDigestLen !> **Type-Bound Function**: GetSponge <br> !  **Purpose**:  To return a pointer to the sponge component of the digest object. <br> !  **Usage**: <br> !   --->    Instance => MD%GetSponge() PROCEDURE :: GetSponge => KP1600Core_GetSponge ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AddBitsNPad => KP1600Core_AddBitsNPad PROCEDURE , PRIVATE :: KP1600Core_ByteDigest_AddBits PROCEDURE , PRIVATE :: KP1600Core_HexDigest_AddBits ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits , & KP1600Core_HexDigest_AddBits END TYPE KP1600Core","tags":"","loc":"type\\kp1600core.html"},{"title":"BaseDigest – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT :: BaseDigest BaseDigest is an abstract type representing a base type for a (Message) Digest object.  It defines an API for common operations\n of an incremental cryptographic hash function. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. subroutine MDCreate(MD) Prototype MDCreate is a deferred procedure to perform any essential initialization\n of a digest object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() subroutine MDReset(MD) Prototype MDReset is a deferred procedure to reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) subroutine MDClone(Src, Dst) Prototype MDClone is a deferred procedure to clone the current state. The returned\n object evolves independently of this object. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: Src a source digest object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination (clone) digest object procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() function MDName(MD) result(Name) Prototype MDName is a deferred procedure to get the display name for this hash\n function (e.g. \"SHA-1\" for SHA-1). Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(in) :: MD 'BaseDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure(MDInsertBytes), public, deferred :: InsertBytes InsertBytes is a binding name of the MDInsertBytes deferred procedure. Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. subroutine MDInsertBytes(MD, ByteArr, Offset, Length) Prototype MDInsertBytes is a deferred procedure to insert input data as a byte\n (8-bit integer) array where offset (zero-based) and length are specified. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure(MDInsertGen), public, deferred :: InsertGen InsertGen is a binding name of the MDInsertGen deferred procedure. Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. subroutine MDInsertGen(MD, Input, InpSize) Prototype MDInsertGen is a deferred procedure to insert input data in a generic way\n where the Input argument can be any type and any rank and the InpSize argument specifies the size of the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure(MDByteDigest), public, deferred :: ByteDigest ByteDigest is a binding name of the MDByteDigest deferred procedure. Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. subroutine MDByteDigest(MD, ByteArr) Prototype MDByteDigest is a deferred procedure to finalize the current hash computation\n and return the hash value as an array of (8-bit integer) bytes in a newly-\n allocated array.  The digest object is reset. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure(MDByteDigestII), public, deferred :: ByteDigest_wInput ByteDigest_wInput is a binding name of the MDByteDigestII deferred procedure. Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. subroutine MDByteDigestII(MD, Input, InpSize, ByteArr) Prototype MDByteDigestII is a deferred procedure to insert final input in a generic way\n and then finalize the current hash computation and return the hash value as\n an array of (8-bit integer) bytes in a newly-allocated array.  The digest\n object is reset. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , ABSTRACT :: BaseDigest CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *Initialize* is a binding name of the *MDCreate* deferred procedure. <br> !  Use the *Create* method in place of the *Initialize* method to perform !  any essential initialization of a *digest* object. PROCEDURE ( MDCreate ), DEFERRED :: Initialize !> *Reset* is a binding name of the *MDReset* deferred procedure. <br> !  **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE ( MDReset ), DEFERRED :: Reset !> *GetClone* is a binding name of the *MDClone* deferred procedure. <br> !  **Type-Bound Function**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE ( MDClone ), DEFERRED :: GetClone !> *GetName* is a binding name of the *MDName* deferred procedure. <br> !  **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE ( MDName ), DEFERRED :: GetName !> *InsertBytes* is a binding name of the *MDInsertBytes* deferred procedure. <br> !  Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE ( MDInsertBytes ), DEFERRED :: InsertBytes !> *InsertGen* is a binding name of the *MDInsertGen* deferred procedure. <br> !  Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE ( MDInsertGen ), DEFERRED :: InsertGen !> *ByteDigest* is a binding name of the *MDByteDigest* deferred procedure. <br> !  Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE ( MDByteDigest ), DEFERRED :: ByteDigest !> *ByteDigest_wInput* is a binding name of the *MDByteDigestII* deferred procedure. <br> !  Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE ( MDByteDigestII ), DEFERRED :: ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> HexDigest is a private procedure to finalize the current hash computation and !  return the hash value as a hexadecimal string in a newly-allocated character string. <br> !  Use the *Digest* method in place of the *HexDigest* method. PROCEDURE , PRIVATE :: HexDigest => HexStr_Digest !> HexDigest_wInput is a private procedure to insert final input in a generic !  way and then finalize the current hash computation and return the hash value as !  a hexadecimal string in a newly-allocated character string. <br> !  Use the *Digest* method in place of the *HexDigest_wInput* method. PROCEDURE , PRIVATE :: HexDigest_wInput => HexStr_Digest_wInput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   --->    CALL MD%Create() GENERIC :: Create => Initialize !> **Type-Bound Subroutine**: Update <br> !  **Purpose**:  To insert input data into the *digest* object (commonly stored in a !                buffer array) and process block(s) of data if necessary. <br> !  **Usage**: <br> !   ! insert input data in a generic way <br> !   --->    CALL MD%Update(Input, InpSize) <br> !   ! insert input data as an array of bytes (8-bit integers) <br> !   --->    CALL MD%Update(ByteArr, Offset, Length) <br> GENERIC :: Update => InsertBytes , InsertGen !> **Type-Bound Subroutine**: Digest <br> !  **Purpose**:  To finalize the current hash computation and return the hash output. !                The object is reset.  Some final input data can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%Digest(ByteArr) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%Digest(Input, InpSize, ByteArr) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%Digest(HexStr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%Digest(Input, InpSize, HexStr) <br> GENERIC :: Digest => ByteDigest , ByteDigest_wInput , & HexDigest , HexDigest_wInput END TYPE BaseDigest","tags":"","loc":"type\\basedigest.html"},{"title":"Fugue – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: Fugue Fugue is a concrete digest type that implements an incremental\n cryptographic hash function based on the Fugue hash algorithms. Finalization Procedures final :: Fugue_Finalize private  subroutine Fugue_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( Fugue ), intent(inout) :: MD 'Fugue' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Fugue_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Fugue-256). private  subroutine Fugue_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object procedure, public :: Reset => Fugue_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Fugue_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object procedure, public :: GetClone => Fugue_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Fugue_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Fugue_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Fugue_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(in) :: MD 'Fugue' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: InsertBytes => Fugue_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Fugue_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Fugue_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Fugue_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Fugue_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Fugue_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Fugue_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Fugue_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: GetDigestLen => Fugue_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Fugue_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Fugue ), intent(in) :: MD 'Fugue' object Return Value integer(kind=kInt32) the digest length generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Fugue-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Fugue-512 algorithm --->    CALL MD%Create(512) private  subroutine Fugue_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object private  subroutine Fugue_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout), TARGET :: MD 'Fugue' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. generic, public :: AddBitsNDigest => Fugue_ByteDigest_AddBits, Fugue_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine Fugue_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine Fugue_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( Fugue ), intent(inout) :: MD 'Fugue' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , EXTENDS ( BaseDigest ) :: Fugue PRIVATE !% state (pointer) and its storage tInteger :: Store ( 0 : 35 ) = 0 tInteger , POINTER :: State (:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 !% other working variables tLong :: BitCount tInteger :: Partial tInteger :: PartialLen tInteger :: RoundShift !% pointer to a procedure that processes input data PROCEDURE ( FugueCore ), POINTER :: DoUpdate => NULL () !% pointer to a procedure that finalize the hash process PROCEDURE ( FugueClose ), POINTER :: DoFinal => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Fugue_ByteDigest_AddBits PROCEDURE , PRIVATE :: Fugue_HexDigest_AddBits PROCEDURE , PRIVATE :: InitializeWSecurity => Fugue_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Fugue-256). PROCEDURE :: Initialize => Fugue_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Fugue_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Fugue_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Fugue_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Fugue_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Fugue_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Fugue_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Fugue_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Fugue_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Fugue-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Fugue-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => Fugue_ByteDigest_AddBits , & Fugue_HexDigest_AddBits ! --------------------------------------------------------------------- FINAL :: Fugue_Finalize ! --------------------------------------------------------------------- END TYPE Fugue","tags":"","loc":"type\\fugue.html"},{"title":"Skein – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseDigest ) :: Skein Skein is a concrete digest type that implements an incremental\n cryptographic hash function based on the Skein hash algorithms. Finalization Procedures final :: Skein_Finalize private  subroutine Skein_Finalize(MD) To free a pointer component of the object. Arguments Type Intent Optional Attributes Name type( Skein ), intent(inout) :: MD 'Skein' object Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => Skein_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Skein-256). private  subroutine Skein_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object procedure, public :: Reset => Skein_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine Skein_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object procedure, public :: GetClone => Skein_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine Skein_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => Skein_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function Skein_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( Skein ), intent(in) :: MD 'Skein' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: InsertBytes => Skein_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine Skein_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => Skein_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine Skein_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => Skein_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine Skein_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => Skein_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine Skein_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: GetDigestLen => Skein_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function Skein_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( Skein ), intent(in) :: MD 'Skein' object Return Value integer(kind=kInt32) the digest length generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Skein-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Skein-512 algorithm --->    CALL MD%Create(512) private  subroutine Skein_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object private  subroutine Skein_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout), TARGET :: MD 'Skein' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. generic, public :: AddBitsNDigest => Skein_ByteDigest_AddBits, Skein_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. private  subroutine Skein_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine Skein_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( Skein ), intent(inout) :: MD 'Skein' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output Source Code TYPE , EXTENDS ( BaseDigest ) :: Skein PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variables (State will point to the first 8 elements of H) tLong :: H ( 0 : 26 ) = 0_kInt64 tLong , POINTER :: State (:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 !% the number of blocks of input processed tLong :: BlockCount = 0_kInt64 !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Skein_ByteDigest_AddBits PROCEDURE , PRIVATE :: Skein_HexDigest_AddBits PROCEDURE , PRIVATE :: ProcessBlock => Skein_ProcessBlock PROCEDURE , PRIVATE :: InitializeWSecurity => Skein_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Skein-256). PROCEDURE :: Initialize => Skein_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Skein_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Skein_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Skein_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Skein_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Skein_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Skein_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Skein_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Skein_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Skein-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Skein-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => Skein_ByteDigest_AddBits , & Skein_HexDigest_AddBits ! --------------------------------------------------------------------- FINAL :: Skein_Finalize ! --------------------------------------------------------------------- END TYPE Skein","tags":"","loc":"type\\skein.html"},{"title":"EChoB – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: EChoB EChoB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the ECHO-384 or the ECHO-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => EChoB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (ECHO-512). private  subroutine EChoB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object procedure, public :: Reset => EChoB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine EChoB_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object procedure, public :: GetClone => EChoB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine EChoB_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => EChoB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function EChoB_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(in) :: MD 'EChoB' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => EChoB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function EChoB_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( EChoB ), intent(in) :: MD 'EChoB' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => EChoB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function EChoB_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(in) :: MD 'EChoB' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => EChoB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine EChoB_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout), TARGET :: MD 'EChoB' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => EChoB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine EChoB_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => EChoB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine EChoB_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => EChoB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine EChoB_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (ECHO-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the ECHO-384 algorithm --->    CALL MD%Create(IsECHO384=.TRUE.) private  subroutine EChoB_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object private  subroutine EChoB_Initialize_wFlag(MD, IsECHO384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( EChoB ), intent(inout) :: MD 'EChoB' object logical, intent(in) :: IsECHO384 flag indicating whether the ECHO-384 algorithm is employed or not. - If true, use the ECHO-384 algorithm. - Otherwise, use the ECHO-512 algorithm. Source Code TYPE , EXTENDS ( MDEngine ) :: EChoB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: V ( 0 : 31 ) = 0 tInteger :: C ( 0 : 3 ) = 0 !% flag indicating whether the ECHO-384 algorithm is employed or not. tLogical :: IsECHO384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => EChoB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (ECHO-512). PROCEDURE :: Initialize => EChoB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => EChoB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => EChoB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => EChoB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => EChoB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => EChoB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => EChoB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => EChoB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => EChoB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => EChoB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (ECHO-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the ECHO-384 algorithm <br> !   --->    CALL MD%Create(IsECHO384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE EChoB","tags":"","loc":"type\\echob.html"},{"title":"HalfSip24Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( Hasher32 ) :: HalfSip24Hasher32 HalfSip24Hasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the HalfSip24 hash algorithm by Jean-Philippe Aumasson. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. private  subroutine HS_Reset(HS) To reset components of the hasher. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function HS_BlockCount(HS) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function HS_BufLen(HS) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) number of bytes procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. private  subroutine HS_Update(HS, Input, InpSize) To insert input data into the hasher (i.e. temporary stored in the buffer array)\n and process block(s) of data if necessary. Arguments Type Intent Optional Attributes Name class( BaseHasher ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: GetName => HalfSip24_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() private  function HalfSip24_GetName(HS) result(Name) To get the display name for this hasher. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(in) :: HS a hasher (HS) object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetBlockLength => HalfSip24_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. private  function HalfSip24_BlockLength(HS) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(in) :: HS a hasher (HS) object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => HalfSip24_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. private  subroutine HalfSip24_SetBufPtr(HS, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => HalfSip24_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. private  subroutine HalfSip24_ProcessBlock(HS, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout) :: HS a hasher (HS) object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: Initialize => HalfSip24_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value private  subroutine HalfSip24_Initialize(HS, Seed, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: InitializeWKey => HalfSip24_Initialize_wKey Type-Bound Subroutine : InitializeWKey Purpose :  To initialize the hasher with a key. Usage : --->    CALL Hasher%InitializeWKey(Seed, Key)           ! hash value with sign --->    CALL Hasher%InitializeWKey(Seed, Key, .TRUE.)   ! remove sign from hash value private  subroutine HalfSip24_Initialize_wKey(HS, Seed, Key, RemoveSign) To initialize the hasher. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout), TARGET :: HS a hasher (HS) object integer(kind=kInt32), intent(in) :: Seed seed integer(kind=kInt8), intent(in) :: Key (0:7) key bytes logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. procedure, public :: Finalize => HalfSip24_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() private  function HalfSip24_Finalize(HS) result(HashCode) To finalize the current hash computation and return the hash value\n in a 32-bit integer.  The object is reset. Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout) :: HS a hasher (HS) object Return Value integer(kind=kInt32) hash code procedure, public :: HashDirect => HalfSip24_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. private  function HalfSip24_HashDirect(HS, Input, InpSize, Seed, RemoveSign) result(HashCode) To compute the hash value directly (non-incremental). Arguments Type Intent Optional Attributes Name class( HalfSip24Hasher32 ), intent(inout) :: HS a hasher (HS) object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: Seed seed logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Source Code TYPE , EXTENDS ( Hasher32 ) :: HalfSip24Hasher32 PRIVATE !% state tUInt32 :: State ( 4 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 3 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => HalfSip24_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => HalfSip24_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => HalfSip24_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => HalfSip24_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => HalfSip24_Initialize !> **Type-Bound Subroutine**: InitializeWKey <br> !  **Purpose**:  To initialize the hasher with a key. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key)           ! hash value with sign <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, .TRUE.)   ! remove sign from hash value <br> PROCEDURE :: InitializeWKey => HalfSip24_Initialize_wKey !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => HalfSip24_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => HalfSip24_HashDirect END TYPE HalfSip24Hasher32","tags":"","loc":"type\\halfsip24hasher32.html"},{"title":"SHA1 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: SHA1 SHA1 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the SHA-1 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => SHA1_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. private  subroutine SHA1_Initialize(MD) To perform initialization of the digest object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object procedure, public :: Reset => SHA1_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SHA1_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object procedure, public :: GetClone => SHA1_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHA1_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHA1_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHA1_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(in) :: MD 'SHA1' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SHA1_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SHA1_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(in) :: MD 'SHA1' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SHA1_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SHA1_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(in) :: MD 'SHA1' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SHA1_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SHA1_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout), TARGET :: MD 'SHA1' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SHA1_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SHA1_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SHA1_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA1_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SHA1_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA1_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SHA1 ), intent(inout) :: MD 'SHA1' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset Source Code TYPE , EXTENDS ( MDHelper ) :: SHA1 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 4 ) = IV ( 0 : 4 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => SHA1_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA1_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA1_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA1_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA1_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA1_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA1_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA1_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA1_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA1_AddBitsNPad END TYPE SHA1","tags":"","loc":"type\\sha1.html"},{"title":"SHA2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDHelper ) :: SHA2B SHA2B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either the SHA-384 or the SHA-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_Init(MDH, LittleEndian, LenLen, FByte) To initialize the object with the specified first padding byte.\n The padding byte is normally Z'80'. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object logical, intent(in) :: LittleEndian true for little-endian padding integer(kind=kInt32), intent(in) :: LenLen the length encoding length, in bytes (must be at least 8) integer(kind=kInt8), intent(in), optional :: FByte the first padding byte procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. private  subroutine MDHelper_DoPadding(MDH) To compute the padding.  The padding data is input into the engine. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MDH 'MDHelper' object procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(inout) :: MD 'MDHelper' object procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDHelper_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDHelper ), intent(in) :: SrcMD source object class( MDHelper ), intent(inout) :: DstMD destination object procedure, public :: Initialize => SHA2B_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA-512). private  subroutine SHA2B_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object procedure, public :: Reset => SHA2B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SHA2B_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object procedure, public :: GetClone => SHA2B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHA2B_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHA2B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHA2B_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(in) :: MD 'SHA2B' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SHA2B_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SHA2B_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(in) :: MD 'SHA2B' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SHA2B_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SHA2B_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(in) :: MD 'SHA2B' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SHA2B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SHA2B_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout), TARGET :: MD 'SHA2B' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SHA2B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2B_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SHA2B_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2B_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SHA2B_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA2B_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA-384 algorithm --->    CALL MD%Create(IsSHA384=.TRUE.) private  subroutine SHA2B_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object private  subroutine SHA2B_Initialize_wFlag(MD, IsSHA384) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( SHA2B ), intent(inout) :: MD 'SHA2B' object logical, intent(in) :: IsSHA384 flag indicating whether the SHA-384 algorithm is employed or not. - If true, use the SHA-384 algorithm. - Otherwise, use the SHA-512 algorithm. Source Code TYPE , EXTENDS ( MDHelper ) :: SHA2B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tLong :: State ( 0 : 7 ) = IV512 ( 0 : 7 ) !% flag indicating whether the SHA-384 algorithm is employed or not. tLogical :: IsSHA384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SHA2B_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA-512). PROCEDURE :: Initialize => SHA2B_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA2B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA2B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA2B_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA2B_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA2B_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA2B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA2B_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA2B_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA2B_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA-384 algorithm <br> !   --->    CALL MD%Create(IsSHA384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag END TYPE SHA2B","tags":"","loc":"type\\sha2b.html"},{"title":"SHA3 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: SHA3 SHA3 is a concrete digest type that implements an incremental\n cryptographic hash function based on the so-called Keccak hash\n functions, which is a family of message-digest algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => SHA3_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA3-256). private  subroutine SHA3_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object procedure, public :: Reset => SHA3_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine SHA3_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object procedure, public :: GetClone => SHA3_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine SHA3_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => SHA3_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function SHA3_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(in) :: MD 'SHA3' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => SHA3_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function SHA3_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(in) :: MD 'SHA3' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => SHA3_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function SHA3_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(in) :: MD 'SHA3' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => SHA3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine SHA3_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout), TARGET :: MD 'SHA3' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => SHA3_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine SHA3_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => SHA3_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA3_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => SHA3_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine SHA3_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. buffer array used to store output data Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA3-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Keccak-256 algorithm --->    CALL MD%Create(IsKeccak=.TRUE.) ! initialize the object to employ the SHA3-384 algorithm --->    CALL MD%Create(IsKeccak=.FALSE., Security=384) ! initialize the object to employ the Keccak-512 algorithm --->    CALL MD%Create(IsKeccak=.TRUE., Security=512) private  subroutine SHA3_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object private  subroutine SHA3_Initialize_wOption(MD, IsKeccak, Security) To perform initialization of the digest object with the specified flag. Arguments Type Intent Optional Attributes Name class( SHA3 ), intent(inout) :: MD 'SHA3' object logical, intent(in) :: IsKeccak flag indicating whether the Keccak family is employed or not. - If true, use the Keccak family. - Otherwise, use the SHA-3 algorithm. integer(kind=kInt32), intent(in), optional :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. Source Code TYPE , EXTENDS ( MDEngine ) :: SHA3 PRIVATE !% buffer array used to store input data tByte :: BufInp ( 0 : 143 ) = 0_kInt8 !% state tLong :: State ( 0 : 24 ) = 0_kInt64 !% flag indicating whether the Keccak family is employed or not. tLogical :: IsKeccak = FalseVal !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = 32_kIndex !% length of data block to be processed when exceeded tIndex :: BlockLen = 136_kIndex !% length of temporary output buffer tIndex :: OutLen = 32_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => SHA3_Initialize_wOption ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA3-256). PROCEDURE :: Initialize => SHA3_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA3_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA3_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA3_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA3_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA3_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA3_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA3_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA3_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA3-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Keccak-256 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.TRUE.) <br> !   ! initialize the object to employ the SHA3-384 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.FALSE., Security=384) <br> !   ! initialize the object to employ the Keccak-512 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.TRUE., Security=512) <br> GENERIC :: Create => InitializeWOption END TYPE SHA3","tags":"","loc":"type\\sha3.html"},{"title":"JHDigest – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( MDEngine ) :: JHDigest JHDigest is a concrete digest type that implements an incremental\n cryptographic hash function based on the JH hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine HexStr_Digest(MD, HexStr) To finalize the current hash computation and return the hash value\n as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output private  subroutine HexStr_Digest_wInput(MD, Input, InpSize, HexStr) To insert final input in a generic way and then finalize the current hash computation\n and return the hash value as a hexadecimal string in a newly-allocated character string. Arguments Type Intent Optional Attributes Name class( BaseDigest ), intent(inout) :: MD 'BaseDigest' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. private  subroutine MDEngine_InsertBytes(MD, ByteArr, Offset, Length) To insert input data as a byte (8-bit integer) array where offset (zero-based)\n and length are specified. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: ByteArr (0:) a byte array of input data integer(kind=kInt32), intent(in) :: Offset the offset in input data integer(kind=kInt32), intent(in) :: Length the length of input data in bytes procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. private  subroutine MDEngine_InsertGen(MD, Input, InpSize) To insert input data in a generic way where the Input argument can be\n any type and any rank and the InpSize argument specifies the size of\n the input data in a number of bytes. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. private  subroutine MDEngine_ByteDigest(MD, ByteArr) To finalize the current hash computation and return the hash value\n as an array of (8-bit integer) bytes in a newly-allocated array.\n The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. private  subroutine MDEngine_ByteDigest_wInput(MD, Input, InpSize, ByteArr) To insert final input in a generic way and then finalize the current hash\n computation and return the hash value as an array of (8-bit integer) bytes\n in a newly-allocated array.  The digest object is reset. Important Note : The newly-allocated array has a zero-based index. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object type(*), intent(in), CONTIGUOUS :: Input (..) input data (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Reset(MD) To reset components of the digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. private  subroutine MDEngine_Clone(SrcMD, DstMD) To copy components of the source digest. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: SrcMD source object class( MDEngine ), intent(inout) :: DstMD destination object procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. private  function MDEngine_BlockCount(MD) result(BlockCount) To get the number of blocks of input processed. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of blocks procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. private  function MDEngine_BufLen(MD) result(BufLen) To get the number of bytes of input currently stored in the buffer. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(in) :: MD 'MDEngine' object Return Value integer(kind=kInt32) number of bytes generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits private  subroutine MDEngine_ByteDigest_AddBits(MD, LastByte, NBits, ByteArr) To add the last byte and then finalize the current hash computation\n and return the hash output as a byte array. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(out), ALLOCATABLE :: ByteArr (:) the hash output private  subroutine MDEngine_HexDigest_AddBits(MD, LastByte, NBits, HexStr) To add the last byte and then finalize the current hash computation\n and return the hash output as a hexadecimal string. This routine is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. Arguments Type Intent Optional Attributes Name class( MDEngine ), intent(inout) :: MD 'MDEngine' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte character(kind=kChar, len=:), intent(out), ALLOCATABLE :: HexStr the hash output procedure, public :: Initialize => JHDigest_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (JH-256). private  subroutine JHDigest_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object procedure, public :: Reset => JHDigest_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() private  subroutine JHDigest_Reset(MD) To reset the hash algorithm state. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object procedure, public :: GetClone => JHDigest_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) private  subroutine JHDigest_GetClone(Src, Dst) To clone the current state of the source object. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: Src a source object class( BaseDigest ), intent(out), ALLOCATABLE :: Dst a destination object procedure, public :: GetName => JHDigest_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() private  function JHDigest_GetName(MD) result(Name) To return the algorithm name of the hash function. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(in) :: MD 'JHDigest' object Return Value character(kind=kChar, len=:), ALLOCATABLE name of the hash function procedure, public :: GetDigestLen => JHDigest_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() private  function JHDigest_GetDigestLen(MD) result(Length) To get the natural hash function output length (in bytes). Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(in) :: MD 'JHDigest' object Return Value integer(kind=kInt32) the digest length procedure, public :: GetBlockLen => JHDigest_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. private  function JHDigest_GetBlockLen(MD) result(Length) To return the block length for the hash function. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(in) :: MD 'JHDigest' object Return Value integer(kind=kInt32) the block length procedure, public :: SetBufPtr => JHDigest_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. private  subroutine JHDigest_SetBufPtr(MD, BufPtr) To set the pointer BufPtr to the actual buffer array with starting index of zero. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout), TARGET :: MD 'JHDigest' object integer(kind=kInt8), intent(inout), POINTER :: BufPtr (:) a buffer pointer procedure, public :: ProcessBlock => JHDigest_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. private  subroutine JHDigest_ProcessBlock(MD, BytesIn) To process one block of data. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object integer(kind=kInt8), intent(in) :: BytesIn (0:) the data block procedure, public :: DoPadding => JHDigest_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine JHDigest_DoPadding(MD, BytesOut, Offset) To perform the final padding and store the result in the\n provided buffer. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset procedure, public :: AddBitsNPad => JHDigest_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. private  subroutine JHDigest_AddBitsNPad(MD, LastByte, NBits, BytesOut, Offset) To add the last byte and then perform the final padding and\n store the result in the provided buffer. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object integer(kind=kInt8), intent(in) :: LastByte the last byte integer(kind=kInt8), intent(in) :: NBits number of bits in the last byte integer(kind=kInt8), intent(inout) :: BytesOut (0:) the output buffer integer(kind=kInt32), intent(in) :: Offset the output offset generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (JH-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the JH-512 algorithm --->    CALL MD%Create(512) private  subroutine JHDigest_Initialize(MD) To perform initialization of the digest object with default algorithm. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object private  subroutine JHDigest_Initialize_wSecurity(MD, Security) To perform initialization of the digest object with the specified Security. Arguments Type Intent Optional Attributes Name class( JHDigest ), intent(inout) :: MD 'JHDigest' object integer(kind=kInt32), intent(in) :: Security Strength of security in bits with four possible values: 224, 256, 384 and 512.\n If the specified value is NOT valid, it is set to the default (256) value. Source Code TYPE , EXTENDS ( MDEngine ) :: JHDigest PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tLong :: State ( 0 : 15 ) = IV256 ( 0 : 15 ) !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => JHDigest_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (JH-256). PROCEDURE :: Initialize => JHDigest_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => JHDigest_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => JHDigest_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => JHDigest_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => JHDigest_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => JHDigest_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => JHDigest_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => JHDigest_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => JHDigest_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => JHDigest_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (JH-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the JH-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity END TYPE JHDigest","tags":"","loc":"type\\jhdigest.html"},{"title":"Pack_I16 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public  function Pack_I16(ByteArr, Offset) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt16) result Description To convert an array of 8-bit integers starting at the offset to\n a 16-bit integer value.","tags":"","loc":"interface\\pack_i16.html"},{"title":"Pack_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public  function Pack_I32(ByteArr, Offset) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Description To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value.","tags":"","loc":"interface\\pack_i32.html"},{"title":"Pack_I32_A1 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A1(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL and IOR intrinsic\n functions. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A1 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = IOR ( IOR ( IOR ( MaskI32 ( ByteArr ( Offset )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 1 )), 8 )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 2 )), 16 )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 3 )), 24 )) ! big-endian order !    Res = IOR(IOR(IOR(SHIFTL(MaskI32(ByteArr(Offset)),   24),  & !                      SHIFTL(MaskI32(ByteArr(Offset+1)), 16)), & !                      SHIFTL(MaskI32(ByteArr(Offset+2)),  8)), & !                             MaskI32(ByteArr(Offset+3))) RETURN END FUNCTION Pack_I32_A1","tags":"","loc":"proc\\pack_i32_a1.html"},{"title":"Pack_I32_A2 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A2(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL intrinsic function\n and an addition operator. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A2 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* intrinsic function !  and an addition operator. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = MaskI32 ( ByteArr ( Offset )) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 1 )), 8 ) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 2 )), 16 ) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 3 )), 24 ) ! big-endian order !    Res = SHIFTL(MaskI32(ByteArr(Offset)),   24) + & !          SHIFTL(MaskI32(ByteArr(Offset+1)), 16) + & !          SHIFTL(MaskI32(ByteArr(Offset+2)),  8) + & !                 MaskI32(ByteArr(Offset+3)) RETURN END FUNCTION Pack_I32_A2","tags":"","loc":"proc\\pack_i32_a2.html"},{"title":"Pack_I32_A3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A3(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL and IOR intrinsic\n functions. Note : Although this routine and the Pack_I32_A3 routine employ\n the same intrinsic functions, orders of the functions being used\n are somewhat different. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A3 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. <br> !  *Note*: Although this routine and the *Pack_I32_A3* routine employ !  the same intrinsic functions, orders of the functions being used !  are somewhat different. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order #define UnsignedShort(Val, Off)     IOR(MaskI32(Val(Off)), SHIFTL(MaskI32(Val(Off+1)), 8)) Res = IOR ( UnsignedShort ( ByteArr , Offset ), SHIFTL ( UnsignedShort ( ByteArr , Offset + 2 ), 16 )) #undef UnsignedShort ! big-endian order !#define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), ToInt32(Z'000000FF')) !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    Res = IOR(UnsignedShort(ByteArr, Offset+2), SHIFTL(UnsignedShort(ByteArr, Offset), 16)) !#undef UnsignedByte !#undef UnsignedShort RETURN END FUNCTION Pack_I32_A3","tags":"","loc":"proc\\pack_i32_a3.html"},{"title":"Pack_I32_A4 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A4(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the MVBITS intrinsic subroutine. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A4 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *MVBITS* intrinsic subroutine. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = 0 CALL MVBITS ( MaskI32 ( ByteArr ( Offset )), 0 , 8 , Res , 0 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 1 )), 0 , 8 , Res , 8 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 2 )), 0 , 8 , Res , 16 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 3 )), 0 , 8 , Res , 24 ) ! big-endian order !    Res = 0 !    CALL MVBITS(MaskI32(ByteArr(Offset)),   0, 8, Res, 24) !    CALL MVBITS(MaskI32(ByteArr(Offset+1)), 0, 8, Res, 16) !    CALL MVBITS(MaskI32(ByteArr(Offset+2)), 0, 8, Res,  8) !    CALL MVBITS(MaskI32(ByteArr(Offset+3)), 0, 8, Res,  0) RETURN END FUNCTION Pack_I32_A4","tags":"","loc":"proc\\pack_i32_a4.html"},{"title":"Pack_I32_A5 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A5(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the TRANSFER intrinsic function. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A5 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *TRANSFER* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = TRANSFER ([ ByteArr ( Offset ), ByteArr ( Offset + 1 ), ByteArr ( Offset + 2 ), & ByteArr ( Offset + 3 )], 0_kInt32 ) ! big-endian order !    Res = TRANSFER([ByteArr(Offset+3), ByteArr(Offset+2), ByteArr(Offset+1), !                    ByteArr(Offset)], 0_kInt32) RETURN END FUNCTION Pack_I32_A5","tags":"","loc":"proc\\pack_i32_a5.html"},{"title":"Pack_I32_A6 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A6(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the C_LOC and C_F_POINTER intrinsic module routines. Note :  This routine works best for system-endian order. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A6 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *C_LOC* and *C_F_POINTER* !  intrinsic module routines. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 , POINTER :: fPtr ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW !+++ get a C pointer to the input +++ CPtr = C_LOC ( ByteArr ( Offset )) !+++ associate a Fortran pointer with the C pointer +++ CALL C_F_POINTER ( cPtr , fPtr ) !+++ copy bit patterns +++ ! system (or machine) endian order Res = fPtr ! little endian order !    IF (IsLittleEndian) THEN !        Res = fPtr !    ELSE !        Res = SwapBytes(fPtr) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(fPtr) !    ELSE !        Res = fPtr !    END IF !+++ nullify pointers +++ NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END FUNCTION Pack_I32_A6","tags":"","loc":"proc\\pack_i32_a6.html"},{"title":"Pack_I32_A7 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I32_A7(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the EQUIVALENCE statement. Note :  This routine works best for system-endian order. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Source Code FUNCTION Pack_I32_A7 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *EQUIVALENCE* statement. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 3 ) tUInt32 :: Output EQUIVALENCE ( Input , Output ) ! FLOW !+++ copy input +++ Input ( 0 : 3 ) = ByteArr ( Offset : Offset + 3 ) !+++ copy output +++ ! system (or machine) endian order Res = Output ! little endian order !    IF (IsLittleEndian) THEN !        Res = Output !    ELSE !        Res = SwapBytes(Output) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(Output) !    ELSE !        Res = Output !    END IF RETURN END FUNCTION Pack_I32_A7","tags":"","loc":"proc\\pack_i32_a7.html"},{"title":"Pack_I16_A1 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A1(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A1 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Res = IOR ( MaskI16 ( Buf ( Off )), SHIFTL ( MaskI16 ( Buf ( Off + 1 )), 8 )) RETURN END FUNCTION Pack_I16_A1","tags":"","loc":"proc\\pack_i16_a1.html"},{"title":"Pack_I16_A2 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A2(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A2 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #2 (comparable to #1) Res = MaskI16 ( Buf ( Off )) + SHIFTL ( MaskI16 ( Buf ( Off + 1 )), 8 ) RETURN END FUNCTION Pack_I16_A2","tags":"","loc":"proc\\pack_i16_a2.html"},{"title":"Pack_I16_A3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A3(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A3 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #3 (comparable to #1) #define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), Z'000000FF') #define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) Res = ToInt16 ( UnsignedShort ( Buf , Off )) #undef UnsignedByte #undef UnsignedShort RETURN END FUNCTION Pack_I16_A3","tags":"","loc":"proc\\pack_i16_a3.html"},{"title":"Pack_I16_A4 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A4(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A4 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) Res = 0 CALL MVBITS ( MaskI16 ( Buf ( Off )), 0 , 8 , Res , 0 ) CALL MVBITS ( MaskI16 ( Buf ( Off + 1 )), 0 , 8 , Res , 8 ) RETURN END FUNCTION Pack_I16_A4","tags":"","loc":"proc\\pack_i16_a4.html"},{"title":"Pack_I16_A5 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A5(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A5 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #5 (slowest) Res = TRANSFER ([ Buf ( Off ), Buf ( Off + 1 )], 0_kInt16 ) RETURN END FUNCTION Pack_I16_A5","tags":"","loc":"proc\\pack_i16_a5.html"},{"title":"Pack_I16_A6 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A6(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A6 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt16 , POINTER :: Val => NULL () TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! implementation algorithm #6 CPtr = C_LOC ( Buf ( Off )) CALL C_F_POINTER ( CPtr , Val ) Res = Val NULLIFY ( Val ) cPtr = C_NULL_PTR RETURN END FUNCTION Pack_I16_A6","tags":"","loc":"proc\\pack_i16_a6.html"},{"title":"Pack_I16_A7 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function Pack_I16_A7(Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) Source Code FUNCTION Pack_I16_A7 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 1 ) tUInt16 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 1 ) = Buf ( Off : Off + 1 ) Res = Output RETURN END FUNCTION Pack_I16_A7","tags":"","loc":"proc\\pack_i16_a7.html"},{"title":"Lookup3_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Lookup3_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2].","tags":"","loc":"interface\\lookup3_hash32_exp.html"},{"title":"Murmur3_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the MurmurHash3 hash algorithm by Austin\n Appleby [1].","tags":"","loc":"interface\\murmur3_hash32_exp.html"},{"title":"City_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function City_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the City hash algorithm by Google Inc [3].","tags":"","loc":"interface\\city_hash32_exp.html"},{"title":"FarmMk_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmMk_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the FarmMk hash algorithm by Google Inc [4].","tags":"","loc":"interface\\farmmk_hash32_exp.html"},{"title":"NM_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NM_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7].","tags":"","loc":"interface\\nm_hash32_exp.html"},{"title":"NMx_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMx_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7].","tags":"","loc":"interface\\nmx_hash32_exp.html"},{"title":"XX_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the XXHash hash algorithm by Yann Collet [8].","tags":"","loc":"interface\\xx_hash32_exp.html"},{"title":"Water_Hash32_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Water_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11].","tags":"","loc":"interface\\water_hash32_exp.html"},{"title":"BytePack – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BytePack Subroutine Interface : BytePack Purpose :  To convert a byte array stored in machine-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePack(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePack(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePack(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePack(ByteArr, Offset, IntArr) Module Procedures private  subroutine PackBytes_Short(ByteArr, I16) To convert from the byte array (stored according to the machine endianess)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out), TARGET :: I16 16-bit integer private  subroutine PackBytesWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytes_Shorts(ByteArr, I16Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out), TARGET :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytes_Integer(ByteArr, I32) To convert from the byte array (stored according to the machine endianess)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out), TARGET :: I32 32-bit integer private  subroutine PackBytesWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytes_Integers(ByteArr, I32Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out), TARGET :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytes_Long(ByteArr, I64) To convert from the byte array (stored according to the machine endianess)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out), TARGET :: I64 64-bit integer private  subroutine PackBytesWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytes_Longs(ByteArr, I64Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out), TARGET :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers","tags":"","loc":"interface\\bytepack.html"},{"title":"ByteUnpack – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ByteUnpack Subroutine Interface : ByteUnpack Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in machine-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpack(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpack(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpack(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpack(IntArr, ByteArr, Offset) Module Procedures private  subroutine UnpackBytes_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in), TARGET :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in), TARGET :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in), TARGET :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in), TARGET :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in), TARGET :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in), TARGET :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array","tags":"","loc":"interface\\byteunpack.html"},{"title":"BytePackBE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BytePackBE Subroutine Interface : BytePackBE Purpose :  To convert a byte array stored in big-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePackBE(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePackBE(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePackBE(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePackBE(ByteArr, Offset, IntArr) Module Procedures private  subroutine PackBytesBE_Short(ByteArr, I16) To convert from the byte array (stored in big-endian order)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesBEWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesBE_Shorts(ByteArr, I16Arr) To convert from the byte array (stored in big-endian order)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesBEWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesBE_Integer(ByteArr, I32) To convert from the byte array (stored in big-endian order)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesBEWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesBE_Integers(ByteArr, I32Arr) To convert from the byte array (stored in big-endian order)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesBEWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesBE_Long(ByteArr, I64) To convert from the byte array (stored in big-endian order)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesBEWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesBE_Longs(ByteArr, I64Arr) To convert from the byte array (stored in big-endian order)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesBEWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers","tags":"","loc":"interface\\bytepackbe.html"},{"title":"ByteUnpackBE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ByteUnpackBE Subroutine Interface : ByteUnpackBE Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in big-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpackBE(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpackBE(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpackBE(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpackBE(IntArr, ByteArr, Offset) Module Procedures private  subroutine UnpackBytesBE_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesBEWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesBEWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesBEWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array","tags":"","loc":"interface\\byteunpackbe.html"},{"title":"BytePackLE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BytePackLE Subroutine Interface : BytePackLE Purpose :  To convert a byte array stored in little-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePackLE(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePackLE(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePackLE(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePackLE(ByteArr, Offset, IntArr) Module Procedures private  subroutine PackBytesLE_Short(ByteArr, I16) To convert from the byte array (stored in little-endian order)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesLEWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesLE_Shorts(ByteArr, I16Arr) To convert from the byte array (stored in little-endian order)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesLEWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesLE_Integer(ByteArr, I32) To convert from the byte array (stored in little-endian order)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesLEWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesLE_Integers(ByteArr, I32Arr) To convert from the byte array (stored in little-endian order)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesLEWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesLE_Long(ByteArr, I64) To convert from the byte array (stored in little-endian order)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesLEWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesLE_Longs(ByteArr, I64Arr) To convert from the byte array (stored in little-endian order)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesLEWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers","tags":"","loc":"interface\\bytepackle.html"},{"title":"ByteUnpackLE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ByteUnpackLE Subroutine Interface : ByteUnpackLE Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in little-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpackLE(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpackLE(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpackLE(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpackLE(IntArr, ByteArr, Offset) Module Procedures private  subroutine UnpackBytesLE_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesLEWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesLEWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesLEWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array","tags":"","loc":"interface\\byteunpackle.html"},{"title":"Metro_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Metro_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2].","tags":"","loc":"interface\\metro_hash64_exp.html"},{"title":"Murmur3_Hash128_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-14) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the MurmurHash3 hash algorithm by Austin\n Appleby [1].","tags":"","loc":"interface\\murmur3_hash128_exp.html"},{"title":"Wy_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Wy_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-11) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4].","tags":"","loc":"interface\\wy_hash64_exp.html"},{"title":"WyF3_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WyF3_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3].","tags":"","loc":"interface\\wyf3_hash64_exp.html"},{"title":"XX_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the XXHash hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx_hash64_exp.html"},{"title":"XX3_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Secret) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code Description To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx3_hash64_exp.html"},{"title":"XX3_Hash128_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Secret, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx3_hash128_exp.html"},{"title":"City_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function City_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the CityHash hash algorithm by Google Inc [6].","tags":"","loc":"interface\\city_hash64_exp.html"},{"title":"FarmNa_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmNa_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmNaHash hash algorithm by Google Inc [7].","tags":"","loc":"interface\\farmna_hash64_exp.html"},{"title":"FarmUo_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmUo_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmUoHash hash algorithm by Google Inc [7].","tags":"","loc":"interface\\farmuo_hash64_exp.html"},{"title":"Spooky_Hash128_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Spooky_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8].","tags":"","loc":"interface\\spooky_hash128_exp.html"},{"title":"PengyV03_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyV03_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15].","tags":"","loc":"interface\\pengyv03_hash64_exp.html"},{"title":"PengyV02_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyV02_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10].","tags":"","loc":"interface\\pengyv02_hash64_exp.html"},{"title":"Komi_Hash64_Exp – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Komi_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-8) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13].","tags":"","loc":"interface\\komi_hash64_exp.html"},{"title":"Lookup3_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Lookup3_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2].","tags":"","loc":"interface\\lookup3_hash32_opt.html"},{"title":"Murmur3_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the MurmurHash3 hash algorithm by Austin\n Appleby [1].","tags":"","loc":"interface\\murmur3_hash32_opt.html"},{"title":"City_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function City_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the City hash algorithm by Google Inc [3].","tags":"","loc":"interface\\city_hash32_opt.html"},{"title":"FarmMk_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmMk_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the FarmMk hash algorithm by Google Inc [4].","tags":"","loc":"interface\\farmmk_hash32_opt.html"},{"title":"NM_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NM_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7].","tags":"","loc":"interface\\nm_hash32_opt.html"},{"title":"NMx_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMx_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7].","tags":"","loc":"interface\\nmx_hash32_opt.html"},{"title":"XX_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the XXHash hash algorithm by Yann Collet [8].","tags":"","loc":"interface\\xx_hash32_opt.html"},{"title":"Water_Hash32_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Water_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11].","tags":"","loc":"interface\\water_hash32_opt.html"},{"title":"Lookup3Hash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Lookup3Hash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2].","tags":"","loc":"interface\\lookup3hash_i32.html"},{"title":"Murmur3Hash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3Hash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the Murmur3 hash algorithm by Austin Appleby [1].","tags":"","loc":"interface\\murmur3hash_i32.html"},{"title":"CityHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function CityHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the City hash algorithm by Google Inc [3].","tags":"","loc":"interface\\cityhash_i32.html"},{"title":"FarmMkHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmMkHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Note : The working routine of this procedure is a non-recursive one.","tags":"","loc":"interface\\farmmkhash_i32.html"},{"title":"FarmMkHash_I32_Recur – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmMkHash_I32_Recur(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Note : The working routine of this procedure is a recursive one.","tags":"","loc":"interface\\farmmkhash_i32_recur.html"},{"title":"SuperFastHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function SuperFastHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the SuperFast hash algorithm by Paul\n Hsieh [5].","tags":"","loc":"interface\\superfasthash_i32.html"},{"title":"NMHash_V1_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMHash_V1_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 1 of the NMHASH hash algorithm\n by James Z. M. Gao [6].","tags":"","loc":"interface\\nmhash_v1_i32.html"},{"title":"NMxHash_V1_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMxHash_V1_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 1 of the NMxHASH hash algorithm by\n James Z. M. Gao [6].","tags":"","loc":"interface\\nmxhash_v1_i32.html"},{"title":"NMHash_V2_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMHash_V2_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7].","tags":"","loc":"interface\\nmhash_v2_i32.html"},{"title":"NMxHash_V2_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function NMxHash_V2_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7].","tags":"","loc":"interface\\nmxhash_v2_i32.html"},{"title":"XXHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XXHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the XXHash hash algorithm by Yann Collet [8].","tags":"","loc":"interface\\xxhash_i32.html"},{"title":"CrapWowHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function CrapWowHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the CrapWow hash algorithm [9].","tags":"","loc":"interface\\crapwowhash_i32.html"},{"title":"FastHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FastHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the Fast hash algorithm by\n Zilong Tan [10].","tags":"","loc":"interface\\fasthash_i32.html"},{"title":"WaterHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WaterHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the WaterHash hash algorithm by Tommy\n Ettinger [6].","tags":"","loc":"interface\\waterhash_i32.html"},{"title":"WaterHash_I32_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WaterHash_I32_New(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11].","tags":"","loc":"interface\\waterhash_i32_new.html"},{"title":"HalfSipHash24_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function HalfSipHash24_I32(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (:) key (at least 8 bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Description To compute the hash value using the HalfSipHash24 hash algorithm by\n Jean-Philippe Aumasson [12].","tags":"","loc":"interface\\halfsiphash24_i32.html"},{"title":"HalfSipHash_I32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function HalfSipHash_I32(Input, InpSize, Key, cRound, dRound, StartHash, RemoveSign, HashLong) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (:) key (at least 8 bytes) integer(kind=kInt32), intent(in) :: cRound number of C rounds integer(kind=kInt32), intent(in) :: dRound number of D rounds integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashLong long integer hash code Return Value integer(kind=kInt32) hash code Description To compute the hash value using the HalfSipHash hash algorithm by\n Jean-Philippe Aumasson [12] where the numbers of rounds are specified.","tags":"","loc":"interface\\halfsiphash_i32.html"},{"title":"Metro_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Metro_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2].","tags":"","loc":"interface\\metro_hash64_opt.html"},{"title":"Murmur3_Hash128_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the MurmurHash3 hash algorithm by Austin\n Appleby [1].","tags":"","loc":"interface\\murmur3_hash128_opt.html"},{"title":"Wy_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Wy_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4].","tags":"","loc":"interface\\wy_hash64_opt.html"},{"title":"WyF3_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WyF3_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3].","tags":"","loc":"interface\\wyf3_hash64_opt.html"},{"title":"XX_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the XXHash hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx_hash64_opt.html"},{"title":"XX3_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Secret) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code Description To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx3_hash64_opt.html"},{"title":"XX3_Hash128_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, Secret, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5].","tags":"","loc":"interface\\xx3_hash128_opt.html"},{"title":"City_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function City_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the CityHash hash algorithm by Google Inc [6].","tags":"","loc":"interface\\city_hash64_opt.html"},{"title":"FarmNa_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmNa_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmNaHash hash algorithm by Google Inc [7].","tags":"","loc":"interface\\farmna_hash64_opt.html"},{"title":"FarmUo_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmUo_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmUoHash hash algorithm by Google Inc [7].","tags":"","loc":"interface\\farmuo_hash64_opt.html"},{"title":"Spooky_Hash128_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Spooky_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, Seed, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8].","tags":"","loc":"interface\\spooky_hash128_opt.html"},{"title":"PengyV03_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyV03_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15].","tags":"","loc":"interface\\pengyv03_hash64_opt.html"},{"title":"PengyV02_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyV02_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10].","tags":"","loc":"interface\\pengyv02_hash64_opt.html"},{"title":"Komi_Hash64_Opt – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Komi_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13].","tags":"","loc":"interface\\komi_hash64_opt.html"},{"title":"MetroHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function MetroHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2, 4].","tags":"","loc":"interface\\metrohash_i64.html"},{"title":"Murmur3Hash_I128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Murmur3Hash_I128(Input, InpSize, StartHash, RemoveSign, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the Murmur3 hash algorithm by Austin Appleby [1, 4].","tags":"","loc":"interface\\murmur3hash_i128.html"},{"title":"WyHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WyHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4].","tags":"","loc":"interface\\wyhash_i64.html"},{"title":"WyHash_F3_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function WyHash_F3_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3].","tags":"","loc":"interface\\wyhash_f3_i64.html"},{"title":"XXHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XXHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the XXHash hash algorithm by Yann Collet [4, 5].","tags":"","loc":"interface\\xxhash_i64.html"},{"title":"XX3Hash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3Hash_I64(Input, InpSize, StartHash, RemoveSign, Secret) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code Description To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [4, 5].","tags":"","loc":"interface\\xx3hash_i64.html"},{"title":"XX3Hash_I128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function XX3Hash_I128(Input, InpSize, StartHash, RemoveSign, Secret, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [4, 5].","tags":"","loc":"interface\\xx3hash_i128.html"},{"title":"CityHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function CityHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the CityHash hash algorithm by Google Inc [4, 6].","tags":"","loc":"interface\\cityhash_i64.html"},{"title":"FarmNaHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmNaHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmNaHash hash algorithm by Google Inc [4, 7].","tags":"","loc":"interface\\farmnahash_i64.html"},{"title":"FarmUoHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function FarmUoHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code Description To compute hash code using the FarmUoHash hash algorithm by Google Inc [4, 7].","tags":"","loc":"interface\\farmuohash_i64.html"},{"title":"SpookyHash_I128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function SpookyHash_I128(Input, InpSize, StartHash, RemoveSign, Seed, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8].","tags":"","loc":"interface\\spookyhash_i128.html"},{"title":"PengyHash_V03_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyHash_V03_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15].","tags":"","loc":"interface\\pengyhash_v03_i64.html"},{"title":"PengyHash_V02_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function PengyHash_V02_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10].","tags":"","loc":"interface\\pengyhash_v02_i64.html"},{"title":"SipHash24_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function SipHash24_I64(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the SipHash24 hash algorithm by Jean-Philippe\n Aumasson [11].","tags":"","loc":"interface\\siphash24_i64.html"},{"title":"TSipHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function TSipHash_I64(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the TSipHash hash algorithm (a variant of SipHash)\n from SMHasher [9].","tags":"","loc":"interface\\tsiphash_i64.html"},{"title":"Mx3Hash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function Mx3Hash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the Mx3Hash hash algorithm by Jon Maiga [12].","tags":"","loc":"interface\\mx3hash_i64.html"},{"title":"KomiHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function KomiHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13].","tags":"","loc":"interface\\komihash_i64.html"},{"title":"MirHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function MirHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the MirHash hash algorithm by Vladimir Makarov [9, 14].","tags":"","loc":"interface\\mirhash_i64.html"},{"title":"MumHash_I64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function MumHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code Description To compute hash code using the MumHash hash algorithm by Vladimir Makarov [9, 15].","tags":"","loc":"interface\\mumhash_i64.html"},{"title":"SipHash_I128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function SipHash_I128(Input, InpSize, Key, cRound, dRound, StartHash, RemoveSign, HashPair) result(HashCode) Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt32), intent(in) :: cRound integer(kind=kInt32), intent(in) :: dRound integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code Description To compute hash code using the SipHash24 hash algorithm by Jean-Philippe\n Aumasson [11] where the numbers of rounds are specified.","tags":"","loc":"interface\\siphash_i128.html"},{"title":"MClass_HamsiB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HamsiB type and its related routines.\n  The HamsiB type is a digest type that extends directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. The HamsiB type implements an incremental cryptographic hash function\n  by employing either the Hamsi-384 or the Hamsi-512 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the HamsiB type employs the Hamsi-512 message-digest algorithm.  However, a user can specify the IsHamsi384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the Hamsi-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The Hash Function Hamsi. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_ByteUtil MBase_Common MClass_BaseDigest MBase_SIntUtil MBase_MemHandlers MBase_BytePack Derived Types type, public, extends( BaseDigest ) :: HamsiB HamsiB is a concrete digest type that implements an incremental\n cryptographic hash function based on the Hamsi hash algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => HamsiB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (HamsiB-512). procedure, public :: Reset => HamsiB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => HamsiB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => HamsiB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: InsertBytes => HamsiB_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => HamsiB_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => HamsiB_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => HamsiB_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: GetDigestLen => HamsiB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Hamsi-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the Hamsi-384 algorithm --->    CALL MD%Create(IsHamsi384=.TRUE.) generic, public :: AddBitsNDigest => HamsiB_ByteDigest_AddBits, HamsiB_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_hamsib.html"},{"title":"MBase_ExperimentalHash32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains an experimental implementation of various non-cryptographic\n  hash function routines that output a hash value as a 32-bit integer.  The available\n  hash functions are a subset of those reference hash functions implemented in the ModBase_ReferenceHash32 module.\n  The API of these experimental routines are the same as those reference routines with\n  the exception of an additional argument ( Algo ). The Algo argument is an algorithm flag used to indicate which algorithm is employed\n  to implement a Pack_I32 procedure, which perform a conversion from an array of four\n  8-bit integers to a 32-bit integer.  There are a number of possible implementations\n  of the Pack_I32 procedure.  In this module, seven basic implementations are provided.\n  A user can perform a benchmark of each specific hash function routine in order to know\n  which one of the Pack_I32 algorithms is the best one for a particular system (i.e.\n  a combination of operating system, machine as well as compiler used).  The benchmark\n  can then be used to implement an optimal implementation of the hash function. REFERENCES : See the ModBase_ReferenceHash32 module for references of the available hash functions in this module. Uses MBase_ByteUtil MBase_Common iso_c_binding Interfaces interface public module function Lookup3_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function Murmur3_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using the MurmurHash3 hash algorithm by Austin\n Appleby [1]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function City_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using the City hash algorithm by Google Inc [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function FarmMk_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NM_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMx_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function XX_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function Water_Hash32_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code Abstract Interfaces abstract interface public  function Pack_I16(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 16-bit integer value. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt16) result abstract interface public  function Pack_I32(ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result Functions public  function Pack_I32_A1 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL and IOR intrinsic\n functions. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A2 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL intrinsic function\n and an addition operator. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A3 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the SHIFTL and IOR intrinsic\n functions. Note : Although this routine and the Pack_I32_A3 routine employ\n the same intrinsic functions, orders of the functions being used\n are somewhat different. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A4 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the MVBITS intrinsic subroutine. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A5 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the TRANSFER intrinsic function. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A6 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the C_LOC and C_F_POINTER intrinsic module routines. Note :  This routine works best for system-endian order. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I32_A7 (ByteArr, Offset) result(Res) To convert an array of 8-bit integers starting at the offset to\n a 32-bit integer value using the EQUIVALENCE statement. Note :  This routine works best for system-endian order. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset offset Return Value integer(kind=kInt32) result public  function Pack_I16_A1 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A2 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A3 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A4 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A5 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A6 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16) public  function Pack_I16_A7 (Buf, Off) result(Res) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in), TARGET :: Buf (0:) integer(kind=kInt32), intent(in) :: Off Return Value integer(kind=kInt16)","tags":"","loc":"module\\mbase_experimentalhash32.html"},{"title":"MClass_FarmUoHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the FarmUoHasher64 type and its related routines.\n  The FarmUoHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The FarmUoHasher64 type employs the FarmUo hash algorithm for 64-bit integer\n  output by Google Inc [1, 2].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] FarmHash: a family of hash functions. [2] Zero-Allocation Hashing for Java. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: FarmUoHasher64 FarmUoHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the FarmUo hash algorithm by Google Inc. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => FarmUo_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => FarmUo_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => FarmUo_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => FarmUo_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => FarmUo_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with one seed. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSeeds => FarmUo_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value procedure, public :: Finalize => FarmUo_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => FarmUo_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally)\n               without seed or with one seed. Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirectWSeeds => FarmUo_HashDirect_WithSeeds Type-Bound Function : HashDirectWSeeds Purpose :  To compute the hash value directly (non-incrementally)\n               with two seeds. Usage : --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_farmuohasher64.html"},{"title":"MClass_EChoS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the EChoS type and its related routines.\n  The EChoS type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The EChoS type implements an incremental cryptographic hash function\n  by employing  either the ECHO-224 or the ECHO-256 algorithm [1].  The\n  implementation here is based mainly on the SPHLIB implementation [2]. By default, the EChoS type employs the ECHO-256 message-digest algorithm.  However, a user can specify the IsECHO224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the ECHO-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] ECHO hash function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: EChoS EChoS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the ECHO-224 or the ECHO-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => EChoS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (ECHO-256). procedure, public :: Reset => EChoS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => EChoS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => EChoS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => EChoS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => EChoS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => EChoS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => EChoS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => EChoS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => EChoS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (ECHO-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the ECHO-224 algorithm --->    CALL MD%Create(IsECHO224=.TRUE.)","tags":"","loc":"module\\mclass_echos.html"},{"title":"MClass_WaterHasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the WaterHasher32 type and its related routines.\n  The WaterHasher32 type is a hasher type that extends directly from the Hasher32 type.\n  It provides all deferred procedures required by a Hasher32 class and\n  outputs the hash value as a 32-bit integer. The WaterHasher32 type employs the Water hash algorithm for 32-bit integer\n  output by Tommy Ettinger [1].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] WaterHash: A variant of WyHash. Uses MBase_Common MClass_Hasher32 Derived Types type, public, extends( Hasher32 ) :: WaterHasher32 WaterHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the Water hash algorithm by Tommy Ettinger. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Water_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Water_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Water_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Water_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Water_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Water_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Water_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_waterhasher32.html"},{"title":"MClass_Blake2Core – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake2Core type and its related routines.\n  The Blake2Core type is an abstract digest type extending directly\n  from the BaseDigest type.  It defines and implements additional methods\n  (most of which is intended to be used internally) to provide an\n  extended API for an incremental cryptographic hash function. By design, the Blake2Core type is intended to be used as a parent\n  type for all BLAKE2-based digest types.  The Blake2Core type\n  provides an implementation of an incremental cryptographic hash function\n  by employing the BLAKE2 message-digest algorithm [1, 2].  It takes care\n  core operations (i.e. some of the deferred procedures and additional methods\n  provided) required by a BLAKE2-based digest object where its subtypes must\n  take care the remaining operations (i.e the rest of the deferred procedures).\n  The implementation of the Blake2Core type and its subtypes are based\n  mainly on the references [3, 4]. It should be noted that the BLAKE2 message-digest algorithm has several\n  variants with additional features such as keyed hashing (that is, MAC or\n  PRF), hashing with a salt, personalization and/or incremental tree-hashing.\n  The algorithm can also produce a variable-length hash output.  Among these\n  additional features, the Blake2Core type and its subtypes only allow\n  keyed hashing and variable-length hash output. REFERENCES : [1] J.P. Aumasson, W. Meier,\n      R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. [2] BLAKE2 - Fast Secure Hashing. [3] JBlake2: A pure Java\n      implementation of BLAKE2 (RFC 7693). [4] BLAKE2 official implementations. Uses MBase_MemHandlers MBase_ByteUtil MBase_Common MClass_BaseDigest Derived Types type, public, extends( BaseDigest ) :: Blake2Core Blake2Core is an abstract digest type provided to be a parent type\n for other Blake2-based digest types to implement incremental cryptographic\n hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure(BCSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the BCSetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(BCProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the BCProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure(BCEncode), public, deferred :: EncodeOutput EncodeOutput is a binding name of the BCEncode deferred procedure. This procedure is NOT intended to be used by a user. procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen()","tags":"","loc":"module\\mclass_blake2core.html"},{"title":"MClass_Blake1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake1B type and its related routines.\n  The Blake1B type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Blake1B type implements an incremental cryptographic hash\n  function by employing either the BLAKE-384 or the BLAKE-512\n  message-digest algorithm where both algorithms are described in\n  the Hash Function BLAKE book [1].  The implementation here is\n  based mainly on the SPHLIB implementation [2]. By default, the Blake1B type employs the BLAKE-512 message-digest algorithm.  However, a user can specify the IsBLAKE384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the BLAKE-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] J.P. Aumasson, W. Meier,\n      R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: Blake1B Blake1B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BLAKE-384 or the BLAKE-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => Blake1B_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BLAKE-512). procedure, public :: Reset => Blake1B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Blake1B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Blake1B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => Blake1B_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => Blake1B_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => Blake1B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Blake1B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => Blake1B_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => Blake1B_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BLAKE-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the BLAKE-384 algorithm --->    CALL MD%Create(IsBLAKE384=.TRUE.)","tags":"","loc":"module\\mclass_blake1b.html"},{"title":"MClass_Luffa – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Luffa type and its related routines.\n  The Luffa type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Luffa type implements an incremental cryptographic hash\n  function by employing the Luffa message-digest algorithm [1].  The\n  implementation here is mainly based on the references [2]. The Luffa type represents four cryptographic hash functions:\n  the Luffa-224 , Luffa-256 , Luffa-384 , and Luffa-512 hash\n  functions.  By default, the Luffa type represents the Luffa-256 hash function.  However, a user can specify the Security argument\n  (to one of the four applicable values: 224, 256, 384 and 512) when\n  initializing the digest object in order to use a different hash\n  function and get a different hash output size. REFERENCES : [1] The Hash Function\n      Family Luffa (Round 2 Archive). [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_Common MClass_BaseDigest MClass_MDEngine MBase_SIntUtil MBase_BytePack Derived Types type, public, extends( MDEngine ) :: Luffa Luffa is a concrete digest type that implements an incremental\n cryptographic hash function based on the Luffa hash functions. Finalizations Procedures final :: Luffa_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => Luffa_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Luffa-256). procedure, public :: Reset => Luffa_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Luffa_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Luffa_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => Luffa_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => Luffa_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => Luffa_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Luffa_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => Luffa_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => Luffa_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Luffa-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Luffa-512 algorithm --->    CALL MD%Create(512)","tags":"","loc":"module\\mclass_luffa.html"},{"title":"MClass_XXHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the XXHasher64 type and its related routines.\n  The XXHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The XXHasher64 type employs the XX hash algorithm for 64-bit integer\n  output by Yann Collet [1, 2].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] xxHash: Extremely fast hash algorithm. [2] Zero-Allocation Hashing for Java. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: XXHasher64 XXHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the XX hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => XX_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => XX_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => XX_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => XX_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => XX_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => XX_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => XX_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_xxhasher64.html"},{"title":"MClass_Kangaroo – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Kangaroo type and its related routines.\n  The Kangaroo type is a digest type extending directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. As a Keccak-based digest type, the Kangaroo type utilizes the KP1600Sponge type, similar to other Keccak-based digest types.\n  However, unlike other Keccak-based digest types, the Kangaroo type does\n  not extends from the KP1600Core type, due to different designs of internal structures. Similar to the SHAKE type, the Kangaroo type represents two incremental cryptographic hash\n  functions ( KangarooTwelve and MarsupilamiFourteen ) and is capable of\n  producing a variable-length hash output.  By default, the Kangaroo type\n  employs the KangarooTwelve hash function as a default algorithm.  However,\n  a user can specify the IsMarsupilami14 flag to true when initializing the\n  digest object in order to use the MarsupilamiFourteen hash function instead\n  of the default one.  As previously mentioned, the Kangaroo type is capable\n  of producing variable-length hash output.  Therefore, a user can specify an\n  output length through the optional OutputLen argument when initializing the\n  digest object.  If the optional argument is NOT present, the Kangaroo type\n  produces the output length based on a default length for a specific algorithm.\n  In addition, a user may use the Kangaroo type as an extendable-output function\n  (XOF) by specifying the hash output length during a finalization of the digest\n  object where the DigestWOutLen method is called.  This method will ignore the\n  output length specified during initialization if the specified length is valid\n  (greater than or equal to 1). REFERENCES : [1] KangarooTwelve:\n      fast hashing based on Keccak-p. [2] The eXtended Keccak Code Package. Uses MBase_ByteUtil MBase_Common MClass_KP1600Sponge MClass_BaseDigest MBase_MemHandlers iso_c_binding Derived Types type, public, extends( BaseDigest ) :: Kangaroo Kangaroo is a concrete Keccak-based digest type that implements an incremental\n cryptographic hash function by employing either the KangarooTwelve or the MarsupilamiFourteen message-digest algorithm. Finalizations Procedures final :: Kangaroo_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => Kangaroo_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (KangarooTwelve)\n and default hash output length. procedure, public :: GetClone => Kangaroo_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Kangaroo_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: Reset => Kangaroo_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => Kangaroo_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Kangaroo_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Kangaroo_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Kangaroo_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: GetDigestLen => Kangaroo_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (KangarooTwelve) algorithm and default output length --->    CALL MD%Create() ! employ the MarsupilamiFourteen algorithm and default output length --->    CALL MD%Create(IsMarsupilami14=.TRUE.) ! employ the KangarooTwelve algorithm with specified output length --->    CALL MD%Create(IsMarsupilami14=.FALSE., OutputLen=32) ! employ the KMarsupilamiFourteen algorithm with specified output length --->    CALL MD%Create(IsMarsupilami14=.TRUE., OutputLen=64) generic, public :: DigestWOutLen => Kangaroo_ByteDigest_wOutLen, Kangaroo_ByteDigest_wInputNOutLen, Kangaroo_HexDigest_wOutLen, Kangaroo_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored.","tags":"","loc":"module\\mclass_kangaroo.html"},{"title":"MClass_cSHAKE – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the cSHAKE type and its related routines.\n  The cSHAKE type is a Keccak-based digest type that extends from\n  the KP1600Core type.  As a concrete derived type, it provides\n  all remaining deferred procedures required by all its parent types. Like the SHAKE type, the cSHAKE type represents two incremental cryptographic hash\n  functions and is capable of producing a variable-length hash output.\n  The cSHAKE type is a customizable version of the SHAKE type that\n  supports explicit domain separation via customization parameters.\n  For default initializations (initializing without other input arguments),\n  both types should produces the same hash output for the same input message. See the MClass_SHAKE module for\n  the default algorithm and how to specify the desired algorithm and/or\n  the desired output length.  See the Create ( InitializeWOption to be\n  exact) method for detailed explanation of customization parameters.\n  Similar to the SHAKE type, a user may use the cSHAKE type as an\n  extendable-output function (XOF) by specifying the hash output length\n  during a finalization of the digest object where the DigestWOutLen method is called.  This method will ignore the output length specified\n  during initialization if the specified length is valid (greater than or\n  equal to 1). REFERENCES : [1] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [2] The eXtended Keccak Code Package. Uses MBase_ByteUtil MBase_Common MClass_KP1600Core MClass_KP1600Sponge MClass_BaseDigest MBase_MemHandlers iso_c_binding Derived Types type, public, extends( KP1600Core ) :: cSHAKE cSHAKE is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function by employing either the cSHAKE-128 or the cSHAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => cSHAKE_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (cSHAKE-128)\n and default hash output length, and without customization parameters. procedure, public :: GetClone => cSHAKE_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => cSHAKE_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (cSHAKE-256) algorithm and default output length --->    CALL MD%Create() ! employ the cSHAKE-256 algorithm and default output length --->    CALL MD%Create(IscSHAKE256=.TRUE.) ! employ the cSHAKE-128 algorithm with specified output length --->    CALL MD%Create(IscSHAKE256=.FALSE., OutputLen=64) ! employ the cSHAKE-256 algorithm with specified output length --->    CALL MD%Create(IscSHAKE256=.TRUE., OutputLen=128) ! employ the cSHAKE-128 algorithm with customization parameters --->    CALL MD%Create(IscSHAKE256=.FALSE., Name=FuncStr, Custom=CustomStr) generic, public :: DigestWOutLen => cSHAKE_ByteDigest_wOutLen, cSHAKE_ByteDigest_wInputNOutLen, cSHAKE_HexDigest_wOutLen, cSHAKE_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored.","tags":"","loc":"module\\mclass_cshake.html"},{"title":"MClass_HamsiS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HamsiS type and its related routines.\n  The HamsiS type is a digest type that extends directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. The HamsiS type implements an incremental cryptographic hash function\n  by employing either the Hamsi-224 or the Hamsi-256 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the HamsiS type employs the Hamsi-256 message-digest algorithm.  However, a user can specify the IsHamsi224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the Hamsi-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The Hash Function Hamsi. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_ByteUtil MBase_Common MClass_BaseDigest MBase_SIntUtil MBase_MemHandlers MBase_BytePack Derived Types type, public, extends( BaseDigest ) :: HamsiS HamsiS is a concrete digest type that implements an incremental\n cryptographic hash function based on the Hamsi hash algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => HamsiS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (HamsiS-256). procedure, public :: Reset => HamsiS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => HamsiS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => HamsiS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: InsertBytes => HamsiS_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => HamsiS_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => HamsiS_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => HamsiS_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: GetDigestLen => HamsiS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Hamsi-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Hamsi-224 algorithm --->    CALL MD%Create(IsHamsi224=.TRUE.) generic, public :: AddBitsNDigest => HamsiS_ByteDigest_AddBits, HamsiS_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_hamsis.html"},{"title":"MClass_Keccak – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Keccak type and its related routines.\n  The Keccak type is a Keccak-based digest type that extends from\n  the KP1600Core type.  As a concrete derived type, it provides\n  all remaining deferred procedures required by all its parent types. Similar to the SHA3 type, the Keccak type represents two families of incremental\n  cryptographic hash functions: the Keccak and the SHA-3 families.\n  Both types are functionally the same and should provide the same\n  hash output if they are initialized to employ the same message-digest\n  algorithm (e.g. SHA3-256).  However, they uses completely different\n  implementations. As the name suggested, the Keccak type represents the Keccak family\n  by default.  However, a user can specify the IsSHA3 flag to true\n  when initializing the digest object (by calling the Create method)\n  in order to use the padding strategy of the SHA-3 family.  Also,\n  the Keccak type employs the Keccak-256 hash function as a default\n  algorithm.  This implies that the hash output has the output size\n  and the strength of security (against pre-image attack) of 256 bits.\n  The user can also specify the Security argument (to one of the four\n  applicable values: 224, 256, 384 and 512) when initializing the digest\n  object in order to use a different algorithm and get a different hash\n  output size. REFERENCES : [1] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [2] The eXtended Keccak Code Package. Uses MClass_KP1600Core MClass_BaseDigest MBase_Common MBase_SIntUtil Derived Types type, public, extends( KP1600Core ) :: Keccak Keccak is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function based on the so-called Keccak\n hash functions, which is a family of message-digest algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => Keccak_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Keccak-256). procedure, public :: GetClone => Keccak_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Keccak_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Keccak-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA3-256 algorithm --->    CALL MD%Create(IsSHA3=.TRUE.) ! initialize the object to employ the Keccak-384 algorithm --->    CALL MD%Create(IsSHA3=.FALSE., Security=384) ! initialize the object to employ the SHA3-512 algorithm --->    CALL MD%Create(IsSHA3=.TRUE., Security=512)","tags":"","loc":"module\\mclass_keccak.html"},{"title":"MBase_BytePack – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains utility routines for conversion of bit patterns between\n  a byte array (an array of 8-bit integers) and other integer types.  The module\n  provide six procedure interfaces: BytePack, ByteUnpack, BytePackBE, ByteUnpackBE,\n  BytePackLE, and ByteUnpackLE. The BytePack procedure interface performs a conversion from a byte array to\n  an (other) integer (or an array of other integers) using machine endianess. The ByteUnpack procedure interface performs a conversion from an (other) integer\n  (or an array of other integers) to a byte array using machine endianess. The BytePackBE procedure interface performs a conversion from a byte array in\n  big-endian order to an (other) integer (or an array of other integers). The ByteUnpackBE procedure interface performs a conversion from an (other) integer\n  (or an array of other integers) to a byte array in big-endian order. The BytePackLE procedure interface performs a conversion from a byte array in\n  little-endian order to an (other) integer (or an array of other integers). The ByteUnpackLE procedure interface performs a conversion from an (other) integer\n  (or an array of other integers) to a byte array in little-endian order. Uses MBase_Common iso_c_binding Interfaces public        interface BytePack Subroutine Interface : BytePack Purpose :  To convert a byte array stored in machine-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePack(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePack(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePack(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePack(ByteArr, Offset, IntArr) private  subroutine PackBytes_Short(ByteArr, I16) To convert from the byte array (stored according to the machine endianess)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out), TARGET :: I16 16-bit integer private  subroutine PackBytesWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytes_Shorts(ByteArr, I16Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out), TARGET :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytes_Integer(ByteArr, I32) To convert from the byte array (stored according to the machine endianess)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out), TARGET :: I32 32-bit integer private  subroutine PackBytesWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytes_Integers(ByteArr, I32Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out), TARGET :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytes_Long(ByteArr, I64) To convert from the byte array (stored according to the machine endianess)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out), TARGET :: I64 64-bit integer private  subroutine PackBytesWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytes_Longs(ByteArr, I64Arr) To convert from the byte array (stored according to the machine endianess)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out), TARGET :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored according to the machine endianess)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers public        interface ByteUnpack Subroutine Interface : ByteUnpack Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in machine-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpack(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpack(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpack(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpack(IntArr, ByteArr, Offset) private  subroutine UnpackBytes_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in), TARGET :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in), TARGET :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in), TARGET :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in), TARGET :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored according to\n the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in), TARGET :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored according to\n the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytes_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n according to the machine endianess). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in), TARGET :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n according to the machine endianess) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array public        interface BytePackBE Subroutine Interface : BytePackBE Purpose :  To convert a byte array stored in big-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePackBE(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePackBE(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePackBE(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePackBE(ByteArr, Offset, IntArr) private  subroutine PackBytesBE_Short(ByteArr, I16) To convert from the byte array (stored in big-endian order)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesBEWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesBE_Shorts(ByteArr, I16Arr) To convert from the byte array (stored in big-endian order)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesBEWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesBE_Integer(ByteArr, I32) To convert from the byte array (stored in big-endian order)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesBEWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesBE_Integers(ByteArr, I32Arr) To convert from the byte array (stored in big-endian order)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesBEWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesBE_Long(ByteArr, I64) To convert from the byte array (stored in big-endian order)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesBEWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored in big-endian order)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesBE_Longs(ByteArr, I64Arr) To convert from the byte array (stored in big-endian order)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesBEWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored in big-endian order)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers public        interface ByteUnpackBE Subroutine Interface : ByteUnpackBE Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in big-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpackBE(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpackBE(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpackBE(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpackBE(IntArr, ByteArr, Offset) private  subroutine UnpackBytesBE_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesBEWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesBEWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesBEWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored in big-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesBE_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n in big-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesBEWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n in big-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array public        interface BytePackLE Subroutine Interface : BytePackLE Purpose :  To convert a byte array stored in little-endian order to an\n               (16-bit, 32-bit or 64-bit) integer (or an array of integers). Usage : ! convert a byte array to an integer --->    CALL BytePackLE(ByteArr, IntVal) ! convert a byte array starting at the specified offset to an integer --->    CALL BytePackLE(ByteArr, Offset, IntVal) ! convert a byte array to an integer array --->    CALL BytePackLE(ByteArr, IntArr) ! convert a byte array starting at the specified offset to an integer array --->    CALL BytePackLE(ByteArr, Offset, IntArr) private  subroutine PackBytesLE_Short(ByteArr, I16) To convert from the byte array (stored in little-endian order)\n to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int16) byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesLEWOffset_Short(ByteArr, Offset, I16) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 16-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16 16-bit integer private  subroutine PackBytesLE_Shorts(ByteArr, I16Arr) To convert from the byte array (stored in little-endian order)\n to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesLEWOffset_Shorts(ByteArr, Offset, I16Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 16-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt16), intent(out) :: I16Arr (:) array of 16-bit integers private  subroutine PackBytesLE_Integer(ByteArr, I32) To convert from the byte array (stored in little-endian order)\n to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int32) byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesLEWOffset_Integer(ByteArr, Offset, I32) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 32-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32 32-bit integer private  subroutine PackBytesLE_Integers(ByteArr, I32Arr) To convert from the byte array (stored in little-endian order)\n to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesLEWOffset_Integers(ByteArr, Offset, I32Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 32-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt32), intent(out) :: I32Arr (:) array of 32-bit integers private  subroutine PackBytesLE_Long(ByteArr, I64) To convert from the byte array (stored in little-endian order)\n to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (Bytes_Int64) byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesLEWOffset_Long(ByteArr, Offset, I64) To convert from the byte array (stored in little-endian order)\n starting at the offset to a 64-bit integer. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64 64-bit integer private  subroutine PackBytesLE_Longs(ByteArr, I64Arr) To convert from the byte array (stored in little-endian order)\n to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (:) byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers private  subroutine PackBytesLEWOffset_Longs(ByteArr, Offset, I64Arr) To convert from the byte array (stored in little-endian order)\n starting at the offset to an array of 64-bit integers. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array integer(kind=kInt64), intent(out) :: I64Arr (:) array of 64-bit integers public        interface ByteUnpackLE Subroutine Interface : ByteUnpackLE Purpose :  To convert an (16-bit, 32-bit or 64-bit) integer (or an array\n               of integers) to a byte array stored in little-endian order. Usage : ! convert an integer to a byte array --->    CALL ByteUnpackLE(IntVal, ByteArr) ! convert an integer to a byte array starting at the specified offset --->    CALL ByteUnpackLE(IntVal, ByteArr, Offset) ! convert an integer array to a byte array --->    CALL ByteUnpackLE(IntArr, ByteArr) ! convert an integer array to a byte array starting at the specified offset --->    CALL ByteUnpackLE(IntArr, ByteArr, Offset) private  subroutine UnpackBytesLE_Short(I16, ByteArr) To convert from a 16-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int16) byte array private  subroutine UnpackBytesLEWOffset_Short(I16, ByteArr, Offset) To convert from a 16-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16 16-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Shorts(I16Arr, ByteArr) To convert from an array of 16-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Shorts(I16Arr, ByteArr, Offset) To convert from an array of 16-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: I16Arr (:) array of 16-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Integer(I32, ByteArr) To convert from a 32-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int32) byte array private  subroutine UnpackBytesLEWOffset_Integer(I32, ByteArr, Offset) To convert from a 32-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 32-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Integers(I32Arr, ByteArr) To convert from an array of 32-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Integers(I32Arr, ByteArr, Offset) To convert from an array of 32-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32Arr (:) array of 32-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Long(I64, ByteArr) To convert from a 64-bit integer to the byte array (stored in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (Bytes_Int64) byte array private  subroutine UnpackBytesLEWOffset_Long(I64, ByteArr, Offset) To convert from a 64-bit integer to the byte array (stored in little-endian order)\n starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 64-bit integer integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array private  subroutine UnpackBytesLE_Longs(I64Arr, ByteArr) To convert from an array of 64-bit integers to the byte array (stored\n in little-endian order). Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (:) byte array private  subroutine UnpackBytesLEWOffset_Longs(I64Arr, ByteArr, Offset) To convert from an array of 64-bit integers to the byte array (stored\n in little-endian order) starting at the offset. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64Arr (:) array of 64-bit integers integer(kind=kInt8), intent(out) :: ByteArr (0:) byte array integer(kind=kInt32), intent(in) :: Offset starting index of the byte array","tags":"","loc":"module\\mbase_bytepack.html"},{"title":"MBase_ExperimentalHash64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains an experimental implementation of various non-cryptographic\n  hash function routines that output a hash value as a 64-bit integer.  The available\n  hash functions are a subset of those reference hash functions implemented in the ModBase_ReferenceHash64 module.\n  The API of these experimental routines are the same as those reference routines with\n  the exception of an additional argument ( Algo ). The Algo argument is an algorithm flag used to indicate which algorithm is employed\n  to implement a Pack_I64 procedure, which perform a conversion from an array of eight\n  8-bit integers to a 64-bit integer.  There are a number of possible implementations\n  of the Pack_I64 procedure.  In this module, seven basic implementations are provided.\n  A user can perform a benchmark of each specific hash function routine in order to know\n  which one of the Pack_I64 algorithms is the best one for a particular system (i.e.\n  a combination of operating system, machine as well as compiler used).  The benchmark\n  can then be used to implement an optimal implementation of the hash function. REFERENCES : See the ModBase_ReferenceHash64 module for references of the available hash functions in this module. Uses MBase_ByteUtil MBase_Common iso_c_binding Interfaces interface public module function Metro_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Murmur3_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, HashPair) result(HashCode) To compute hash code using the MurmurHash3 hash algorithm by Austin\n Appleby [1]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-14) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function Wy_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-11) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function WyF3_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XX_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the XXHash hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XX3_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Secret) result(HashCode) To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code interface public module function XX3_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Secret, HashPair) result(HashCode) To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function City_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the CityHash hash algorithm by Google Inc [6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-10) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmNa_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmNaHash hash algorithm by Google Inc [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmUo_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmUoHash hash algorithm by Google Inc [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function Spooky_Hash128_Exp(Input, InpSize, Algo, StartHash, RemoveSign, Seed, HashPair) result(HashCode) To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-9) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function PengyV03_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function PengyV02_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-7) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Komi_Hash64_Exp(Input, InpSize, Algo, StartHash, RemoveSign) result(HashCode) To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in) :: Algo algorithm flag (1-8) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code","tags":"","loc":"module\\mbase_experimentalhash64.html"},{"title":"MClass_ShaviteB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ShaviteB type and its related routines.\n  The ShaviteB type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The ShaviteB type implements an incremental cryptographic hash function\n  by employing a SHAvite-3 message-digest algorithm (either the SHAvite-384 or the SHAvite-512 ) [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the ShaviteB type employs the SHAvite-512 message-digest algorithm.  However, a user can specify the IsSHAvite384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SHAvite-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The SHAvite-3 hash function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: ShaviteB ShaviteB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SHAvite-384 or the SHAvite-512 message-digest algorithm. Finalizations Procedures final :: ShaviteB_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => ShaviteB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAvite-512). procedure, public :: Reset => ShaviteB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => ShaviteB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => ShaviteB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => ShaviteB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => ShaviteB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => ShaviteB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => ShaviteB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => ShaviteB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => ShaviteB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHAvite-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHAvite-384 algorithm --->    CALL MD%Create(IsSHAvite384=.TRUE.)","tags":"","loc":"module\\mclass_shaviteb.html"},{"title":"MClass_CubeHash – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the CubeHash type and its related routines.\n  The CubeHash type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The CubeHash type implements an incremental cryptographic hash\n  function by employing the CubeHash message-digest algorithm [1].\n  The implementation here is mainly based on the references [2]. The CubeHash type represents four cryptographic hash functions:\n  the CubeHash-224 , CubeHash-256 , CubeHash-384 , and CubeHash-512 hash functions.  By default, the CubeHash type represents the CubeHash-512 hash function.  However, a user can specify the Security argument (to one of the four applicable values: 224, 256,\n  384 and 512) when initializing the digest object in order to use a\n  different hash function and get a different hash output size. REFERENCES : [1] CubeHash: a simple hash function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_Common MClass_BaseDigest MClass_MDEngine MBase_SIntUtil MBase_BytePack Derived Types type, public, extends( MDEngine ) :: CubeHash CubeHash is a concrete digest type that implements an incremental\n cryptographic hash function based on the CubeHash hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => CubeHash_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (CubeHash-512). procedure, public :: Reset => CubeHash_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => CubeHash_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => CubeHash_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => CubeHash_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => CubeHash_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => CubeHash_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => CubeHash_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => CubeHash_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => CubeHash_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (CubeHash-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the CubeHash-256 algorithm --->    CALL MD%Create(256)","tags":"","loc":"module\\mclass_cubehash.html"},{"title":"MClass_MetroHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MetroHasher64 type and its related routines.\n  The MetroHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The MetroHasher64 type employs the Metro hash algorithm for 64-bit integer\n  output by J. Andrew Rogers [1, 2].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] MetroHash: Faster, Better\n      Hash Functions. [2] Zero-Allocation Hashing for Java. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: MetroHasher64 MetroHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Metro hash algorithm by J. Andrew Rogers. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Metro_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Metro_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Metro_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Metro_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Metro_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Metro_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Metro_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_metrohasher64.html"},{"title":"MClass_MD2 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MD2 type and its related routines.\n  The MD2 type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The MD2 type implements an incremental cryptographic hash\n  function by employing the MD2 message-digest algorithm [1]\n  where the algorithm is described in RFC 1319.  The implementation\n  here is mainly based on the SPHLIB implementation [2]. REFERENCES : [1] RFC1319:\n      The MD2 Message-Digest Algorithm. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: MD2 MD2 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD2 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => MD2_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. procedure, public :: Reset => MD2_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => MD2_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => MD2_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => MD2_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => MD2_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => MD2_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => MD2_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => MD2_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => MD2_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user.","tags":"","loc":"module\\mclass_md2.html"},{"title":"MClass_GroestlS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the GroestlS type and its related routines.\n  The GroestlS type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The GroestlS type implements an incremental cryptographic hash function\n  by employing either the Groestl-224 or the Groestl-256 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the GroestlS type employs the Groestl-256 message-digest algorithm.  However, a user can specify the IsGroestl224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the Groestl-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] Grostl - a SHA-3 candidate. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Variables Type Visibility Attributes Name Initial integer(kind=kInt64), public, parameter :: T0 (0:255) = [INT(Z'C632F4A5F497A5C6', KIND=kInt64), INT(Z'F86F978497EB84F8', KIND=kInt64), INT(Z'EE5EB099B0C799EE', KIND=kInt64), INT(Z'F67A8C8D8CF78DF6', KIND=kInt64), INT(Z'FFE8170D17E50DFF', KIND=kInt64), INT(Z'D60ADCBDDCB7BDD6', KIND=kInt64), INT(Z'DE16C8B1C8A7B1DE', KIND=kInt64), INT(Z'916DFC54FC395491', KIND=kInt64), INT(Z'6090F050F0C05060', KIND=kInt64), INT(Z'0207050305040302', KIND=kInt64), INT(Z'CE2EE0A9E087A9CE', KIND=kInt64), INT(Z'56D1877D87AC7D56', KIND=kInt64), INT(Z'E7CC2B192BD519E7', KIND=kInt64), INT(Z'B513A662A67162B5', KIND=kInt64), INT(Z'4D7C31E6319AE64D', KIND=kInt64), INT(Z'EC59B59AB5C39AEC', KIND=kInt64), INT(Z'8F40CF45CF05458F', KIND=kInt64), INT(Z'1FA3BC9DBC3E9D1F', KIND=kInt64), INT(Z'8949C040C0094089', KIND=kInt64), INT(Z'FA68928792EF87FA', KIND=kInt64), INT(Z'EFD03F153FC515EF', KIND=kInt64), INT(Z'B29426EB267FEBB2', KIND=kInt64), INT(Z'8ECE40C94007C98E', KIND=kInt64), INT(Z'FBE61D0B1DED0BFB', KIND=kInt64), INT(Z'416E2FEC2F82EC41', KIND=kInt64), INT(Z'B31AA967A97D67B3', KIND=kInt64), INT(Z'5F431CFD1CBEFD5F', KIND=kInt64), INT(Z'456025EA258AEA45', KIND=kInt64), INT(Z'23F9DABFDA46BF23', KIND=kInt64), INT(Z'535102F702A6F753', KIND=kInt64), INT(Z'E445A196A1D396E4', KIND=kInt64), INT(Z'9B76ED5BED2D5B9B', KIND=kInt64), INT(Z'75285DC25DEAC275', KIND=kInt64), INT(Z'E1C5241C24D91CE1', KIND=kInt64), INT(Z'3DD4E9AEE97AAE3D', KIND=kInt64), INT(Z'4CF2BE6ABE986A4C', KIND=kInt64), INT(Z'6C82EE5AEED85A6C', KIND=kInt64), INT(Z'7EBDC341C3FC417E', KIND=kInt64), INT(Z'F5F3060206F102F5', KIND=kInt64), INT(Z'8352D14FD11D4F83', KIND=kInt64), INT(Z'688CE45CE4D05C68', KIND=kInt64), INT(Z'515607F407A2F451', KIND=kInt64), INT(Z'D18D5C345CB934D1', KIND=kInt64), INT(Z'F9E1180818E908F9', KIND=kInt64), INT(Z'E24CAE93AEDF93E2', KIND=kInt64), INT(Z'AB3E9573954D73AB', KIND=kInt64), INT(Z'6297F553F5C45362', KIND=kInt64), INT(Z'2A6B413F41543F2A', KIND=kInt64), INT(Z'081C140C14100C08', KIND=kInt64), INT(Z'9563F652F6315295', KIND=kInt64), INT(Z'46E9AF65AF8C6546', KIND=kInt64), INT(Z'9D7FE25EE2215E9D', KIND=kInt64), INT(Z'3048782878602830', KIND=kInt64), INT(Z'37CFF8A1F86EA137', KIND=kInt64), INT(Z'0A1B110F11140F0A', KIND=kInt64), INT(Z'2FEBC4B5C45EB52F', KIND=kInt64), INT(Z'0E151B091B1C090E', KIND=kInt64), INT(Z'247E5A365A483624', KIND=kInt64), INT(Z'1BADB69BB6369B1B', KIND=kInt64), INT(Z'DF98473D47A53DDF', KIND=kInt64), INT(Z'CDA76A266A8126CD', KIND=kInt64), INT(Z'4EF5BB69BB9C694E', KIND=kInt64), INT(Z'7F334CCD4CFECD7F', KIND=kInt64), INT(Z'EA50BA9FBACF9FEA', KIND=kInt64), INT(Z'123F2D1B2D241B12', KIND=kInt64), INT(Z'1DA4B99EB93A9E1D', KIND=kInt64), INT(Z'58C49C749CB07458', KIND=kInt64), INT(Z'3446722E72682E34', KIND=kInt64), INT(Z'3641772D776C2D36', KIND=kInt64), INT(Z'DC11CDB2CDA3B2DC', KIND=kInt64), INT(Z'B49D29EE2973EEB4', KIND=kInt64), INT(Z'5B4D16FB16B6FB5B', KIND=kInt64), INT(Z'A4A501F60153F6A4', KIND=kInt64), INT(Z'76A1D74DD7EC4D76', KIND=kInt64), INT(Z'B714A361A37561B7', KIND=kInt64), INT(Z'7D3449CE49FACE7D', KIND=kInt64), INT(Z'52DF8D7B8DA47B52', KIND=kInt64), INT(Z'DD9F423E42A13EDD', KIND=kInt64), INT(Z'5ECD937193BC715E', KIND=kInt64), INT(Z'13B1A297A2269713', KIND=kInt64), INT(Z'A6A204F50457F5A6', KIND=kInt64), INT(Z'B901B868B86968B9', KIND=kInt64), INT(Z'0000000000000000', KIND=kInt64), INT(Z'C1B5742C74992CC1', KIND=kInt64), INT(Z'40E0A060A0806040', KIND=kInt64), INT(Z'E3C2211F21DD1FE3', KIND=kInt64), INT(Z'793A43C843F2C879', KIND=kInt64), INT(Z'B69A2CED2C77EDB6', KIND=kInt64), INT(Z'D40DD9BED9B3BED4', KIND=kInt64), INT(Z'8D47CA46CA01468D', KIND=kInt64), INT(Z'671770D970CED967', KIND=kInt64), INT(Z'72AFDD4BDDE44B72', KIND=kInt64), INT(Z'94ED79DE7933DE94', KIND=kInt64), INT(Z'98FF67D4672BD498', KIND=kInt64), INT(Z'B09323E8237BE8B0', KIND=kInt64), INT(Z'855BDE4ADE114A85', KIND=kInt64), INT(Z'BB06BD6BBD6D6BBB', KIND=kInt64), INT(Z'C5BB7E2A7E912AC5', KIND=kInt64), INT(Z'4F7B34E5349EE54F', KIND=kInt64), INT(Z'EDD73A163AC116ED', KIND=kInt64), INT(Z'86D254C55417C586', KIND=kInt64), INT(Z'9AF862D7622FD79A', KIND=kInt64), INT(Z'6699FF55FFCC5566', KIND=kInt64), INT(Z'11B6A794A7229411', KIND=kInt64), INT(Z'8AC04ACF4A0FCF8A', KIND=kInt64), INT(Z'E9D9301030C910E9', KIND=kInt64), INT(Z'040E0A060A080604', KIND=kInt64), INT(Z'FE66988198E781FE', KIND=kInt64), INT(Z'A0AB0BF00B5BF0A0', KIND=kInt64), INT(Z'78B4CC44CCF04478', KIND=kInt64), INT(Z'25F0D5BAD54ABA25', KIND=kInt64), INT(Z'4B753EE33E96E34B', KIND=kInt64), INT(Z'A2AC0EF30E5FF3A2', KIND=kInt64), INT(Z'5D4419FE19BAFE5D', KIND=kInt64), INT(Z'80DB5BC05B1BC080', KIND=kInt64), INT(Z'0580858A850A8A05', KIND=kInt64), INT(Z'3FD3ECADEC7EAD3F', KIND=kInt64), INT(Z'21FEDFBCDF42BC21', KIND=kInt64), INT(Z'70A8D848D8E04870', KIND=kInt64), INT(Z'F1FD0C040CF904F1', KIND=kInt64), INT(Z'63197ADF7AC6DF63', KIND=kInt64), INT(Z'772F58C158EEC177', KIND=kInt64), INT(Z'AF309F759F4575AF', KIND=kInt64), INT(Z'42E7A563A5846342', KIND=kInt64), INT(Z'2070503050403020', KIND=kInt64), INT(Z'E5CB2E1A2ED11AE5', KIND=kInt64), INT(Z'FDEF120E12E10EFD', KIND=kInt64), INT(Z'BF08B76DB7656DBF', KIND=kInt64), INT(Z'8155D44CD4194C81', KIND=kInt64), INT(Z'18243C143C301418', KIND=kInt64), INT(Z'26795F355F4C3526', KIND=kInt64), INT(Z'C3B2712F719D2FC3', KIND=kInt64), INT(Z'BE8638E13867E1BE', KIND=kInt64), INT(Z'35C8FDA2FD6AA235', KIND=kInt64), INT(Z'88C74FCC4F0BCC88', KIND=kInt64), INT(Z'2E654B394B5C392E', KIND=kInt64), INT(Z'936AF957F93D5793', KIND=kInt64), INT(Z'55580DF20DAAF255', KIND=kInt64), INT(Z'FC619D829DE382FC', KIND=kInt64), INT(Z'7AB3C947C9F4477A', KIND=kInt64), INT(Z'C827EFACEF8BACC8', KIND=kInt64), INT(Z'BA8832E7326FE7BA', KIND=kInt64), INT(Z'324F7D2B7D642B32', KIND=kInt64), INT(Z'E642A495A4D795E6', KIND=kInt64), INT(Z'C03BFBA0FB9BA0C0', KIND=kInt64), INT(Z'19AAB398B3329819', KIND=kInt64), INT(Z'9EF668D16827D19E', KIND=kInt64), INT(Z'A322817F815D7FA3', KIND=kInt64), INT(Z'44EEAA66AA886644', KIND=kInt64), INT(Z'54D6827E82A87E54', KIND=kInt64), INT(Z'3BDDE6ABE676AB3B', KIND=kInt64), INT(Z'0B959E839E16830B', KIND=kInt64), INT(Z'8CC945CA4503CA8C', KIND=kInt64), INT(Z'C7BC7B297B9529C7', KIND=kInt64), INT(Z'6B056ED36ED6D36B', KIND=kInt64), INT(Z'286C443C44503C28', KIND=kInt64), INT(Z'A72C8B798B5579A7', KIND=kInt64), INT(Z'BC813DE23D63E2BC', KIND=kInt64), INT(Z'1631271D272C1D16', KIND=kInt64), INT(Z'AD379A769A4176AD', KIND=kInt64), INT(Z'DB964D3B4DAD3BDB', KIND=kInt64), INT(Z'649EFA56FAC85664', KIND=kInt64), INT(Z'74A6D24ED2E84E74', KIND=kInt64), INT(Z'1436221E22281E14', KIND=kInt64), INT(Z'92E476DB763FDB92', KIND=kInt64), INT(Z'0C121E0A1E180A0C', KIND=kInt64), INT(Z'48FCB46CB4906C48', KIND=kInt64), INT(Z'B88F37E4376BE4B8', KIND=kInt64), INT(Z'9F78E75DE7255D9F', KIND=kInt64), INT(Z'BD0FB26EB2616EBD', KIND=kInt64), INT(Z'43692AEF2A86EF43', KIND=kInt64), INT(Z'C435F1A6F193A6C4', KIND=kInt64), INT(Z'39DAE3A8E372A839', KIND=kInt64), INT(Z'31C6F7A4F762A431', KIND=kInt64), INT(Z'D38A593759BD37D3', KIND=kInt64), INT(Z'F274868B86FF8BF2', KIND=kInt64), INT(Z'D583563256B132D5', KIND=kInt64), INT(Z'8B4EC543C50D438B', KIND=kInt64), INT(Z'6E85EB59EBDC596E', KIND=kInt64), INT(Z'DA18C2B7C2AFB7DA', KIND=kInt64), INT(Z'018E8F8C8F028C01', KIND=kInt64), INT(Z'B11DAC64AC7964B1', KIND=kInt64), INT(Z'9CF16DD26D23D29C', KIND=kInt64), INT(Z'49723BE03B92E049', KIND=kInt64), INT(Z'D81FC7B4C7ABB4D8', KIND=kInt64), INT(Z'ACB915FA1543FAAC', KIND=kInt64), INT(Z'F3FA090709FD07F3', KIND=kInt64), INT(Z'CFA06F256F8525CF', KIND=kInt64), INT(Z'CA20EAAFEA8FAFCA', KIND=kInt64), INT(Z'F47D898E89F38EF4', KIND=kInt64), INT(Z'476720E9208EE947', KIND=kInt64), INT(Z'1038281828201810', KIND=kInt64), INT(Z'6F0B64D564DED56F', KIND=kInt64), INT(Z'F073838883FB88F0', KIND=kInt64), INT(Z'4AFBB16FB1946F4A', KIND=kInt64), INT(Z'5CCA967296B8725C', KIND=kInt64), INT(Z'38546C246C702438', KIND=kInt64), INT(Z'575F08F108AEF157', KIND=kInt64), INT(Z'732152C752E6C773', KIND=kInt64), INT(Z'9764F351F3355197', KIND=kInt64), INT(Z'CBAE6523658D23CB', KIND=kInt64), INT(Z'A125847C84597CA1', KIND=kInt64), INT(Z'E857BF9CBFCB9CE8', KIND=kInt64), INT(Z'3E5D6321637C213E', KIND=kInt64), INT(Z'96EA7CDD7C37DD96', KIND=kInt64), INT(Z'611E7FDC7FC2DC61', KIND=kInt64), INT(Z'0D9C9186911A860D', KIND=kInt64), INT(Z'0F9B9485941E850F', KIND=kInt64), INT(Z'E04BAB90ABDB90E0', KIND=kInt64), INT(Z'7CBAC642C6F8427C', KIND=kInt64), INT(Z'712657C457E2C471', KIND=kInt64), INT(Z'CC29E5AAE583AACC', KIND=kInt64), INT(Z'90E373D8733BD890', KIND=kInt64), INT(Z'06090F050F0C0506', KIND=kInt64), INT(Z'F7F4030103F501F7', KIND=kInt64), INT(Z'1C2A36123638121C', KIND=kInt64), INT(Z'C23CFEA3FE9FA3C2', KIND=kInt64), INT(Z'6A8BE15FE1D45F6A', KIND=kInt64), INT(Z'AEBE10F91047F9AE', KIND=kInt64), INT(Z'69026BD06BD2D069', KIND=kInt64), INT(Z'17BFA891A82E9117', KIND=kInt64), INT(Z'9971E858E8295899', KIND=kInt64), INT(Z'3A5369276974273A', KIND=kInt64), INT(Z'27F7D0B9D04EB927', KIND=kInt64), INT(Z'D991483848A938D9', KIND=kInt64), INT(Z'EBDE351335CD13EB', KIND=kInt64), INT(Z'2BE5CEB3CE56B32B', KIND=kInt64), INT(Z'2277553355443322', KIND=kInt64), INT(Z'D204D6BBD6BFBBD2', KIND=kInt64), INT(Z'A9399070904970A9', KIND=kInt64), INT(Z'07878089800E8907', KIND=kInt64), INT(Z'33C1F2A7F266A733', KIND=kInt64), INT(Z'2DECC1B6C15AB62D', KIND=kInt64), INT(Z'3C5A66226678223C', KIND=kInt64), INT(Z'15B8AD92AD2A9215', KIND=kInt64), INT(Z'C9A96020608920C9', KIND=kInt64), INT(Z'875CDB49DB154987', KIND=kInt64), INT(Z'AAB01AFF1A4FFFAA', KIND=kInt64), INT(Z'50D8887888A07850', KIND=kInt64), INT(Z'A52B8E7A8E517AA5', KIND=kInt64), INT(Z'03898A8F8A068F03', KIND=kInt64), INT(Z'594A13F813B2F859', KIND=kInt64), INT(Z'09929B809B128009', KIND=kInt64), INT(Z'1A2339173934171A', KIND=kInt64), INT(Z'651075DA75CADA65', KIND=kInt64), INT(Z'D784533153B531D7', KIND=kInt64), INT(Z'84D551C65113C684', KIND=kInt64), INT(Z'D003D3B8D3BBB8D0', KIND=kInt64), INT(Z'82DC5EC35E1FC382', KIND=kInt64), INT(Z'29E2CBB0CB52B029', KIND=kInt64), INT(Z'5AC3997799B4775A', KIND=kInt64), INT(Z'1E2D3311333C111E', KIND=kInt64), INT(Z'7B3D46CB46F6CB7B', KIND=kInt64), INT(Z'A8B71FFC1F4BFCA8', KIND=kInt64), INT(Z'6D0C61D661DAD66D', KIND=kInt64), INT(Z'2C624E3A4E583A2C', KIND=kInt64)] integer(kind=kInt64), public, parameter :: T1 (0:255) = [(ISHFTC(T0(Indx), 56), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T2 (0:255) = [(ISHFTC(T0(Indx), 48), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T3 (0:255) = [(ISHFTC(T0(Indx), 40), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T4 (0:255) = [(ISHFTC(T0(Indx), 32), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T5 (0:255) = [(ISHFTC(T0(Indx), 24), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T6 (0:255) = [(ISHFTC(T0(Indx), 16), Indx=0, 255)] integer(kind=kInt64), public, parameter :: T7 (0:255) = [(ISHFTC(T0(Indx), 8), Indx=0, 255)] Derived Types type, public, extends( MDEngine ) :: GroestlS GroestlS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the Groestl-224 or the Groestl-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => GroestlS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Groestl-256). procedure, public :: Reset => GroestlS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => GroestlS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => GroestlS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => GroestlS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => GroestlS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => GroestlS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => GroestlS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => GroestlS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => GroestlS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Groestl-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Groestl-224 algorithm --->    CALL MD%Create(IsGroestl224=.TRUE.)","tags":"","loc":"module\\mclass_groestls.html"},{"title":"MClass_ByteConverter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ByteConverter type and its related routines.  The ByteConverter type performs a conversion of bit patterns between a byte\n  array (an array of 8-bit integers) and an other integer type (i.e. a 16-bit,\n  32-bit or 64-bit integer).  The ByteConverter type is intended to be used\n  with a general-purpose (non-cryptographic) hash function. It is important to note that the ByteConverter type MUST be initialized\n  before being used.  Otherwise, unexpected behaviors or a crash may occur.\n  The initialization provides a way to specify how the byte values are stored\n  in a byte array.  The byte values can be stored in either the big-endian\n  or the little-endian order.  If the optional flag is not specified during\n  the initialization, it assumes that the byte values are stored according to\n  machine-endian order. Uses MBase_ErrHandlers MBase_Common Derived Types type, public :: ByteConverter The ByteConverter type is a converter type that performs a conversion\n of bit patterns between a byte (an array of 8-bit integers) array and\n an other integer type (i.e. a 16-bit, 32-bit or 64-bit integer). Components Type Visibility Attributes Name Initial procedure(PackShort), public, POINTER, NOPASS :: Pack_I16 => NULL() Function Pointer : Pack_I16 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 16-bit integer. Usage : --->    IntVal = Pack_I16(ByteArr, Offset) procedure(PackInt), public, POINTER, NOPASS :: Pack_I32 => NULL() Function Pointer : Pack_I32 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 32-bit integer. Usage : --->    IntVal = Pack_I32(ByteArr, Offset) procedure(PackLong), public, POINTER, NOPASS :: Pack_I64 => NULL() Function Pointer : Pack_I64 Purpose :  To convert a byte array (starting at the specified offset)\n              to a 64-bit integer. Usage : --->    IntVal = Pack_I64(ByteArr, Offset) procedure(UnpackShort), public, POINTER, NOPASS :: Unpack_I16 => NULL() Subroutine Pointer : Unpack_I16 Purpose :  To convert a 16-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I16(IntVal, ByteArr, Offset) procedure(UnpackInt), public, POINTER, NOPASS :: Unpack_I32 => NULL() Subroutine Pointer : Unpack_I32 Purpose :  To convert a 32-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I32(IntVal, ByteArr, Offset) procedure(UnpackLong), public, POINTER, NOPASS :: Unpack_I64 => NULL() Subroutine Pointer : Unpack_I64 Purpose :  To convert a 64-bit integer to a byte array (starting at the\n               specified offset). Usage : --->    CALL Unpack_I64(IntVal, ByteArr, Offset) Type-Bound Procedures procedure, public :: Initialize => ByteConverter_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the ByteConverter object according to the\n              optionally specified endianess flag. Usage : --->    CALL ByteConv%Initialize()          ! machine endian --->    CALL ByteConv%Initialize(.TRUE.)    ! big endian --->    CALL ByteConv%Initialize(.FALSE.)   ! little endian procedure, public :: Reset => ByteConverter_Reset Type-Bound Subroutine : Reset Purpose :  To reset the ByteConverter object. Usage : --->    CALL ByteConv%Reset() procedure, public :: Get_I8 => Get_Byte Type-Bound Function : Get_I8 Purpose :  To get a single byte at the specified offset of the given byte\n              array and return the result widened to default integer type. Usage : --->    IntVal = ByteConv%Get_I8(ByteArr, Offset) procedure, public :: Get_U8 => Get_Unsigned_Byte Type-Bound Function : Get_U8 Purpose :  To get a single byte at the specified offset of the given byte\n              array and return the result widened to default integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Get_U8(ByteArr, Offset) procedure, public :: Pack_U16 => Pack_Unsigned_Short Type-Bound Function : Pack_U16 Purpose :  To get two bytes starting at the specified offset of the given byte\n              array and return the result widened to default integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Pack_U16(ByteArr, Offset) procedure, public :: Pack_U32 => Pack_Unsigned_Integer Type-Bound Function : Pack_U32 Purpose :  To get four bytes starting at the specified offset of the given byte\n              array and return the result widened to 64-bit integer type with\n              the signed of the requested byte removed. Usage : --->    IntVal = ByteConv%Pack_U32(ByteArr, Offset) procedure, public :: Pack_I32_Partial => Pack_Integer_Partial Type-Bound Function : Pack_I32_Partial Purpose :  To get three or fewer bytes of the given byte array starting at\n              the specified offset and return the result as 32-bit integer. Usage : --->    IntVal = ByteConv%Pack_I32_Partial(ByteArr, Offset, Length) Note : Length must be between 1 and 3. procedure, public :: Pack_I64_Partial => Pack_Long_Partial Type-Bound Function : Pack_I64_Partial Purpose :  To get seven or fewer bytes of the given byte array starting at\n              the specified offset and return the result as 64-bit integer. Usage : --->    IntVal = ByteConv%Pack_I64_Partial(ByteArr, Offset, Length) Note : Length must be between 1 and 7.","tags":"","loc":"module\\mclass_byteconverter.html"},{"title":"MClass_KomiHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the KomiHasher64 type and its related routines.\n  The KomiHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The KomiHasher64 type employs the Komi hash algorithm for 64-bit integer\n  output by Aleksey Vaneev [1].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] KOMIHASH - Very fast, high-quality\n      hash function, discrete-incremental and streamed hashing-capable (non-cryptographic,\n      in C) + PRNG. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: KomiHasher64 KomiHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Komi hash algorithm by Aleksey Vaneev. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Komi_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Komi_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Komi_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Komi_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Komi_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Komi_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Komi_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_komihasher64.html"},{"title":"MClass_BaseHasher – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BaseHasher type and its related routines.\n  The BaseHasher type is an abstract type representing a base type for\n  a hasher object, which is an incremental non-cryptographic hash function.\n  By design, it defines a somewhat incomplete application programming\n  interface (API) for some operations of an incremental hash function.\n  The Hasher32 type, which is an abstract type representing a 32-bit-integer hasher,\n  defines additional methods and completes the API of an incremental\n  32-bit-integer hash function.\n  Also, the Hasher64 type, which is an abstract type representing a 64-bit-integer hasher,\n  defines additional methods and completes the API of an incremental\n  64-bit-integer hash function.\n  All other (concrete) hasher types that implement specific hash functions\n  extend from either the Hasher32 type or the Hasher64 type. Uses MBase_ByteUtil MBase_Common Derived Types type, public :: BaseHasher BaseHasher is an abstract type representing a base hasher that\n defines an incomplete application programming interface (API)\n for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_basehasher.html"},{"title":"MClass_BmwS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BmwS type and its related routines.\n  The BmwS type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The BmwS type implements an incremental cryptographic hash function\n  by employing a Blue Midnight Wish (BMW) message-digest algorithm\n  (either the BMW-224 or the BMW-256 ) [1].  The implementation here\n  is based mainly on the SPHLIB implementation [2]. By default, the BmwS type employs the BMW-256 message-digest algorithm.  However, a user can specify the IsBMW224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the BMW-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The Blue Midnight Wish cryptographic hash function package submitted\n      to the second round of the NIST's SHA-3 hash competition. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: BmwS BmwS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BMW-224 or the BMW-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => BmwS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BMW-256). procedure, public :: Reset => BmwS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => BmwS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => BmwS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => BmwS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => BmwS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => BmwS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => BmwS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => BmwS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => BmwS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BMW-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the BMW-224 algorithm --->    CALL MD%Create(IsBMW224=.TRUE.)","tags":"","loc":"module\\mclass_bmws.html"},{"title":"MClass_MDHelper – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MDHelper type and its related routines.\n  The MDHelper type is an abstract digest type extending from the MDEngine type.  It is a helper type that implements the padding common to\n  MD4, MD5, and the SHA family.  The implementation works as long as\n  the internal block length is a power of 2, which is the case for all\n  these algorithms. REFERENCES : [1] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_ErrHandlers MBase_BytePack MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: MDHelper MDHelper is an abstract digest type acting as a helper by\n implementing the padding common to MD4, MD5, and the SHA family. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure(DEDigestLen), public, deferred :: GetDigestLen GetDigestLen is a binding name of the DEDigestLen deferred procedure. Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure(DEBlockLen), public, deferred :: GetBlockLen GetBlockLen is a binding name of the DEBlockLen deferred procedure. This procedure is NOT intended to be used by a user. procedure(DESetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the DESetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the DEProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEPadding), public, deferred :: DoPadding DoPadding is a binding name of the DEPadding deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEAddBitsNPad), public, deferred :: AddBitsNPad AddBitsNPad is a binding name of the DEAddBitsNPad deferred procedure. This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method.","tags":"","loc":"module\\mclass_mdhelper.html"},{"title":"MClass_WyHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the WyHasher64 type and its related routines.\n  The WyHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The WyHasher64 type employs the Wy hash algorithm for 64-bit integer\n  output by Wang Yi [1].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] WYHASH and WYRAND - The FASTEST\n      QUALITY hash function, random number generators (PRNG) and hash map. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: WyHasher64 WyHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the final version 3 of the Wy hash algorithm by Wang Yi. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Wy_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Wy_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Wy_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Wy_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Wy_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Wy_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Wy_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_wyhasher64.html"},{"title":"MClass_Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Hasher32 type and its related routines.\n  The Hasher32 type is an abstract type that extends from the BaseHasher type.  It represents a 32-bit integer hasher where additional methods,\n  specific for 32-bit integer hash functions, are defined to complete\n  the API for an incremental non-cryptographic hash function.  All\n  hashers that output a hash value as a 32-bit integer should extends\n  from this abstract type. USAGE : Although there are a number of methods provided, several of them are\n  intended for internal use (by developers).  Only five methods are\n  intentionally provided for users including: - the Initialize method that initializes the hasher, - the Update method that inputs data into the hasher, - the Finalize method that returns the hash value, - the GetName method that returns the hasher name, and - the HashDirect method that compute the hash value directly. The first three methods mentioned are provided for the incremental\n  hash computations where the Initialize method is first called\n  (once), the Update method is then called (many times), and the Finalize method is finally called (once). If the Update method is to be called only one time, then the HashDirect method (for non-incremental hash computations) should\n  be employed in place of those three methods. Uses MBase_Common MClass_BaseHasher Derived Types type, public, extends( BaseHasher ) :: Hasher32 Hasher32 is an abstract type representing a hasher that outputs the hash value\n as a 32-bit integer for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure(HS32Init), public, deferred :: Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure(HS32Final), public, deferred :: Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure(HS32Hash), public, deferred :: HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_hasher32.html"},{"title":"MClass_Murmur3Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Murmur3Hasher64 and Murmur3Hasher128 types and their\n  related routines.  The Murmur3Hasher64 type is a hasher type that extends directly\n  from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and outputs the\n  hash value as a 64-bit integer.  The Murmur3Hasher128 type is a hasher type that\n  extends from the Murmur3Hasher64 type and provides two additional methods (the Finalize128 and HashDirect128 methods) to output the hash value as a 128-bit\n  integer. Both hashers employ the Murmur3 hash algorithm by Austin Appleby [1, 2].  As hashers,\n  they can be used to compute the hash value incrementally.  They also provide a method\n  to compute the hash value directly (i.e. non-incrementally).  The following code snippet\n  shows a typical usage of the hashers. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) To compute the hash value as a 128-bit integer, simply replace the Finalize and HashDirect methods by the Finalize128 and HashDirect128 methods, respectively. REFERENCES : [1] SMHasher: a test suite designed to\n      test the distribution, collision, and performance properties of non-cryptographic\n      hash functions. [2] Zero-Allocation Hashing for Java. Uses MBase_SInt128 MClass_Hasher64 MBase_Common iso_c_binding Derived Types type, public, extends( Hasher64 ) :: Murmur3Hasher64 Murmur3Hasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Murmur3 hash algorithm by Austin Appleby. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Murmur3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. type, public, extends( Murmur3Hasher64 ) :: Murmur3Hasher128 Murmur3Hasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the Murmur3Hasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: GetName => Murmur3_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: Finalize128 => Murmur3_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() procedure, public :: HashDirect128 => Murmur3_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_murmur3hasher64.html"},{"title":"MClass_Shabal – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Shabal type and its related routines.\n  The Shabal type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Shabal type implements an incremental cryptographic hash\n  function by employing the Shabal message-digest algorithm [1].\n  The implementation here is mainly based on the references [2]. The Shabal type represents five cryptographic hash functions:\n  the Shabal-192 , Shabal-224 , Shabal-256 , Shabal-384 , and Shabal-512 hash functions.  By default, the Shabal type\n  represents the Shabal-256 hash function.  However, a user can\n  specify the Security argument (to one of the five applicable\n  values: 192, 224, 256, 384 and 512) when initializing the digest\n  object in order to use a different hash function and get a\n  different hash output size. REFERENCES : [1] SHABAL: A submission to NIST's Cryptographic Hash Algorithm Competition. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_Common MClass_BaseDigest MClass_MDEngine MBase_SIntUtil MBase_BytePack Derived Types type, public, extends( MDEngine ) :: Shabal Shabal is a concrete digest type that implements an incremental\n cryptographic hash function based on the Shabal hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => Shabal_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Shabal-256). procedure, public :: Reset => Shabal_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Shabal_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Shabal_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => Shabal_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => Shabal_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => Shabal_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Shabal_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => Shabal_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => Shabal_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Shabal-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Shabal-512 algorithm --->    CALL MD%Create(512)","tags":"","loc":"module\\mclass_shabal.html"},{"title":"MClass_ShaviteS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ShaviteS type and its related routines.\n  The ShaviteS type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The ShaviteS type implements an incremental cryptographic hash function\n  by employing a SHAvite-3 message-digest algorithm (either the SHAvite-224 or the SHAvite-256 ) [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the ShaviteS type employs the SHAvite-256 message-digest algorithm.  However, a user can specify the IsSHAvite224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SHAvite-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The SHAvite-3 hash function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: ShaviteS ShaviteS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SHAvite-224 or the SHAvite-256 message-digest algorithm. Finalizations Procedures final :: ShaviteS_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => ShaviteS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAvite-256). procedure, public :: Reset => ShaviteS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => ShaviteS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => ShaviteS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => ShaviteS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => ShaviteS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => ShaviteS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => ShaviteS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => ShaviteS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => ShaviteS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHAvite-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHAvite-224 algorithm --->    CALL MD%Create(IsSHAvite224=.TRUE.)","tags":"","loc":"module\\mclass_shavites.html"},{"title":"MClass_SHAKE – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHAKE type and its related routines.\n  The SHAKE type is a Keccak-based digest type that extends from\n  the KP1600Core type.  As a concrete derived type, it provides\n  all remaining deferred procedures required by all its parent types. Unlike the Keccak type, which produces a fixed-length hash output for the\n  specified strength of security, the SHAKE type allows an arbitrary\n  output length, which is useful in applications such as optimal\n  asymmetric encryption padding.  Similar to the Keccak type, the SHAKE type represents a family of incremental cryptographic hash\n  functions (two functions, exactly), rather than just one hash function. By default, the SHAKE type employs the SHAKE-128 hash function as\n  a default algorithm.  However, a user can specify the IsSHAKE256 flag to true when initializing the digest object (by calling the Create method) in order to use the SHAKE-256 hash function, in\n  place of the SHAKE-128 hash function.  As previously mentioned,\n  the SHAKE type is capable of producing variable-length hash output.\n  Therefore, a user can specify an output length through the optional OutputLen argument when initializing the digest object.  If the\n  optional argument is NOT present, the SHAKE type produces the hash\n  output length based on a default length for a specific algorithm.\n  In addition, a user may use the SHAKE type as an extendable-output\n  function (XOF) by specifying the hash output length during a finalization\n  of the digest object where the DigestWOutLen method is called.  This\n  method will ignore the output length specified during initialization if\n  the specified length is valid (greater than or equal to 1). REFERENCES : [1] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [2] The eXtended Keccak Code Package. Uses MClass_KP1600Core MBase_ByteUtil MBase_Common MClass_BaseDigest Derived Types type, public, extends( KP1600Core ) :: SHAKE SHAKE is a concrete Keccak-based digest type that implements an\n incremental cryptographic hash function by employing either the SHAKE-128 or the SHAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => SHAKE_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHAKE-128)\n and default hash output length. procedure, public :: GetClone => SHAKE_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHAKE_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! employ the default (SHAKE-256) algorithm and default output length --->    CALL MD%Create() ! employ the SHAKE-256 algorithm and default output length --->    CALL MD%Create(IsSHAKE256=.TRUE.) ! employ the SHAKE-128 algorithm with specified output length --->    CALL MD%Create(IsSHAKE256=.FALSE., OutputLen=64) ! employ the SHAKE-256 algorithm with specified output length --->    CALL MD%Create(IsSHAKE256=.TRUE., OutputLen=128) generic, public :: DigestWOutLen => SHAKE_ByteDigest_wOutLen, SHAKE_ByteDigest_wInputNOutLen, SHAKE_HexDigest_wOutLen, SHAKE_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) Important Note : If the specified output length is applicable, the output\n  length specified during initialization will be ignored.","tags":"","loc":"module\\mclass_shake.html"},{"title":"MClass_Blake2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake2B type and its related routines.\n  The Blake2B type is a digest type that directly extends from the Blake2Core type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Blake2B type implements an incremental cryptographic hash\n  function by employing the BLAKE2b message-digest algorithm, which\n  is optimized for 64-bit platforms and can produce the hash output of\n  any size between 1 and 64 bytes [1, 2].  The implementation here is\n  based mainly on the references [3, 4].  Unlike most of other digest types, the Blake2B type can perform keyed hashing providing that a\n  user specifies the key during an initialization of the digest object\n  by calling the CreateHMAC method instead of the Create method. REFERENCES : [1] J.P. Aumasson, W. Meier,\n      R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. [2] BLAKE2 - Fast Secure Hashing. [3] JBlake2: A pure Java\n      implementation of BLAKE2 (RFC 7693). [4] BLAKE2 official implementations. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_Blake2Core Derived Types type, public, extends( Blake2Core ) :: Blake2B Blake2B is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE2b message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC). Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: Initialize => Blake2B_InitDefault Use the Create method in place of the Initialize method to\n initialize the digest object with default hash output length. procedure, public :: Reset => Blake2B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Blake2B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Blake2B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: SetBufPtr => Blake2B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Blake2B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: EncodeOutput => Blake2B_EncodeOutput EncodeOutput is a procedure to encode the hash output. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitWOutLen Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object\n               (as a hasher). Usage : ! initialization with default output length --->    CALL MD%Create() ! initialization with specified output length generic, public :: CreateHMAC => InitWKey Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : ! initialization with default output length --->    CALL MD%CreateHMAC(Key) ! initialization with specified output length --->    CALL MD%CreateHMAC(Key, OutputLen)","tags":"","loc":"module\\mclass_blake2b.html"},{"title":"MClass_Blake2S – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake2S type and its related routines.\n  The Blake2S type is a digest type that directly extends from the Blake2Core type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Blake2S type implements an incremental cryptographic hash\n  function by employing the BLAKE2s message-digest algorithm,\n  which is optimized for 8-bit to 32-bit platforms and can produce\n  the hash output of any size between 1 and 32 bytes [1, 2].  The\n  implementation here is based mainly on the references [3, 4].\n  Unlike most of other digest types, the Blake2S type can\n  perform keyed hashing providing that a user specifies the key\n  during an initialization of the digest object by calling the CreateHMAC method instead of the Create method. REFERENCES : [1] J.P. Aumasson, W. Meier,\n      R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. [2] BLAKE2 - Fast Secure Hashing. [3] JBlake2: A pure Java\n      implementation of BLAKE2 (RFC 7693). [4] BLAKE2 official implementations. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_Blake2Core Derived Types type, public, extends( Blake2Core ) :: Blake2S Blake2S is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE2s message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC). Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => Blake2Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Blake2Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Blake2Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => Blake2Core_Init CoreInit is a procedure to initialize the Blake2Core's components. This procedure is NOT intended to be used by a user but all initialization procedures\n implemented by a concrete digest type should call this method. procedure, public :: CoreReset => Blake2Core_Reset CoreReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: CoreClone => Blake2Core_Clone CoreClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBufLen => Blake2Core_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: GetKeyLen => Blake2Core_KeyLen GetKeyLen is a procedure to get the length of the specified key. This procedure is NOT intended to be used by a user. procedure, public :: GetDigestLen => Blake2Core_DigestLen Type-Bound Function : GetDigestLen Purpose :  To return the hash output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: Initialize => Blake2S_InitDefault Use the Create method in place of the Initialize method to\n initialize the digest object with default hash output length. procedure, public :: Reset => Blake2S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Blake2S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Blake2S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: SetBufPtr => Blake2S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Blake2S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: EncodeOutput => Blake2S_EncodeOutput EncodeOutput is a procedure to encode the hash output. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitWOutLen Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object\n               (as a hasher). Usage : ! initialization with default output length --->    CALL MD%Create() ! initialization with specified output length generic, public :: CreateHMAC => InitWKey Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : ! initialization with default output length --->    CALL MD%CreateHMAC(Key) ! initialization with specified output length --->    CALL MD%CreateHMAC(Key, OutputLen)","tags":"","loc":"module\\mclass_blake2s.html"},{"title":"MClass_MD4 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MD4 type and its related routines.\n  The MD4 type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The MD4 type implements an incremental cryptographic hash\n  function by employing the MD4 message-digest algorithm [1]\n  where the algorithm is described in RFC 1320.  The implementation\n  here is mainly based on the SPHLIB implementation [2]. REFERENCES : [1] RFC1320:\n      The MD4 Message-Digest Algorithm. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: MD4 MD4 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD4 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => MD4_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. procedure, public :: Reset => MD4_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => MD4_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => MD4_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => MD4_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => MD4_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => MD4_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => MD4_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => MD4_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => MD4_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user.","tags":"","loc":"module\\mclass_md4.html"},{"title":"MClass_SipHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SipHasher64 type and its related routines.\n  The SipHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The SipHasher64 type employs the Sip hash algorithm for 64-bit integer\n  output by Jean-Philippe Aumasson [1].  As a hasher, it can be used to compute\n  the hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] SipHash: high-speed secure pseudorandom\n      function for short messages. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: SipHasher64 SipHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Sip hash algorithm by Jean-Philippe Aumasson. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Sip_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Sip_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Sip_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Sip_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Sip_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with default keys and rounds (i.e. Sip24). Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWKey => Sip_Initialize_wKey Type-Bound Subroutine : InitializeWKey Purpose :  To initialize the hasher with keys and optionally the number of rounds. Usage : ! hash value (with default rounds and sign) --->    CALL Hasher%InitializeWKey(Seed, Key) ! hash value with specified rounds --->    CALL Hasher%InitializeWKey(Seed, Key, cRound=1, dRound=3) ! hash value with specified remove sign flag --->    CALL Hasher%InitializeWKey(Seed, Key, RemoveSign=.TRUE.) procedure, public :: Finalize => Sip_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Sip_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally) with optional\n               seed and remove sign flag (and default key and number of rounds). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirectWKey => Sip_HashDirect_wKey Type-Bound Function : HashDirectWKey Purpose :  To compute the hash value directly with specified seed and keys\n               and optionally the number of rounds. Usage : --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key) --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, cRound=2, dRound=4) --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_siphasher64.html"},{"title":"MClass_SpookyHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SpookyHasher64 and SpookyHasher128 types and their\n  related routines.  The SpookyHasher64 type is a hasher type that extends directly\n  from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and outputs the\n  hash value as a 64-bit integer.  The SpookyHasher128 type is a hasher type that\n  extends from the SpookyHasher64 type and provides two additional methods (the Finalize128 and HashDirect128 methods) to output the hash value as a 128-bit\n  integer. Both hashers employ the Spooky hash algorithm by Bob Jenkins [1].  As hashers,\n  they can be used to compute the hash value incrementally.  They also provide a method\n  to compute the hash value directly (i.e. non-incrementally).  The following code snippet\n  shows a typical usage of the hashers. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) To compute the hash value as a 128-bit integer, simply replace the Finalize and HashDirect methods by the Finalize128 and HashDirect128 methods, respectively. REFERENCES : [1] SpookyHash: a 128-bit\n      non-cryptographic hash. Uses MBase_SInt128 MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: SpookyHasher64 SpookyHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the Spooky hash algorithm by Bob Jenkins. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Spooky_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Spooky_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Spooky_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Spooky_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Spooky_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSeeds => Spooky_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value procedure, public :: Finalize => Spooky_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Spooky_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. type, public, extends( SpookyHasher64 ) :: SpookyHasher128 SpookyHasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the SpookyHasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetBlockLength => Spooky_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Spooky_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Spooky_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Spooky_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSeeds => Spooky_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value procedure, public :: Finalize => Spooky_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Spooky_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: GetName => Spooky_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: Finalize128 => Spooky_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() procedure, public :: HashDirect128 => Spooky_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_spookyhasher64.html"},{"title":"MClass_SHA0 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHA0 type and its related routines.\n  The SHA0 type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SHA0 type implements an incremental cryptographic hash\n  function by employing the SHA-0 message-digest algorithm [1].\n  The implementation here is mainly based on the SPHLIB implementation [2]. REFERENCES : [1] Secure\n      Hash Algorithms. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: SHA0 SHA0 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the SHA-0 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => SHA0_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. procedure, public :: Reset => SHA0_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SHA0_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHA0_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SHA0_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SHA0_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SHA0_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SHA0_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SHA0_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SHA0_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user.","tags":"","loc":"module\\mclass_sha0.html"},{"title":"MClass_SHA2S – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHA2S type and its related routines.\n  The SHA2S type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SHA2S type implements an incremental cryptographic hash\n  function by employing the SHA-224 or SHA-256 message-digest algorithm where both algorithms are described in FIPS 180-4 [1].\n  The implementation here is mainly based on the references [2, 3]. By default, the SHA2S type employs the SHA-256 message-digest algorithm.  However, a user can specify the IsSHA224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SHA-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] FIPS PUB 180-4:\n      Secure Hash Standard (SHS). [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. [3] The Bouncy Castle Crypto\n      Package For Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: SHA2S SHA2B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either the SHA-224 or the SHA-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => SHA2S_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA-256). procedure, public :: Reset => SHA2S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SHA2S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHA2S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SHA2S_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SHA2S_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SHA2S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SHA2S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SHA2S_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SHA2S_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA-224 algorithm --->    CALL MD%Create(IsSHA224=.TRUE.)","tags":"","loc":"module\\mclass_sha2s.html"},{"title":"MClass_GroestlB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the GroestlB type and its related routines.\n  The GroestlB type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The GroestlB type implements an incremental cryptographic hash function\n  by employing either the Groestl-384 or the Groestl-512 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the GroestlB type employs the Groestl-512 message-digest algorithm.  However, a user can specify the IsGroestl384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the Groestl-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] Grostl - a SHA-3 candidate. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_Common MClass_GroestlS MClass_BaseDigest MClass_MDEngine MBase_BytePack Derived Types type, public, extends( MDEngine ) :: GroestlB GroestlB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the Groestl-384 or the Groestl-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => GroestlB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Groestl-512). procedure, public :: Reset => GroestlB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => GroestlB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => GroestlB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => GroestlB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => GroestlB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => GroestlB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => GroestlB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => GroestlB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => GroestlB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Groestl-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the Groestl-384 algorithm --->    CALL MD%Create(IsGroestl384=.TRUE.)","tags":"","loc":"module\\mclass_groestlb.html"},{"title":"MClass_FarmNaHasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the FarmNaHasher64 type and its related routines.\n  The FarmNaHasher64 type is a hasher type that extends directly from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and\n  outputs the hash value as a 64-bit integer. The FarmNaHasher64 type employs the FarmNa hash algorithm for 64-bit integer\n  output by Google Inc [1, 2].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] FarmHash: a family of hash functions. [2] Zero-Allocation Hashing for Java. Uses MClass_Hasher64 MBase_Common Derived Types type, public, extends( Hasher64 ) :: FarmNaHasher64 FarmNaHasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the FarmNa hash algorithm by Google Inc. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => FarmNa_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => FarmNa_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => FarmNa_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => FarmNa_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => FarmNa_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher with one seed. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSeeds => FarmNa_Initialize_WithSeeds Type-Bound Subroutine : InitializeWSeeds Purpose :  To initialize the hasher with two seeds. Usage : --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value procedure, public :: Finalize => FarmNa_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => FarmNa_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally)\n               without seed or with one seed. Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirectWSeeds => FarmNa_HashDirect_WithSeeds Type-Bound Function : HashDirectWSeeds Purpose :  To compute the hash value directly (non-incrementally)\n               with two seeds. Usage : --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_farmnahasher64.html"},{"title":"MClass_XXHasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the XXHasher32 type and its related routines.\n  The XXHasher32 type is a hasher type that extends directly from the Hasher32 type.\n  It provides all deferred procedures required by a Hasher32 class and\n  outputs the hash value as a 32-bit integer. The XXHasher32 type employs the XX hash algorithm for 32-bit integer\n  output by Yann Collet [1].  As a hasher, it can be used to compute the\n  hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] xxHash: Extremely fast hash algorithm. Uses MBase_Common MClass_Hasher32 Derived Types type, public, extends( Hasher32 ) :: XXHasher32 XXHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the XX hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => XX_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => XX_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => XX_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => XX_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => XX_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => XX_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => XX_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_xxhasher32.html"},{"title":"MClass_MD5 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MD5 type and its related routines.\n  The MD5 type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The MD5 type implements an incremental cryptographic hash\n  function by employing the MD5 message-digest algorithm where\n  the algorithm is described in RFC 1321 [1].  The implementation\n  here is mainly based on the SPHLIB implementation [2]. REFERENCES : [1] RFC1321:\n      The MD5 Message-Digest Algorithm. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: MD5 MD5 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the MD5 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => MD5_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. procedure, public :: Reset => MD5_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => MD5_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => MD5_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => MD5_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => MD5_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => MD5_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => MD5_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => MD5_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => MD5_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user.","tags":"","loc":"module\\mclass_md5.html"},{"title":"MClass_KP1600Sponge – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the KP1600Sponge type and its related routines.\n  The KP1600Sponge type is a derived type representing a sponge instance\n  for use with the so-called Keccak Sponge function.  It provides basic\n  operations of the Keccak-p[1600, nRound] message-digest algorithm, which\n  has the internal state size of 1600 bits.  The Keccak Sponge function,\n  the Sponge construction and other related information are described in\n  FIPS 202 [1].  The implementation here is mainly based on the eXtended\n  Keccak Code Package (XKCP) [2].  The KP1600Sponge type is provided\n  to help the development and implementation of the Keccak-based digest\n  types. REFERENCES : [1] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [2] The eXtended Keccak Code Package. Uses MBase_BytePack MBase_Common iso_c_binding MBase_UIntUtil Variables Type Visibility Attributes Name Initial integer(kind=kInt8), public, parameter :: SUCCESS = 0_kInt8 integer(kind=kInt8), public, parameter :: FAILURE = 1_kInt8 Derived Types type, public :: KP1600Sponge KP1600Sponge is a derived type representing a sponge instance for\n use with the Keccak Sponge functions.  It gathers the state processed\n by the permutation as well as the rate. Finalizations Procedures final :: KP1600Sponge_Finalize Type-Bound Procedures procedure, public :: Initialize => KP1600Sponge_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the Sponge instance. Usage : --->    CALL Instance%Initialize(Capacity, nRounds) procedure, public :: Absorb => KP1600Sponge_Absorb Type-Bound Function : Absorb Purpose :  To insert input data in bytes to be absorbed by Sponge instance. Usage : --->    Flag = Instance%Absorb(Input, InpSize) --->    IF (.NOT.Instance%Absorb(Input, InpSize)) DoSomething Note : Must call this method before calling either the AbsorbLastFewBits method or the Squeeze method. procedure, public :: AbsorbLastFewBits => KP1600Sponge_AbsorbLastFewBits Type-Bound Function : AbsorbLastFewBits Purpose :  To insert input data in bits to be absorbed by Sponge instance. Usage : --->    Flag = Instance%AbsorbLastFewBits(LastByte) --->    IF (.NOT.Instance%AbsorbLastFewBits(LastByte)) DoSomething Note : Must call this method only once and before calling the Squeeze method. procedure, public :: Permute => KP1600Sponge_Permute Type-Bound Subroutine : Permute Purpose :  To perform a permutation of the state of the Sponge instance. Usage : --->    CALL Instance%Permute() procedure, public :: Squeeze => KP1600Sponge_Squeeze Type-Bound Function : Squeeze Purpose :  To retrieve output data from Sponge instance. Usage : --->    Flag = Instance%Squeeze(Output, OutSize) --->    IF (.NOT.Instance%Squeeze(Output, OutSize)) DoSomething procedure, public :: GetByteIOIndex => KP1600Sponge_GetByteIOIndex Type-Bound Function : GetByteIOIndex Purpose :  To get value of the ByteIOIndex component of the Sponge instance. Usage : --->    Index = Instance%GetByteIOIndex() procedure, public :: SetByteIOIndex => KP1600Sponge_SetByteIOIndex Type-Bound Subroutine : SetByteIOIndex Purpose :  To set value of the ByteIOIndex component of the Sponge instance. Usage : --->    CALL Instance%SetByteIOIndex(Index) procedure, public :: CopyState => KP1600Sponge_CopyState Type-Bound Subroutine : CopyState Purpose :  To copy the current state of the source instance. Usage : --->    CALL Src%CopyState(Dst)","tags":"","loc":"module\\mclass_kp1600sponge.html"},{"title":"MClass_BmwB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BmwB type and its related routines.\n  The BmwB type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The BmwB type implements an incremental cryptographic hash function\n  by employing a Blue Midnight Wish (BMW) message-digest algorithm\n  (either the BMW-384 or the BMW-512 ) [1].  The implementation here\n  is based mainly on the SPHLIB implementation [2]. By default, the BmwB type employs the BMW-512 message-digest algorithm.  However, a user can specify the IsBMW384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the BMW-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The Blue Midnight Wish cryptographic hash function package submitted\n      to the second round of the NIST's SHA-3 hash competition. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: BmwB BmwB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BMW-384 or the BMW-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => BmwB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BMW-512). procedure, public :: Reset => BmwB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => BmwB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => BmwB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => BmwB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => BmwB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => BmwB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => BmwB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => BmwB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => BmwB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BMW-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the BMW-384 algorithm --->    CALL MD%Create(IsBMW384=.TRUE.)","tags":"","loc":"module\\mclass_bmwb.html"},{"title":"MBase_OptimalHash32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains an optimal implementation of various non-cryptographic hash\n  function routines that output a hash value as a 32-bit integer.  The available\n  hash functions are a subset of those reference hash functions implemented in the ModBase_ReferenceHash32 module.\n  The API of these optimal routines are exactly the same as those reference routines. It should be noted that each optimal hash function routine is based on a benchmark\n  that compares performances of various possible implementations of the hash function\n  as provided in the ModBase_ExperimentalHash32 module.  It should also be noted that these so-called\n  optimal hash function routines may not actually be optimal for a particular user so\n  the user is highly encouraged to perform (by himself/herself) a benchmark of each\n  specific hash function routine in order to know which implementation is the best one\n  for a particular system (i.e. a combination of operating system, machine as well as\n  compiler used). REFERENCES : See the ModBase_ReferenceHash32 module for references of the available hash functions in this module. Uses MBase_ByteUtil MBase_Common iso_c_binding Interfaces interface public module function Lookup3_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function Murmur3_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the MurmurHash3 hash algorithm by Austin\n Appleby [1]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function City_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the City hash algorithm by Google Inc [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function FarmMk_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NM_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMx_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function XX_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function Water_Hash32_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code","tags":"","loc":"module\\mbase_optimalhash32.html"},{"title":"MClass_Blake1S – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake1S type and its related routines.\n  The Blake1S type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The Blake1S type implements an incremental cryptographic hash\n  function by employing either the BLAKE-224 or the BLAKE-256\n  message-digest algorithm where both algorithms are described in\n  the Hash Function BLAKE book [1].  The implementation here is\n  based mainly on the SPHLIB implementation [2]. By default, the Blake1S type employs the BLAKE-256 message-digest algorithm.  However, a user can specify the IsBLAKE224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the BLAKE-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] J.P. Aumasson, W. Meier,\n      R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: Blake1S Blake1S is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the BLAKE-224 or the BLAKE-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => Blake1S_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (BLAKE-256). procedure, public :: Reset => Blake1S_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Blake1S_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Blake1S_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => Blake1S_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => Blake1S_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => Blake1S_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => Blake1S_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => Blake1S_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => Blake1S_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (BLAKE-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the BLAKE-224 algorithm --->    CALL MD%Create(IsBLAKE224=.TRUE.)","tags":"","loc":"module\\mclass_blake1s.html"},{"title":"MClass_MDEngine – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MDEngine type and its related routines.\n  The MDEngine type is an abstract digest type extending directly\n  from the BaseDigest type.  It defines additional methods (most of which\n  is intended to be used internally) to provide an extended API for\n  an incremental cryptographic hash function. By design, the MDEngine type is intended to be used as a template\n  (a parent type) to implement a cryptographic hash function.  It takes\n  care some of the deferred procedures required by a digest object.\n  If practical, all other digest types that implement specific hash\n  functions should extend from this template type. Uses MBase_MemHandlers MBase_ByteUtil MBase_Common MClass_BaseDigest Variables Type Visibility Attributes Name Initial integer(kind=kInt8), public, parameter :: FByte00 = INT(Z'00', KIND=kInt8) integer(kind=kInt8), public, parameter :: FByte01 = INT(Z'01', KIND=kInt8) integer(kind=kInt8), public, parameter :: FByte80 = INT(Z'80', KIND=kInt8) integer(kind=kInt8), public, parameter :: FByteFF = INT(Z'FF', KIND=kInt8) Derived Types type, public, extends( BaseDigest ) :: MDEngine MDEngine is an abstract digest type provided to be a template\n (a parent class) for other digest types to implement incremental\n cryptographic hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure(DEDigestLen), public, deferred :: GetDigestLen GetDigestLen is a binding name of the DEDigestLen deferred procedure. Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure(DEBlockLen), public, deferred :: GetBlockLen GetBlockLen is a binding name of the DEBlockLen deferred procedure. This procedure is NOT intended to be used by a user. procedure(DESetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the DESetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the DEProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEPadding), public, deferred :: DoPadding DoPadding is a binding name of the DEPadding deferred procedure. This procedure is NOT intended to be used by a user. procedure(DEAddBitsNPad), public, deferred :: AddBitsNPad AddBitsNPad is a binding name of the DEAddBitsNPad deferred procedure. This procedure is intended to be used by a digest type that implements\n a hash function that is an entrant of the SHA-3 competition.  It is mainly\n used for a test purpose. procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_mdengine.html"},{"title":"MClass_NMHasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the NMHasher32 and NMxHasher32 types and their related\n  routines.  The NMHasher32 type is a hasher type that extends directly from the Hasher32 type.  It\n  provides all deferred procedures required by a Hasher32 class and outputs the\n  hash value as a 32-bit integer.  The NMxHasher32 type is a hasher type that\n  extends from the NMHasher32 type and overrides a couple of methods that require\n  different implementation from those of the NMHasher32 type. The NMHasher32 type employs the NM hash algorithm for 32-bit integer\n  output by James Z. M. Gao. [1] whereas the NMxHasher32 type employs the NMx hash algorithm, which is a variant of the NM hash algorithm.  As hashers, both\n  can be used to compute the hash value incrementally.  They also provide a method\n  to compute the hash value directly (i.e. non-incrementally).  The following code\n  snippet illustrates a typical usage of both hashers. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] NMHash32 Hash Functions. NMHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the NMx hash algorithm, which is a variant of the NM hash algorithm. Uses MBase_Common MClass_Hasher32 Derived Types type, public, extends( Hasher32 ) :: NMHasher32 NMHasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the NM hash algorithm by James Z. M. Gao. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => NM_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => NM_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => NM_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => NM_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => NM_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => NM_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => NM_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. type, public, extends( NMHasher32 ) :: NMxHasher32 Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetBlockLength => NM_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => NM_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => NM_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => NM_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: HashDirect => NM_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: GetName => NMx_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: Finalize => NMx_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize()","tags":"","loc":"module\\mclass_nmhasher32.html"},{"title":"MClass_Murmur3Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Murmur3Hasher32 type and its related routines.\n  The Murmur3Hasher32 type is a hasher type that extends directly from the Hasher32 type.\n  It provides all deferred procedures required by a Hasher32 class and\n  outputs the hash value as a 32-bit integer. The Murmur3Hasher32 type employs the Murmur3 hash algorithm for 32-bit\n  integer output by Austin Appleby [1].  As a hasher, it can be used to compute\n  the hash value incrementally.  It also provides a method to compute the hash\n  value directly (i.e. non-incrementally).  The following code snippet shows\n  a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] SMHasher: a test suite designed to\n      test the distribution, collision, and performance properties of non-cryptographic\n      hash functions. Uses MBase_Common MClass_Hasher32 Derived Types type, public, extends( Hasher32 ) :: Murmur3Hasher32 Murmur3Hasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the Murmur3 hash algorithm by Austin Appleby. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => Murmur3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => Murmur3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => Murmur3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => Murmur3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => Murmur3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: Finalize => Murmur3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => Murmur3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_murmur3hasher32.html"},{"title":"MClass_SIMDS – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SIMDS type and its related routines.\n  The SIMDS type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SIMDS type implements an incremental cryptographic hash function\n  by employing either the SIMD-224 or the SIMD-256 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the SIMDS type employs the SIMD-256 message-digest algorithm.  However, a user can specify the IsSIMD224 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SIMD-224 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The SIMD Hash Function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: MaskI8 = INT(Z'000000FF', KIND=kInt32) integer(kind=kInt32), public, parameter :: MaskI16 = INT(Z'0000FFFF', KIND=kInt32) integer(kind=kInt32), public, parameter :: AlphaTab (0:255) = [1, 41, 139, 45, 46, 87, 226, 14, 60, 147, 116, 130, 190, 80, 196, 69, 2, 82, 21, 90, 92, 174, 195, 28, 120, 37, 232, 3, 123, 160, 135, 138, 4, 164, 42, 180, 184, 91, 133, 56, 240, 74, 207, 6, 246, 63, 13, 19, 8, 71, 84, 103, 111, 182, 9, 112, 223, 148, 157, 12, 235, 126, 26, 38, 16, 142, 168, 206, 222, 107, 18, 224, 189, 39, 57, 24, 213, 252, 52, 76, 32, 27, 79, 155, 187, 214, 36, 191, 121, 78, 114, 48, 169, 247, 104, 152, 64, 54, 158, 53, 117, 171, 72, 125, 242, 156, 228, 96, 81, 237, 208, 47, 128, 108, 59, 106, 234, 85, 144, 250, 227, 55, 199, 192, 162, 217, 159, 94, 256, 216, 118, 212, 211, 170, 31, 243, 197, 110, 141, 127, 67, 177, 61, 188, 255, 175, 236, 167, 165, 83, 62, 229, 137, 220, 25, 254, 134, 97, 122, 119, 253, 93, 215, 77, 73, 166, 124, 201, 17, 183, 50, 251, 11, 194, 244, 238, 249, 186, 173, 154, 146, 75, 248, 145, 34, 109, 100, 245, 22, 131, 231, 219, 241, 115, 89, 51, 35, 150, 239, 33, 68, 218, 200, 233, 44, 5, 205, 181, 225, 230, 178, 102, 70, 43, 221, 66, 136, 179, 143, 209, 88, 10, 153, 105, 193, 203, 99, 204, 140, 86, 185, 132, 15, 101, 29, 161, 176, 20, 49, 210, 129, 149, 198, 151, 23, 172, 113, 7, 30, 202, 58, 65, 95, 40, 98, 163] Derived Types type, public, extends( MDEngine ) :: SIMDS SIMDS is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SIMD-224 or the SIMD-256 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => SIMDS_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SIMD-256). procedure, public :: Reset => SIMDS_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SIMDS_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SIMDS_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SIMDS_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SIMDS_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SIMDS_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SIMDS_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SIMDS_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SIMDS_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SIMD-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the SIMD-224 algorithm --->    CALL MD%Create(IsSIMD224=.TRUE.)","tags":"","loc":"module\\mclass_simds.html"},{"title":"MClass_Blake3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Blake3 type and its related routines.\n  The Blake3 type is a digest type extending directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. The Blake3 type implements an incremental cryptographic hash function\n  by employing the BLAKE3 message-digest algorithm [1].  The implementation\n  here is based mainly on the official implementation in C [2]. Similar to the Blake2-based digest types, the Blake3 type can perform\n  keyed hashing providing that a user specifies the key during an initialization\n  of the digest object by calling the CreateHMAC method in place of the Create method.  In addition, the Blake3 type can be used as a key derivative function\n  (KDF) by specifying the context string during an initialization of the digest\n  object with the CreateKDF method.  Furthermore, the Blake3 type can be used\n  as an extendable-output function (XOF) by specifying the hash output length\n  during a finalization of the digest object where the DigestWOutLen method\n  is called. REFERENCES : [1] The BLAKE3 paper:\n      specifications, analysis, and design rationale. [2] Blake3: The official Rust\n      and C implementations of BLAKE3 cryptographic hash function. Uses MBase_ByteUtil MBase_Common MClass_BaseDigest MBase_MemHandlers MBase_BytePack iso_c_binding Derived Types type, public, extends( BaseDigest ) :: Blake3 Blake3 is a concrete digest type that implements an incremental cryptographic\n hash function by employing the BLAKE3 message-digest algorithm.  It can also be\n utilized as a hash-based message authentication code (HMAC).  It can be used as\n a key derivation function (KDF) as well.  In addition, it can be employed as an\n extendable-output function (XOF) to output the hash value with a desired length. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => Blake3_Initialize Use the Create method in place of the Initialize method to perform\n default initialization of the digest object. procedure, public :: GetClone => Blake3_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Blake3_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: Reset => Blake3_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => Blake3_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Blake3_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Blake3_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Blake3_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CreateHMAC => Blake3_InitHMAC Type-Bound Subroutine : CreateHMAC Purpose :  To perform any essential initialization of the digest object\n               as a HMAC object (for keyed hashing). Usage : --->    CALL MD%CreateHMAC(Key) procedure, public :: CreateKDF => Blake3_InitKDF Type-Bound Subroutine : CreateKDF Purpose :  To perform any essential initialization of the digest object\n               as a KDF object (for key derivation). Usage : --->    CALL MD%CreateKDF(ContextString) generic, public :: DigestWOutLen => Blake3_ByteDigest_wOutLen, Blake3_ByteDigest_wInputNOutLen, Blake3_HexDigest_wOutLen, Blake3_HexDigest_wInputNOutLen Type-Bound Subroutine : DigestWOutLen Purpose :  To finalize the current hash computation and return the hash output\n               with specified length.  The object is reset.  Some final input data\n               can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%DigestWOutLen(ByteArr, OutLen) ! insert final input and return hash output as a byte array --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(HexStr, OutLen) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen)","tags":"","loc":"module\\mclass_blake3.html"},{"title":"MClass_XX3Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the XX3Hasher64 and XX3Hasher128 types and their\n  related routines.  The XX3Hasher64 type is a hasher type that extends directly\n  from the Hasher64 type.\n  It provides all deferred procedures required by a Hasher64 class and outputs the\n  hash value as a 64-bit integer.  The XX3Hasher128 type is a hasher type that\n  extends from the XX3Hasher64 type and provides additional methods to output\n  the hash value as a 128-bit integer. Both hashers employ the XX3 hash algorithm by Yann Collet [1, 2].  As hashers,\n  they can be used to compute the hash value incrementally.  They also provide a\n  method to compute the hash value directly (i.e. non-incrementally).  The following\n  code snippet shows a typical usage of the hashers. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) To compute the hash value as a 128-bit integer, simply replace the Finalize and HashDirect methods by the Finalize128 and HashDirect128 methods, respectively. REFERENCES : [1] xxHash: Extremely fast hash algorithm. [2] Zero-Allocation Hashing for Java. Uses MBase_SInt128 MBase_Common MBase_UIntUtil MClass_Hasher64 MBase_SIntUtil Derived Types type, public, extends( Hasher64 ) :: XX3Hasher64 XX3Hasher64 is a hasher type that outputs the hash value as a 64-bit integer.\n It employs the XX3 hash algorithm by Yann Collet. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => XX3_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => XX3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => XX3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => XX3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => XX3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSecret => XX3_Initialize_wSecret Type-Bound Subroutine : InitializeWSecret Purpose :  To initialize the hasher with specified secret. Usage : --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value procedure, public :: Finalize => XX3_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => XX3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirectWSecret => XX3_HashDirect_wSecret Type-Bound Function : HashDirectWSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. type, public, extends( XX3Hasher64 ) :: XX3Hasher128 XX3Hasher128 is a hasher type that outputs the hash value as a 128-bit integer.\n It is a subtype of the XX3Hasher64 type. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetBlockLength => XX3_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => XX3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => XX3_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => XX3_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWSecret => XX3_Initialize_wSecret Type-Bound Subroutine : InitializeWSecret Purpose :  To initialize the hasher with specified secret. Usage : --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value procedure, public :: HashDirect => XX3_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirectWSecret => XX3_HashDirect_wSecret Type-Bound Function : HashDirectWSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: GetName => XX3_GetName128 Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: Finalize => XX3_Finalize64 Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: Finalize128 => XX3_Finalize128 Type-Bound Function : Finalize128 Purpose :  To finalize the current hash computation and return the hash value\n               in a 128-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize128() procedure, public :: HashDirect128 => XX3_HashDirect128 Type-Bound Function : HashDirect128 Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect128(Input, InpSize) --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input. procedure, public :: HashDirect128WSecret => XX3_HashDirect128_wSecret Type-Bound Function : HashDirect128WSecret Purpose :  To compute the hash value directly with specified seed and secret. Usage : --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret) --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_xx3hasher64.html"},{"title":"MBase_ReferenceHash32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains a reference implementation of various non-cryptographic\n  hash function routines that output a hash value as a 32-bit integer.  The API\n  of these hash function routines are mostly similar to that of routines in the ModBase_SimpleHash32 module.  The main difference between routines in these two modules is that routines\n  in the ModBase_SimpleHash32 module process input data one byte at a time whereas\n  routines in this module commonly process input data several/many bytes at a time.\n  Also, routines in this module are somewhat more complicated than those in the ModBase_SimpleHash32 module. Similar to those routines in the ModBase_SimpleHash32 module, all routines can\n  be used for an input (i.e. a key) of any type and rank providing that the size of\n  the input (in bytes) is known at compile time.  All routines can be used for a\n  continued hashing by providing the previously computed hash value as an (optional)\n  input argument (i.e. the StartHash argument).  Optionally, a user can specify\n  whether to return only positive value of the hash code.  This is particularly\n  useful when used in conjunction with a hash table. REFERENCES : [1] SMHasher: a test suite designed to\n      test the distribution, collision, and performance properties of non-cryptographic\n      hash functions. [2] Lookup 3 Hash Function: C Code. [3] CityHash: a family of hash functions\n      for strings. [4] FarmHash: a family of hash functions. [5] Hash functions by Paul Hsieh. [6] Fortran Standard Library. [7] NMHash32 Hash Functions. [8] xxHash: Extremely fast hash algorithm. [9] HashLand: a collection of hash\n      functions in Go. [10] FastHash by Zilong Tan. [11] WaterHash: A variant of WyHash. [12] SipHash: high-speed secure pseudorandom\n      function for short messages. Uses MBase_Common Interfaces interface public module function Lookup3Hash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function Murmur3Hash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the Murmur3 hash algorithm by Austin Appleby [1]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function CityHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the City hash algorithm by Google Inc [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function FarmMkHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Note : The working routine of this procedure is a non-recursive one. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function FarmMkHash_I32_Recur(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. Note : The working routine of this procedure is a recursive one. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function SuperFastHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the SuperFast hash algorithm by Paul\n Hsieh [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMHash_V1_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 1 of the NMHASH hash algorithm\n by James Z. M. Gao [6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMxHash_V1_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 1 of the NMxHASH hash algorithm by\n James Z. M. Gao [6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMHash_V2_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMHASH hash algorithm\n by James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function NMxHash_V2_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using version 2 of the NMxHASH hash algorithm by\n James Z. M. Gao [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function XXHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function CrapWowHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the CrapWow hash algorithm [9]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function FastHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the Fast hash algorithm by\n Zilong Tan [10]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function WaterHash_I32(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using the WaterHash hash algorithm by Tommy\n Ettinger [6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function WaterHash_I32_New(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute the hash value using a new version of the WaterHash hash\n algorithm by Tommy Ettinger [11]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function HalfSipHash24_I32(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) To compute the hash value using the HalfSipHash24 hash algorithm by\n Jean-Philippe Aumasson [12]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (:) key (at least 8 bytes) integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt32) hash code interface public module function HalfSipHash_I32(Input, InpSize, Key, cRound, dRound, StartHash, RemoveSign, HashLong) result(HashCode) To compute the hash value using the HalfSipHash hash algorithm by\n Jean-Philippe Aumasson [12] where the numbers of rounds are specified. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (:) key (at least 8 bytes) integer(kind=kInt32), intent(in) :: cRound number of C rounds integer(kind=kInt32), intent(in) :: dRound number of D rounds integer(kind=kInt32), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashLong long integer hash code Return Value integer(kind=kInt32) hash code","tags":"","loc":"module\\mbase_referencehash32.html"},{"title":"MClass_SIMDB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SIMDB type and its related routines.\n  The SIMDB type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SIMDB type implements an incremental cryptographic hash function\n  by employing either the SIMD-384 or the SIMD-512 message-digest algorithm [1].  The implementation here is based mainly on the SPHLIB implementation [2]. By default, the SIMDB type employs the SIMD-512 message-digest algorithm.  However, a user can specify the IsSIMD384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SIMD-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] The SIMD Hash Function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MClass_SIMDS MBase_Common MClass_BaseDigest MClass_MDEngine MBase_BytePack Derived Types type, public, extends( MDEngine ) :: SIMDB SIMDB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the SIMD-384 or the SIMD-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => SIMDB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SIMD-512). procedure, public :: Reset => SIMDB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SIMDB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SIMDB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SIMDB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SIMDB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SIMDB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SIMDB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SIMDB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SIMDB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SIMD-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SIMD-384 algorithm --->    CALL MD%Create(IsSIMD384=.TRUE.)","tags":"","loc":"module\\mclass_simdb.html"},{"title":"MClass_Hasher64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Hasher64 type and its related routines.\n  The Hasher64 type is an abstract type that extends from the BaseHasher type.  It represents a 64-bit integer hasher where additional methods,\n  specific for 64-bit integer hash functions, are defined to complete\n  the API for an incremental non-cryptographic hash function.  All\n  hashers that output a hash value as a 64-bit integer should extends\n  from this abstract type. USAGE : Although there are a number of methods provided, several of them are\n  intended for internal use (by developers).  Only five methods are\n  intentionally provided for users including: - the Initialize method that initializes the hasher, - the Update method that inputs data into the hasher, - the Finalize method that returns the hash value, - the GetName method that returns the hasher name, and - the HashDirect method that compute the hash value directly. The first three methods mentioned are provided for the incremental\n  hash computations where the Initialize method is first called\n  (once), the Update method is then called (many times), and the Finalize method is finally called (once). If the Update method is to be called only one time, then the HashDirect method (for non-incremental hash computations) should\n  be employed in place of those three methods. Uses MBase_Common MClass_BaseHasher Derived Types type, public, extends( BaseHasher ) :: Hasher64 Hasher64 is an abstract type representing a hasher that outputs the hash value\n as a 64-bit integer for an incremental non-cryptographic hash function. Type-Bound Procedures procedure(HSName), public, deferred :: GetName GetName is a binding name of the HSName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure(HSBlockLen), public, deferred :: GetBlockLength GetBlockLength is a binding name of the HSBlockLen deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSSetPtr), public, deferred :: SetBufPtr SetBufPtr is a binding name of the HSSetPtr deferred procedure. This procedure is NOT intended to be used by a user. procedure(HSProcess), public, deferred :: ProcessBlock ProcessBlock is a binding name of the HSProcess deferred procedure. This procedure is NOT intended to be used by a user. procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure(HS64Init), public, deferred :: Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure(HS64Final), public, deferred :: Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 64-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure(HS64Hash), public, deferred :: HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_hasher64.html"},{"title":"MBase_OptimalHash64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains an optimal implementation of various non-cryptographic hash\n  function routines that output a hash value as a 64-bit integer.  The available\n  hash functions are a subset of those reference hash functions implemented in the ModBase_ReferenceHash64 module.\n  The API of these optimal routines are exactly the same as those reference routines. It should be noted that each optimal hash function routine is based on a benchmark\n  that compares performances of various possible implementations of the hash function\n  as provided in the ModBase_ExperimentalHash64 module.  It should also be noted that these so-called\n  optimal hash function routines may not actually be optimal for a particular user so\n  the user is highly encouraged to perform (by himself/herself) a benchmark of each\n  specific hash function routine in order to know which implementation is the best one\n  for a particular system (i.e. a combination of operating system, machine as well as\n  compiler used). REFERENCES : See the ModBase_ReferenceHash64 module for references of the available hash functions in this module. Uses MBase_ByteUtil MBase_Common iso_c_binding Interfaces interface public module function Metro_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Murmur3_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, HashPair) result(HashCode) To compute hash code using the MurmurHash3 hash algorithm by Austin\n Appleby [1]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function Wy_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function WyF3_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XX_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the XXHash hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XX3_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Secret) result(HashCode) To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code interface public module function XX3_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, Secret, HashPair) result(HashCode) To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function City_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the CityHash hash algorithm by Google Inc [6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmNa_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmNaHash hash algorithm by Google Inc [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmUo_Hash64_Opt(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmUoHash hash algorithm by Google Inc [7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function Spooky_Hash128_Opt(Input, InpSize, StartHash, RemoveSign, Seed, HashPair) result(HashCode) To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function PengyV03_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function PengyV02_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Komi_Hash64_Opt(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code","tags":"","loc":"module\\mbase_optimalhash64.html"},{"title":"MClass_KP1600Core – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the KP1600Core type and its related routines.\n  The KP1600Core type is an abstract digest type extending directly\n  from the BaseDigest type.  It implements additional methods to provide an\n  extended API for an incremental cryptographic hash function.  Several\n  of these additional methods are the same as those methods defined by the MDEngine type. By design, the KP1600Core type is intended to be used as a parent\n  type for all Keccak-based digest types.  The KP1600Core type\n  provides an implementation of an incremental cryptographic hash function\n  by employing the Keccak message-digest algorithm with the internal\n  state size of 1600 bits (i.e. Keccak-p[1600, nRound]) [1].  It takes care\n  core operations (i.e. some of the deferred procedures and additional methods\n  provided) required by a Keccak-based digest object where its subtypes must\n  take care the remaining operations (i.e the rest of the deferred procedures).\n  The KP1600Core type utilizes the KP1600Sponge type, which provides all basic operations of the Keccak-p[1600, nRound] algorithm.  The implementation of the KP1600Sponge type is mainly based on the eXtended Keccak Code Package (XKCP) [2]. REFERENCES : [1] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [2] The eXtended Keccak Code Package. Uses MBase_ByteUtil MBase_Common MClass_KP1600Sponge MClass_BaseDigest MBase_MemHandlers Derived Types type, public, extends( BaseDigest ) :: KP1600Core KP1600Core is an abstract digest type provided to be a parent\n type for other Keccak-based digest types to implement incremental\n cryptographic hash functions. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Reset => KP1600Core_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: InsertBytes => KP1600Core_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => KP1600Core_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => KP1600Core_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: CoreInit => KP1600Core_Initialize CoreInit is a procedure to initialize components of the 'KP1600Core' object. This procedure is NOT intended to be used by a user but the Initialize method(s) implemented by a concrete digest type should call this method. procedure, public :: CopyState => KP1600Core_CopyState CopyState is a procedure to copy components of the source to the destination. This procedure is NOT intended to be used by a user but the GetClone method\n implemented by a concrete digest type should call this method. procedure, public :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen DoFinalWOutLen is a procedure to finalize the digest object with a specified\n hash output length. This procedure is NOT intended to be used by a user.  It is provided to aid the\n development and implementation of the Keccak-based digest types that can be\n used as an extendable-output function (XOF). procedure, public :: GetDigestLen => KP1600Core_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetSponge => KP1600Core_GetSponge Type-Bound Function : GetSponge Purpose :  To return a pointer to the sponge component of the digest object. Usage : --->    Instance => MD%GetSponge() generic, public :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits, KP1600Core_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_kp1600core.html"},{"title":"MClass_BaseDigest – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BaseDigest type and its related routines.\n  The BaseDigest type is an abstract type representing a base type for\n  a (message) digest object, which is an incremental cryptographic hash function.\n  The BaseDigest type defines an application programming interface (API)\n  for various common operations shared by most cryptographic hash functions.\n  Therefore, all (message) digest types should extend from this base type. Typically, a digest object maintains a running state for a hash computation.\n  Therefore, it must first be initialized via the Create method.  Then, input\n  data can be inserted (a number of times) into the digest object (which normally\n  stored in a buffer and/or processed if a buffer is fulled) by using the Update method.  Finally, the result can be obtained from the Digest method (where\n  some final data can be inserted as well). When a digest output has been produced, the digest object is automatically reset\n  to its initialized state, and can thus be used immediately for another digest\n  operation.  The state of a hash computation can be copied by using the GetClone method; this can be used to get a partial hash result without interrupting the\n  complete computation.  The new (clone) object evolves independently of the source\n  object. Uses MBase_ByteUtil MBase_Common Derived Types type, public :: BaseDigest BaseDigest is an abstract type representing a base type for a (Message) Digest object.  It defines an API for common operations\n of an incremental cryptographic hash function. Type-Bound Procedures procedure(MDCreate), public, deferred :: Initialize Initialize is a binding name of the MDCreate deferred procedure. Use the Create method in place of the Initialize method to perform\n any essential initialization of a digest object. procedure(MDReset), public, deferred :: Reset Reset is a binding name of the MDReset deferred procedure. Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure(MDClone), public, deferred :: GetClone GetClone is a binding name of the MDClone deferred procedure. Type-Bound Function : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure(MDName), public, deferred :: GetName GetName is a binding name of the MDName deferred procedure. Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure(MDInsertBytes), public, deferred :: InsertBytes InsertBytes is a binding name of the MDInsertBytes deferred procedure. Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure(MDInsertGen), public, deferred :: InsertGen InsertGen is a binding name of the MDInsertGen deferred procedure. Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure(MDByteDigest), public, deferred :: ByteDigest ByteDigest is a binding name of the MDByteDigest deferred procedure. Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure(MDByteDigestII), public, deferred :: ByteDigest_wInput ByteDigest_wInput is a binding name of the MDByteDigestII deferred procedure. Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr)","tags":"","loc":"module\\mclass_basedigest.html"},{"title":"MClass_Fugue – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Fugue type and its related routines.\n  The Fugue type is a digest type that extends directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. The Fugue type implements an incremental cryptographic hash\n  function by employing the Fugue message-digest algorithm [1].\n  The implementation here is mainly based on the references [2]. The Fugue type represents four cryptographic hash functions: the Fugue-224 , Fugue-256 , Fugue-384 , and Fugue-512 hash functions.\n  By default, the Fugue type represents the Fugue-256 hash function.\n  However, a user can specify the Security argument (to one of the\n  four applicable values: 224, 256, 384 and 512) when initializing the\n  digest object in order to use a different hash function and get a\n  different hash output size. REFERENCES : [1] The Hash Function \"Fugue\". [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_ByteUtil MBase_Common MClass_BaseDigest MBase_SIntUtil MBase_MemHandlers MBase_BytePack Derived Types type, public, extends( BaseDigest ) :: Fugue Fugue is a concrete digest type that implements an incremental\n cryptographic hash function based on the Fugue hash algorithms. Finalizations Procedures final :: Fugue_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => Fugue_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Fugue-256). procedure, public :: Reset => Fugue_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Fugue_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Fugue_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: InsertBytes => Fugue_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Fugue_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Fugue_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Fugue_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: GetDigestLen => Fugue_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Fugue-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Fugue-512 algorithm --->    CALL MD%Create(512) generic, public :: AddBitsNDigest => Fugue_ByteDigest_AddBits, Fugue_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_fugue.html"},{"title":"MClass_Skein – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Skein type and its related routines.\n  The Skein type is a digest type that extends directly from the BaseDigest type.  It implements all deferred procedures required by a digest type. The Skein type implements an incremental cryptographic hash\n  function by employing the Skein message-digest algorithm [1].\n  The implementation here is mainly based on the references [2]. The Skein type represents four cryptographic hash functions: the Skein-224 , Skein-256 , Skein-384 , and Skein-512 hash functions.\n  By default, the Skein type represents the Skein-256 hash function.\n  However, a user can specify the Security argument (to one of the\n  four applicable values: 224, 256, 384 and 512) when initializing the\n  digest object in order to use a different hash function and get a\n  different hash output size. REFERENCES : [1] The Skein Hash Function Family. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_ByteUtil MBase_Common MClass_BaseDigest MBase_SIntUtil MBase_MemHandlers MBase_BytePack Derived Types type, public, extends( BaseDigest ) :: Skein Skein is a concrete digest type that implements an incremental\n cryptographic hash function based on the Skein hash algorithms. Finalizations Procedures final :: Skein_Finalize Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: Initialize => Skein_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (Skein-256). procedure, public :: Reset => Skein_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => Skein_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => Skein_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: InsertBytes => Skein_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => Skein_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => Skein_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => Skein_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: GetDigestLen => Skein_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (Skein-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Skein-512 algorithm --->    CALL MD%Create(512) generic, public :: AddBitsNDigest => Skein_ByteDigest_AddBits, Skein_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose.","tags":"","loc":"module\\mclass_skein.html"},{"title":"MClass_EChoB – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the EChoB type and its related routines.\n  The EChoB type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The EChoB type implements an incremental cryptographic hash function\n  by employing either the ECHO-384 or the ECHO-512 algorithm [1].  The\n  implementation here is based mainly on the SPHLIB implementation [2]. By default, the EChoB type employs the ECHO-512 message-digest algorithm.  However, a user can specify the IsECHO384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the ECHO-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] ECHO hash function. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDEngine Derived Types type, public, extends( MDEngine ) :: EChoB EChoB is a concrete digest type that implements an\n incremental cryptographic hash function by employing either\n the ECHO-384 or the ECHO-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => EChoB_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (ECHO-512). procedure, public :: Reset => EChoB_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => EChoB_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => EChoB_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => EChoB_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => EChoB_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => EChoB_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => EChoB_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => EChoB_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => EChoB_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (ECHO-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the ECHO-384 algorithm --->    CALL MD%Create(IsECHO384=.TRUE.)","tags":"","loc":"module\\mclass_echob.html"},{"title":"MClass_HalfSip24Hasher32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HalfSip24Hasher32 type and its related routines.\n  The HalfSip24Hasher32 type is a hasher type that extends directly from the Hasher32 type.\n  It provides all deferred procedures required by a Hasher32 class and\n  outputs the hash value as a 32-bit integer. The HalfSip24Hasher32 type employs the HalfSip24 hash algorithm for\n  32-bit integer output by Jean-Philippe Aumasson [1].  As a hasher, it can be\n  used to compute the hash value incrementally.  It also provides a method to\n  compute the hash value directly (i.e. non-incrementally).  The following code\n  snippet illustrates a typical usage of the hasher. ! first, initialize the hasher (once)\n  CALL Hasher%Initialize(Seed)\n  ! then, put data into the hasher (a number of times)\n  CALL Hasher%Update(Input, InpSize)\n              ...\n              ...\n              ...\n  ! finally, get the hash value from the hasher (once)\n  HashCode = Hasher%Finalize() However, if the Update method is to be called only one time, then the HashDirect method should be employed as follows. ! directly compute the hash value\n  HashCode = Hasher%HashDirect(Input, InpSize, Seed) REFERENCES : [1] SipHash: high-speed secure pseudorandom\n      function for short messages. Uses MBase_Common MClass_Hasher32 Derived Types type, public, extends( Hasher32 ) :: HalfSip24Hasher32 HalfSip24Hasher32 is a hasher type that outputs the hash value as a 32-bit integer.\n It employs the HalfSip24 hash algorithm by Jean-Philippe Aumasson. Type-Bound Procedures procedure, public :: Reset => HS_Reset Reset is a procedure to reset components of the hasher to their initial values. This procedure is NOT intended to be used by a user. procedure, public :: GetBlockCount => HS_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => HS_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. procedure, public :: Update => HS_Update Type-Bound Subroutine : Update Purpose :  To insert input data into the hasher (i.e. temporarily stored in the\n               buffer array) and process block(s) of data if necessary. Usage : --->    CALL Hasher%Update(Input, InpSize) Important Note : The specified input can be any type and any rank where\n              its size is the number of bytes of storage used by the input. procedure, public :: GetName => HalfSip24_GetName Type-Bound Function : GetName Purpose :  To get the name of the hasher. Usage : --->    Name = Hasher%GetName() procedure, public :: GetBlockLength => HalfSip24_BlockLength GetBlockLength is a procedure to return the block length of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: SetBufPtr => HalfSip24_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this hasher. This procedure is NOT intended to be used by a user. procedure, public :: ProcessBlock => HalfSip24_ProcessBlock ProcessBlock is a procedure to process one block of data for this hasher. This procedure is NOT intended to be used by a user. procedure, public :: Initialize => HalfSip24_Initialize Type-Bound Subroutine : Initialize Purpose :  To initialize the hasher. Usage : --->    CALL Hasher%Initialize(Seed)            ! hash value with sign --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value procedure, public :: InitializeWKey => HalfSip24_Initialize_wKey Type-Bound Subroutine : InitializeWKey Purpose :  To initialize the hasher with a key. Usage : --->    CALL Hasher%InitializeWKey(Seed, Key)           ! hash value with sign --->    CALL Hasher%InitializeWKey(Seed, Key, .TRUE.)   ! remove sign from hash value procedure, public :: Finalize => HalfSip24_Finalize Type-Bound Function : Finalize Purpose :  To finalize the current hash computation and return the hash value\n               in a 32-bit integer.  The object is reset. Usage : --->    HashCode = Hasher%Finalize() procedure, public :: HashDirect => HalfSip24_HashDirect Type-Bound Function : HashDirect Purpose :  To compute the hash value directly (non-incrementally). Usage : --->    HashCode = Hasher%HashDirect(Input, InpSize) --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) Note : The specified input can be any type and any rank where its size is\n           the number of bytes of storage used by the input.","tags":"","loc":"module\\mclass_halfsip24hasher32.html"},{"title":"MClass_SHA1 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHA1 type and its related routines.\n  The SHA1 type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SHA1 type implements an incremental cryptographic hash\n  function by employing the SHA-1 message-digest algorithm where\n  the algorithm is described in FIPS 180-4 [1]. The implementation\n  here is mainly based on the SPHLIB implementation [2]. REFERENCES : [1] FIPS PUB 180-4:\n      Secure Hash Standard (SHS). [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: SHA1 SHA1 is a concrete digest type that implements an\n incremental cryptographic hash function by employing\n the SHA-1 message-digest algorithm. Type-Bound Procedures generic, public :: Create => Initialize Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : --->    CALL MD%Create() generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => SHA1_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object before starting using it. procedure, public :: Reset => SHA1_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SHA1_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHA1_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SHA1_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SHA1_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SHA1_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SHA1_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SHA1_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SHA1_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user.","tags":"","loc":"module\\mclass_sha1.html"},{"title":"MClass_SHA2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHA2B type and its related routines.\n  The SHA2B type is a digest type that directly extends from the MDHelper type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SHA2B type implements an incremental cryptographic hash\n  function by employing the SHA-384 or SHA-512 message-digest algorithm where both algorithms are described in FIPS 180-4 [1].\n  The implementation here is mainly based on the references [2, 3]. By default, the SHA2B type employs the SHA-512 message-digest algorithm.  However, a user can specify the IsSHA384 flag to\n  true when initializing the digest object (by calling the Create method) in order to use the SHA-384 message-digest algorithm\n  instead of the default one. REFERENCES : [1] FIPS PUB 180-4:\n      Secure Hash Standard (SHS). [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. [3] The Bouncy Castle Crypto\n      Package For Java. Uses MBase_BytePack MClass_BaseDigest MBase_Common MClass_MDHelper Derived Types type, public, extends( MDHelper ) :: SHA2B SHA2B is a concrete digest type that implements an\n incremental cryptographic hash function by employing either the SHA-384 or the SHA-512 message-digest algorithm. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: HelperInit => MDHelper_Init HelperInit is a procedure to initialize components of the MDHelper type. This procedure is NOT intended to be used by a user but the Create method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperPadding => MDHelper_DoPadding HelperPadding is a procedure to perform padding required by the hash functions. This procedure is NOT intended to be used by a user but the DoPadding method\n implemented by a concrete digest type that extends from this type should\n call this method. procedure, public :: HelperReset => MDHelper_Reset HelperReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: HelperClone => MDHelper_Clone HelperClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: Initialize => SHA2B_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA-512). procedure, public :: Reset => SHA2B_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SHA2B_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHA2B_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SHA2B_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SHA2B_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SHA2B_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SHA2B_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SHA2B_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SHA2B_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWFlag Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA-512) algorithm --->    CALL MD%Create() ! initialize the object to employ the SHA-384 algorithm --->    CALL MD%Create(IsSHA384=.TRUE.)","tags":"","loc":"module\\mclass_sha2b.html"},{"title":"MBase_ReferenceHash64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains a reference implementation of various non-cryptographic\n  hash function routines that output a hash value as a 64-bit integer.  The API\n  of these hash function routines are mostly similar to that of routines in the ModBase_SimpleHash64 module.  The main difference between routines in these two modules is that routines\n  in the ModBase_SimpleHash64 module process input data one byte at a time whereas\n  routines in this module commonly process input data several/many bytes at a time.\n  Also, routines in this module are somewhat more complicated than those in the ModBase_SimpleHash64 module. Similar to those routines in the ModBase_SimpleHash64 module, all routines can\n  be used for an input (i.e. a key) of any type and rank providing that the size of\n  the input (in bytes) is known at compile time.  All routines can be used for a\n  continued hashing by providing the previously computed hash value as an (optional)\n  input argument (i.e. the StartHash argument).  Optionally, a user can specify\n  whether to return only positive value of the hash code.  This is particularly\n  useful when used in conjunction with a hash table. REFERENCES : [1] SMHasher: a test suite designed to\n      test the distribution, collision, and performance properties of non-cryptographic\n      hash functions. [2] MetroHash: Faster, Better\n      Hash Functions. [3] WYHASH and WYRAND - The FASTEST\n      QUALITY hash function, random number generators (PRNG) and hash map. [4] Zero-Allocation Hashing for Java. [5] xxHash: Extremely fast hash algorithm. [6] CityHash: a family of hash functions\n      for strings. [7] FarmHash: a family of hash functions. [8] SpookyHash: a 128-bit\n      non-cryptographic hash. [9] SMHasher by Reini Urban. [10] Fortran Standard Library. [11] SipHash: high-speed secure pseudorandom\n      function for short messages. [12] mx3: A bit mixer, pseudo random number\n      generator and a hash function. [13] KOMIHASH - Very fast, high-quality\n      hash function, discrete-incremental and streamed hashing-capable (non-cryptographic,\n      in C) + PRNG. [14] MIR Project: A lightweight JIT compiler\n      based on MIR (Medium Internal Representation) and C11 JIT compiler and interpreter\n      based on MIR. [15] MumHash: Hashing functions and\n      PRNGs based on them. [15] PengyHash: Fast 64-bit\n      non-cryptographic function. Uses MBase_Common MClass_ByteConverter Interfaces interface public module function MetroHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the MetroHash64 hash algorithm by J. Andrew\n Rogers [2, 4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Murmur3Hash_I128(Input, InpSize, StartHash, RemoveSign, HashPair) result(HashCode) To compute hash code using the Murmur3 hash algorithm by Austin Appleby [1, 4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function WyHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using version 3 (?) of the WyHash hash algorithm by\n Wang Yi [3, 4]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function WyHash_F3_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the final version 3 of the WyHash hash algorithm\n by Wang Yi [3]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XXHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the XXHash hash algorithm by Yann Collet [4, 5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function XX3Hash_I64(Input, InpSize, StartHash, RemoveSign, Secret) result(HashCode) To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [4, 5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret Return Value integer(kind=kInt64) hash code interface public module function XX3Hash_I128(Input, InpSize, StartHash, RemoveSign, Secret, HashPair) result(HashCode) To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [4, 5]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt8), intent(in), optional :: Secret (:) a byte (8-bit integer) array (of at least 192 bytes) representing\n a custom secret integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function CityHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the CityHash hash algorithm by Google Inc [4, 6]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmNaHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmNaHash hash algorithm by Google Inc [4, 7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function FarmUoHash_I64(Input, InpSize, StartHash, RemoveSign, Seed) result(HashCode) To compute hash code using the FarmUoHash hash algorithm by Google Inc [4, 7]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed Return Value integer(kind=kInt64) hash code interface public module function SpookyHash_I128(Input, InpSize, StartHash, RemoveSign, Seed, HashPair) result(HashCode) To compute hash code using version 2 of the SpookyHash hash algorithm\n by Bob Jenkins [8]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(in), optional :: Seed optional seed integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code interface public module function PengyHash_V03_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.3) by\n Alberto Fajardo [15]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function PengyHash_V02_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the PengyHash hash algorithm (v0.2) by\n Alberto Fajardo [9, 10]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function SipHash24_I64(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) To compute hash code using the SipHash24 hash algorithm by Jean-Philippe\n Aumasson [11]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function TSipHash_I64(Input, InpSize, Key, StartHash, RemoveSign) result(HashCode) To compute hash code using the TSipHash hash algorithm (a variant of SipHash)\n from SMHasher [9]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function Mx3Hash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the Mx3Hash hash algorithm by Jon Maiga [12]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function KomiHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function MirHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the MirHash hash algorithm by Vladimir Makarov [9, 14]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function MumHash_I64(Input, InpSize, StartHash, RemoveSign) result(HashCode) To compute hash code using the MumHash hash algorithm by Vladimir Makarov [9, 15]. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. Return Value integer(kind=kInt64) hash code interface public module function SipHash_I128(Input, InpSize, Key, cRound, dRound, StartHash, RemoveSign, HashPair) result(HashCode) To compute hash code using the SipHash24 hash algorithm by Jean-Philippe\n Aumasson [11] where the numbers of rounds are specified. Arguments Type Intent Optional Attributes Name type(*), intent(in), CONTIGUOUS :: Input (..) input (any type and rank) integer(kind=kInt32), intent(in) :: InpSize size of the input (in bytes) integer(kind=kInt8), intent(in) :: Key (0:15) key bytes integer(kind=kInt32), intent(in) :: cRound integer(kind=kInt32), intent(in) :: dRound integer(kind=kInt64), intent(in), optional :: StartHash optional starting hash for continued hashing logical, intent(in), optional :: RemoveSign flag indicating whether to remove sign bit or not. - If true, always returns a positive value of the hash code. - If false, returns either a positive or negative value of the hash code. - default is false. integer(kind=kInt64), intent(out), optional :: HashPair (2) dual (128-bit) hash codes Return Value integer(kind=kInt64) single (64-bit) hash code","tags":"","loc":"module\\mbase_referencehash64.html"},{"title":"MClass_SHA3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SHA3 type and its related routines.\n  The SHA3 type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The SHA3 type implements an incremental cryptographic hash\n  function by employing the Keccak message-digest algorithm [1, 2].\n  The implementation here is mainly based on the references [3, 4]. Unlike other digest types, which represent one or two hash functions,\n  the SHA3 type represents eight cryptographic hash functions; four of\n  which are in the so-called SHA-3 family while the rest are in the\n  so-called Keccak family.  These two families of hash functions employ\n  the same Keccak message-digest algorithm; however, they use different\n  padding strategies. As the name suggested, the SHA3 type represents the SHA-3 family\n  by default.  However, a user can specify the IsKeccak flag to true\n  when initializing the digest object (by calling the Create method)\n  in order to use the padding strategy of the Keccak family.  Also,\n  the SHA3 type employs the SHA3-256 hash function as a default\n  algorithm.  This implies that the hash output has the output size\n  and the strength of security (against pre-image attack) of 256 bits.\n  The user can also specify the Security argument (to one of the four\n  applicable values: 224, 256, 384 and 512) when initializing the digest\n  object in order to use a different algorithm and get a different hash\n  output size. REFERENCES : [1] The Keccak Reference, Version 3.0. [2] SHA-3 Standard:\n      Permutation-Based Hash and Extendable-Output Functions. [3] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. [4] The Keccak Reference Implementation in C. Uses MBase_Common MClass_BaseDigest MClass_MDEngine MBase_SIntUtil MBase_BytePack Derived Types type, public, extends( MDEngine ) :: SHA3 SHA3 is a concrete digest type that implements an incremental\n cryptographic hash function based on the so-called Keccak hash\n functions, which is a family of message-digest algorithms. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => SHA3_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (SHA3-256). procedure, public :: Reset => SHA3_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => SHA3_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => SHA3_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => SHA3_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => SHA3_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => SHA3_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => SHA3_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => SHA3_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => SHA3_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWOption Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (SHA3-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the Keccak-256 algorithm --->    CALL MD%Create(IsKeccak=.TRUE.) ! initialize the object to employ the SHA3-384 algorithm --->    CALL MD%Create(IsKeccak=.FALSE., Security=384) ! initialize the object to employ the Keccak-512 algorithm --->    CALL MD%Create(IsKeccak=.TRUE., Security=512)","tags":"","loc":"module\\mclass_sha3.html"},{"title":"MClass_JHDigest – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the JHDigest type and its related routines.\n  The JHDigest type is a digest type that directly extends from the MDEngine type.  As a concrete derived type, it provides all remaining\n  deferred procedures required by all its abstract parent types. The JHDigest type implements an incremental cryptographic hash\n  function by employing the JH message-digest algorithm [1].  The\n  implementation here is mainly based on the references [2]. The JHDigest type represents four cryptographic hash functions:\n  the JH-224 , JH-256 , JH-384 , and JH-512 hash functions.  By\n  default, the JHDigest type represents the JH-256 hash function.\n  However, a user can specify the Security argument (to one of the\n  four applicable values: 224, 256, 384 and 512) when initializing the\n  digest object in order to use a different hash function and get a\n  different hash output size. REFERENCES : [1] Hash Function JH. [2] SPHLIB 3.0: A Set of\n      Implementations of Various Hash Functions, Both in C and in Java. Uses MBase_Common MClass_BaseDigest MClass_MDEngine MBase_SIntUtil MBase_BytePack Derived Types type, public, extends( MDEngine ) :: JHDigest JHDigest is a concrete digest type that implements an incremental\n cryptographic hash function based on the JH hash functions. Type-Bound Procedures generic, public :: Update => InsertBytes , InsertGen Type-Bound Subroutine : Update Purpose :  To insert input data into the digest object (commonly stored in a\n               buffer array) and process block(s) of data if necessary. Usage : ! insert input data in a generic way --->    CALL MD%Update(Input, InpSize) ! insert input data as an array of bytes (8-bit integers) --->    CALL MD%Update(ByteArr, Offset, Length) generic, public :: Digest => ByteDigest , ByteDigest_wInput , HexDigest, HexDigest_wInput Type-Bound Subroutine : Digest Purpose :  To finalize the current hash computation and return the hash output.\n               The object is reset.  Some final input data can be inserted. Usage : ! finalize hash computation and return hash output as a byte array --->    CALL MD%Digest(ByteArr) ! insert final input and return hash output as a byte array --->    CALL MD%Digest(Input, InpSize, ByteArr) ! finalize hash computation and return hash output as a hexadecimal string --->    CALL MD%Digest(HexStr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%Digest(Input, InpSize, HexStr) procedure, public :: InsertBytes => MDEngine_InsertBytes Use the Update method in place of the InsertBytes method to insert input\n data as an array of bytes (8-bit integers) where the offset (zero-based) into\n the array and the length of the input in bytes are specified. procedure, public :: InsertGen => MDEngine_InsertGen Use the Update method in place of the InsertGen method to insert\n input data in a generic way where the Input argument can be any type and\n any rank and the InpSize argument specifies the size of input data in bytes. procedure, public :: ByteDigest => MDEngine_ByteDigest Use the Digest method in place of the ByteDigest method to finalize the\n current hash computation and return the hash value as an array of bytes\n in a newly-allocated array. procedure, public :: ByteDigest_wInput => MDEngine_ByteDigest_wInput Use the Digest method in place of the ByteDigest_wInput method to insert final\n input in a generic way and then finalize the current hash computation and return\n the hash value as an array of bytes in a newly-allocated array. procedure, public :: EngineReset => MDEngine_Reset EngineReset is a procedure to reset components of the digest to their initial values. This procedure is NOT intended to be used by a user but the Reset method implemented\n by a concrete digest type should call this method. procedure, public :: EngineClone => MDEngine_Clone EngineClone is a procedure to copy components of the source object to the destination one. This procedure is NOT intended to be used by a user but the GetClone method implemented\n by a concrete digest type should call this method. procedure, public :: GetBlockCount => MDEngine_BlockCount GetBlockCount is a procedure to get the number of blocks of input processed. This procedure is NOT intended to be used by a user. procedure, public :: GetBufLen => MDEngine_BufLen GetBufLen is a procedure to get the number of bytes of input currently\n stored in the buffer. This procedure is NOT intended to be used by a user. generic, public :: AddBitsNDigest => MDEngine_ByteDigest_AddBits, MDEngine_HexDigest_AddBits Type-Bound Subroutine : AddBitsNDigest Purpose :  To add the last byte and then finalize the current hash computation\n               and return the hash output. The object is reset. Usage : ! insert final input and return hash output as a byte array --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) ! insert final input and return hash output as a hexadecimal string --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) Note : This method is only used for an input message whose bit length is not\n a multiple of eight (i.e. a message with partial bytes). The method is intended to be used by a digest type that implements a hash function\n that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. procedure, public :: Initialize => JHDigest_Initialize Use the Create method in place of the Initialize method to\n initialize the digest object with default algorithm (JH-256). procedure, public :: Reset => JHDigest_Reset Type-Bound Subroutine : Reset Purpose :  To reset the digest object to its initial state. Usage : --->    CALL MD%Reset() procedure, public :: GetClone => JHDigest_GetClone Type-Bound Subroutine : GetClone Purpose :  To clone the current state of the source object. The destination\n               object evolves independently of the source object. Usage : --->    CALL SrcMD%GetClone(DstMD) procedure, public :: GetName => JHDigest_GetName Type-Bound Function : GetName Purpose :  To get the name of the digest object. Usage : --->    Name = MD%GetName() procedure, public :: GetDigestLen => JHDigest_GetDigestLen Type-Bound Function : GetDigestLen Purpose :  To return the natural hash function output length (in bytes). Usage : --->    Length = MD%GetDigestLen() procedure, public :: GetBlockLen => JHDigest_GetBlockLen GetBlockLen is a procedure to return the block length of the digest. This method is NOT intended to be used by a user. procedure, public :: SetBufPtr => JHDigest_SetBufPtr SetBufPtr is a procedure to set a pointer to the buffer array of this digest. This method is NOT intended to be used by a user. procedure, public :: ProcessBlock => JHDigest_ProcessBlock ProcessBlock is a procedure to process one block of data for this digest. This method is NOT intended to be used by a user. procedure, public :: DoPadding => JHDigest_DoPadding DoPadding is a procedure to perform padding of the message for this digest. This method is NOT intended to be used by a user. procedure, public :: AddBitsNPad => JHDigest_AddBitsNPad AddBitsNPad is a procedure to add the final partial byte and then perform\n padding of the message for this digest. This method is NOT intended to be used by a user. generic, public :: Create => Initialize , InitializeWSecurity Type-Bound Subroutine : Create Purpose :  To perform any essential initialization of the digest object. Usage : ! initialize the object to employ the default (JH-256) algorithm --->    CALL MD%Create() ! initialize the object to employ the JH-512 algorithm --->    CALL MD%Create(512)","tags":"","loc":"module\\mclass_jhdigest.html"},{"title":"MClass_HamsiB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HamsiB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HamsiB* type and its related routines. !   The *HamsiB* type is a *digest* type that extends directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   The *HamsiB* type implements an incremental cryptographic hash function !   by employing either the *Hamsi-384* or the *Hamsi-512 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *HamsiB* type employs the *Hamsi-512 message-digest* !   algorithm.  However, a user can specify the *IsHamsi384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *Hamsi-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.esat.kuleuven.be/cosic/publications/article-1203.pdf\"> !       The Hash Function Hamsi. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : ByteUnpackBE USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: HamsiB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/HamsiB_Def Macro.f90\" !** MODULE PARAMETERS: #include    \"Includes/HamsiB_Constants.f90\" tByte , PARAMETER :: FByte00 = ToInt8 ( Z '00' ) tByte , PARAMETER :: FByte80 = ToInt8 ( Z '80' ) tByte , PARAMETER :: FByteFF = ToInt8 ( Z 'FF' ) tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: Alpha_N ( 0 : 31 ) = [ & ToInt32 ( Z 'FF00F0F0' ), ToInt32 ( Z 'CCCCAAAA' ), & ToInt32 ( Z 'F0F0CCCC' ), ToInt32 ( Z 'FF00AAAA' ), & ToInt32 ( Z 'CCCCAAAA' ), ToInt32 ( Z 'F0F0FF00' ), & ToInt32 ( Z 'AAAACCCC' ), ToInt32 ( Z 'F0F0FF00' ), & ToInt32 ( Z 'F0F0CCCC' ), ToInt32 ( Z 'AAAAFF00' ), & ToInt32 ( Z 'CCCCFF00' ), ToInt32 ( Z 'AAAAF0F0' ), & ToInt32 ( Z 'AAAAF0F0' ), ToInt32 ( Z 'FF00CCCC' ), & ToInt32 ( Z 'CCCCF0F0' ), ToInt32 ( Z 'FF00AAAA' ), & ToInt32 ( Z 'CCCCAAAA' ), ToInt32 ( Z 'FF00F0F0' ), & ToInt32 ( Z 'FF00AAAA' ), ToInt32 ( Z 'F0F0CCCC' ), & ToInt32 ( Z 'F0F0FF00' ), ToInt32 ( Z 'CCCCAAAA' ), & ToInt32 ( Z 'F0F0FF00' ), ToInt32 ( Z 'AAAACCCC' ), & ToInt32 ( Z 'AAAAFF00' ), ToInt32 ( Z 'F0F0CCCC' ), & ToInt32 ( Z 'AAAAF0F0' ), ToInt32 ( Z 'CCCCFF00' ), & ToInt32 ( Z 'FF00CCCC' ), ToInt32 ( Z 'AAAAF0F0' ), & ToInt32 ( Z 'FF00AAAA' ), ToInt32 ( Z 'CCCCF0F0' )] tInteger , PARAMETER :: Alpha_F ( 0 : 31 ) = [ & ToInt32 ( Z 'CAF9639C' ), ToInt32 ( Z '0FF0F9C0' ), & ToInt32 ( Z '639C0FF0' ), ToInt32 ( Z 'CAF9F9C0' ), & ToInt32 ( Z '0FF0F9C0' ), ToInt32 ( Z '639CCAF9' ), & ToInt32 ( Z 'F9C00FF0' ), ToInt32 ( Z '639CCAF9' ), & ToInt32 ( Z '639C0FF0' ), ToInt32 ( Z 'F9C0CAF9' ), & ToInt32 ( Z '0FF0CAF9' ), ToInt32 ( Z 'F9C0639C' ), & ToInt32 ( Z 'F9C0639C' ), ToInt32 ( Z 'CAF90FF0' ), & ToInt32 ( Z '0FF0639C' ), ToInt32 ( Z 'CAF9F9C0' ), & ToInt32 ( Z '0FF0F9C0' ), ToInt32 ( Z 'CAF9639C' ), & ToInt32 ( Z 'CAF9F9C0' ), ToInt32 ( Z '639C0FF0' ), & ToInt32 ( Z '639CCAF9' ), ToInt32 ( Z '0FF0F9C0' ), & ToInt32 ( Z '639CCAF9' ), ToInt32 ( Z 'F9C00FF0' ), & ToInt32 ( Z 'F9C0CAF9' ), ToInt32 ( Z '639C0FF0' ), & ToInt32 ( Z 'F9C0639C' ), ToInt32 ( Z '0FF0CAF9' ), & ToInt32 ( Z 'CAF90FF0' ), ToInt32 ( Z 'F9C0639C' ), & ToInt32 ( Z 'CAF9F9C0' ), ToInt32 ( Z '0FF0639C' )] tInteger , PARAMETER :: IV384 ( 0 : 15 ) = [ & ToInt32 ( Z '656B7472' ), ToInt32 ( Z '6F746563' ), & ToInt32 ( Z '686E6965' ), ToInt32 ( Z '6B2C2043' ), & ToInt32 ( Z '6F6D7075' ), ToInt32 ( Z '74657220' ), & ToInt32 ( Z '53656375' ), ToInt32 ( Z '72697479' ), & ToInt32 ( Z '20616E64' ), ToInt32 ( Z '20496E64' ), & ToInt32 ( Z '75737472' ), ToInt32 ( Z '69616C20' ), & ToInt32 ( Z '43727970' ), ToInt32 ( Z '746F6772' ), & ToInt32 ( Z '61706879' ), ToInt32 ( Z '2C204B61' )] tInteger , PARAMETER :: IV512 ( 0 : 15 ) = [ & ToInt32 ( Z '73746565' ), ToInt32 ( Z '6C706172' ), & ToInt32 ( Z '6B204172' ), ToInt32 ( Z '656E6265' ), & ToInt32 ( Z '72672031' ), ToInt32 ( Z '302C2062' ), & ToInt32 ( Z '75732032' ), ToInt32 ( Z '3434362C' ), & ToInt32 ( Z '20422D33' ), ToInt32 ( Z '30303120' ), & ToInt32 ( Z '4C657576' ), ToInt32 ( Z '656E2D48' ), & ToInt32 ( Z '65766572' ), ToInt32 ( Z '6C65652C' ), & ToInt32 ( Z '2042656C' ), ToInt32 ( Z '6769756D' )] !** DERIVED TYPE DEFINITIONS !> *HamsiB* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Hamsi hash algorithms. TYPE , EXTENDS ( BaseDigest ) :: HamsiB PRIVATE !% state tInteger :: State ( 0 : 15 ) = IV512 ( 0 : 15 ) !% buffer tByte :: Partial ( 0 : 7 ) = 0_kInt8 !% number of bytes used in the buffer tIndex :: PartialLen = 0_kIndex !% bit count tLong :: BitCount = 0_kInt64 !% flag indicating whether the Hamsi-384 algorithm is employed or not. tLogical :: IsHamsi384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: HamsiB_ByteDigest_AddBits PROCEDURE , PRIVATE :: HamsiB_HexDigest_AddBits !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => HamsiB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (HamsiB-512). PROCEDURE :: Initialize => HamsiB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => HamsiB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => HamsiB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => HamsiB_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => HamsiB_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => HamsiB_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => HamsiB_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => HamsiB_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => HamsiB_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Hamsi-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Hamsi-384 algorithm <br> !   --->    CALL MD%Create(IsHamsi384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => HamsiB_ByteDigest_AddBits , & HamsiB_HexDigest_AddBits ! --------------------------------------------------------------------- END TYPE HamsiB !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE HamsiB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the Hamsi-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE HamsiB_Initialize !****************************************************************************** SUBROUTINE HamsiB_Initialize_wFlag ( MD , IsHamsi384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object tLogical , INTENT ( IN ) :: IsHamsi384 !&#94; flag indicating whether the Hamsi-384 algorithm is employed or not. <br> !  - If true, use the Hamsi-384 algorithm. <br> !  - Otherwise, use the Hamsi-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsHamsi384 = IsHamsi384 CALL MD % Reset () RETURN END SUBROUTINE HamsiB_Initialize_wFlag !****************************************************************************** SUBROUTINE HamsiB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi384 ) THEN MD % State = IV384 ELSE MD % State = IV512 END IF MD % BitCount = 0_kInt64 MD % Partial = 0_kInt8 MD % PartialLen = 0_kIndex RETURN END SUBROUTINE HamsiB_Reset !****************************************************************************** SUBROUTINE HamsiB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( HamsiB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( HamsiB ) CALL Dst % Create ( Src % IsHamsi384 ) Dst % State = Src % State Dst % BitCount = Src % BitCount Dst % Partial = Src % Partial Dst % PartialLen = Src % PartialLen END SELECT RETURN END SUBROUTINE HamsiB_GetClone !****************************************************************************** FUNCTION HamsiB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( IN ) :: MD !! 'HamsiB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi384 ) THEN Name = 'Hamsi-384' ELSE Name = 'Hamsi-512' END IF RETURN END FUNCTION HamsiB_GetName !****************************************************************************** FUNCTION HamsiB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( IN ) :: MD !! 'HamsiB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION HamsiB_GetDigestLen !****************************************************************************** SUBROUTINE HamsiB_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MLen , CurPos , CurLen ! FLOW CurLen = Length CurPos = Offset IF ( MD % PartialLen /= 0_kIndex ) THEN MLen = 8_kIndex - MD % PartialLen IF ( CurLen < MLen ) THEN MD % Partial ( MD % PartialLen : MD % PartialLen + CurLen - 1 ) = ByteArr ( CurPos : CurPos + CurLen - 1 ) MD % PartialLen = MD % PartialLen + CurLen RETURN ELSE MD % Partial ( MD % PartialLen : MD % PartialLen + MLen - 1 ) = ByteArr ( CurPos : CurPos + MLen - 1 ) CurLen = CurLen - MLen CurPos = CurPos + MLen CALL HamsiB_Process ( MD , MD % Partial , 0_kIndex , 1_kIndex ) MD % PartialLen = 0_kIndex END IF END IF CALL HamsiB_Process ( MD , ByteArr , CurPos , SHIFTR ( CurLen , 3 )) CurPos = CurPos + IAND ( CurLen , NOT ( 7_kIndex )) CurLen = IAND ( CurLen , 7_kIndex ) MD % Partial ( 0 : CurLen - 1 ) = ByteArr ( CurPos : CurPos + CurLen - 1 ) MD % PartialLen = CurLen RETURN END SUBROUTINE HamsiB_InsertBytes !****************************************************************************** SUBROUTINE HamsiB_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % Update ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE HamsiB_InsertGen !****************************************************************************** SUBROUTINE HamsiB_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % AddBitsNDigest ( 0_kInt8 , 0_kInt8 , ByteArr ) RETURN END SUBROUTINE HamsiB_ByteDigest !****************************************************************************** SUBROUTINE HamsiB_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE HamsiB_ByteDigest_wInput !****************************************************************************** SUBROUTINE HamsiB_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Ptr tByte :: Z tByte :: Pad ( 0 : 7 ) ! FLOW Ptr = MD % PartialLen CALL ByteUnpackBE ( MD % BitCount + SHIFTL ( Ptr , 3 ) + ToInt64 ( NBits ), Pad , 0_kIndex ) Z = SHIFTR ( FByte80 , NBits ) MD % Partial ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex DO WHILE ( Ptr < 8_kIndex ) MD % Partial ( Ptr ) = FByte00 Ptr = Ptr + 1_kIndex END DO CALL HamsiB_Process ( MD , MD % Partial , 0_kIndex , 1_kIndex ) CALL HamsiB_Final ( MD , Pad ) ! get output CALL MemAlloc ( ByteArr , MD % GetDigestLen (), StartID = 0_kIndex ) IF ( MD % IsHamsi384 ) THEN CALL ByteUnpackBE ( MD % State ( 0 ), ByteArr , 0_kIndex ) CALL ByteUnpackBE ( MD % State ( 1 ), ByteArr , 4_kIndex ) CALL ByteUnpackBE ( MD % State ( 3 ), ByteArr , 8_kIndex ) CALL ByteUnpackBE ( MD % State ( 4 ), ByteArr , 12_kIndex ) CALL ByteUnpackBE ( MD % State ( 5 ), ByteArr , 16_kIndex ) CALL ByteUnpackBE ( MD % State ( 6 ), ByteArr , 20_kIndex ) CALL ByteUnpackBE ( MD % State ( 8 ), ByteArr , 24_kIndex ) CALL ByteUnpackBE ( MD % State ( 9 ), ByteArr , 28_kIndex ) CALL ByteUnpackBE ( MD % State ( 10 ), ByteArr , 32_kIndex ) CALL ByteUnpackBE ( MD % State ( 12 ), ByteArr , 36_kIndex ) CALL ByteUnpackBE ( MD % State ( 13 ), ByteArr , 40_kIndex ) CALL ByteUnpackBE ( MD % State ( 15 ), ByteArr , 44_kIndex ) ELSE DO I = 0 , ( SHIFTR ( MD % GetDigestLen (), 2 ) - 1 ) CALL ByteUnpackBE ( MD % State ( I ), ByteArr , SHIFTL ( I , 2 )) END DO END IF ! reset the states CALL MD % Reset () RETURN END SUBROUTINE HamsiB_ByteDigest_AddBits !****************************************************************************** SUBROUTINE HamsiB_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD !! 'HamsiB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE HamsiB_HexDigest_AddBits !****************************************************************************** SUBROUTINE HamsiB_Process ( MD , Buffer , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: ! To process input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD ! 'HamsiB' object tByte , INTENT ( IN ) :: Buffer ( 0 :) ! the input data buffer tIndex , INTENT ( IN ) :: Offset ! input offset tIndex , INTENT ( IN ) :: Length ! input length to be processed (in words?) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Indx ( 0 : 7 ) tInteger :: VC ( 0 : 15 ), VM ( 0 : 15 ), T tIndex :: Num , CurID , I ! FLOW ! initialize MD % BitCount = MD % BitCount + SHIFTL ( ToInt64 ( Length ), 6 ) Num = Length CurID = Offset READ_STATE_BIG ( VC ) DO WHILE ( Num > 0 ) Num = Num - 1 DO I = 0 , 7 Indx ( I ) = GetIndex ( Buffer ( CurID + I )) END DO INPUT_BIG ( VM , Indx ) DO I = 0 , 5 ROUND_BIG_INIT ( I , Alpha_N ) ROUND_BIG_SBOX ROUND_BIG_LBOX END DO T_BIG ( VC ) CurID = CurID + 8 END DO WRITE_STATE_BIG ( VC ) RETURN END SUBROUTINE HamsiB_Process !****************************************************************************** SUBROUTINE HamsiB_Final ( MD , Buffer ) !** PURPOSE OF THIS SUBROUTINE: ! To process final input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiB ), INTENT ( INOUT ) :: MD ! 'HamsiB' object tByte , INTENT ( IN ) :: Buffer ( 0 :) ! the input data buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Indx ( 0 : 7 ) tInteger :: VC ( 0 : 15 ), VM ( 0 : 15 ), T tIndex :: I ! FLOW READ_STATE_BIG ( VC ) DO I = 0 , 7 Indx ( I ) = GetIndex ( Buffer ( I )) END DO INPUT_BIG ( VM , Indx ) DO I = 0 , 11 ROUND_BIG_INIT ( I , Alpha_F ) ROUND_BIG_SBOX ROUND_BIG_LBOX END DO T_BIG ( VC ) WRITE_STATE_BIG ( VC ) RETURN END SUBROUTINE HamsiB_Final !****************************************************************************** #include    \"Includes/HamsiB_Undef Macro.f90\" END MODULE MClass_HamsiB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hamsib.f90.html"},{"title":"MBase_ExperimentalHash32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_ExperimentalHash32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains an experimental implementation of various non-cryptographic !   hash function routines that output a hash value as a 32-bit integer.  The available !   hash functions are a subset of those reference hash functions implemented in the !   <a href=\"../module/mbase_referencehash32.html\">ModBase_ReferenceHash32</a> module. !   The API of these experimental routines are the same as those reference routines with !   the exception of an additional argument (*Algo*). <br> !   The *Algo* argument is an algorithm flag used to indicate which algorithm is employed !   to implement a *Pack_I32* procedure, which perform a conversion from an array of four !   8-bit integers to a 32-bit integer.  There are a number of possible implementations !   of the *Pack_I32* procedure.  In this module, seven basic implementations are provided. !   A user can perform a benchmark of each specific hash function routine in order to know !   which one of the *Pack_I32* algorithms is the best one for a particular system (i.e. !   a combination of operating system, machine as well as compiler used).  The benchmark !   can then be used to implement an optimal implementation of the hash function. <br> !   <br> !&#94; **REFERENCES**: <br> !   See the <a href=\"../module/mbase_referencehash32.html\">ModBase_ReferenceHash32</a> !   module for references of the available hash functions in this module. !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_ByteUtil , ONLY : SwapBytes IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! experimental procedures PUBLIC :: City_Hash32_Exp PUBLIC :: FarmMk_Hash32_Exp PUBLIC :: Lookup3_Hash32_Exp PUBLIC :: Murmur3_Hash32_Exp PUBLIC :: NM_Hash32_Exp PUBLIC :: NMx_Hash32_Exp PUBLIC :: Water_Hash32_Exp PUBLIC :: XX_Hash32_Exp ! auxiliary procedures PUBLIC :: Pack_I16 PUBLIC :: Pack_I16_A1 PUBLIC :: Pack_I16_A2 PUBLIC :: Pack_I16_A3 PUBLIC :: Pack_I16_A4 PUBLIC :: Pack_I16_A5 PUBLIC :: Pack_I16_A6 PUBLIC :: Pack_I16_A7 PUBLIC :: Pack_I32 PUBLIC :: Pack_I32_A1 PUBLIC :: Pack_I32_A2 PUBLIC :: Pack_I32_A3 PUBLIC :: Pack_I32_A4 PUBLIC :: Pack_I32_A5 PUBLIC :: Pack_I32_A6 PUBLIC :: Pack_I32_A7 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define MaskI32(X)      IAND(ToInt32(X), ToInt32(Z'000000FF')) #define MaskI16(X)      IAND(ToInt16(X), ToInt16(Z'00FF')) !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_ExperimentalHash32' ! The maximum (positive) number of hash code tUInt32 , PARAMETER :: MaxHash = ToInt32 ( Z '7FFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE FUNCTION Pack_I16 ( ByteArr , Offset ) RESULT ( Res ) !&#94; To convert an array of 8-bit integers starting at the offset to !  a 16-bit integer value. IMPORT tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt16 :: Res !! result END FUNCTION Pack_I16 FUNCTION Pack_I32 ( ByteArr , Offset ) RESULT ( Res ) !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value. IMPORT tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result END FUNCTION Pack_I32 END INTERFACE INTERFACE !---------------------------------------------------------------------- MODULE FUNCTION Lookup3_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Murmur3_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the MurmurHash3 hash algorithm by Austin !  Appleby [1]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION City_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the City hash algorithm by Google Inc [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmMk_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION NM_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMHASH hash algorithm !  by James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION NMx_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMxHASH hash algorithm by !  James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Water_Hash32_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using a new version of the WaterHash hash !  algorithm by Tommy Ettinger [11]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Pack_I32_A1 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = IOR ( IOR ( IOR ( MaskI32 ( ByteArr ( Offset )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 1 )), 8 )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 2 )), 16 )), & SHIFTL ( MaskI32 ( ByteArr ( Offset + 3 )), 24 )) ! big-endian order !    Res = IOR(IOR(IOR(SHIFTL(MaskI32(ByteArr(Offset)),   24),  & !                      SHIFTL(MaskI32(ByteArr(Offset+1)), 16)), & !                      SHIFTL(MaskI32(ByteArr(Offset+2)),  8)), & !                             MaskI32(ByteArr(Offset+3))) RETURN END FUNCTION Pack_I32_A1 !************************************************************************** FUNCTION Pack_I32_A2 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* intrinsic function !  and an addition operator. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = MaskI32 ( ByteArr ( Offset )) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 1 )), 8 ) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 2 )), 16 ) + & SHIFTL ( MaskI32 ( ByteArr ( Offset + 3 )), 24 ) ! big-endian order !    Res = SHIFTL(MaskI32(ByteArr(Offset)),   24) + & !          SHIFTL(MaskI32(ByteArr(Offset+1)), 16) + & !          SHIFTL(MaskI32(ByteArr(Offset+2)),  8) + & !                 MaskI32(ByteArr(Offset+3)) RETURN END FUNCTION Pack_I32_A2 !************************************************************************** FUNCTION Pack_I32_A3 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. <br> !  *Note*: Although this routine and the *Pack_I32_A3* routine employ !  the same intrinsic functions, orders of the functions being used !  are somewhat different. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order #define UnsignedShort(Val, Off)     IOR(MaskI32(Val(Off)), SHIFTL(MaskI32(Val(Off+1)), 8)) Res = IOR ( UnsignedShort ( ByteArr , Offset ), SHIFTL ( UnsignedShort ( ByteArr , Offset + 2 ), 16 )) #undef UnsignedShort ! big-endian order !#define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), ToInt32(Z'000000FF')) !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    Res = IOR(UnsignedShort(ByteArr, Offset+2), SHIFTL(UnsignedShort(ByteArr, Offset), 16)) !#undef UnsignedByte !#undef UnsignedShort RETURN END FUNCTION Pack_I32_A3 !************************************************************************** FUNCTION Pack_I32_A4 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *MVBITS* intrinsic subroutine. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = 0 CALL MVBITS ( MaskI32 ( ByteArr ( Offset )), 0 , 8 , Res , 0 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 1 )), 0 , 8 , Res , 8 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 2 )), 0 , 8 , Res , 16 ) CALL MVBITS ( MaskI32 ( ByteArr ( Offset + 3 )), 0 , 8 , Res , 24 ) ! big-endian order !    Res = 0 !    CALL MVBITS(MaskI32(ByteArr(Offset)),   0, 8, Res, 24) !    CALL MVBITS(MaskI32(ByteArr(Offset+1)), 0, 8, Res, 16) !    CALL MVBITS(MaskI32(ByteArr(Offset+2)), 0, 8, Res,  8) !    CALL MVBITS(MaskI32(ByteArr(Offset+3)), 0, 8, Res,  0) RETURN END FUNCTION Pack_I32_A4 !************************************************************************** FUNCTION Pack_I32_A5 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *TRANSFER* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = TRANSFER ([ ByteArr ( Offset ), ByteArr ( Offset + 1 ), ByteArr ( Offset + 2 ), & ByteArr ( Offset + 3 )], 0_kInt32 ) ! big-endian order !    Res = TRANSFER([ByteArr(Offset+3), ByteArr(Offset+2), ByteArr(Offset+1), !                    ByteArr(Offset)], 0_kInt32) RETURN END FUNCTION Pack_I32_A5 !************************************************************************** FUNCTION Pack_I32_A6 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *C_LOC* and *C_F_POINTER* !  intrinsic module routines. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 , POINTER :: fPtr ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW !+++ get a C pointer to the input +++ CPtr = C_LOC ( ByteArr ( Offset )) !+++ associate a Fortran pointer with the C pointer +++ CALL C_F_POINTER ( cPtr , fPtr ) !+++ copy bit patterns +++ ! system (or machine) endian order Res = fPtr ! little endian order !    IF (IsLittleEndian) THEN !        Res = fPtr !    ELSE !        Res = SwapBytes(fPtr) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(fPtr) !    ELSE !        Res = fPtr !    END IF !+++ nullify pointers +++ NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END FUNCTION Pack_I32_A6 !************************************************************************** FUNCTION Pack_I32_A7 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value using the *EQUIVALENCE* statement. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 3 ) tUInt32 :: Output EQUIVALENCE ( Input , Output ) ! FLOW !+++ copy input +++ Input ( 0 : 3 ) = ByteArr ( Offset : Offset + 3 ) !+++ copy output +++ ! system (or machine) endian order Res = Output ! little endian order !    IF (IsLittleEndian) THEN !        Res = Output !    ELSE !        Res = SwapBytes(Output) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(Output) !    ELSE !        Res = Output !    END IF RETURN END FUNCTION Pack_I32_A7 !************************************************************************** FUNCTION PackPartial ( Buf , Off , Length , PackFull ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack three or fewer bytes of the array 'Buf' at offset 'Off' ! into the 32-bit word 'Res'. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 3) PROCEDURE ( Pack_I32 ) :: PackFull !! procedure to convert a byte array to 32-bit integer tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 3 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes in little-endian order Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! gather available bytes in big-endian order !    Wrk(Length-1:0:-1) = Buf(Off:Off+Length-1) ! pack bytes into word Res = PackFull ( Wrk , 0_kIndex ) RETURN END FUNCTION PackPartial !****************************************************************************** FUNCTION Pack_I16_A1 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Res = IOR ( MaskI16 ( Buf ( Off )), SHIFTL ( MaskI16 ( Buf ( Off + 1 )), 8 )) RETURN END FUNCTION Pack_I16_A1 !****************************************************************************** FUNCTION Pack_I16_A2 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #2 (comparable to #1) Res = MaskI16 ( Buf ( Off )) + SHIFTL ( MaskI16 ( Buf ( Off + 1 )), 8 ) RETURN END FUNCTION Pack_I16_A2 !****************************************************************************** FUNCTION Pack_I16_A3 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #3 (comparable to #1) #define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), Z'000000FF') #define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) Res = ToInt16 ( UnsignedShort ( Buf , Off )) #undef UnsignedByte #undef UnsignedShort RETURN END FUNCTION Pack_I16_A3 !****************************************************************************** FUNCTION Pack_I16_A4 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) Res = 0 CALL MVBITS ( MaskI16 ( Buf ( Off )), 0 , 8 , Res , 0 ) CALL MVBITS ( MaskI16 ( Buf ( Off + 1 )), 0 , 8 , Res , 8 ) RETURN END FUNCTION Pack_I16_A4 !****************************************************************************** FUNCTION Pack_I16_A5 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #5 (slowest) Res = TRANSFER ([ Buf ( Off ), Buf ( Off + 1 )], 0_kInt16 ) RETURN END FUNCTION Pack_I16_A5 !****************************************************************************** FUNCTION Pack_I16_A6 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt16 , POINTER :: Val => NULL () TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! implementation algorithm #6 CPtr = C_LOC ( Buf ( Off )) CALL C_F_POINTER ( CPtr , Val ) Res = Val NULLIFY ( Val ) cPtr = C_NULL_PTR RETURN END FUNCTION Pack_I16_A6 !****************************************************************************** FUNCTION Pack_I16_A7 ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 1 ) tUInt16 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 1 ) = Buf ( Off : Off + 1 ) Res = Output RETURN END FUNCTION Pack_I16_A7 !****************************************************************************** END MODULE MBase_ExperimentalHash32 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_experimentalhash32.f90.html"},{"title":"MClass_FarmUoHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_FarmUoHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *FarmUoHasher64* type and its related routines. !   The *FarmUoHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *FarmUoHasher64* type employs the *FarmUo* hash algorithm for 64-bit integer !   output by Google Inc [1, 2].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/google/farmhash\">FarmHash: a family of hash functions. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: FarmUoHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define ShiftMix(V)             IEOR(V, SHIFTR(V, 47)) #define HashLen16_3(U,V,M)      ShiftMix(IEOR(V, ShiftMix(IEOR(U, V)*M))*M)*M #define HashLen16_2(U,V)        HashLen16_3(U, V, K_MUL) #define Mul(L)                  K2 + SHIFTL(ToInt64(L), 1) #define MaskI8(X)               IAND(ToInt64(X), Z'00000000000000FF') #define MaskI32(X)              IAND(ToInt64(X), Z'00000000FFFFFFFF') #define Pack_U32(Buf,Index)     MaskI32(PackInteger(Buf, Index)) #define FarmUoH(X, Y, M, R)     RotateRight(IEOR(Y, ShiftMix(IEOR(X, Y)*M))*M, R)*M !** MODULE PARAMETERS: tUInt64 , PARAMETER :: K0 = ToInt64 ( Z 'C3A5C85C97CB3127' ) tUInt64 , PARAMETER :: K1 = ToInt64 ( Z 'B492B66FBE98F273' ) tUInt64 , PARAMETER :: K2 = ToInt64 ( Z '9AE16A3B2F90404F' ) tUInt64 , PARAMETER :: K_MUL = ToInt64 ( Z '9DDFEA08EB382D69' ) tIndex , PARAMETER :: BlockLen = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *FarmUoHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *FarmUo* hash algorithm by Google Inc. TYPE , EXTENDS ( Hasher64 ) :: FarmUoHasher64 PRIVATE !% seeds tUInt64 :: Seed ( 2 ) = 0_kInt64 !% state tUInt64 :: State ( 8 ) = 0_kInt64 !% multiplier tUInt64 :: Mul = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => FarmUo_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => FarmUo_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => FarmUo_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => FarmUo_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with one seed. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => FarmUo_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => FarmUo_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => FarmUo_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                without seed or with one seed. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => FarmUo_HashDirect !> **Type-Bound Function**: HashDirectWSeeds <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                with two seeds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSeeds => FarmUo_HashDirect_WithSeeds END TYPE FarmUoHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION FarmUo_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'FarmUo_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION FarmUo_GetName !****************************************************************************** FUNCTION FarmUo_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION FarmUo_BlockLength !****************************************************************************** SUBROUTINE FarmUo_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE FarmUo_SetBufPtr !****************************************************************************** SUBROUTINE FarmUo_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Tmp tUInt64 :: A0 , A1 , A2 , A3 , A4 , A5 , A6 , A7 !** FLOW ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V0 => HS % State ( 4 ), V1 => HS % State ( 5 ), W0 => HS % State ( 6 ), & W1 => HS % State ( 7 ), U => HS % State ( 8 ), M => HS % Mul ) A0 = PackLong ( BytesIn , 0_kIndex ) A1 = PackLong ( BytesIn , 8_kIndex ) A2 = PackLong ( BytesIn , 16_kIndex ) A3 = PackLong ( BytesIn , 24_kIndex ) A4 = PackLong ( BytesIn , 32_kIndex ) A5 = PackLong ( BytesIn , 40_kIndex ) A6 = PackLong ( BytesIn , 48_kIndex ) A7 = PackLong ( BytesIn , 56_kIndex ) X = X + A0 + A1 Y = Y + A2 Z = Z + A3 V0 = V0 + A4 V1 = V1 + A5 + A1 W0 = W0 + A6 W1 = W1 + A7 X = RotateRight ( X , 26 ) X = X * 9_kInt64 Y = RotateRight ( Y , 29 ) Z = Z * M V0 = RotateRight ( V0 , 33 ) V1 = RotateRight ( V1 , 30 ) W0 = IEOR ( W0 , X ) W0 = W0 * 9_kInt64 Z = RotateRight ( Z , 32 ) Z = Z + W1 W1 = W1 + Z Z = Z * 9_kInt64 ! swap U and Y Tmp = U U = Y Y = Tmp Z = Z + A0 + A6 V0 = V0 + A2 V1 = V1 + A3 W0 = W0 + A4 W1 = W1 + A5 + A6 X = X + A1 Y = Y + A7 Y = Y + V0 V0 = V0 + X - Y V1 = V1 + W0 W0 = W0 + V1 W1 = W1 + X - Y X = X + W1 W1 = RotateRight ( W1 , 34 ) ! swap U and Z Tmp = U U = Z Z = Tmp END ASSOCIATE RETURN END SUBROUTINE FarmUo_ProcessBlock !****************************************************************************** SUBROUTINE FarmUo_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL HS % InitializeWSeeds ( Seed , K2 , RemoveSign ) RETURN END SUBROUTINE FarmUo_Initialize !****************************************************************************** SUBROUTINE FarmUo_Initialize_WithSeeds ( HS , Seed1 , Seed2 , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher with two seeds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed1 !! seed1 tUInt64 , INTENT ( IN ) :: Seed2 !! seed2 tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW IF ( Seed2 == K2 ) THEN Seed0 = 0_kInt64 ELSE Seed0 = Seed2 END IF HS % Seed ( 1 ) = Seed1 HS % Seed ( 2 ) = Seed2 ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V0 => HS % State ( 4 ), V1 => HS % State ( 5 ), W0 => HS % State ( 6 ), & W1 => HS % State ( 7 ), U => HS % State ( 8 ), M => HS % Mul ) X = Seed0 Y = Seed1 * K2 + 113_kInt64 Z = ShiftMix ( Y * K2 ) * K2 V0 = Seed0 V1 = Seed1 W0 = 0_kInt64 W1 = 0_kInt64 U = X - Z X = X * K2 M = K2 + IAND ( U , ToInt64 ( Z '0000000000000082' )) END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE FarmUo_Initialize_WithSeeds !****************************************************************************** FUNCTION FarmUo_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length !** FLOW IF ( HS % GetBlockCount () > 0_kIndex ) THEN ! compute length Length = HS % GetBlockCount () * HS % GetBlockLength () + HS % GetBufLen () BLOCK ! block variables tUInt8 :: LastBuf ( 0 : BlockLen - 1 ) tIndex :: I , J tUInt64 :: A1 , B1 , C1 , Z1 tUInt64 :: A2 , B2 , C2 , Z2 ! copy buffer data for last round J = HS % GetBufLen () + 1_kIndex DO I = 0_kIndex , BlockLen - 1_kIndex LastBuf ( I ) = HS % BufArr ( J ) J = J + 1_kIndex IF ( J >= BlockLen ) J = 0_kIndex END DO ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V0 => HS % State ( 4 ), V1 => HS % State ( 5 ), W0 => HS % State ( 6 ), & W1 => HS % State ( 7 ), U => HS % State ( 8 ), M => HS % Mul ) U = U * 9_kInt64 V1 = RotateRight ( V1 , 28 ) V0 = RotateRight ( V0 , 20 ) W0 = W0 + ToInt64 ( IAND ( Length - 1_kIndex , 63_kIndex )) U = U + Y Y = Y + U X = RotateRight ( Y - X + V0 + PackLong ( LastBuf , 8_kIndex ), 37 ) * M Y = RotateRight ( IEOR ( IEOR ( Y , V1 ), PackLong ( LastBuf , 48_kIndex )), 42 ) * M X = IEOR ( X , W1 * 9_kInt64 ) Y = Y + V0 + PackLong ( LastBuf , 40_kIndex ) Z = RotateRight ( Z + W0 , 33 ) * M ! WeakHashLen32WithSeeds A1 = V1 * M B1 = X + W0 Z1 = PackLong ( LastBuf , 24_kIndex ) A1 = A1 + PackLong ( LastBuf , 0_kIndex ) B1 = RotateRight ( B1 + A1 + Z1 , 21 ) C1 = A1 A1 = A1 + PackLong ( LastBuf , 8_kIndex ) A1 = A1 + PackLong ( LastBuf , 16_kIndex ) B1 = B1 + RotateRight ( A1 , 44 ) V0 = A1 + Z1 V1 = B1 + C1 ! WeakHashLen32WithSeeds A2 = Z + W1 B2 = Y + PackLong ( LastBuf , 16_kIndex ) Z2 = PackLong ( LastBuf , 56_kIndex ) A2 = A2 + PackLong ( LastBuf , 32_kIndex ) B2 = RotateRight ( B2 + A2 + Z2 , 21 ) C2 = A2 A2 = A2 + PackLong ( LastBuf , 40_kIndex ) A2 = A2 + PackLong ( LastBuf , 48_kIndex ) B2 = B2 + RotateRight ( A2 , 44_kIndex ) W0 = A2 + Z2 W1 = B2 + C2 ! finalize HashCode = FarmUoH ( HashLen16_3 ( V0 + X , IEOR ( W0 , Y ), M ) + Z - U , \\ IEOR ( FarmUoH ( V1 + Y , W1 + Z , K2 , 30_kInt32 ), X ), K2 , 31_kInt32 ) END ASSOCIATE END BLOCK ELSE Length = HS % GetBufLen () ASSOCIATE ( Input => HS % BufArr ) IF ( Length <= 16 ) THEN ! FarmUoHash_Len0To16 IF ( Length >= 8 ) THEN BLOCK tUInt64 :: M , A , C , D tUInt64 :: First8Bytes , Last8Bytes First8Bytes = PackLong ( Input , 0_kIndex ) Last8Bytes = PackLong ( Input , Length - 8 ) ! Hash 8 To 16 Bytes M = Mul ( Length ) A = First8Bytes + K2 C = RotateRight ( Last8Bytes , 37 ) * M + A D = ( RotateRight ( A , 25 ) + Last8Bytes ) * M HashCode = HashLen16_3 ( C , D , M ) END BLOCK ELSEIF ( Length >= 4 ) THEN BLOCK tUInt64 :: M , First4Bytes , Last4Bytes First4Bytes = Pack_U32 ( Input , 0_kIndex ) Last4Bytes = Pack_U32 ( Input , Length - 4 ) ! Hash 4 To 7 Bytes M = Mul ( Length ) HashCode = HashLen16_3 ( ToInt64 ( Length ) + SHIFTL ( First4Bytes , 3 ), Last4Bytes , M ) END BLOCK ELSEIF ( Length > 0 ) THEN BLOCK tUInt32 :: FirstByte , MidOrLastByte , LastByte tUInt32 :: Y , Z FirstByte = MaskI8 ( Input ( 0 )) MidOrLastByte = MaskI8 ( Input ( SHIFTA ( Length , 1 ))) LastByte = MaskI8 ( Input ( Length - 1 )) ! Hash 1 To 3 Bytes Y = FirstByte + SHIFTL ( MidOrLastByte , 8 ) Z = ToInt32 ( Length ) + SHIFTL ( LastByte , 2 ) HashCode = ShiftMix ( IEOR ( ToInt64 ( Y ) * K2 , ToInt64 ( Z ) * K0 )) * K2 END BLOCK ELSE HashCode = K2 END IF ELSEIF ( Length <= 32 ) THEN ! FarmUoHash_Len17To32 BLOCK tUInt64 :: M , A , B , C , D ! perform hashing M = Mul ( Length ) A = PackLong ( Input , 0_kIndex ) * K1 B = PackLong ( Input , 8_kIndex ) C = PackLong ( Input , Length - 8 ) * M D = PackLong ( Input , Length - 16 ) * K2 HashCode = HashLen16_3 ( RotateRight ( A + B , 43 ) + RotateRight ( C , 30 ) + D , \\ A + RotateRight ( B + K2 , 18 ) + C , M ) END BLOCK ELSE ! FarmUoHash_Len33To64 BLOCK tUInt64 :: M , A , B , C , D , E , F , G , H tUInt64 :: Y , Z ! perform hashing M = Mul ( Length ) A = PackLong ( Input , 0_kIndex ) * K2 B = PackLong ( Input , 8_kIndex ) C = PackLong ( Input , Length - 8 ) * M D = PackLong ( Input , Length - 16 ) * K2 Y = RotateRight ( A + B , 43 ) + RotateRight ( C , 30 ) + D Z = HashLen16_3 ( Y , A + RotateRight ( B + K2 , 18 ) + C , M ) E = PackLong ( Input , 16_kIndex ) * M F = PackLong ( Input , 24_kIndex ) G = ( Y + PackLong ( Input , Length - 32 )) * M H = ( Z + PackLong ( Input , Length - 24 )) * M HashCode = HashLen16_3 ( RotateRight ( E + F , 43 ) + RotateRight ( G , 30 ) + H , \\ E + RotateRight ( F + A , 18 ) + G , M ) END BLOCK END IF ! finalize with seed(s) HashCode = HashLen16_2 ( HashCode - HS % Seed ( 2 ), HS % Seed ( 1 )) END ASSOCIATE END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % Seed = 0_kInt64 HS % State = 0_kInt64 HS % Mul = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS PURE FUNCTION PackInteger ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 32-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #undef MaskInt32 RETURN END FUNCTION PackInteger !************************************************************************** END FUNCTION FarmUo_Finalize !****************************************************************************** FUNCTION FarmUo_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION FarmUo_HashDirect !****************************************************************************** FUNCTION FarmUo_HashDirect_WithSeeds ( HS , Input , InpSize , Seed1 , Seed2 , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) with two seeds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmUoHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , INTENT ( IN ) :: Seed1 !! seed1 tUInt64 , INTENT ( IN ) :: Seed2 !! seed2 tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following code illustrates simple use of the hasher. CALL HS % InitializeWSeeds ( Seed1 , Seed2 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION FarmUo_HashDirect_WithSeeds !****************************************************************************** PURE FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackLong !************************************************************************** END MODULE MClass_FarmUoHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_farmuohasher64.f90.html"},{"title":"MClass_EchoS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_EChoS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *EChoS* type and its related routines. !   The *EChoS* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *EChoS* type implements an incremental cryptographic hash function !   by employing  either the *ECHO-224* or the *ECHO-256* algorithm [1].  The !   implementation here is based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *EChoS* type employs the *ECHO-256 message-digest* !   algorithm.  However, a user can specify the *IsECHO224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *ECHO-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20180315075044/http://crypto.rd.francetelecom.com/ECHO/\"> !       ECHO hash function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: EChoS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/AES_LittleEndian.f90\" !** MODULE PARAMETERS: #include    \"Includes/AES_Constants.f90\" tIndex , PARAMETER :: BlockLen = 192_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex !** DERIVED TYPE DEFINITIONS !> *EChoS* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *ECHO-224* or the *ECHO-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: EChoS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: V ( 0 : 15 ) = 0 tInteger :: C ( 0 : 3 ) = 0 !% flag indicating whether the ECHO-224 algorithm is employed or not. tLogical :: IsECHO224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => EChoS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (ECHO-256). PROCEDURE :: Initialize => EChoS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => EChoS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => EChoS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => EChoS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => EChoS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => EChoS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => EChoS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => EChoS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => EChoS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => EChoS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (ECHO-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the ECHO-224 algorithm <br> !   --->    CALL MD%Create(IsECHO224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE EChoS !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE EChoS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the ECHO-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE EChoS_Initialize !****************************************************************************** SUBROUTINE EChoS_Initialize_wFlag ( MD , IsECHO224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object tLogical , INTENT ( IN ) :: IsECHO224 !&#94; flag indicating whether the ECHO-224 algorithm is employed or not. <br> !  - If true, use the ECHO-224 algorithm. <br> !  - Otherwise, use the ECHO-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsECHO224 = IsECHO224 CALL MD % Reset () RETURN END SUBROUTINE EChoS_Initialize_wFlag !****************************************************************************** SUBROUTINE EChoS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % C = 0 MD % V = 0 MD % V ( 0 ) = ToInt32 ( SHIFTL ( MD % GetDigestLen (), 3 )) MD % V ( 4 ) = MD % V ( 0 ) MD % V ( 8 ) = MD % V ( 0 ) MD % V ( 12 ) = MD % V ( 0 ) CALL MD % EngineReset () RETURN END SUBROUTINE EChoS_Reset !****************************************************************************** SUBROUTINE EChoS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( EChoS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( EChoS ) CALL Dst % Create ( Src % IsECHO224 ) Dst % V = Src % V Dst % C = Src % C Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE EChoS_GetClone !****************************************************************************** FUNCTION EChoS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( IN ) :: MD !! 'EChoS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsECHO224 ) THEN Name = 'ECHO-224' ELSE Name = 'ECHO-256' END IF RETURN END FUNCTION EChoS_GetName !****************************************************************************** FUNCTION EChoS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( IN ) :: MD !! 'EChoS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsECHO224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION EChoS_GetDigestLen !****************************************************************************** FUNCTION EChoS_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( IN ) :: MD !! 'EChoS' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION EChoS_GetBlockLen !****************************************************************************** SUBROUTINE EChoS_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), TARGET , INTENT ( INOUT ) :: MD !! 'EChoS' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE EChoS_SetBufPtr !****************************************************************************** SUBROUTINE EChoS_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: IncVal ! FLOW ! increment value IncVal = 1536 ! increment counters CALL IncrementCounters ( MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), IncVal ) ! compress CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), BytesIn ) RETURN END SUBROUTINE EChoS_ProcessBlock !****************************************************************************** SUBROUTINE EChoS_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE EChoS_DoPadding !****************************************************************************** SUBROUTINE EChoS_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoS ), INTENT ( INOUT ) :: MD !! 'EChoS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , OutLen , I tInteger :: C0 , C1 , C2 , C3 , ELen tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () ELen = SHIFTL ( Ptr , 3 ) + NBits CALL IncrementCounters ( MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), ELen ) C0 = MD % C ( 0 ) C1 = MD % C ( 1 ) C2 = MD % C ( 2 ) C3 = MD % C ( 3 ) ! If ELen is zero, then this block actually contains no message ! bit, only the first padding bit. IF ( ELen == 0 ) THEN MD % C ( 0 ) = 0 MD % C ( 1 ) = 0 MD % C ( 2 ) = 0 MD % C ( 3 ) = 0 END IF Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1 IF ( Ptr > 174 ) THEN TmpBuf ( Ptr : 191 ) = FByte00 CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), TmpBuf ) MD % C ( 0 ) = 0 MD % C ( 1 ) = 0 MD % C ( 2 ) = 0 MD % C ( 3 ) = 0 Ptr = 0 END IF TmpBuf ( Ptr : 173 ) = FByte00 OutLen = SHIFTL ( MD % GetDigestLen (), 3 ) TmpBuf ( 174 ) = ToInt8 ( OutLen ) TmpBuf ( 175 ) = ToInt8 ( SHIFTR ( OutLen , 8 )) CALL ByteUnpackLE ( C0 , TmpBuf , 176_kIndex ) CALL ByteUnpackLE ( C1 , TmpBuf , 180_kIndex ) CALL ByteUnpackLE ( C2 , TmpBuf , 184_kIndex ) CALL ByteUnpackLE ( C3 , TmpBuf , 188_kIndex ) CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), TmpBuf ) END ASSOCIATE ! finalizing OutLen = SHIFTR ( OutLen , 5 ) DO I = 0 , OutLen - 1 CALL ByteUnpackLE ( MD % V ( I ), BytesOut , Offset + SHIFTL ( I , 2 )) END DO RETURN END SUBROUTINE EChoS_AddBitsNPad !****************************************************************************** SUBROUTINE IncrementCounters ( C0 , C1 , C2 , C3 , IncVal ) !** PURPOSE OF THIS SUBROUTINE: ! To increment counters. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: C0 , C1 , C2 , C3 tInteger , INTENT ( IN ) :: IncVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW C0 = C0 + IncVal IF (( C0 >= 0 ). AND .( C0 < IncVal )) THEN C1 = C1 + 1 IF ( C1 == 0 ) THEN C2 = C2 + 1 IF ( C2 == 0 ) THEN C3 = C3 + 1 END IF END IF END IF RETURN END SUBROUTINE IncrementCounters !****************************************************************************** SUBROUTINE Compress ( V , C0 , C1 , C2 , C3 , InpDat ) !** PURPOSE OF THIS SUBROUTINE: ! To compress input block. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: V ( 0 :) ! state values tInteger , INTENT ( IN ) :: C0 , C1 , C2 , C3 ! constants tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: K0 , K1 , K2 , K3 tInteger :: A , B , C , Tmp tInteger :: Y0 , Y1 , Y2 , Y3 tInteger , TARGET :: W2D ( 0 : 3 , 0 : 15 ) tInteger , POINTER :: W1D (:) tIndex :: U , I , J !** SUBROUTINE MACRO DEFINITIONS: #define AES_2ROUNDS(W, C)   \\ AES_ROUND_LE ( W ( 0 , C ), W ( 1 , C ), W ( 2 , C ), W ( 3 , C ), K0 , K1 , K2 , K3 , Y0 , Y1 , Y2 , Y3 ); \\ AES_ROUND_NOKEY_LE ( Y0 , Y1 , Y2 , Y3 , W ( 0 , C ), W ( 1 , C ), W ( 2 , C ), W ( 3 , C )); \\ K0 = K0 + 1 ; \\ IF ( K0 == 0 ) THEN ; \\ K1 = K1 + 1 ; \\ IF ( K1 == 0 ) THEN ; \\ K2 = K2 + 1 ; \\ IF ( K2 == 0 ) THEN ; \\ K3 = K3 + 1 ; \\ END IF ; \\ END IF ; \\ END IF ; #define BIG_SUB_WORDS(W) \\ DO I = 0 , 15 ; \\ AES_2ROUNDS ( W , I ); \\ END DO ; #define SHIFT_ROW1(W, A, B, C, D)  \\ Tmp = W ( 0 , A ); \\ W ( 0 , A ) = W ( 0 , B ); \\ W ( 0 , B ) = W ( 0 , C ); \\ W ( 0 , C ) = W ( 0 , D ); \\ W ( 0 , D ) = Tmp ; \\ Tmp = W ( 1 , A ); \\ W ( 1 , A ) = W ( 1 , B ); \\ W ( 1 , B ) = W ( 1 , C ); \\ W ( 1 , C ) = W ( 1 , D ); \\ W ( 1 , D ) = Tmp ; \\ Tmp = W ( 2 , A ); \\ W ( 2 , A ) = W ( 2 , B ); \\ W ( 2 , B ) = W ( 2 , C ); \\ W ( 2 , C ) = W ( 2 , D ); \\ W ( 2 , D ) = Tmp ; \\ Tmp = W ( 3 , A ); \\ W ( 3 , A ) = W ( 3 , B ); \\ W ( 3 , B ) = W ( 3 , C ); \\ W ( 3 , C ) = W ( 3 , D ); \\ W ( 3 , D ) = Tmp ; #define SHIFT_ROW2(W, A, B, C, D)  \\ Tmp = W ( 0 , A ); \\ W ( 0 , A ) = W ( 0 , C ); \\ W ( 0 , C ) = Tmp ; \\ Tmp = W ( 0 , B ); \\ W ( 0 , B ) = W ( 0 , D ); \\ W ( 0 , D ) = Tmp ; \\ Tmp = W ( 1 , A ); \\ W ( 1 , A ) = W ( 1 , C ); \\ W ( 1 , C ) = Tmp ; \\ Tmp = W ( 1 , B ); \\ W ( 1 , B ) = W ( 1 , D ); \\ W ( 1 , D ) = Tmp ; \\ Tmp = W ( 2 , A ); \\ W ( 2 , A ) = W ( 2 , C ); \\ W ( 2 , C ) = Tmp ; \\ Tmp = W ( 2 , B ); \\ W ( 2 , B ) = W ( 2 , D ); \\ W ( 2 , D ) = Tmp ; \\ Tmp = W ( 3 , A ); \\ W ( 3 , A ) = W ( 3 , C ); \\ W ( 3 , C ) = Tmp ; \\ Tmp = W ( 3 , B ); \\ W ( 3 , B ) = W ( 3 , D ); \\ W ( 3 , D ) = Tmp ; #define SHIFT_ROW3(W, A, B, C, D)   SHIFT_ROW1(W, D, C, B, A) #define BIG_SHIFT_ROWS(W)  \\ SHIFT_ROW1 ( W , 1 , 5 , 9 , 13 ); \\ SHIFT_ROW2 ( W , 2 , 6 , 10 , 14 ); \\ SHIFT_ROW3 ( W , 3 , 7 , 11 , 15 ); #define BIG_MIX_COLUMNS(W) \\ CALL MixColumn ( W , 0 , 1 , 2 , 3 ); \\ CALL MixColumn ( W , 4 , 5 , 6 , 7 ); \\ CALL MixColumn ( W , 8 , 9 , 10 , 11 ); \\ CALL MixColumn ( W , 12 , 13 , 14 , 15 ); ! FLOW ! set Ks K0 = C0 K1 = C1 K2 = C2 K3 = C3 ! set pointer W1D ( 0 : 63 ) => W2D ! +++ INPUT_BLOCK_SMALL +++ ! copy state values W1D ( 0 : 15 ) = V ( 0 : 15 ) ! get input block CALL BytePackLE ( InpDat , 0_kIndex , W1D ( 16 : 63 )) DO U = 0 , 7 ! +++ BIG_ROUND +++ BIG_SUB_WORDS ( W2D ) BIG_SHIFT_ROWS ( W2D ) BIG_MIX_COLUMNS ( W2D ) END DO ! +++ FINAL_SMALL +++ ! get output and return state values J = 0_kIndex DO I = 0 , 15 CALL BytePackLE ( InpDat , J , A ) CALL BytePackLE ( InpDat , J + 64_kIndex , B ) CALL BytePackLE ( InpDat , J + 128_kIndex , C ) V ( I ) = IEOR ( V ( I ), IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( A , B ), C ), W1D ( I )), W1D ( I + 16 )), & W1D ( I + 32 )), W1D ( I + 48 ))) J = J + 4_kIndex END DO NULLIFY ( W1D ) RETURN #undef AES_2ROUNDS #undef BIG_SUB_WORDS #undef SHIFT_ROW1 #undef SHIFT_ROW2 #undef SHIFT_ROW3 #undef BIG_SHIFT_ROWS #undef MIX_COLUMN #undef BIG_MIX_COLUMNS #include \"Includes/AES_Undef Macro.f90\" CONTAINS SUBROUTINE MixColumn ( W , IA , IB , IC , ID ) !** PURPOSE OF THIS SUBROUTINE: ! To perform mixing of columns of W. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: W ( 0 :, 0 :) tInteger , INTENT ( IN ) :: IA , IB , IC , ID !** SUBROUTINE PARAMETER DECLARATIONS: tInteger , PARAMETER :: C1 = ToInt32 ( Z '80808080' ) tInteger , PARAMETER :: C2 = ToInt32 ( Z '7F7F7F7F' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D tInteger :: AB , BC , CD tInteger :: ABX , BCX , CDX tInteger :: N ! FLOW DO N = 0 , 3 A = W ( N , IA ) B = W ( N , IB ) C = W ( N , IC ) D = W ( N , ID ) AB = IEOR ( A , B ) BC = IEOR ( B , C ) CD = IEOR ( C , D ) ABX = IEOR ( SHIFTR ( IAND ( AB , C1 ), 7 ) * 27 , SHIFTL ( IAND ( AB , C2 ), 1 )) BCX = IEOR ( SHIFTR ( IAND ( BC , C1 ), 7 ) * 27 , SHIFTL ( IAND ( BC , C2 ), 1 )) CDX = IEOR ( SHIFTR ( IAND ( CD , C1 ), 7 ) * 27 , SHIFTL ( IAND ( CD , C2 ), 1 )) W ( N , IA ) = IEOR ( IEOR ( ABX , BC ), D ) W ( N , IB ) = IEOR ( IEOR ( BCX , A ), CD ) W ( N , IC ) = IEOR ( IEOR ( CDX , AB ), D ) W ( N , ID ) = IEOR ( IEOR ( IEOR ( IEOR ( ABX , BCX ), CDX ), AB ), C ) END DO RETURN END SUBROUTINE MixColumn !************************************************************************** END SUBROUTINE Compress !****************************************************************************** END MODULE MClass_EChoS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_echos.f90.html"},{"title":"MClass_WaterHasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_WaterHasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *WaterHasher32* type and its related routines. !   The *WaterHasher32* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> type. !   It provides all deferred procedures required by a *Hasher32* class and !   outputs the hash value as a 32-bit integer. <br> !   The *WaterHasher32* type employs the *Water* hash algorithm for 32-bit integer !   output by Tommy Ettinger [1].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/tommyettinger/waterhash\">WaterHash: A variant of WyHash. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher32 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: WaterHasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskInt16(X)        IAND(ToInt16(X), ToInt16(Z'00FF')) #define MaskInt32(X)        IAND(ToInt32(X), Z'000000FF') #define Pack_I16(Buf,Off)   (MaskInt16(Buf(Off)) + SHIFTL(MaskInt16(Buf(Off+1)), 8)) #define Pack_I32(Buf,Off)   (MaskInt32(Buf(Off)) + SHIFTL(MaskInt32(Buf(Off+1)),  8) + \\ SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 ) + SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #define MaskU32(X)          IAND(ToInt64(X), Z'00000000FFFFFFFF') #define WaterR08(Inp,Off)   MaskU32(IAND(ToInt32(Inp(Off)), Z'000000FF')) #define WaterR16(Inp,Off)   MaskU32(IAND(ToInt32(Pack_I16(Inp, Off)), Z'0000FFFF')) #define WaterR32(Inp,Off)   MaskU32(Pack_I32(Inp, Off)) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: WaterP0 = ToInt64 ( Z '00000000A0761D65' ) tUInt64 , PARAMETER :: WaterP1 = ToInt64 ( Z '00000000E7037ED1' ) tUInt64 , PARAMETER :: WaterP2 = ToInt64 ( Z '000000008EBC6AF1' ) tUInt64 , PARAMETER :: WaterP3 = ToInt64 ( Z '00000000589965CD' ) tUInt64 , PARAMETER :: WaterP4 = ToInt64 ( Z '000000001D8E4E27' ) tUInt64 , PARAMETER :: WaterP5 = ToInt64 ( Z '00000000EB44ACCB' ) tUInt64 , PARAMETER :: LONG_LO_MASK = ToInt64 ( Z '00000000FFFFFFFF' ) !** DERIVED TYPE DEFINITIONS !> *WaterHasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *Water* hash algorithm by Tommy Ettinger. TYPE , EXTENDS ( Hasher32 ) :: WaterHasher32 PRIVATE !% state tUInt64 :: State = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 15 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Water_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Water_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Water_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Water_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Water_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Water_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Water_HashDirect END TYPE WaterHasher32 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Water_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Water_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Water_GetName !****************************************************************************** FUNCTION Water_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = 16_kIndex ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Water_BlockLength !****************************************************************************** SUBROUTINE Water_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Water_SetBufPtr !****************************************************************************** SUBROUTINE Water_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS , RHS !** FLOW ASSOCIATE ( H => HS % State ) CALL WaterMum ( IEOR ( WaterR32 ( BytesIn , 0_kIndex ), WaterP1 ), & IEOR ( WaterR32 ( BytesIn , 4_kIndex ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( WaterR32 ( BytesIn , 8_kIndex ), WaterP3 ), & IEOR ( WaterR32 ( BytesIn , 12_kIndex ), WaterP4 ), RHS ) CALL WaterMum ( LHS + H , RHS , H ) END ASSOCIATE RETURN END SUBROUTINE Water_ProcessBlock !****************************************************************************** SUBROUTINE Water_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % State = Seed SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Water_Initialize !****************************************************************************** FUNCTION Water_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS , RHS tIndex :: Length , Remaining , Offset !** FLOW ! initialize Remaining = HS % GetBufLen () Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining Offset = 0_kIndex ASSOCIATE ( H => HS % State ) H = H + WaterP5 ! process remaining SELECT CASE ( Remaining ) CASE ( 1 ) CALL WaterMum ( IEOR ( WaterP2 , H ), IEOR ( WaterR08 ( HS % BufArr , Offset ), WaterP1 ), H ) CASE ( 2 ) CALL WaterMum ( IEOR ( WaterP3 , H ), IEOR ( WaterR16 ( HS % BufArr , Offset ), WaterP4 ), H ) CASE ( 3 ) CALL WaterMum ( IEOR ( WaterR16 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR08 ( HS % BufArr , Offset + 2 ), WaterP2 ), H ) CASE ( 4 ) CALL WaterMum ( IEOR ( WaterR16 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR16 ( HS % BufArr , Offset + 2 ), WaterP3 ), H ) CASE ( 5 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR08 ( HS % BufArr , Offset + 4 ), WaterP1 ), H ) CASE ( 6 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR16 ( HS % BufArr , Offset + 4 ), WaterP1 ), H ) CASE ( 7 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( IOR ( SHIFTL ( WaterR16 ( HS % BufArr , Offset + 4 ), 8 ), & WaterR08 ( HS % BufArr , Offset + 6 )), WaterP1 ), H ) CASE ( 8 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP0 ), H ) CASE ( 9 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( H , WaterP4 ), IEOR ( WaterR08 ( HS % BufArr , Offset + 8 ), WaterP3 ), RHS ) H = IEOR ( LHS , RHS ) CASE ( 10 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( H , IEOR ( WaterR16 ( HS % BufArr , Offset + 8 ), WaterP3 ), RHS ) H = IEOR ( LHS , RHS ) CASE ( 11 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( H , IEOR ( IOR ( SHIFTL ( WaterR16 ( HS % BufArr , Offset + 8 ), 8 ), & WaterR08 ( HS % BufArr , Offset + 10 )), WaterP3 ), RHS ) H = IEOR ( LHS , RHS ) CASE ( 12 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( H , WaterR32 ( HS % BufArr , Offset + 8 )), WaterP4 , RHS ) H = IEOR ( LHS , RHS ) CASE ( 13 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( H , WaterR32 ( HS % BufArr , Offset + 8 )), & IEOR ( WaterR08 ( HS % BufArr , Offset + 12 ), WaterP4 ), RHS ) H = IEOR ( LHS , RHS ) CASE ( 14 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( H , WaterR32 ( HS % BufArr , Offset + 8 )), & IEOR ( WaterR16 ( HS % BufArr , Offset + 12 ), WaterP4 ), RHS ) H = IEOR ( LHS , RHS ) CASE ( 15 ) CALL WaterMum ( IEOR ( WaterR32 ( HS % BufArr , Offset ), H ), & IEOR ( WaterR32 ( HS % BufArr , Offset + 4 ), WaterP2 ), LHS ) CALL WaterMum ( IEOR ( H , WaterR32 ( HS % BufArr , Offset + 8 )), & IEOR ( IOR ( SHIFTL ( WaterR16 ( HS % BufArr , Offset + 12 ), 8 ), & WaterR08 ( HS % BufArr , Offset + 14 )), WaterP4 ), RHS ) H = IEOR ( LHS , RHS ) END SELECT ! finalize H = IEOR ( H , SHIFTL ( H , 16 )) * IEOR ( ToInt64 ( Length ), WaterP0 ) HashCode = ToInt32 ( IAND ( H - SHIFTR ( H , 32 ), LONG_LO_MASK )) END ASSOCIATE ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % State = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Water_Finalize !****************************************************************************** FUNCTION Water_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WaterHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt32 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Water_HashDirect !****************************************************************************** SUBROUTINE WaterMum ( A , B , R ) !** PURPOSE OF THIS SUBROUTINE: ! To perform multiplication and mixing. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: A , B tUInt64 , INTENT ( OUT ) :: R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW R = A * B R = R - SHIFTR ( R , 32 ) RETURN END SUBROUTINE WaterMum !****************************************************************************** END MODULE MClass_WaterHasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_waterhasher32.f90.html"},{"title":"MClass_Blake2Core.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake2Core !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake2Core* type and its related routines. !   The *Blake2Core* type is an abstract *digest* type extending directly !   from the <a href=\"../module/mclass_basedigest.html#type-basedigest\"> !   BaseDigest</a> type.  It defines and implements additional methods !   (most of which is intended to be used internally) to provide an !   extended API for an incremental cryptographic hash function. <br> !   By design, the *Blake2Core* type is intended to be used as a parent !   type for all *BLAKE2-based* digest types.  The *Blake2Core* type !   provides an implementation of an incremental cryptographic hash function !   by employing the *BLAKE2 message-digest* algorithm [1, 2].  It takes care !   core operations (i.e. some of the deferred procedures and additional methods !   provided) required by a *BLAKE2-based digest* object where its subtypes must !   take care the remaining operations (i.e the rest of the deferred procedures). !   The implementation of the *Blake2Core* type and its subtypes are based !   mainly on the references [3, 4]. <br> !   It should be noted that the *BLAKE2 message-digest* algorithm has several !   variants with additional features such as keyed hashing (that is, MAC or !   PRF), hashing with a salt, personalization and/or incremental tree-hashing. !   The algorithm can also produce a variable-length hash output.  Among these !   additional features, the *Blake2Core* type and its subtypes only allow !   keyed hashing and variable-length hash output. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.aumasson.jp/blake/book/\">J.P. Aumasson, W. Meier, !       R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. </a> <br> !   [2] <a href=\"https://www.blake2.net/\">BLAKE2 - Fast Secure Hashing. </a> <br> !   [3] <a href=\"https://github.com/kocakosm/jblake2\">JBlake2: A pure Java !       implementation of BLAKE2 (RFC 7693). </a> <br> !   [4] <a href=\"https://github.com/BLAKE2/BLAKE2\">BLAKE2 official implementations. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc , MemFree USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Blake2Core PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *Blake2Core* is an abstract *digest* type provided to be a parent type !  for other *Blake2-based digest* types to implement incremental cryptographic !  hash functions. TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: Blake2Core PRIVATE !% the number of bytes of input currently stored in the buffer array tIndex :: BufLen = 0_kIndex !% the size in bytes of hash output tIndex :: DigestLen = 32_kIndex !% the size in bytes of the buffer array tIndex :: BlockLen = 64_kIndex !% a copy of the specified key for keyed hashing tByte , ALLOCATABLE :: Key (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Additional Deferred Procedures            ----- ! --------------------------------------------------------------------- !> *SetBufPtr* is a binding name of the *BCSetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCSetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *BCProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCProcess ), DEFERRED :: ProcessBlock !> *EncodeOutput* is a binding name of the *BCEncode* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( BCEncode ), DEFERRED :: EncodeOutput ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Blake2Core_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Blake2Core_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Blake2Core_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Blake2Core_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *CoreInit* is a procedure to initialize the Blake2Core's components. <br> !  This procedure is NOT intended to be used by a user but all initialization procedures !  implemented by a *concrete* digest type should call this method. PROCEDURE :: CoreInit => Blake2Core_Init !> *CoreReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: CoreReset => Blake2Core_Reset !> *CoreClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: CoreClone => Blake2Core_Clone !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => Blake2Core_BufLen !> *GetKeyLen* is a procedure to get the length of the specified key. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetKeyLen => Blake2Core_KeyLen !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the hash output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake2Core_DigestLen ! --------------------------------------------------------------------- END TYPE Blake2Core !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> BCSetPtr is a deferred procedure to set the pointer *BufPtr* to !  the actual buffer array with starting index of zero. <br> SUBROUTINE BCSetPtr ( MD , BufPtr ) IMPORT CLASS ( Blake2Core ), TARGET , INTENT ( INOUT ) :: MD !! *Blake2Core* object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer END SUBROUTINE !> BCProcess is a deferred procedure to process one block of data. <br> SUBROUTINE BCProcess ( MD , BytesIn , LastBlock ) IMPORT CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! *Blake2Core* object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block tLogical , INTENT ( IN ) :: LastBlock !! true if input block is the last one END SUBROUTINE !> BCEncode is a deferred procedure to perform the encoding of the output data !  (e.g. unpacking the state variables into the output data). SUBROUTINE BCEncode ( MD , BytesOut ) IMPORT CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake2Core_Init ( MD , BlockLen , DigestLen , Key ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object tIndex , INTENT ( IN ) :: BlockLen !! block length tIndex , INTENT ( IN ) :: DigestLen !! digest length tByte , OPTIONAL , INTENT ( IN ) :: Key ( 0 :) !! key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: DefaultLen , KeyLen ! FLOW ! set block length MD % BlockLen = BlockLen ! set digest length DefaultLen = BlockLen / 2_kIndex IF (( DigestLen >= 1_kIndex ). AND .( DigestLen <= DefaultLen )) THEN MD % DigestLen = DigestLen ELSE MD % DigestLen = DefaultLen END IF ! allocate and copy key if present IF ( PRESENT ( Key )) THEN KeyLen = MIN ( SIZE ( Key , KIND = kIndex ), DefaultLen ) IF ( KeyLen > 0_kIndex ) THEN CALL MemAlloc ( MD % Key , KeyLen , StartID = 0_kIndex ) MD % Key ( 0 : KeyLen - 1 ) = Key ( 0 : KeyLen - 1 ) END IF ELSE CALL MemFree ( MD % Key ) END IF ! reset CALL MD % Reset () RETURN END SUBROUTINE Blake2Core_Init !****************************************************************************** SUBROUTINE Blake2Core_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: BufPtr (:) tIndex :: MinSize , KeyLen !** FLOW MD % BufLen = 0_kIndex KeyLen = MD % GetKeyLen () IF ( KeyLen > 0_kIndex ) THEN ! set pointer to the buffer array CALL MD % SetBufPtr ( BufPtr ) MinSize = MIN ( KeyLen , MD % BlockLen ) BufPtr ( 0 : MinSize - 1 ) = MD % Key ( 0 : MinSize - 1 ) IF ( MinSize < MD % BlockLen ) THEN BufPtr ( MinSize : MD % BlockLen - 1 ) = 0_kInt8 END IF MD % BufLen = MD % BlockLen NULLIFY ( BufPtr ) END IF RETURN END SUBROUTINE Blake2Core_Reset !****************************************************************************** SUBROUTINE Blake2Core_Clone ( SrcMD , DstMD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy components of the source digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( IN ) :: SrcMD !! source object CLASS ( Blake2Core ), INTENT ( INOUT ) :: DstMD !! destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DstMD % BufLen = SrcMD % BufLen DstMD % DigestLen = SrcMD % DigestLen DstMD % BlockLen = SrcMD % BlockLen CALL MemAlloc ( DstMD % Key , SIZE ( SrcMD % Key , KIND = kIndex ), StartID = 0_kIndex ) DstMD % Key = SrcMD % Key RETURN END SUBROUTINE Blake2Core_Clone !****************************************************************************** FUNCTION Blake2Core_BufLen ( MD ) RESULT ( BufLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of bytes of input currently stored in the buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( IN ) :: MD !! 'Blake2Core' object tIndex :: BufLen !! number of bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufLen = MD % BufLen RETURN END FUNCTION Blake2Core_BufLen !****************************************************************************** SUBROUTINE Blake2Core_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: BufPtr (:) tIndex :: CurrLen , CopyLen , CurrOff ! FLOW ! set pointer to the buffer array CALL MD % SetBufPtr ( BufPtr ) CurrLen = Length CurrOff = Offset DO WHILE ( CurrLen > 0_kIndex ) ! process the input if the buffer is full IF ( MD % BufLen == MD % BlockLen ) THEN CALL MD % ProcessBlock ( BufPtr , FalseVal ) MD % BufLen = 0_kIndex END IF CopyLen = MD % BlockLen - MD % BufLen IF ( CopyLen > CurrLen ) CopyLen = CurrLen ! store input in the buffer array BufPtr ( MD % BufLen : MD % BufLen + CopyLen - 1_kIndex ) = ByteArr ( CurrOff : CurrOff + CopyLen - 1_kIndex ) CurrOff = CurrOff + CopyLen MD % BufLen = MD % BufLen + CopyLen CurrLen = CurrLen - CopyLen END DO NULLIFY ( BufPtr ) RETURN END SUBROUTINE Blake2Core_InsertBytes !****************************************************************************** SUBROUTINE Blake2Core_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % Update ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE Blake2Core_InsertGen !****************************************************************************** SUBROUTINE Blake2Core_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: BufPtr (:) ! FLOW ! set pointer to the buffer array CALL MD % SetBufPtr ( BufPtr ) ! pad zero to the end of the buffer BufPtr ( MD % BufLen : MD % BlockLen - 1 ) = 0_kInt8 ! process the last block of data CALL MD % ProcessBlock ( BufPtr , TrueVal ) ! get output CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) CALL MD % EncodeOutput ( ByteArr ) ! reset the states CALL MD % Reset () ! free pointer NULLIFY ( BufPtr ) RETURN END SUBROUTINE Blake2Core_ByteDigest !****************************************************************************** SUBROUTINE Blake2Core_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( INOUT ) :: MD !! 'Blake2Core' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE Blake2Core_ByteDigest_wInput !****************************************************************************** FUNCTION Blake2Core_DigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( IN ) :: MD !! 'Blake2Core' object tIndex :: Length !! digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Blake2Core_DigestLen !****************************************************************************** FUNCTION Blake2Core_KeyLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get key length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2Core ), INTENT ( IN ) :: MD !! 'Blake2Key' object tIndex :: Length !! the key length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( MD % Key )) THEN Length = SIZE ( MD % Key , KIND = kIndex ) ELSE Length = 0_kIndex END IF RETURN END FUNCTION Blake2Core_KeyLen !****************************************************************************** END MODULE MClass_Blake2Core !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake2core.f90.html"},{"title":"MClass_Blake1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake1B* type and its related routines. !   The *Blake1B* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Blake1B* type implements an incremental cryptographic hash !   function by employing either the *BLAKE-384* or the *BLAKE-512 !   message-digest* algorithm where both algorithms are described in !   the *Hash Function BLAKE* book [1].  The implementation here is !   based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *Blake1B* type employs the *BLAKE-512 message-digest* !   algorithm.  However, a user can specify the *IsBLAKE384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *BLAKE-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.aumasson.jp/blake/book/\">J.P. Aumasson, W. Meier, !       R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Blake1B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tLong , PARAMETER :: IV384 ( 0 : 7 ) = [ & ToInt64 ( Z 'CBBB9D5DC1059ED8' ), ToInt64 ( Z '629A292A367CD507' ), & ToInt64 ( Z '9159015A3070DD17' ), ToInt64 ( Z '152FECD8F70E5939' ), & ToInt64 ( Z '67332667FFC00B31' ), ToInt64 ( Z '8EB44A8768581511' ), & ToInt64 ( Z 'DB0C2E0D64F98FA7' ), ToInt64 ( Z '47B5481DBEFA4FA4' )] tLong , PARAMETER :: IV512 ( 0 : 7 ) = [ & ToInt64 ( Z '6A09E667F3BCC908' ), ToInt64 ( Z 'BB67AE8584CAA73B' ), & ToInt64 ( Z '3C6EF372FE94F82B' ), ToInt64 ( Z 'A54FF53A5F1D36F1' ), & ToInt64 ( Z '510E527FADE682D1' ), ToInt64 ( Z '9B05688C2B3E6C1F' ), & ToInt64 ( Z '1F83D9ABFB41BD6B' ), ToInt64 ( Z '5BE0CD19137E2179' )] tIndex , PARAMETER :: SIGMA ( 0 : 255 ) = [ & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 , & 9 , 0 , 5 , 7 , 2 , 4 , 10 , 15 , 14 , 1 , 11 , 12 , 6 , 8 , 3 , 13 , & 2 , 12 , 6 , 10 , 0 , 11 , 8 , 3 , 4 , 13 , 7 , 5 , 15 , 14 , 1 , 9 , & 12 , 5 , 1 , 15 , 14 , 13 , 4 , 10 , 0 , 7 , 6 , 3 , 9 , 2 , 8 , 11 , & 13 , 11 , 7 , 14 , 12 , 1 , 3 , 9 , 5 , 0 , 15 , 4 , 8 , 6 , 2 , 10 , & 6 , 15 , 14 , 9 , 11 , 3 , 0 , 8 , 12 , 2 , 13 , 7 , 1 , 4 , 10 , 5 , & 10 , 2 , 8 , 4 , 7 , 6 , 1 , 5 , 15 , 11 , 9 , 14 , 3 , 12 , 13 , 0 , & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 , & 9 , 0 , 5 , 7 , 2 , 4 , 10 , 15 , 14 , 1 , 11 , 12 , 6 , 8 , 3 , 13 , & 2 , 12 , 6 , 10 , 0 , 11 , 8 , 3 , 4 , 13 , 7 , 5 , 15 , 14 , 1 , 9 ] tLong , PARAMETER :: CS ( 0 : 15 ) = [ & ToInt64 ( Z '243F6A8885A308D3' ), ToInt64 ( Z '13198A2E03707344' ), & ToInt64 ( Z 'A4093822299F31D0' ), ToInt64 ( Z '082EFA98EC4E6C89' ), & ToInt64 ( Z '452821E638D01377' ), ToInt64 ( Z 'BE5466CF34E90C6C' ), & ToInt64 ( Z 'C0AC29B7C97C50DD' ), ToInt64 ( Z '3F84D5B5B5470917' ), & ToInt64 ( Z '9216D5D98979FB1B' ), ToInt64 ( Z 'D1310BA698DFB5AC' ), & ToInt64 ( Z '2FFD72DBD01ADFB7' ), ToInt64 ( Z 'B8E1AFED6A267E96' ), & ToInt64 ( Z 'BA7C9045F12C7F99' ), ToInt64 ( Z '24A19947B3916CF7' ), & ToInt64 ( Z '0801F2E2858EFC16' ), ToInt64 ( Z '636920D871574E69' )] !** DERIVED TYPE DEFINITIONS !> *Blake1B* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *BLAKE-384* or the *BLAKE-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: Blake1B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tLong :: H ( 0 : 7 ) = IV512 ( 0 : 7 ) tLong :: S ( 0 : 3 ) = 0_kInt64 tLong :: T ( 0 : 1 ) = 0_kInt64 !% flag indicating whether the BLAKE-384 algorithm is employed or not. tLogical :: IsBLAKE384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => Blake1B_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BLAKE-512). PROCEDURE :: Initialize => Blake1B_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake1B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake1B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake1B_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake1B_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Blake1B_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake1B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake1B_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Blake1B_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Blake1B_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BLAKE-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BLAKE-384 algorithm <br> !   --->    CALL MD%Create(IsBLAKE384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE Blake1B !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake1B_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the BLAKE-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE Blake1B_Initialize !****************************************************************************** SUBROUTINE Blake1B_Initialize_wFlag ( MD , IsBLAKE384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object tLogical , INTENT ( IN ) :: IsBLAKE384 !&#94; flag indicating whether the BLAKE-384 algorithm is employed or not. <br> !  - If true, use the BLAKE-384 algorithm. <br> !  - Otherwise, use the BLAKE-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsBLAKE384 = IsBLAKE384 CALL MD % Reset () RETURN END SUBROUTINE Blake1B_Initialize_wFlag !****************************************************************************** SUBROUTINE Blake1B_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % S = 0_kInt64 MD % T = 0_kInt64 IF ( MD % IsBLAKE384 ) THEN MD % H = IV384 ELSE MD % H = IV512 END IF CALL MD % EngineReset () RETURN END SUBROUTINE Blake1B_Reset !****************************************************************************** SUBROUTINE Blake1B_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Blake1B :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Blake1B ) CALL Dst % Create ( Src % IsBLAKE384 ) Dst % H = Src % H Dst % S = Src % S Dst % T = Src % T Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE Blake1B_GetClone !****************************************************************************** FUNCTION Blake1B_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( IN ) :: MD !! 'Blake1B' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBLAKE384 ) THEN Name = 'BLAKE-384' ELSE Name = 'BLAKE-512' END IF RETURN END FUNCTION Blake1B_GetName !****************************************************************************** FUNCTION Blake1B_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( IN ) :: MD !! 'Blake1B' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBLAKE384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION Blake1B_GetDigestLen !****************************************************************************** FUNCTION Blake1B_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( IN ) :: MD !! 'Blake1B' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION Blake1B_GetBlockLen !****************************************************************************** SUBROUTINE Blake1B_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), TARGET , INTENT ( INOUT ) :: MD !! 'Blake1B' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Blake1B_SetBufPtr !****************************************************************************** SUBROUTINE Blake1B_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: M ( 0 : 15 ) ! FLOW ! initialize MD % T ( 0 ) = MD % T ( 0 ) + 1024_kInt64 IF ( IAND ( MD % T ( 0 ), NOT ( ToInt64 ( Z '00000000000003FF' ))) == 0_kInt64 ) MD % T ( 1 ) = MD % T ( 1 ) + 1 ! input block CALL BytePackBE ( BytesIn , 0_kIndex , M ) ! perform block transformation CALL Process_One_Block ( MD , M ) RETURN CONTAINS SUBROUTINE Process_One_Block ( MD , M ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD ! 'Blake1B' object tLong , INTENT ( IN ) :: M ( 0 : 15 ) ! the message block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: V ( 0 : 15 ) tIndex :: I , J , R tIndex :: K ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define IEOR2(X, Y, Z)      IEOR(IEOR(X, Y), Z) #define LShift4(X)          SHIFTL(X, 4) #define GB(K0, K1, A, B, C, D) \\ A = A + B + ( IEOR ( M ( K0 ), CS ( K1 ))); \\ D = RotateRight ( IEOR ( D , A ), 32 ); \\ C = C + D ; \\ B = RotateRight ( IEOR ( B , C ), 25 ); \\ A = A + B + ( IEOR ( M ( K1 ), CS ( K0 ))); \\ D = RotateRight ( IEOR ( D , A ), 16 ); \\ C = C + D ; \\ B = RotateRight ( IEOR ( B , C ), 11 ); ! FLOW ! initialize V ( 0 : 3 ) = MD % S ( 0 : 3 ) V ( 4 : 5 ) = MD % T ( 0 ) V ( 6 : 7 ) = MD % T ( 1 ) DO I = 0 , 7 V ( I + 8 ) = IEOR ( V ( I ), CS ( I )) END DO V ( 0 : 7 ) = MD % H ( 0 : 7 ) ! perform block transformation DO R = 0 , 15 ! compute indices DO I = 0 , 15 K ( I ) = SIGMA ( LShift4 ( R ) + I ) END DO ! perform core operations GB ( K ( 0 ), K ( 1 ), V ( 0 ), V ( 4 ), V ( 8 ), V ( 12 )) GB ( K ( 2 ), K ( 3 ), V ( 1 ), V ( 5 ), V ( 9 ), V ( 13 )) GB ( K ( 4 ), K ( 5 ), V ( 2 ), V ( 6 ), V ( 10 ), V ( 14 )) GB ( K ( 6 ), K ( 7 ), V ( 3 ), V ( 7 ), V ( 11 ), V ( 15 )) GB ( K ( 8 ), K ( 9 ), V ( 0 ), V ( 5 ), V ( 10 ), V ( 15 )) GB ( K ( 10 ), K ( 11 ), V ( 1 ), V ( 6 ), V ( 11 ), V ( 12 )) GB ( K ( 12 ), K ( 13 ), V ( 2 ), V ( 7 ), V ( 8 ), V ( 13 )) GB ( K ( 14 ), K ( 15 ), V ( 3 ), V ( 4 ), V ( 9 ), V ( 14 )) END DO ! update H DO I = 0 , 7 J = I IF ( J > 3 ) J = J - 4 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR2 ( MD % S ( J ), V ( I ), V ( I + 8 ))) END DO #undef IEOR2 #undef LShift4 #undef GB RETURN END SUBROUTINE Process_One_Block !************************************************************************** END SUBROUTINE Blake1B_ProcessBlock !****************************************************************************** SUBROUTINE Blake1B_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE Blake1B_DoPadding !****************************************************************************** SUBROUTINE Blake1B_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1B ), INTENT ( INOUT ) :: MD !! 'Blake1B' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , BitLen , I tLong :: TH , TL tByte :: Z ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) TmpBuf = 0_kInt8 Ptr = MD % GetBufLen () BitLen = SHIFTL ( Ptr , 3 ) + NBits Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) TL = MD % T ( 0 ) + BitLen TH = MD % T ( 1 ) IF (( Ptr == 0_kIndex ). AND .( NBits == 0_kIndex )) THEN MD % T ( 0 ) = ToInt64 ( Z 'FFFFFFFFFFFFFC00' ) MD % T ( 1 ) = ToInt64 ( Z 'FFFFFFFFFFFFFFFF' ) ELSEIF ( MD % T ( 0 ) == 0 ) THEN MD % T ( 0 ) = ToInt64 ( Z 'FFFFFFFFFFFFFC00' ) + ToInt64 ( BitLen ) MD % T ( 1 ) = MD % T ( 1 ) - 1_kInt64 ELSE MD % T ( 0 ) = MD % T ( 0 ) - ToInt64 ( 1024 - BitLen ) END IF IF ( BitLen <= 894_kIndex ) THEN TmpBuf ( Ptr + 1 : 111 ) = FByte00 IF ( MD % GetDigestLen () == 64_kIndex ) TmpBuf ( 111 ) = IOR ( TmpBuf ( 111 ), FByte01 ) CALL ByteUnpackBE ( TH , TmpBuf , 112_kIndex ) CALL ByteUnpackBE ( TL , TmpBuf , 120_kIndex ) CALL MD % Update ( TmpBuf , Ptr , 128_kIndex - Ptr ) ELSE TmpBuf ( Ptr + 1 : 127 ) = FByte00 CALL MD % Update ( TmpBuf , Ptr , 128_kIndex - Ptr ) MD % T ( 0 ) = ToInt64 ( Z 'FFFFFFFFFFFFFC00' ) MD % T ( 1 ) = ToInt64 ( Z 'FFFFFFFFFFFFFFFF' ) TmpBuf ( 0 : 111 ) = FByte00 IF ( MD % GetDigestLen () == 64_kIndex ) TmpBuf ( 111 ) = FByte01 CALL ByteUnpackBE ( TH , TmpBuf , 112_kIndex ) CALL ByteUnpackBE ( TL , TmpBuf , 120_kIndex ) CALL MD % Update ( TmpBuf , 0_kIndex , 128_kIndex ) END IF END ASSOCIATE DO I = 0_kIndex , ( MD % GetDigestLen () / 8_kIndex - 1_kIndex ) CALL ByteUnpackBE ( MD % H ( I ), BytesOut , Offset + 8_kIndex * I ) END DO RETURN END SUBROUTINE Blake1B_AddBitsNPad !****************************************************************************** END MODULE MClass_Blake1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake1b.f90.html"},{"title":"MClass_Luffa.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Luffa !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Luffa* type and its related routines. !   The *Luffa* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Luffa* type implements an incremental cryptographic hash !   function by employing the *Luffa message-digest* algorithm [1].  The !   implementation here is mainly based on the references [2]. <br> !   The *Luffa* type represents four cryptographic hash functions: !   the *Luffa-224*, *Luffa-256*, *Luffa-384*, and *Luffa-512* hash !   functions.  By default, the *Luffa* type represents the *Luffa-256* !   hash function.  However, a user can specify the *Security* argument !   (to one of the four applicable values: 224, 256, 384 and 512) when !   initializing the digest object in order to use a different hash !   function and get a different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.hitachi.com/rd/yrl/crypto/luffa/\">The Hash Function !       Family Luffa (Round 2 Archive). </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Luffa PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 32_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: V_INIT ( 0 : 7 , 0 : 4 ) = RESHAPE ([ & ToInt32 ( Z '6D251E69' ), ToInt32 ( Z '44B051E0' ), & ToInt32 ( Z '4EAA6FB4' ), ToInt32 ( Z 'DBF78465' ), & ToInt32 ( Z '6E292011' ), ToInt32 ( Z '90152DF4' ), & ToInt32 ( Z 'EE058139' ), ToInt32 ( Z 'DEF610BB' ), & ToInt32 ( Z 'C3B44B95' ), ToInt32 ( Z 'D9D2F256' ), & ToInt32 ( Z '70EEE9A0' ), ToInt32 ( Z 'DE099FA3' ), & ToInt32 ( Z '5D9B0557' ), ToInt32 ( Z '8FC944B3' ), & ToInt32 ( Z 'CF1CCF0E' ), ToInt32 ( Z '746CD581' ), & ToInt32 ( Z 'F7EFC89D' ), ToInt32 ( Z '5DBA5781' ), & ToInt32 ( Z '04016CE5' ), ToInt32 ( Z 'AD659C05' ), & ToInt32 ( Z '0306194F' ), ToInt32 ( Z '666D1836' ), & ToInt32 ( Z '24AA230A' ), ToInt32 ( Z '8B264AE7' ), & ToInt32 ( Z '858075D5' ), ToInt32 ( Z '36D79CCE' ), & ToInt32 ( Z 'E571F7D7' ), ToInt32 ( Z '204B1F67' ), & ToInt32 ( Z '35870C6A' ), ToInt32 ( Z '57E9E923' ), & ToInt32 ( Z '14BCB808' ), ToInt32 ( Z '7CDE72CE' ), & ToInt32 ( Z '6C68E9BE' ), ToInt32 ( Z '5EC41E22' ), & ToInt32 ( Z 'C825B7C7' ), ToInt32 ( Z 'AFFB4363' ), & ToInt32 ( Z 'F5DF3999' ), ToInt32 ( Z '0FC688F1' ), & ToInt32 ( Z 'B07224CC' ), ToInt32 ( Z '03E86CEA' )], [ 8 , 5 ]) tInteger , PARAMETER :: RC00 ( 0 : 7 ) = [ & ToInt32 ( Z '303994A6' ), ToInt32 ( Z 'C0E65299' ), & ToInt32 ( Z '6CC33A12' ), ToInt32 ( Z 'DC56983E' ), & ToInt32 ( Z '1E00108F' ), ToInt32 ( Z '7800423D' ), & ToInt32 ( Z '8F5B7882' ), ToInt32 ( Z '96E1DB12' )] tInteger , PARAMETER :: RC04 ( 0 : 7 ) = [ & ToInt32 ( Z 'E0337818' ), ToInt32 ( Z '441BA90D' ), & ToInt32 ( Z '7F34D442' ), ToInt32 ( Z '9389217F' ), & ToInt32 ( Z 'E5A8BCE6' ), ToInt32 ( Z '5274BAF4' ), & ToInt32 ( Z '26889BA7' ), ToInt32 ( Z '9A226E9D' )] tInteger , PARAMETER :: RC10 ( 0 : 7 ) = [ & ToInt32 ( Z 'B6DE10ED' ), ToInt32 ( Z '70F47AAE' ), & ToInt32 ( Z '0707A3D4' ), ToInt32 ( Z '1C1E8F51' ), & ToInt32 ( Z '707A3D45' ), ToInt32 ( Z 'AEB28562' ), & ToInt32 ( Z 'BACA1589' ), ToInt32 ( Z '40A46F3E' )] tInteger , PARAMETER :: RC14 ( 0 : 7 ) = [ & ToInt32 ( Z '01685F3D' ), ToInt32 ( Z '05A17CF4' ), & ToInt32 ( Z 'BD09CACA' ), ToInt32 ( Z 'F4272B28' ), & ToInt32 ( Z '144AE5CC' ), ToInt32 ( Z 'FAA7AE2B' ), & ToInt32 ( Z '2E48F1C1' ), ToInt32 ( Z 'B923C704' )] tInteger , PARAMETER :: RC20 ( 0 : 7 ) = [ & ToInt32 ( Z 'FC20D9D2' ), ToInt32 ( Z '34552E25' ), & ToInt32 ( Z '7AD8818F' ), ToInt32 ( Z '8438764A' ), & ToInt32 ( Z 'BB6DE032' ), ToInt32 ( Z 'EDB780C8' ), & ToInt32 ( Z 'D9847356' ), ToInt32 ( Z 'A2C78434' )] tInteger , PARAMETER :: RC24 ( 0 : 7 ) = [ & ToInt32 ( Z 'E25E72C1' ), ToInt32 ( Z 'E623BB72' ), & ToInt32 ( Z '5C58A4A4' ), ToInt32 ( Z '1E38E2E7' ), & ToInt32 ( Z '78E38B9D' ), ToInt32 ( Z '27586719' ), & ToInt32 ( Z '36EDA57F' ), ToInt32 ( Z '703AACE7' )] tInteger , PARAMETER :: RC30 ( 0 : 7 ) = [ & ToInt32 ( Z 'B213AFA5' ), ToInt32 ( Z 'C84EBE95' ), & ToInt32 ( Z '4E608A22' ), ToInt32 ( Z '56D858FE' ), & ToInt32 ( Z '343B138F' ), ToInt32 ( Z 'D0EC4E3D' ), & ToInt32 ( Z '2CEB4882' ), ToInt32 ( Z 'B3AD2208' )] tInteger , PARAMETER :: RC34 ( 0 : 7 ) = [ & ToInt32 ( Z 'E028C9BF' ), ToInt32 ( Z '44756F91' ), & ToInt32 ( Z '7E8FCE32' ), ToInt32 ( Z '956548BE' ), & ToInt32 ( Z 'FE191BE2' ), ToInt32 ( Z '3CB226E5' ), & ToInt32 ( Z '5944A28E' ), ToInt32 ( Z 'A1C4C355' )] tInteger , PARAMETER :: RC40 ( 0 : 7 ) = [ & ToInt32 ( Z 'F0D2E9E3' ), ToInt32 ( Z 'AC11D7FA' ), & ToInt32 ( Z '1BCB66F2' ), ToInt32 ( Z '6F2D9BC9' ), & ToInt32 ( Z '78602649' ), ToInt32 ( Z '8EDAE952' ), & ToInt32 ( Z '3B6BA548' ), ToInt32 ( Z 'EDAE9520' )] tInteger , PARAMETER :: RC44 ( 0 : 7 ) = [ & ToInt32 ( Z '5090D577' ), ToInt32 ( Z '2D1925AB' ), & ToInt32 ( Z 'B46496AC' ), ToInt32 ( Z 'D1925AB0' ), & ToInt32 ( Z '29131AB6' ), ToInt32 ( Z '0FC053C3' ), & ToInt32 ( Z '3F014F0C' ), ToInt32 ( Z 'FC053C31' )] !** DERIVED TYPE DEFINITIONS !> *Luffa* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Luffa hash functions. TYPE , EXTENDS ( MDEngine ) :: Luffa PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and its storage tInteger :: Store ( 0 : 7 , 0 : 4 ) = 0 tInteger , POINTER :: State (:,:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => Luffa_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Luffa-256). PROCEDURE :: Initialize => Luffa_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Luffa_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Luffa_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Luffa_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Luffa_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Luffa_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Luffa_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Luffa_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Luffa_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Luffa_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Luffa-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Luffa-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity ! --------------------------------------------------------------------- FINAL :: Luffa_Finalize ! --------------------------------------------------------------------- END TYPE Luffa !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Luffa_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Create ( 256 ) RETURN END SUBROUTINE Luffa_Initialize !****************************************************************************** SUBROUTINE Luffa_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), TARGET , INTENT ( INOUT ) :: MD !! 'Luffa' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT SELECT CASE ( MD % Security ) CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT SELECT CASE ( MD % DigestLen ) CASE ( 28 , 32 ) !        MD%State(0:7,0:2) => MD%Store(0:7,0:2) MD % State ( 0 : 7 , 0 : 2 ) => MD % Store CASE ( 48 ) !        MD%State(0:7,0:3) => MD%Store(0:7,0:3) MD % State ( 0 : 7 , 0 : 3 ) => MD % Store CASE ( 64 ) !        MD%State(0:7,0:4) => MD%Store(0:7,0:4) MD % State ( 0 : 7 , 0 : 4 ) => MD % Store END SELECT CALL MD % Reset () RETURN END SUBROUTINE Luffa_Initialize_wSecurity !****************************************************************************** SUBROUTINE Luffa_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW MD % BufArr = 0_kInt8 IF ( ASSOCIATED ( MD % State )) THEN DO I = 0 , SIZE ( MD % State , DIM = 2 ) - 1 MD % State (:, I ) = V_INIT (:, I ) END DO ELSE MD % Store = V_INIT END IF CALL MD % EngineReset () RETURN END SUBROUTINE Luffa_Reset !****************************************************************************** SUBROUTINE Luffa_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Luffa :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Luffa ) CALL Dst % Create ( Src % Security ) Dst % Store = Src % Store Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE Luffa_GetClone !****************************************************************************** FUNCTION Luffa_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( IN ) :: MD !! 'Luffa' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'Luffa-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION Luffa_GetName !****************************************************************************** FUNCTION Luffa_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( IN ) :: MD !! 'Luffa' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Luffa_GetDigestLen !****************************************************************************** FUNCTION Luffa_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( IN ) :: MD !! 'Luffa' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION Luffa_GetBlockLen !****************************************************************************** SUBROUTINE Luffa_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), TARGET , INTENT ( INOUT ) :: MD !! 'Luffa' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Luffa_SetBufPtr !****************************************************************************** SUBROUTINE Luffa_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( MD % DigestLen ) CASE ( 28 , 32 ) CALL LuffaCore_Process3 ( MD % State (:, 0 ), MD % State (:, 1 ), MD % State (:, 2 ), BytesIn ) CASE ( 48 ) CALL LuffaCore_Process4 ( MD % State (:, 0 ), MD % State (:, 1 ), MD % State (:, 2 ), & MD % State (:, 3 ), BytesIn ) CASE ( 64 ) CALL LuffaCore_Process5 ( MD % State (:, 0 ), MD % State (:, 1 ), MD % State (:, 2 ), & MD % State (:, 3 ), MD % State (:, 4 ), BytesIn ) END SELECT RETURN END SUBROUTINE Luffa_ProcessBlock !****************************************************************************** SUBROUTINE Luffa_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE Luffa_DoPadding !****************************************************************************** SUBROUTINE Luffa_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: TmpBuf ( 0 : 31 ) tIndex :: Ptr , DLen tByte :: Z ! FLOW Ptr = MD % GetBufLen () Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) TmpBuf ( Ptr + 1 : 31 ) = FByte00 CALL MD % Update ( TmpBuf , Ptr , 32_kIndex - Ptr ) TmpBuf ( 0 : Ptr ) = FByte00 CALL MD % Update ( TmpBuf , 0_kIndex , 32_kIndex ) DLen = MD % DigestLen SELECT CASE ( DLen ) CASE ( 28 , 32 ) CALL LuffaCore_GetOutput ( MD , DLen , BytesOut , Offset , MD % State (:, 0 ), & MD % State (:, 1 ), MD % State (:, 2 )) CASE ( 48 ) CALL LuffaCore_GetOutput ( MD , DLen , BytesOut , Offset , MD % State (:, 0 ), & MD % State (:, 1 ), MD % State (:, 2 ), MD % State (:, 3 )) CASE ( 64 ) CALL LuffaCore_GetOutput ( MD , DLen , BytesOut , Offset , MD % State (:, 0 ), & MD % State (:, 1 ), MD % State (:, 2 ), MD % State (:, 3 ), & MD % State (:, 4 )) END SELECT RETURN CONTAINS SUBROUTINE LuffaCore_GetOutput ( MD , DigestLen , BytesOut , Offset , VC0 , VC1 , VC2 , VC3 , VC4 ) !** PURPOSE OF THIS SUBROUTINE: ! To get output. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Luffa ), INTENT ( INOUT ) :: MD tIndex , INTENT ( IN ) :: DigestLen tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) tIndex , INTENT ( IN ) :: Offset tInteger , INTENT ( INOUT ) :: VC0 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC1 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC2 ( 0 : 7 ) tInteger , OPTIONAL , INTENT ( INOUT ) :: VC3 ( 0 : 7 ) tInteger , OPTIONAL , INTENT ( INOUT ) :: VC4 ( 0 : 7 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: TmpBuf ( 0 : 31 ) tInteger :: Output tIndex :: I , CurOff !** SUBROUTINE MACRO DEFINITIONS: #define IEOR_3(A, B, C)         IEOR(IEOR(A, B), C) #define IEOR_4(A, B, C, D)      IEOR(IEOR_3(A, B, C), D) #define IEOR_5(A, B, C, D, E)   IEOR(IEOR_4(A, B, C, D), E) ! FLOW SELECT CASE ( DigestLen ) CASE ( 28 ) CurOff = Offset DO I = 0 , 6 Output = IEOR_3 ( VC0 ( I ), VC1 ( I ), VC2 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO CASE ( 32 ) CurOff = Offset DO I = 0 , 7 Output = IEOR_3 ( VC0 ( I ), VC1 ( I ), VC2 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO CASE ( 48 ) CurOff = Offset DO I = 0 , 7 Output = IEOR_4 ( VC0 ( I ), VC1 ( I ), VC2 ( I ), VC3 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO TmpBuf = 0_kInt8 CALL MD % Update ( TmpBuf , 0_kIndex , 32_kIndex ) DO I = 0 , 3 Output = IEOR_4 ( VC0 ( I ), VC1 ( I ), VC2 ( I ), VC3 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO CASE ( 64 ) CurOff = Offset DO I = 0 , 7 Output = IEOR_5 ( VC0 ( I ), VC1 ( I ), VC2 ( I ), VC3 ( I ), VC4 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO TmpBuf = 0_kInt8 CALL MD % Update ( TmpBuf , 0_kIndex , 32_kIndex ) DO I = 0 , 7 Output = IEOR_5 ( VC0 ( I ), VC1 ( I ), VC2 ( I ), VC3 ( I ), VC4 ( I )) CALL ByteUnpackBE ( Output , BytesOut , CurOff ) CurOff = CurOff + 4_kIndex END DO END SELECT RETURN #undef IEOR_3 #undef IEOR_4 #undef IEOR_5 END SUBROUTINE LuffaCore_GetOutput !************************************************************************** END SUBROUTINE Luffa_AddBitsNPad !****************************************************************************** SUBROUTINE Luffa_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Luffa ), INTENT ( INOUT ) :: MD !! 'Luffa' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % State ) RETURN END SUBROUTINE Luffa_Finalize !****************************************************************************** SUBROUTINE LuffaCore_Process3 ( VC0 , VC1 , VC2 , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: VC0 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC1 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC2 ( 0 : 7 ) tByte , INTENT ( IN ) :: BytesIn ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 7 ) tInteger :: A ( 0 : 7 ) tInteger :: Tmp tIndex :: I !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/Luffa_Def Macro.f90\" ! FLOW ! MI3(BytesIn, VC0, VC1, VC2) CALL BytePackBE ( BytesIn , 0_kIndex , M ) XOR_ALL ( A , VC0 , VC1 ) XOR_ALL ( A , A , VC2 ) M2 ( A , A ) XOR_ALL ( VC0 , A , VC0 ) XOR_ALL ( VC0 , M , VC0 ) M2 ( M , M ) XOR_ALL ( VC1 , A , VC1 ) XOR_ALL ( VC1 , M , VC1 ) M2 ( M , M ) XOR_ALL ( VC2 , A , VC2 ) XOR_ALL ( VC2 , M , VC2 ) ! P3(VC0, VC1, VC2) TWEAK3 ( VC1 , VC2 ) DO I = 0 , 7 SUB_CRUMB ( VC0 ( 0 ), VC0 ( 1 ), VC0 ( 2 ), VC0 ( 3 )) SUB_CRUMB ( VC0 ( 5 ), VC0 ( 6 ), VC0 ( 7 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 0 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 1 ), VC0 ( 5 )) MIX_WORD ( VC0 ( 2 ), VC0 ( 6 )) MIX_WORD ( VC0 ( 3 ), VC0 ( 7 )) VC0 ( 0 ) = IEOR ( VC0 ( 0 ), RC00 ( I )) VC0 ( 4 ) = IEOR ( VC0 ( 4 ), RC04 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC1 ( 0 ), VC1 ( 1 ), VC1 ( 2 ), VC1 ( 3 )) SUB_CRUMB ( VC1 ( 5 ), VC1 ( 6 ), VC1 ( 7 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 0 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 1 ), VC1 ( 5 )) MIX_WORD ( VC1 ( 2 ), VC1 ( 6 )) MIX_WORD ( VC1 ( 3 ), VC1 ( 7 )) VC1 ( 0 ) = IEOR ( VC1 ( 0 ), RC10 ( I )) VC1 ( 4 ) = IEOR ( VC1 ( 4 ), RC14 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC2 ( 0 ), VC2 ( 1 ), VC2 ( 2 ), VC2 ( 3 )) SUB_CRUMB ( VC2 ( 5 ), VC2 ( 6 ), VC2 ( 7 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 0 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 1 ), VC2 ( 5 )) MIX_WORD ( VC2 ( 2 ), VC2 ( 6 )) MIX_WORD ( VC2 ( 3 ), VC2 ( 7 )) VC2 ( 0 ) = IEOR ( VC2 ( 0 ), RC20 ( I )) VC2 ( 4 ) = IEOR ( VC2 ( 4 ), RC24 ( I )) END DO RETURN #include    \"Includes/Luffa_Undef Macro.f90\" END SUBROUTINE LuffaCore_Process3 !****************************************************************************** SUBROUTINE LuffaCore_Process4 ( VC0 , VC1 , VC2 , VC3 , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: VC0 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC1 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC2 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC3 ( 0 : 7 ) tByte , INTENT ( IN ) :: BytesIn ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 7 ) tInteger :: A ( 0 : 7 ) tInteger :: B ( 0 : 7 ) tInteger :: Tmp tIndex :: I !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/Luffa_Def Macro.f90\" ! FLOW ! MI4(BytesIn, VC0, VC1, VC2, VC3) CALL BytePackBE ( BytesIn , 0_kIndex , M ) XOR_ALL ( A , VC0 , VC1 ) XOR_ALL ( B , VC2 , VC3 ) XOR_ALL ( A , A , B ) M2 ( A , A ) XOR_ALL ( VC0 , A , VC0 ) XOR_ALL ( VC1 , A , VC1 ) XOR_ALL ( VC2 , A , VC2 ) XOR_ALL ( VC3 , A , VC3 ) M2 ( B , VC0 ) XOR_ALL ( B , B , VC3 ) M2 ( VC3 , VC3 ) XOR_ALL ( VC3 , VC3 , VC2 ) M2 ( VC2 , VC2 ) XOR_ALL ( VC2 , VC2 , VC1 ) M2 ( VC1 , VC1 ) XOR_ALL ( VC1 , VC1 , VC0 ) XOR_ALL ( VC0 , B , M ) M2 ( M , M ) XOR_ALL ( VC1 , VC1 , M ) M2 ( M , M ) XOR_ALL ( VC2 , VC2 , M ) M2 ( M , M ) XOR_ALL ( VC3 , VC3 , M ) ! P4(VC0, VC1, VC2, VC3) TWEAK4 ( VC1 , VC2 , VC3 ) DO I = 0 , 7 SUB_CRUMB ( VC0 ( 0 ), VC0 ( 1 ), VC0 ( 2 ), VC0 ( 3 )) SUB_CRUMB ( VC0 ( 5 ), VC0 ( 6 ), VC0 ( 7 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 0 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 1 ), VC0 ( 5 )) MIX_WORD ( VC0 ( 2 ), VC0 ( 6 )) MIX_WORD ( VC0 ( 3 ), VC0 ( 7 )) VC0 ( 0 ) = IEOR ( VC0 ( 0 ), RC00 ( I )) VC0 ( 4 ) = IEOR ( VC0 ( 4 ), RC04 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC1 ( 0 ), VC1 ( 1 ), VC1 ( 2 ), VC1 ( 3 )) SUB_CRUMB ( VC1 ( 5 ), VC1 ( 6 ), VC1 ( 7 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 0 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 1 ), VC1 ( 5 )) MIX_WORD ( VC1 ( 2 ), VC1 ( 6 )) MIX_WORD ( VC1 ( 3 ), VC1 ( 7 )) VC1 ( 0 ) = IEOR ( VC1 ( 0 ), RC10 ( I )) VC1 ( 4 ) = IEOR ( VC1 ( 4 ), RC14 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC2 ( 0 ), VC2 ( 1 ), VC2 ( 2 ), VC2 ( 3 )) SUB_CRUMB ( VC2 ( 5 ), VC2 ( 6 ), VC2 ( 7 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 0 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 1 ), VC2 ( 5 )) MIX_WORD ( VC2 ( 2 ), VC2 ( 6 )) MIX_WORD ( VC2 ( 3 ), VC2 ( 7 )) VC2 ( 0 ) = IEOR ( VC2 ( 0 ), RC20 ( I )) VC2 ( 4 ) = IEOR ( VC2 ( 4 ), RC24 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC3 ( 0 ), VC3 ( 1 ), VC3 ( 2 ), VC3 ( 3 )) SUB_CRUMB ( VC3 ( 5 ), VC3 ( 6 ), VC3 ( 7 ), VC3 ( 4 )) MIX_WORD ( VC3 ( 0 ), VC3 ( 4 )) MIX_WORD ( VC3 ( 1 ), VC3 ( 5 )) MIX_WORD ( VC3 ( 2 ), VC3 ( 6 )) MIX_WORD ( VC3 ( 3 ), VC3 ( 7 )) VC3 ( 0 ) = IEOR ( VC3 ( 0 ), RC30 ( I )) VC3 ( 4 ) = IEOR ( VC3 ( 4 ), RC34 ( I )) END DO RETURN #include    \"Includes/Luffa_Undef Macro.f90\" END SUBROUTINE LuffaCore_Process4 !****************************************************************************** SUBROUTINE LuffaCore_Process5 ( VC0 , VC1 , VC2 , VC3 , VC4 , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: VC0 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC1 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC2 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC3 ( 0 : 7 ) tInteger , INTENT ( INOUT ) :: VC4 ( 0 : 7 ) tByte , INTENT ( IN ) :: BytesIn ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 7 ) tInteger :: A ( 0 : 7 ) tInteger :: B ( 0 : 7 ) tInteger :: Tmp tIndex :: I !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/Luffa_Def Macro.f90\" ! FLOW ! MI5(BytesIn, VC0, VC1, VC2, VC3, VC4) CALL BytePackBE ( BytesIn , 0_kIndex , M ) XOR_ALL ( A , VC0 , VC1 ) XOR_ALL ( B , VC2 , VC3 ) XOR_ALL ( A , A , B ) XOR_ALL ( A , A , VC4 ) M2 ( A , A ) XOR_ALL ( VC0 , A , VC0 ) XOR_ALL ( VC1 , A , VC1 ) XOR_ALL ( VC2 , A , VC2 ) XOR_ALL ( VC3 , A , VC3 ) XOR_ALL ( VC4 , A , VC4 ) M2 ( B , VC0 ) XOR_ALL ( B , B , VC1 ) M2 ( VC1 , VC1 ) XOR_ALL ( VC1 , VC1 , VC2 ) M2 ( VC2 , VC2 ) XOR_ALL ( VC2 , VC2 , VC3 ) M2 ( VC3 , VC3 ) XOR_ALL ( VC3 , VC3 , VC4 ) M2 ( VC4 , VC4 ) XOR_ALL ( VC4 , VC4 , VC0 ) M2 ( VC0 , B ) XOR_ALL ( VC0 , VC0 , VC4 ) M2 ( VC4 , VC4 ) XOR_ALL ( VC4 , VC4 , VC3 ) M2 ( VC3 , VC3 ) XOR_ALL ( VC3 , VC3 , VC2 ) M2 ( VC2 , VC2 ) XOR_ALL ( VC2 , VC2 , VC1 ) M2 ( VC1 , VC1 ) XOR_ALL ( VC1 , VC1 , B ) XOR_ALL ( VC0 , VC0 , M ) M2 ( M , M ) XOR_ALL ( VC1 , VC1 , M ) M2 ( M , M ) XOR_ALL ( VC2 , VC2 , M ) M2 ( M , M ) XOR_ALL ( VC3 , VC3 , M ) M2 ( M , M ) XOR_ALL ( VC4 , VC4 , M ) ! P5(VC0, VC1, VC2, VC3, VC4) TWEAK5 ( VC1 , VC2 , VC3 , VC4 ) DO I = 0 , 7 SUB_CRUMB ( VC0 ( 0 ), VC0 ( 1 ), VC0 ( 2 ), VC0 ( 3 )) SUB_CRUMB ( VC0 ( 5 ), VC0 ( 6 ), VC0 ( 7 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 0 ), VC0 ( 4 )) MIX_WORD ( VC0 ( 1 ), VC0 ( 5 )) MIX_WORD ( VC0 ( 2 ), VC0 ( 6 )) MIX_WORD ( VC0 ( 3 ), VC0 ( 7 )) VC0 ( 0 ) = IEOR ( VC0 ( 0 ), RC00 ( I )) VC0 ( 4 ) = IEOR ( VC0 ( 4 ), RC04 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC1 ( 0 ), VC1 ( 1 ), VC1 ( 2 ), VC1 ( 3 )) SUB_CRUMB ( VC1 ( 5 ), VC1 ( 6 ), VC1 ( 7 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 0 ), VC1 ( 4 )) MIX_WORD ( VC1 ( 1 ), VC1 ( 5 )) MIX_WORD ( VC1 ( 2 ), VC1 ( 6 )) MIX_WORD ( VC1 ( 3 ), VC1 ( 7 )) VC1 ( 0 ) = IEOR ( VC1 ( 0 ), RC10 ( I )) VC1 ( 4 ) = IEOR ( VC1 ( 4 ), RC14 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC2 ( 0 ), VC2 ( 1 ), VC2 ( 2 ), VC2 ( 3 )) SUB_CRUMB ( VC2 ( 5 ), VC2 ( 6 ), VC2 ( 7 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 0 ), VC2 ( 4 )) MIX_WORD ( VC2 ( 1 ), VC2 ( 5 )) MIX_WORD ( VC2 ( 2 ), VC2 ( 6 )) MIX_WORD ( VC2 ( 3 ), VC2 ( 7 )) VC2 ( 0 ) = IEOR ( VC2 ( 0 ), RC20 ( I )) VC2 ( 4 ) = IEOR ( VC2 ( 4 ), RC24 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC3 ( 0 ), VC3 ( 1 ), VC3 ( 2 ), VC3 ( 3 )) SUB_CRUMB ( VC3 ( 5 ), VC3 ( 6 ), VC3 ( 7 ), VC3 ( 4 )) MIX_WORD ( VC3 ( 0 ), VC3 ( 4 )) MIX_WORD ( VC3 ( 1 ), VC3 ( 5 )) MIX_WORD ( VC3 ( 2 ), VC3 ( 6 )) MIX_WORD ( VC3 ( 3 ), VC3 ( 7 )) VC3 ( 0 ) = IEOR ( VC3 ( 0 ), RC30 ( I )) VC3 ( 4 ) = IEOR ( VC3 ( 4 ), RC34 ( I )) END DO DO I = 0 , 7 SUB_CRUMB ( VC4 ( 0 ), VC4 ( 1 ), VC4 ( 2 ), VC4 ( 3 )) SUB_CRUMB ( VC4 ( 5 ), VC4 ( 6 ), VC4 ( 7 ), VC4 ( 4 )) MIX_WORD ( VC4 ( 0 ), VC4 ( 4 )) MIX_WORD ( VC4 ( 1 ), VC4 ( 5 )) MIX_WORD ( VC4 ( 2 ), VC4 ( 6 )) MIX_WORD ( VC4 ( 3 ), VC4 ( 7 )) VC4 ( 0 ) = IEOR ( VC4 ( 0 ), RC40 ( I )) VC4 ( 4 ) = IEOR ( VC4 ( 4 ), RC44 ( I )) END DO RETURN #include    \"Includes/Luffa_Undef Macro.f90\" END SUBROUTINE LuffaCore_Process5 !****************************************************************************** END MODULE MClass_Luffa !******************************************************************************","tags":"","loc":"sourcefile\\mclass_luffa.f90.html"},{"title":"MClass_XXHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_XXHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *XXHasher64* type and its related routines. !   The *XXHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *XXHasher64* type employs the *XX* hash algorithm for 64-bit integer !   output by Yann Collet [1, 2].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/Cyan4973/xxHash\">xxHash: Extremely fast hash algorithm. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: XXHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskI8(X)           IAND(ToInt64(X), Z'00000000000000FF') #define MaskI32(X)          IAND(ToInt64(X), Z'00000000FFFFFFFF') #define XXH64_Round(Acc, Inp) \\ Acc = Acc + Inp * XXH_PRIME64_2 ; \\ Acc = RotateLeft ( Acc , 31 ); \\ Acc = Acc * XXH_PRIME64_1 ; #define XXH64_MergeRound(Acc, Val) \\ Val = Val * XXH_PRIME64_2 ; \\ Val = RotateLeft ( Val , 31 ); \\ Val = Val * XXH_PRIME64_1 ; \\ Acc = IEOR ( Acc , Val ); \\ Acc = Acc * XXH_PRIME64_1 + XXH_PRIME64_4 ; #define GetU8(In, Off)      MaskI8(In(Off)) #define Pack_U32(In, Off)   MaskI32(PackInteger(In, Off)) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: XXH_PRIME64_1 = ToInt64 ( Z '9E3779B185EBCA87' ) ! < 0b1001111000110111011110011011000110000101111010111100101010000111 > tUInt64 , PARAMETER :: XXH_PRIME64_2 = ToInt64 ( Z 'C2B2AE3D27D4EB4F' ) ! < 0b1100001010110010101011100011110100100111110101001110101101001111 > tUInt64 , PARAMETER :: XXH_PRIME64_3 = ToInt64 ( Z '165667B19E3779F9' ) ! < 0b0001011001010110011001111011000110011110001101110111100111111001 > tUInt64 , PARAMETER :: XXH_PRIME64_4 = ToInt64 ( Z '85EBCA77C2B2AE63' ) ! < 0b1000010111101011110010100111011111000010101100101010111001100011 > tUInt64 , PARAMETER :: XXH_PRIME64_5 = ToInt64 ( Z '27D4EB2F165667C5' ) ! < 0b0010011111010100111010110010111100010110010101100110011111000101 > tIndex , PARAMETER :: BlockLen = 32_kIndex !** DERIVED TYPE DEFINITIONS !> *XXHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *XX* hash algorithm by Yann Collet. TYPE , EXTENDS ( Hasher64 ) :: XXHasher64 PRIVATE !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX_HashDirect END TYPE XXHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION XX_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'XX_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX_GetName !****************************************************************************** FUNCTION XX_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX_BlockLength !****************************************************************************** SUBROUTINE XX_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE XX_SetBufPtr !****************************************************************************** SUBROUTINE XX_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( V1 => HS % State ( 1 ), V2 => HS % State ( 2 ), & V3 => HS % State ( 3 ), V4 => HS % State ( 4 )) XXH64_Round ( V1 , PackLong ( BytesIn , 0_kIndex )) XXH64_Round ( V2 , PackLong ( BytesIn , 8_kIndex )) XXH64_Round ( V3 , PackLong ( BytesIn , 16_kIndex )) XXH64_Round ( V4 , PackLong ( BytesIn , 24_kIndex )) END ASSOCIATE RETURN END SUBROUTINE XX_ProcessBlock !****************************************************************************** SUBROUTINE XX_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( V1 => HS % State ( 1 ), V2 => HS % State ( 2 ), & V3 => HS % State ( 3 ), V4 => HS % State ( 4 )) V1 = Seed + XXH_PRIME64_1 + XXH_PRIME64_2 V2 = Seed + XXH_PRIME64_2 V3 = Seed V4 = Seed - XXH_PRIME64_1 END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE XX_Initialize !****************************************************************************** FUNCTION XX_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: K1 tIndex :: Length , Remaining , Offset !** FLOW Remaining = HS % GetBufLen () Offset = 0_kIndex IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ASSOCIATE ( V1 => HS % State ( 1 ), V2 => HS % State ( 2 ), & V3 => HS % State ( 3 ), V4 => HS % State ( 4 )) HashCode = RotateLeft ( V1 , 1 ) + RotateLeft ( V2 , 7 ) + & RotateLeft ( V3 , 12 ) + RotateLeft ( V4 , 18 ) XXH64_MergeRound ( HashCode , V1 ) XXH64_MergeRound ( HashCode , V2 ) XXH64_MergeRound ( HashCode , V3 ) XXH64_MergeRound ( HashCode , V4 ) END ASSOCIATE ELSE Length = Remaining HashCode = HS % State ( 3 ) + XXH_PRIME64_5 END IF HashCode = HashCode + ToInt64 ( Length ) ! XXH64_finalize ASSOCIATE ( Input => HS % BufArr ) DO WHILE ( Remaining >= 8_kIndex ) K1 = 0_kInt64 XXH64_Round ( K1 , PackLong ( Input , Offset )) HashCode = IEOR ( HashCode , K1 ) HashCode = RotateLeft ( HashCode , 27 ) * XXH_PRIME64_1 + XXH_PRIME64_4 Offset = Offset + 8_kIndex Remaining = Remaining - 8_kIndex END DO IF ( Remaining >= 4_kIndex ) THEN HashCode = IEOR ( HashCode , Pack_U32 ( Input , Offset ) * XXH_PRIME64_1 ) HashCode = RotateLeft ( HashCode , 23 ) * XXH_PRIME64_2 + XXH_PRIME64_3 Offset = Offset + 4_kIndex Remaining = Remaining - 4_kIndex END IF DO WHILE ( Remaining /= 0_kIndex ) HashCode = IEOR ( HashCode , GetU8 ( Input , Offset ) * XXH_PRIME64_5 ) HashCode = RotateLeft ( HashCode , 11 ) * XXH_PRIME64_1 Offset = Offset + 1_kIndex Remaining = Remaining - 1_kIndex END DO END ASSOCIATE ! XXH32_avalanche HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 33 )) HashCode = HashCode * XXH_PRIME64_2 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 29 )) HashCode = HashCode * XXH_PRIME64_3 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 32 )) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION XX_Finalize !****************************************************************************** FUNCTION XX_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION XX_HashDirect !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackLong !************************************************************************** PURE FUNCTION PackInteger ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 32-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #undef MaskInt32 RETURN END FUNCTION PackInteger !****************************************************************************** END MODULE MClass_XXHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_xxhasher64.f90.html"},{"title":"MClass_Kangaroo.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Kangaroo !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Kangaroo* type and its related routines. !   The *Kangaroo* type is a *digest* type extending directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   As a *Keccak-based digest* type, the *Kangaroo* type utilizes the !   <a href=\"../module/mclass_kp1600sponge.html#type-kp1600sponge\"> !   KP1600Sponge</a> type, similar to other *Keccak-based digest* types. !   However, unlike other *Keccak-based digest* types, the *Kangaroo* type does !   not extends from the <a href=\"../module/mclass_kp1600core.html#type-kp1600core\"> !   KP1600Core</a> type, due to different designs of internal structures. <br> !   Similar to the <a href=\"../module/mclass_shake.html#type-shake\">SHAKE</a> !   type, the *Kangaroo* type represents two incremental cryptographic hash !   functions (*KangarooTwelve* and *MarsupilamiFourteen*) and is capable of !   producing a variable-length hash output.  By default, the *Kangaroo* type !   employs the *KangarooTwelve* hash function as a default algorithm.  However, !   a user can specify the *IsMarsupilami14* flag to true when initializing the !   digest object in order to use the *MarsupilamiFourteen* hash function instead !   of the default one.  As previously mentioned, the *Kangaroo* type is capable !   of producing variable-length hash output.  Therefore, a user can specify an !   output length through the optional *OutputLen* argument when initializing the !   digest object.  If the optional argument is NOT present, the *Kangaroo* type !   produces the output length based on a default length for a specific algorithm. !   In addition, a user may use the *Kangaroo* type as an extendable-output function !   (XOF) by specifying the hash output length during a finalization of the digest !   object where the *DigestWOutLen* method is called.  This method will ignore the !   output length specified during initialization if the specified length is valid !   (greater than or equal to 1). <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://keccak.team/kangarootwelve.html\">KangarooTwelve: !       fast hashing based on Keccak-p. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc , MemFree USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest USE MClass_KP1600Sponge IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Kangaroo PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tInteger , PARAMETER :: ChunkSize = 8192 tByte , PARAMETER :: SuffixLeaf = ToInt8 ( Z '0B' ) ! '110': message hop, simple padding, inner node tLogical , PARAMETER :: NO_ERROR = . FALSE . tLogical , PARAMETER :: HAVE_ERROR = . TRUE . !** DERIVED TYPE DEFINITIONS !> *Kangaroo* is a concrete *Keccak-based digest* type that implements an incremental !  cryptographic hash function by employing either the *KangarooTwelve* or the !  *MarsupilamiFourteen message-digest* algorithm. TYPE , EXTENDS ( BaseDigest ) :: Kangaroo PRIVATE !% sponge instance for queue node TYPE ( KP1600Sponge ) :: QueueNode ! sponge instance for final node TYPE ( KP1600Sponge ) :: FinalNode !% customization string tByte , POINTER :: Custom (:) => NULL () !% block number tIndex :: BlockNumber = 0_kIndex !% length of input queue absorbed tIndex :: QueueAbsorbedLen = 0_kIndex !% the value of the capacity in bits tInteger :: Capacity = 256 !% the length of output message in bytes tIndex :: DigestLen = 16_kIndex !% the number of permutation rounds tInteger :: NRounds = 12 !% flag indicating whether the MarsupilamiFourteen algorithm is employed or not. tLogical :: IsMarsupilami14 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: DoInit => Kangaroo_DoInit PROCEDURE , PRIVATE :: DoUpdate => Kangaroo_DoUpdate PROCEDURE , PRIVATE :: DoFinal => Kangaroo_DoFinal !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => Kangaroo_Initialize_wOption PROCEDURE , PRIVATE :: Kangaroo_ByteDigest_wOutLen PROCEDURE , PRIVATE :: Kangaroo_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: Kangaroo_HexDigest_wOutLen PROCEDURE , PRIVATE :: Kangaroo_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (KangarooTwelve) !  and default hash output length. PROCEDURE :: Initialize => Kangaroo_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Kangaroo_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Kangaroo_GetName !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Kangaroo_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Kangaroo_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Kangaroo_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Kangaroo_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Kangaroo_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Kangaroo_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (KangarooTwelve) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the MarsupilamiFourteen algorithm and default output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.TRUE.) <br> !   ! employ the KangarooTwelve algorithm with specified output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.FALSE., OutputLen=32) <br> !   ! employ the KMarsupilamiFourteen algorithm with specified output length <br> !   --->    CALL MD%Create(IsMarsupilami14=.TRUE., OutputLen=64) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => Kangaroo_ByteDigest_wOutLen , & Kangaroo_ByteDigest_wInputNOutLen , & Kangaroo_HexDigest_wOutLen , & Kangaroo_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- FINAL :: Kangaroo_Finalize ! --------------------------------------------------------------------- END TYPE Kangaroo !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Kangaroo_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with !  default algorithm and default hash output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the KangarooTwelve algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE Kangaroo_Initialize !****************************************************************************** SUBROUTINE Kangaroo_Initialize_wOption ( MD , IsMarsupilami14 , OutputLen , Custom ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified options. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object tLogical , INTENT ( IN ) :: IsMarsupilami14 !&#94; flag indicating whether the MarsupilamiFourteen algorithm is employed or not. <br> !  - If true, use the MarsupilamiFourteen algorithm. <br> !  - Otherwise, use the KangarooTwelve algorithm. <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; the hash output length in bytes (must be positive; otherwise, !  the default length produced). tByte , TARGET , OPTIONAL , INTENT ( IN ) :: Custom (:) !&#94; an array of (8-bit integers) bytes representing the customization bit string (S) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Security ! security strength in bits tInteger :: Capacity ! the value of the capacity C in bits tIndex :: DigestLen ! the desired length of output in bytes tInteger :: NRounds ! number of permutation rounds ! FLOW ! set security strength MD % IsMarsupilami14 = IsMarsupilami14 IF ( IsMarsupilami14 ) THEN Security = 256 NRounds = 14 ELSE Security = 128 NRounds = 12 END IF ! set input parameters for the *CoreInit* method Capacity = SHIFTL ( Security , 1 ) ! Security*2 DigestLen = SHIFTR ( Security , 3 ) ! Security/8 ! check optional input IF ( PRESENT ( OutputLen )) THEN IF ( OutputLen > 0_kIndex ) THEN ! valid input DigestLen = OutputLen END IF END IF ! initialize the digest object CALL MD % DoInit ( Capacity , DigestLen , NRounds ) IF ( PRESENT ( Custom )) MD % Custom => Custom RETURN END SUBROUTINE Kangaroo_Initialize_wOption !****************************************************************************** SUBROUTINE Kangaroo_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL MD % DoInit ( MD % Capacity , MD % DigestLen , MD % NRounds ) RETURN END SUBROUTINE Kangaroo_Reset !****************************************************************************** SUBROUTINE Kangaroo_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Kangaroo :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Kangaroo ) CALL Src % QueueNode % CopyState ( Dst % QueueNode ) CALL Src % FinalNode % CopyState ( Dst % FinalNode ) Dst % BlockNumber = Src % BlockNumber Dst % QueueAbsorbedLen = Src % QueueAbsorbedLen Dst % DigestLen = Src % DigestLen Dst % NRounds = Src % NRounds Dst % Capacity = Src % Capacity Dst % IsMarsupilami14 = Src % IsMarsupilami14 IF ( ASSOCIATED ( Src % Custom )) Dst % Custom => Src % Custom END SELECT RETURN END SUBROUTINE Kangaroo_GetClone !****************************************************************************** FUNCTION Kangaroo_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( IN ) :: MD !! 'Kangaroo' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsMarsupilami14 ) THEN Name = 'MarsupilamiFourteen' ELSE Name = 'KangarooTwelve' END IF RETURN END FUNCTION Kangaroo_GetName !****************************************************************************** FUNCTION Kangaroo_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( IN ) :: MD !! 'KP1600_Core' object tIndex :: Length !! digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Kangaroo_GetDigestLen !****************************************************************************** SUBROUTINE Kangaroo_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Flag ! FLOW Flag = MD % DoUpdate ( ByteArr ( Offset :), Length ) RETURN END SUBROUTINE Kangaroo_InsertBytes !****************************************************************************** SUBROUTINE Kangaroo_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) tLogical :: Flag ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array Flag = MD % DoUpdate ( InpPtr , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE Kangaroo_InsertGen !****************************************************************************** SUBROUTINE Kangaroo_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Flag ! FLOW IF ( MD % DigestLen > 0_kIndex ) THEN CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) Flag = MD % DoFinal ( ByteArr ) CALL MD % Reset () END IF RETURN END SUBROUTINE Kangaroo_ByteDigest !****************************************************************************** SUBROUTINE Kangaroo_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE Kangaroo_ByteDigest_wInput !****************************************************************************** SUBROUTINE Kangaroo_ByteDigest_wOutLen ( MD , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes. The digest object is reset. <br> !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Flag ! FLOW IF ( OutputLen > 0_kIndex ) THEN Flag = MD % DoFinal ( ByteArr , OutputLen ) CALL MD % Reset () END IF RETURN END SUBROUTINE Kangaroo_ByteDigest_wOutLen !****************************************************************************** SUBROUTINE Kangaroo_ByteDigest_wInputNOutLen ( MD , Input , InpSize , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % DigestWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE Kangaroo_ByteDigest_wInputNOutLen !****************************************************************************** SUBROUTINE Kangaroo_HexDigest_wOutLen ( MD , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Kangaroo_HexDigest_wOutLen !****************************************************************************** SUBROUTINE Kangaroo_HexDigest_wInputNOutLen ( MD , Input , InpSize , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash computation !  and return the hash value as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( Input , InpSize , ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Kangaroo_HexDigest_wInputNOutLen !****************************************************************************** SUBROUTINE Kangaroo_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Kangaroo ), INTENT ( INOUT ) :: MD !! 'Kangaroo' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % Custom ) RETURN END SUBROUTINE Kangaroo_Finalize !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                     ENGINE ROUTINES FOR KangarooCore                        + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE Kangaroo_DoInit ( MD , Capacity , OutputByteLen , NRounds ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize components of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD tInteger , INTENT ( IN ) :: Capacity !! the capacity in bits tIndex , INTENT ( IN ) :: OutputByteLen !! the length of output message in bytes tInteger , INTENT ( IN ) :: NRounds !! number of permutation rounds !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! initialize MD % BlockNumber = 0_kIndex MD % QueueAbsorbedLen = 0_kIndex MD % DigestLen = OutputByteLen MD % NRounds = NRounds MD % Capacity = Capacity ! create the instance CALL MD % FinalNode % Initialize ( MD % Capacity , MD % NRounds ) RETURN END SUBROUTINE Kangaroo_DoInit !****************************************************************************** FUNCTION Kangaroo_DoUpdate ( MD , Input , InputByteLen ) RESULT ( RetFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data to be absorbed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: Input ( 0 :) !! a byte array containing input data tIndex , INTENT ( IN ) :: InputByteLen !! length of the input data in bytes tLogical :: RetFlag !! true if success; otherwise, false !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: InLen , CurIndx tIndex :: Length tByte :: Padding ( 0 : 0 ) tIndex :: CapacityInBytes tByte :: Intermediate ( 0 : SHIFTR ( MD % Capacity , 3 ) - 1 ) ! FLOW ! initialize CapacityInBytes = SHIFTR ( MD % Capacity , 3 ) InLen = InputByteLen CurIndx = 0_kIndex IF ( MD % BlockNumber == 0_kIndex ) THEN ! First block, absorb in final node IF ( InLen < ( ChunkSize - MD % QueueAbsorbedLen )) THEN Length = InLen ELSE Length = ChunkSize - MD % QueueAbsorbedLen END IF IF ( MD % FinalNode % Absorb ( Input ( CurIndx :), Length ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF CurIndx = CurIndx + Length InLen = InLen - Length MD % QueueAbsorbedLen = MD % QueueAbsorbedLen + Length IF (( MD % QueueAbsorbedLen == ChunkSize ). AND .( InLen /= 0_kIndex )) THEN ! First block complete and more input data available, finalize it ! '110&#94;6': message hop, simple padding Padding = ToInt8 ( Z '03' ) MD % QueueAbsorbedLen = 0_kIndex MD % BlockNumber = 1_kIndex IF ( MD % FinalNode % Absorb ( Padding , 1_kIndex ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF ! Zero padding up to 64 bits CALL MD % FinalNode % SetByteIOIndex ( IAND (( MD % FinalNode % GetByteIOIndex () + 7_kIndex ), NOT ( 7_kIndex ))) END IF ELSEIF ( MD % QueueAbsorbedLen /= 0_kIndex ) THEN ! There is data in the queue, absorb further in queue until block complete IF ( InLen < ( ChunkSize - MD % QueueAbsorbedLen )) THEN Length = InLen ELSE Length = ChunkSize - MD % QueueAbsorbedLen END IF IF ( MD % QueueNode % Absorb ( Input ( CurIndx :), Length ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF CurIndx = CurIndx + Length InLen = InLen - Length MD % QueueAbsorbedLen = MD % QueueAbsorbedLen + Length IF ( MD % QueueAbsorbedLen == ChunkSize ) THEN MD % QueueAbsorbedLen = 0_kIndex MD % BlockNumber = MD % BlockNumber + 1_kIndex IF ( MD % QueueNode % AbsorbLastFewBits ( SuffixLeaf ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % QueueNode % Squeeze ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % FinalNode % Absorb ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF END IF END IF DO WHILE ( InLen > 0_kIndex ) IF ( InLen < ChunkSize ) THEN Length = InLen ELSE Length = ChunkSize END IF CALL MD % QueueNode % Initialize ( MD % Capacity , MD % NRounds ) IF ( MD % QueueNode % Absorb ( Input ( CurIndx :), Length ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF CurIndx = CurIndx + Length InLen = InLen - Length IF ( Length == ChunkSize ) THEN MD % BlockNumber = MD % BlockNumber + 1 IF ( MD % QueueNode % AbsorbLastFewBits ( SuffixLeaf ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % QueueNode % Squeeze ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % FinalNode % Absorb ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF ELSE MD % QueueAbsorbedLen = Length END IF END DO RetFlag = NO_ERROR RETURN END FUNCTION Kangaroo_DoUpdate !****************************************************************************** FUNCTION Kangaroo_DoFinal ( MD , Output , OutLen ) RESULT ( RetFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the output data after all the input data have been absorbed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Kangaroo ), INTENT ( INOUT ) :: MD tByte , INTENT ( OUT ) :: Output ( 0 :) !! a byte array containing output data tIndex , OPTIONAL , INTENT ( IN ) :: OutLen !! desired output length tLogical :: RetFlag !! true if success; otherwise, false !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: EncBuf (:) ! the encoding buffer tIndex :: N ! size of the buffer tByte :: Padding tByte :: IsSuccessful tIndex :: CustomLen ! FLOW ! Absorb Customization | right_encode(CustomLen) IF ( ASSOCIATED ( MD % Custom )) THEN CustomLen = SIZE ( MD % Custom , KIND = kIndex ) IF ( MD % DoUpdate ( MD % Custom , CustomLen ) . NEQV . NO_ERROR ) THEN RetFlag = HAVE_ERROR RETURN END IF ELSE BLOCK tByte :: Custom ( 0 : 0 ) CustomLen = 0_kIndex IF ( MD % DoUpdate ( Custom , CustomLen ) . NEQV . NO_ERROR ) THEN RetFlag = HAVE_ERROR RETURN END IF END BLOCK END IF CALL Right_Encode ( CustomLen , EncBuf , N ) IF ( MD % DoUpdate ( EncBuf , N ) . NEQV . NO_ERROR ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % BlockNumber == 0_kIndex ) THEN ! Non complete first block in final node, pad it !  '11': message hop, final node Padding = ToInt8 ( Z '07' ) ELSE IF ( MD % QueueAbsorbedLen /= 0 ) THEN ! There is data in the queue node BLOCK tIndex :: CapacityInBytes tByte , ALLOCATABLE :: Intermediate (:) CapacityInBytes = SHIFTR ( MD % Capacity , 3 ) CALL MemAlloc ( Intermediate , CapacityInBytes , StartID = 0_kIndex ) MD % BlockNumber = MD % BlockNumber + 1 IF ( MD % QueueNode % AbsorbLastFewBits ( SuffixLeaf ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % QueueNode % Squeeze ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( MD % FinalNode % Absorb ( Intermediate , CapacityInBytes ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF CALL MemFree ( Intermediate ) END BLOCK END IF ! Absorb right_encode(number of Chaining Values) || 0xFF || 0xFF MD % BlockNumber = MD % BlockNumber - 1 CALL Right_Encode ( MD % BlockNumber , EncBuf , N ) EncBuf ( N : N + 1 ) = ToInt8 ( Z 'FF' ) N = N + 2 IF ( MD % FinalNode % Absorb ( EncBuf , N ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF ! '01': chaining hop, final node Padding = ToInt8 ( Z '06' ) END IF IF ( MD % FinalNode % AbsorbLastFewBits ( Padding ) /= SUCCESS ) THEN RetFlag = HAVE_ERROR RETURN END IF IF ( PRESENT ( OutLen )) THEN IsSuccessful = MD % FinalNode % Squeeze ( Output , OutLen ) ELSE IsSuccessful = MD % FinalNode % Squeeze ( Output , MD % DigestLen ) END IF IF ( IsSuccessful == SUCCESS ) THEN RetFlag = NO_ERROR ELSE RetFlag = HAVE_ERROR END IF RETURN END FUNCTION Kangaroo_DoFinal !****************************************************************************** SUBROUTINE Right_Encode ( Value , EncBuf , N ) !** PURPOSE OF THIS SUBROUTINE: ! To encode the length !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Value tByte , ALLOCATABLE , INTENT ( OUT ) :: EncBuf (:) tIndex , INTENT ( OUT ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I tIndex :: V ! FLOW ! determine size of the buffer V = Value N = 0 DO WHILE (( V /= 0 ). AND .( N < C_SIZEOF ( Value ))) N = N + 1 V = SHIFTR ( V , 8 ) END DO ! allocate and set the buffer CALL MemAlloc ( EncBuf , N + 1 , StartID = 0_kIndex ) DO I = 1 , N EncBuf ( I - 1 ) = ToInt8 ( SHIFTR ( Value , 8 * ( N - I ))) END DO EncBuf ( N ) = ToInt8 ( N ) N = N + 1 RETURN END SUBROUTINE Right_Encode !****************************************************************************** END MODULE MClass_Kangaroo !******************************************************************************","tags":"","loc":"sourcefile\\mclass_kangaroo.f90.html"},{"title":"MClass_cSHAKE.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_cSHAKE !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *cSHAKE* type and its related routines. !   The *cSHAKE* type is a *Keccak-based digest* type that extends from !   the <a href=\"../module/mclass_kp1600core.html#type-kp1600core\"> !   KP1600Core</a> type.  As a *concrete* derived type, it provides !   all remaining deferred procedures required by all its parent types. <br> !   Like the <a href=\"../module/mclass_shake.html#type-shake\">SHAKE</a> !   type, the *cSHAKE* type represents two incremental cryptographic hash !   functions and is capable of producing a variable-length hash output. !   The *cSHAKE* type is a customizable version of the *SHAKE* type that !   supports explicit domain separation via customization parameters. !   For default initializations (initializing without other input arguments), !   both types should produces the same hash output for the same input message. <br> !   See the <a href=\"../module/mclass_shake.html\">MClass_SHAKE</a> module for !   the default algorithm and how to specify the desired algorithm and/or !   the desired output length.  See the *Create* (*InitializeWOption* to be !   exact) method for detailed explanation of customization parameters. !   Similar to the *SHAKE* type, a user may use the *cSHAKE* type as an !   extendable-output function (XOF) by specifying the hash output length !   during a finalization of the digest object where the *DigestWOutLen* !   method is called.  This method will ignore the output length specified !   during initialization if the specified length is valid (greater than or !   equal to 1). <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest USE MClass_KP1600Core USE MClass_KP1600Sponge IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: cSHAKE PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *cSHAKE* is a concrete *Keccak-based digest* type that implements an !  incremental cryptographic hash function by employing either the !  *cSHAKE-128* or the *cSHAKE-256 message-digest* algorithm. TYPE , EXTENDS ( KP1600Core ) :: cSHAKE PRIVATE !% flag indicating whether the cSHAKE-256 algorithm is employed or not. tLogical :: IscSHAKE256 = FalseVal !% flag indicating whether both function and customization strings are empty or not. tLogical :: EmptyNS CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ReInit => cSHAKE_ReInit !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options and customization !  parameters. PROCEDURE , PRIVATE :: InitializeWOption => cSHAKE_Initialize_wOption PROCEDURE , PRIVATE :: cSHAKE_ByteDigest_wOutLen PROCEDURE , PRIVATE :: cSHAKE_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: cSHAKE_HexDigest_wOutLen PROCEDURE , PRIVATE :: cSHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (cSHAKE-128) !  and default hash output length, and without customization parameters. PROCEDURE :: Initialize => cSHAKE_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => cSHAKE_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => cSHAKE_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (cSHAKE-256) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the cSHAKE-256 algorithm and default output length <br> !   --->    CALL MD%Create(IscSHAKE256=.TRUE.) <br> !   ! employ the cSHAKE-128 algorithm with specified output length <br> !   --->    CALL MD%Create(IscSHAKE256=.FALSE., OutputLen=64) <br> !   ! employ the cSHAKE-256 algorithm with specified output length <br> !   --->    CALL MD%Create(IscSHAKE256=.TRUE., OutputLen=128) <br> !   ! employ the cSHAKE-128 algorithm with customization parameters <br> !   --->    CALL MD%Create(IscSHAKE256=.FALSE., Name=FuncStr, Custom=CustomStr) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => cSHAKE_ByteDigest_wOutLen , & cSHAKE_ByteDigest_wInputNOutLen , & cSHAKE_HexDigest_wOutLen , & cSHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE cSHAKE !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE cSHAKE_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with !  default algorithm and default hash output length, and !  without customization parameters. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'cSHAKE' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the cSHAKE-128 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE cSHAKE_Initialize !****************************************************************************** SUBROUTINE cSHAKE_Initialize_wOption ( MD , IscSHAKE256 , OutputLen , Name , Custom , CustomBitLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified !  options and customization parameters. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'cSHAKE' object tLogical , INTENT ( IN ) :: IscSHAKE256 !&#94; flag indicating whether the cSHAKE-256 algorithm is employed or not. <br> !  - If true, use the cSHAKE-256 algorithm. <br> !  - Otherwise, use the cSHAKE-128 algorithm. <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; the hash output length in bytes (must be positive; otherwise, !  the default length produced). tByte , OPTIONAL , INTENT ( IN ) :: Name (:) !&#94; an array of (8-bit integer) bytes representing the function-name bit string (N); !  if not present, N is an empty string. tByte , OPTIONAL , INTENT ( IN ) :: Custom (:) !&#94; an array of (8-bit integer) bytes representing the customization bit string (S); !  if not present, S is an empty string. tIndex , OPTIONAL , INTENT ( IN ) :: CustomBitLen !&#94; the length of the customization string in bits !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , PARAMETER :: NonEmptySuffix = ToInt8 ( Z '04' ) tByte , PARAMETER :: EmptySuffix = ToInt8 ( Z '1F' ) tInteger , PARAMETER :: NRounds = 24 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Security ! security strength in bits tInteger :: Capacity ! the value of the capacity C in bits tIndex :: DigestLen ! the desired length of output in bytes TYPE ( KP1600Sponge ), POINTER :: Sponge tByte , ALLOCATABLE :: EncBuf (:) ! the encoding buffer tIndex :: N ! size of the buffer !    tInteger                        :: Capacity     ! the value of the capacity C in bits tIndex :: RateInBytes tByte :: Dummy ( 0 : 0 ) ! FLOW ! set security strength MD % IscSHAKE256 = IscSHAKE256 IF ( IscSHAKE256 ) THEN Security = 256 ELSE Security = 128 END IF ! set input parameters for the *CoreInit* method Capacity = SHIFTL ( Security , 1 ) ! Security*2 DigestLen = SHIFTR ( Security , 3 ) ! Security/8 ! check optional input IF ( PRESENT ( OutputLen )) THEN IF ( OutputLen > 0_kIndex ) THEN ! valid input DigestLen = OutputLen END IF END IF ! initialize the core components IF ((. NOT . PRESENT ( Name )). AND .(. NOT . PRESENT ( Custom ))) THEN ! both name and customization strings are empty MD % EmptyNS = TrueVal CALL MD % CoreInit ( Capacity , EmptySuffix , DigestLen , NRounds ) ELSE ! one or both name and customization strings is/are not empty MD % EmptyNS = FalseVal CALL MD % CoreInit ( Capacity , NonEmptySuffix , DigestLen , NRounds ) ! get sponge instance Sponge => MD % GetSponge () Encoding : BLOCK ! Absorb padding byte (.., rate) RateInBytes = ( 1600 - Capacity ) / 8 CALL Left_Encode ( RateInBytes , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding ! Absorb encode_string(Name) IF ( PRESENT ( Name )) THEN CALL Left_Encode ( SIZE ( Name , KIND = kIndex ) * 8 , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding IF ( Sponge % Absorb ( Name , SIZE ( Name , KIND = kIndex )) /= SUCCESS ) EXIT Encoding ELSE CALL Left_Encode ( 0_kIndex , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding IF ( Sponge % Absorb ( Dummy , 0_kIndex ) /= SUCCESS ) EXIT Encoding END IF ! Absorb encode_string(Customization) IF ( PRESENT ( Custom )) THEN IF ( PRESENT ( CustomBitLen )) THEN ! custom length may be not a multiple of eight bits CALL Left_Encode ( CustomBitLen , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding ! allowed to be a bit string, as zero padding is following IF ( Sponge % Absorb ( Custom , ( CustomBitLen + 7 ) / 8 ) /= SUCCESS ) EXIT Encoding ! Zero padding up to rate IF ( Sponge % GetByteIOIndex () /= 0_kIndex ) THEN CALL Sponge % SetByteIOIndex ( RateInBytes - 1 ) EncBuf ( 0 ) = 0 IF ( Sponge % Absorb ( EncBuf , 1_kIndex ) /= SUCCESS ) EXIT Encoding END IF ELSE ! custom length is a multiple of eight bits CALL Left_Encode ( SIZE ( Custom , KIND = kIndex ) * 8 , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding IF ( Sponge % Absorb ( Custom , SIZE ( Custom , KIND = kIndex )) /= SUCCESS ) EXIT Encoding END IF ELSE CALL Left_Encode ( 0_kIndex , EncBuf , N ) IF ( Sponge % Absorb ( EncBuf , N ) /= SUCCESS ) EXIT Encoding IF ( Sponge % Absorb ( Dummy , 0_kIndex ) /= SUCCESS ) EXIT Encoding END IF END BLOCK Encoding NULLIFY ( Sponge ) END IF RETURN END SUBROUTINE cSHAKE_Initialize_wOption !****************************************************************************** SUBROUTINE cSHAKE_ReInit ( MD , IscSHAKE256 , OutputLen , EmptyNS ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform re-initialization of the digest object with the specified !  options. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'cSHAKE' object tLogical , INTENT ( IN ) :: IscSHAKE256 !&#94; flag indicating whether the cSHAKE-256 algorithm is employed or not. <br> !  - If true, use the cSHAKE-256 algorithm. <br> !  - Otherwise, use the cSHAKE-128 algorithm. <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; the hash output length in bytes (must be positive; otherwise, !  the default length produced). tLogical , INTENT ( IN ) :: EmptyNS !&#94; flag indicating whether both function and customization strings are empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , PARAMETER :: NonEmptySuffix = ToInt8 ( Z '04' ) tByte , PARAMETER :: EmptySuffix = ToInt8 ( Z '1F' ) tInteger , PARAMETER :: NRounds = 24 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Security ! security strength in bits tInteger :: Capacity ! the value of the capacity C in bits tIndex :: DigestLen ! the desired length of output in bytes ! FLOW ! set security strength MD % IscSHAKE256 = IscSHAKE256 IF ( IscSHAKE256 ) THEN Security = 256 ELSE Security = 128 END IF ! set input parameters for the *CoreInit* method Capacity = SHIFTL ( Security , 1 ) ! Security*2 DigestLen = SHIFTR ( Security , 3 ) ! Security/8 ! check optional input IF ( PRESENT ( OutputLen )) THEN IF ( OutputLen > 0_kIndex ) THEN ! valid input DigestLen = OutputLen END IF END IF ! initialize the core components MD % EmptyNS = EmptyNS IF ( MD % EmptyNS ) THEN CALL MD % CoreInit ( Capacity , EmptySuffix , DigestLen , NRounds ) ELSE CALL MD % CoreInit ( Capacity , NonEmptySuffix , DigestLen , NRounds ) END IF RETURN END SUBROUTINE cSHAKE_ReInit !****************************************************************************** SUBROUTINE cSHAKE_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( cSHAKE :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( cSHAKE ) CALL Dst % ReInit ( Src % IscSHAKE256 , Src % GetDigestLen (), Src % EmptyNS ) CALL Src % CopyState ( Dst ) END SELECT RETURN END SUBROUTINE cSHAKE_GetClone !****************************************************************************** FUNCTION cSHAKE_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( IN ) :: MD !! 'cSHAKE' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IscSHAKE256 ) THEN Name = 'cSHAKE-256' ELSE Name = 'cSHAKE-128' END IF RETURN END FUNCTION cSHAKE_GetName !****************************************************************************** SUBROUTINE cSHAKE_ByteDigest_wOutLen ( MD , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes. The digest object is reset. <br> !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'cSHAKE' object tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE cSHAKE_ByteDigest_wOutLen !****************************************************************************** SUBROUTINE cSHAKE_ByteDigest_wInputNOutLen ( MD , Input , InpSize , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'cSHAKE' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE cSHAKE_ByteDigest_wInputNOutLen !****************************************************************************** SUBROUTINE cSHAKE_HexDigest_wOutLen ( MD , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE cSHAKE_HexDigest_wOutLen !****************************************************************************** SUBROUTINE cSHAKE_HexDigest_wInputNOutLen ( MD , Input , InpSize , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash computation !  and return the hash value as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( cSHAKE ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( Input , InpSize , ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE cSHAKE_HexDigest_wInputNOutLen !****************************************************************************** SUBROUTINE Left_Encode ( Value , EncBuf , N ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To encode the length !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Value tByte , ALLOCATABLE , INTENT ( OUT ) :: EncBuf (:) tIndex , INTENT ( OUT ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I tIndex :: V ! FLOW ! determine size of the buffer V = Value N = 0 DO WHILE (( V /= 0 ). AND .( N < C_SIZEOF ( Value ))) N = N + 1 V = SHIFTR ( V , 8 ) END DO IF ( N == 0 ) N = 1 ! allocate and set the buffer CALL MemAlloc ( EncBuf , N + 1 , StartID = 0_kIndex ) DO I = 1 , N EncBuf ( I ) = ToInt8 ( SHIFTR ( Value , 8 * ( N - I ))) END DO EncBuf ( 0 ) = ToInt8 ( N ) N = N + 1 RETURN END SUBROUTINE Left_Encode !****************************************************************************** END MODULE MClass_cSHAKE !******************************************************************************","tags":"","loc":"sourcefile\\mclass_cshake.f90.html"},{"title":"MClass_HamsiS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HamsiS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HamsiS* type and its related routines. !   The *HamsiS* type is a *digest* type that extends directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   The *HamsiS* type implements an incremental cryptographic hash function !   by employing either the *Hamsi-224* or the *Hamsi-256 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *HamsiS* type employs the *Hamsi-256 message-digest* !   algorithm.  However, a user can specify the *IsHamsi224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *Hamsi-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.esat.kuleuven.be/cosic/publications/article-1203.pdf\"> !       The Hash Function Hamsi. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : ByteUnpackBE USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: HamsiS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/HamsiS_Def Macro.f90\" !** MODULE PARAMETERS: #include    \"Includes/HamsiS_Constants.f90\" tByte , PARAMETER :: FByte00 = ToInt8 ( Z '00' ) tByte , PARAMETER :: FByte80 = ToInt8 ( Z '80' ) tByte , PARAMETER :: FByteFF = ToInt8 ( Z 'FF' ) tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: Alpha_N ( 0 : 31 ) = [ & ToInt32 ( Z 'FF00F0F0' ), ToInt32 ( Z 'CCCCAAAA' ), & ToInt32 ( Z 'F0F0CCCC' ), ToInt32 ( Z 'FF00AAAA' ), & ToInt32 ( Z 'CCCCAAAA' ), ToInt32 ( Z 'F0F0FF00' ), & ToInt32 ( Z 'AAAACCCC' ), ToInt32 ( Z 'F0F0FF00' ), & ToInt32 ( Z 'F0F0CCCC' ), ToInt32 ( Z 'AAAAFF00' ), & ToInt32 ( Z 'CCCCFF00' ), ToInt32 ( Z 'AAAAF0F0' ), & ToInt32 ( Z 'AAAAF0F0' ), ToInt32 ( Z 'FF00CCCC' ), & ToInt32 ( Z 'CCCCF0F0' ), ToInt32 ( Z 'FF00AAAA' ), & ToInt32 ( Z 'CCCCAAAA' ), ToInt32 ( Z 'FF00F0F0' ), & ToInt32 ( Z 'FF00AAAA' ), ToInt32 ( Z 'F0F0CCCC' ), & ToInt32 ( Z 'F0F0FF00' ), ToInt32 ( Z 'CCCCAAAA' ), & ToInt32 ( Z 'F0F0FF00' ), ToInt32 ( Z 'AAAACCCC' ), & ToInt32 ( Z 'AAAAFF00' ), ToInt32 ( Z 'F0F0CCCC' ), & ToInt32 ( Z 'AAAAF0F0' ), ToInt32 ( Z 'CCCCFF00' ), & ToInt32 ( Z 'FF00CCCC' ), ToInt32 ( Z 'AAAAF0F0' ), & ToInt32 ( Z 'FF00AAAA' ), ToInt32 ( Z 'CCCCF0F0' )] tInteger , PARAMETER :: Alpha_F ( 0 : 31 ) = [ & ToInt32 ( Z 'CAF9639C' ), ToInt32 ( Z '0FF0F9C0' ), & ToInt32 ( Z '639C0FF0' ), ToInt32 ( Z 'CAF9F9C0' ), & ToInt32 ( Z '0FF0F9C0' ), ToInt32 ( Z '639CCAF9' ), & ToInt32 ( Z 'F9C00FF0' ), ToInt32 ( Z '639CCAF9' ), & ToInt32 ( Z '639C0FF0' ), ToInt32 ( Z 'F9C0CAF9' ), & ToInt32 ( Z '0FF0CAF9' ), ToInt32 ( Z 'F9C0639C' ), & ToInt32 ( Z 'F9C0639C' ), ToInt32 ( Z 'CAF90FF0' ), & ToInt32 ( Z '0FF0639C' ), ToInt32 ( Z 'CAF9F9C0' ), & ToInt32 ( Z '0FF0F9C0' ), ToInt32 ( Z 'CAF9639C' ), & ToInt32 ( Z 'CAF9F9C0' ), ToInt32 ( Z '639C0FF0' ), & ToInt32 ( Z '639CCAF9' ), ToInt32 ( Z '0FF0F9C0' ), & ToInt32 ( Z '639CCAF9' ), ToInt32 ( Z 'F9C00FF0' ), & ToInt32 ( Z 'F9C0CAF9' ), ToInt32 ( Z '639C0FF0' ), & ToInt32 ( Z 'F9C0639C' ), ToInt32 ( Z '0FF0CAF9' ), & ToInt32 ( Z 'CAF90FF0' ), ToInt32 ( Z 'F9C0639C' ), & ToInt32 ( Z 'CAF9F9C0' ), ToInt32 ( Z '0FF0639C' )] tInteger , PARAMETER :: IV224 ( 0 : 7 ) = [ & ToInt32 ( Z 'c3967a67' ), ToInt32 ( Z 'c3bc6c20' ), & ToInt32 ( Z '4bc3bcc3' ), ToInt32 ( Z 'a7c3bc6b' ), & ToInt32 ( Z '2c204b61' ), ToInt32 ( Z '74686f6c' ), & ToInt32 ( Z '69656b65' ), ToInt32 ( Z '20556e69' )] tInteger , PARAMETER :: IV256 ( 0 : 7 ) = [ & ToInt32 ( Z '76657273' ), ToInt32 ( Z '69746569' ), & ToInt32 ( Z '74204c65' ), ToInt32 ( Z '7576656e' ), & ToInt32 ( Z '2c204465' ), ToInt32 ( Z '70617274' ), & ToInt32 ( Z '656d656e' ), ToInt32 ( Z '7420456c' )] !** DERIVED TYPE DEFINITIONS !> *HamsiS* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Hamsi hash algorithms. TYPE , EXTENDS ( BaseDigest ) :: HamsiS PRIVATE !% state tInteger :: State ( 0 : 7 ) = IV256 ( 0 : 7 ) !% buffer tByte :: Partial ( 0 : 3 ) = 0_kInt8 !% number of bytes used in the buffer tIndex :: PartialLen = 0_kIndex !% bit count tLong :: BitCount = 0_kInt64 !% flag indicating whether the Hamsi-224 algorithm is employed or not. tLogical :: IsHamsi224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: HamsiS_ByteDigest_AddBits PROCEDURE , PRIVATE :: HamsiS_HexDigest_AddBits !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => HamsiS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (HamsiS-256). PROCEDURE :: Initialize => HamsiS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => HamsiS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => HamsiS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => HamsiS_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => HamsiS_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => HamsiS_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => HamsiS_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => HamsiS_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => HamsiS_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Hamsi-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Hamsi-224 algorithm <br> !   --->    CALL MD%Create(IsHamsi224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => HamsiS_ByteDigest_AddBits , & HamsiS_HexDigest_AddBits ! --------------------------------------------------------------------- END TYPE HamsiS !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE HamsiS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the Hamsi-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE HamsiS_Initialize !****************************************************************************** SUBROUTINE HamsiS_Initialize_wFlag ( MD , IsHamsi224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object tLogical , INTENT ( IN ) :: IsHamsi224 !&#94; flag indicating whether the Hamsi-224 algorithm is employed or not. <br> !  - If true, use the Hamsi-224 algorithm. <br> !  - Otherwise, use the Hamsi-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsHamsi224 = IsHamsi224 CALL MD % Reset () RETURN END SUBROUTINE HamsiS_Initialize_wFlag !****************************************************************************** SUBROUTINE HamsiS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi224 ) THEN MD % State = IV224 ELSE MD % State = IV256 END IF MD % BitCount = 0_kInt64 MD % Partial = 0_kInt8 MD % PartialLen = 0_kIndex RETURN END SUBROUTINE HamsiS_Reset !****************************************************************************** SUBROUTINE HamsiS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( HamsiS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( HamsiS ) CALL Dst % Create ( Src % IsHamsi224 ) Dst % State = Src % State Dst % BitCount = Src % BitCount Dst % Partial = Src % Partial Dst % PartialLen = Src % PartialLen END SELECT RETURN END SUBROUTINE HamsiS_GetClone !****************************************************************************** FUNCTION HamsiS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( IN ) :: MD !! 'HamsiS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi224 ) THEN Name = 'Hamsi-224' ELSE Name = 'Hamsi-256' END IF RETURN END FUNCTION HamsiS_GetName !****************************************************************************** FUNCTION HamsiS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( IN ) :: MD !! 'HamsiS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsHamsi224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION HamsiS_GetDigestLen !****************************************************************************** SUBROUTINE HamsiS_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MLen , CurPos , CurLen ! FLOW CurLen = Length CurPos = Offset IF ( MD % PartialLen /= 0_kIndex ) THEN MLen = 4_kIndex - MD % PartialLen IF ( CurLen < MLen ) THEN MD % Partial ( MD % PartialLen : MD % PartialLen + CurLen - 1 ) = ByteArr ( CurPos : CurPos + CurLen - 1 ) MD % PartialLen = MD % PartialLen + CurLen RETURN ELSE MD % Partial ( MD % PartialLen : MD % PartialLen + MLen - 1 ) = ByteArr ( CurPos : CurPos + MLen - 1 ) CurLen = CurLen - MLen CurPos = CurPos + MLen CALL HamsiS_Process ( MD , MD % Partial , 0_kIndex , 1_kIndex ) MD % PartialLen = 0_kIndex END IF END IF CALL HamsiS_Process ( MD , ByteArr , CurPos , SHIFTR ( CurLen , 2 )) CurPos = CurPos + IAND ( CurLen , NOT ( 3_kIndex )) CurLen = IAND ( CurLen , 3_kIndex ) MD % Partial ( 0 : CurLen - 1 ) = ByteArr ( CurPos : CurPos + CurLen - 1 ) MD % PartialLen = CurLen RETURN END SUBROUTINE HamsiS_InsertBytes !****************************************************************************** SUBROUTINE HamsiS_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % Update ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE HamsiS_InsertGen !****************************************************************************** SUBROUTINE HamsiS_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % AddBitsNDigest ( 0_kInt8 , 0_kInt8 , ByteArr ) RETURN END SUBROUTINE HamsiS_ByteDigest !****************************************************************************** SUBROUTINE HamsiS_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE HamsiS_ByteDigest_wInput !****************************************************************************** SUBROUTINE HamsiS_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Ptr tByte :: Z tByte :: Pad ( 0 : 11 ) ! FLOW Ptr = MD % PartialLen Pad ( 0 : Ptr - 1 ) = MD % Partial ( 0 : Ptr - 1 ) CALL ByteUnpackBE ( MD % BitCount + SHIFTL ( Ptr , 3 ) + ToInt64 ( NBits ), Pad , 4_kIndex ) Z = SHIFTR ( FByte80 , NBits ) Pad ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex DO WHILE ( Ptr < 4_kIndex ) Pad ( Ptr ) = FByte00 Ptr = Ptr + 1_kIndex END DO CALL HamsiS_Process ( MD , Pad , 0_kIndex , 2_kIndex ) CALL HamsiS_Final ( MD , Pad ( 8 :)) ! get output CALL MemAlloc ( ByteArr , MD % GetDigestLen (), StartID = 0_kIndex ) DO I = 0 , ( SHIFTR ( MD % GetDigestLen (), 2 ) - 1 ) CALL ByteUnpackBE ( MD % State ( I ), ByteArr , SHIFTL ( I , 2 )) END DO ! reset the states CALL MD % Reset () RETURN END SUBROUTINE HamsiS_ByteDigest_AddBits !****************************************************************************** SUBROUTINE HamsiS_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD !! 'HamsiS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE HamsiS_HexDigest_AddBits !****************************************************************************** SUBROUTINE HamsiS_Process ( MD , Buffer , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: ! To process input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD ! 'HamsiS' object tByte , INTENT ( IN ) :: Buffer ( 0 :) ! the input data buffer tIndex , INTENT ( IN ) :: Offset ! input offset tIndex , INTENT ( IN ) :: Length ! input length to be processed (in words?) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Indx ( 0 : 3 ) tInteger :: VC ( 0 : 7 ), VM ( 0 : 7 ), T tIndex :: Num , CurID , I ! FLOW ! initialize MD % BitCount = MD % BitCount + SHIFTL ( ToInt64 ( Length ), 5 ) Num = Length CurID = Offset READ_STATE_SMALL ( VC ) DO WHILE ( Num > 0 ) Num = Num - 1 Indx ( 0 ) = GetIndex ( Buffer ( CurID )) Indx ( 1 ) = GetIndex ( Buffer ( CurID + 1 )) Indx ( 2 ) = GetIndex ( Buffer ( CurID + 2 )) Indx ( 3 ) = GetIndex ( Buffer ( CurID + 3 )) INPUT_SMALL ( VM , Indx ) ROUND_SMALL ( 0 , Alpha_N ) ROUND_SMALL ( 1 , Alpha_N ) ROUND_SMALL ( 2 , Alpha_N ) T_SMALL ( VC ) CurID = CurID + 4 END DO WRITE_STATE_SMALL ( VC ) RETURN END SUBROUTINE HamsiS_Process !****************************************************************************** SUBROUTINE HamsiS_Final ( MD , Buffer ) !** PURPOSE OF THIS SUBROUTINE: ! To process final input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HamsiS ), INTENT ( INOUT ) :: MD ! 'HamsiS' object tByte , INTENT ( IN ) :: Buffer ( 0 :) ! the input data buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Indx ( 0 : 3 ) tInteger :: VC ( 0 : 7 ), VM ( 0 : 7 ), T tIndex :: I ! FLOW READ_STATE_SMALL ( VC ) Indx ( 0 ) = GetIndex ( Buffer ( 0 )) Indx ( 1 ) = GetIndex ( Buffer ( 1 )) Indx ( 2 ) = GetIndex ( Buffer ( 2 )) Indx ( 3 ) = GetIndex ( Buffer ( 3 )) INPUT_SMALL ( VM , Indx ) ROUND_SMALL ( 0 , Alpha_F ) ROUND_SMALL ( 1 , Alpha_F ) ROUND_SMALL ( 2 , Alpha_F ) ROUND_SMALL ( 3 , Alpha_F ) ROUND_SMALL ( 4 , Alpha_F ) ROUND_SMALL ( 5 , Alpha_F ) T_SMALL ( VC ) WRITE_STATE_SMALL ( VC ) RETURN END SUBROUTINE HamsiS_Final !****************************************************************************** #include    \"Includes/HamsiS_Undef Macro.f90\" END MODULE MClass_HamsiS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hamsis.f90.html"},{"title":"MClass_Keccak.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Keccak !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Keccak* type and its related routines. !   The *Keccak* type is a *Keccak-based digest* type that extends from !   the <a href=\"../module/mclass_kp1600core.html#type-kp1600core\"> !   KP1600Core</a> type.  As a *concrete* derived type, it provides !   all remaining deferred procedures required by all its parent types. <br> !   Similar to the <a href=\"../module/mclass_sha3.html#type-sha3\">SHA3</a> !   type, the *Keccak* type represents two families of incremental !   cryptographic hash functions: the *Keccak* and the *SHA-3* families. !   Both types are functionally the same and should provide the same !   hash output if they are initialized to employ the same message-digest !   algorithm (e.g. SHA3-256).  However, they uses completely different !   implementations. <br> !   As the name suggested, the *Keccak* type represents the *Keccak* family !   by default.  However, a user can specify the *IsSHA3* flag to true !   when initializing the digest object (by calling the *Create* method) !   in order to use the padding strategy of the *SHA-3* family.  Also, !   the *Keccak* type employs the Keccak-256 hash function as a default !   algorithm.  This implies that the hash output has the output size !   and the strength of security (against pre-image attack) of 256 bits. !   The user can also specify the *Security* argument (to one of the four !   applicable values: 224, 256, 384 and 512) when initializing the digest !   object in order to use a different algorithm and get a different hash !   output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MClass_BaseDigest USE MClass_KP1600Core IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Keccak PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *Keccak* is a concrete *Keccak-based digest* type that implements an !  incremental cryptographic hash function based on the so-called Keccak !  hash functions, which is a family of message-digest algorithms. TYPE , EXTENDS ( KP1600Core ) :: Keccak PRIVATE !% flag indicating whether the SHA-3 family is employed or not. tLogical :: IsSHA3 = FalseVal !% security strength in bits tInteger :: Security = 256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => Keccak_Initialize_wOption ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Keccak-256). PROCEDURE :: Initialize => Keccak_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Keccak_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Keccak_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Keccak-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA3-256 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.TRUE.) <br> !   ! initialize the object to employ the Keccak-384 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.FALSE., Security=384) <br> !   ! initialize the object to employ the SHA3-512 algorithm <br> !   --->    CALL MD%Create(IsSHA3=.TRUE., Security=512) <br> GENERIC :: Create => InitializeWOption END TYPE Keccak !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Keccak_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Keccak ), INTENT ( INOUT ) :: MD !! 'Keccak' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the Keccak-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE Keccak_Initialize !****************************************************************************** SUBROUTINE Keccak_Initialize_wOption ( MD , IsSHA3 , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Keccak ), INTENT ( INOUT ) :: MD !! 'Keccak' object tLogical , INTENT ( IN ) :: IsSHA3 !&#94; flag indicating whether the SHA-3 family is employed or not. <br> !  - If true, use the SHA-3 family. <br> !  - Otherwise, use the Keccak algorithm. <br> tInteger , OPTIONAL , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , PARAMETER :: Keccak_Suffix = ToInt8 ( Z '01' ) tByte , PARAMETER :: SHA3_Suffix = ToInt8 ( Z '06' ) tInteger , PARAMETER :: NRounds = 24 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Capacity ! the value of the capacity C in bits tIndex :: DigestLen ! the desired length of output in bytes tByte :: Suffix ! FLOW IF ( PRESENT ( Security )) THEN SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT ELSE MD % Security = 256 END IF MD % IsSHA3 = IsSHA3 ! set input parameters for the *CoreInit* method Capacity = SHIFTL ( MD % Security , 1 ) ! Security*2 DigestLen = SHIFTR ( MD % Security , 3 ) ! Security/8 IF ( IsSHA3 ) THEN Suffix = SHA3_Suffix ELSE Suffix = Keccak_Suffix END IF ! initialize the core components CALL MD % CoreInit ( Capacity , Suffix , DigestLen , NRounds ) RETURN END SUBROUTINE Keccak_Initialize_wOption !****************************************************************************** SUBROUTINE Keccak_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Keccak ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Keccak :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Keccak ) CALL Dst % Create ( Src % IsSHA3 , Src % Security ) CALL Src % CopyState ( Dst ) END SELECT RETURN END SUBROUTINE Keccak_GetClone !****************************************************************************** FUNCTION Keccak_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Keccak ), INTENT ( IN ) :: MD !! 'Keccak' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHA3 ) THEN Name = 'SHA3-' // ToDecStrSigned ( MD % Security ) ELSE Name = 'Keccak-' // ToDecStrSigned ( MD % Security ) END IF RETURN END FUNCTION Keccak_GetName !****************************************************************************** END MODULE MClass_Keccak !******************************************************************************","tags":"","loc":"sourcefile\\mclass_keccak.f90.html"},{"title":"MBase_BytePack.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_BytePack !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains utility routines for conversion of bit patterns between !   a byte array (an array of 8-bit integers) and other integer types.  The module !   provide six procedure interfaces: BytePack, ByteUnpack, BytePackBE, ByteUnpackBE, !   BytePackLE, and ByteUnpackLE. <br> !   The *BytePack* procedure interface performs a conversion from a byte array to !   an (other) integer (or an array of other integers) using machine endianess. <br> !   The *ByteUnpack* procedure interface performs a conversion from an (other) integer !   (or an array of other integers) to a byte array using machine endianess. <br> !   The *BytePackBE* procedure interface performs a conversion from a byte array in !   big-endian order to an (other) integer (or an array of other integers). <br> !   The *ByteUnpackBE* procedure interface performs a conversion from an (other) integer !   (or an array of other integers) to a byte array in big-endian order. <br> !   The *BytePackLE* procedure interface performs a conversion from a byte array in !   little-endian order to an (other) integer (or an array of other integers). <br> !   The *ByteUnpackLE* procedure interface performs a conversion from an (other) integer !   (or an array of other integers) to a byte array in little-endian order. <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BytePack PUBLIC :: ByteUnpack PUBLIC :: BytePackBE PUBLIC :: ByteUnpackBE PUBLIC :: BytePackLE PUBLIC :: ByteUnpackLE PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #define tByte               tUInt8 #define tShort              tUInt16 #define tInteger            tUInt32 #define tLong               tUInt64 #define MaskShort(X)        IAND(ToInt16(X), ToInt16(Z'00FF')) #define MaskInteger(X)      IAND(ToInt32(X), ToInt32(Z'000000FF')) #define MaskLong(X)         IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) !** MODULE PARAMETERS: ! size of one byte in bits tFloat , PARAMETER :: ByteBits = REAL ( STORAGE_SIZE ( 0_kInt8 ), KIND = kFloat ) ! The number of bits used by each integer type tInteger , PARAMETER :: Bits_Int8 = BIT_SIZE ( 0_kInt8 ) ! should be  8 bits tInteger , PARAMETER :: Bits_Int16 = BIT_SIZE ( 0_kInt16 ) ! should be 16 bits tInteger , PARAMETER :: Bits_Int32 = BIT_SIZE ( 0_kInt32 ) ! should be 32 bits tInteger , PARAMETER :: Bits_Int64 = BIT_SIZE ( 0_kInt64 ) ! should be 64 bits ! The number of bytes used by each integer type tInteger , PARAMETER :: Bytes_Int16 = Bits_Int16 / Bits_Int8 ! should be 2 bytes tInteger , PARAMETER :: Bytes_Int32 = Bits_Int32 / Bits_Int8 ! should be 4 bytes tInteger , PARAMETER :: Bytes_Int64 = Bits_Int64 / Bits_Int8 ! should be 8 bytes !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: INTERFACE BytePack !&#94; **Subroutine Interface**: BytePack <br> !  **Purpose**:  To convert a byte array stored in machine-endian order to an !                (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br> !  **Usage**: <br> !   ! convert a byte array to an integer <br> !   --->    CALL BytePack(ByteArr, IntVal) <br> !   ! convert a byte array starting at the specified offset to an integer <br> !   --->    CALL BytePack(ByteArr, Offset, IntVal) <br> !   ! convert a byte array to an integer array <br> !   --->    CALL BytePack(ByteArr, IntArr) <br> !   ! convert a byte array starting at the specified offset to an integer array <br> !   --->    CALL BytePack(ByteArr, Offset, IntArr) MODULE PROCEDURE PackBytes_Short MODULE PROCEDURE PackBytesWOffset_Short MODULE PROCEDURE PackBytes_Shorts MODULE PROCEDURE PackBytesWOffset_Shorts MODULE PROCEDURE PackBytes_Integer MODULE PROCEDURE PackBytesWOffset_Integer MODULE PROCEDURE PackBytes_Integers MODULE PROCEDURE PackBytesWOffset_Integers MODULE PROCEDURE PackBytes_Long MODULE PROCEDURE PackBytesWOffset_Long MODULE PROCEDURE PackBytes_Longs MODULE PROCEDURE PackBytesWOffset_Longs END INTERFACE INTERFACE ByteUnpack !&#94; **Subroutine Interface**: ByteUnpack <br> !  **Purpose**:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array !                of integers) to a byte array stored in machine-endian order. <br> !  **Usage**: <br> !   ! convert an integer to a byte array <br> !   --->    CALL ByteUnpack(IntVal, ByteArr) <br> !   ! convert an integer to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpack(IntVal, ByteArr, Offset) <br> !   ! convert an integer array to a byte array <br> !   --->    CALL ByteUnpack(IntArr, ByteArr) <br> !   ! convert an integer array to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpack(IntArr, ByteArr, Offset) MODULE PROCEDURE UnpackBytes_Short MODULE PROCEDURE UnpackBytesWOffset_Short MODULE PROCEDURE UnpackBytes_Shorts MODULE PROCEDURE UnpackBytesWOffset_Shorts MODULE PROCEDURE UnpackBytes_Integer MODULE PROCEDURE UnpackBytesWOffset_Integer MODULE PROCEDURE UnpackBytes_Integers MODULE PROCEDURE UnpackBytesWOffset_Integers MODULE PROCEDURE UnpackBytes_Long MODULE PROCEDURE UnpackBytesWOffset_Long MODULE PROCEDURE UnpackBytes_Longs MODULE PROCEDURE UnpackBytesWOffset_Longs END INTERFACE INTERFACE BytePackBE !&#94; **Subroutine Interface**: BytePackBE <br> !  **Purpose**:  To convert a byte array stored in big-endian order to an !                (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br> !  **Usage**: <br> !   ! convert a byte array to an integer <br> !   --->    CALL BytePackBE(ByteArr, IntVal) <br> !   ! convert a byte array starting at the specified offset to an integer <br> !   --->    CALL BytePackBE(ByteArr, Offset, IntVal) <br> !   ! convert a byte array to an integer array <br> !   --->    CALL BytePackBE(ByteArr, IntArr) <br> !   ! convert a byte array starting at the specified offset to an integer array <br> !   --->    CALL BytePackBE(ByteArr, Offset, IntArr) MODULE PROCEDURE PackBytesBE_Short MODULE PROCEDURE PackBytesBEWOffset_Short MODULE PROCEDURE PackBytesBE_Shorts MODULE PROCEDURE PackBytesBEWOffset_Shorts MODULE PROCEDURE PackBytesBE_Integer MODULE PROCEDURE PackBytesBEWOffset_Integer MODULE PROCEDURE PackBytesBE_Integers MODULE PROCEDURE PackBytesBEWOffset_Integers MODULE PROCEDURE PackBytesBE_Long MODULE PROCEDURE PackBytesBEWOffset_Long MODULE PROCEDURE PackBytesBE_Longs MODULE PROCEDURE PackBytesBEWOffset_Longs END INTERFACE INTERFACE ByteUnpackBE !&#94; **Subroutine Interface**: ByteUnpackBE <br> !  **Purpose**:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array !                of integers) to a byte array stored in big-endian order. <br> !  **Usage**: <br> !   ! convert an integer to a byte array <br> !   --->    CALL ByteUnpackBE(IntVal, ByteArr) <br> !   ! convert an integer to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpackBE(IntVal, ByteArr, Offset) <br> !   ! convert an integer array to a byte array <br> !   --->    CALL ByteUnpackBE(IntArr, ByteArr) <br> !   ! convert an integer array to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpackBE(IntArr, ByteArr, Offset) MODULE PROCEDURE UnpackBytesBE_Short MODULE PROCEDURE UnpackBytesBEWOffset_Short MODULE PROCEDURE UnpackBytesBE_Shorts MODULE PROCEDURE UnpackBytesBEWOffset_Shorts MODULE PROCEDURE UnpackBytesBE_Integer MODULE PROCEDURE UnpackBytesBEWOffset_Integer MODULE PROCEDURE UnpackBytesBE_Integers MODULE PROCEDURE UnpackBytesBEWOffset_Integers MODULE PROCEDURE UnpackBytesBE_Long MODULE PROCEDURE UnpackBytesBEWOffset_Long MODULE PROCEDURE UnpackBytesBE_Longs MODULE PROCEDURE UnpackBytesBEWOffset_Longs END INTERFACE INTERFACE BytePackLE !&#94; **Subroutine Interface**: BytePackLE <br> !  **Purpose**:  To convert a byte array stored in little-endian order to an !                (16-bit, 32-bit or 64-bit) integer (or an array of integers). <br> !  **Usage**: <br> !   ! convert a byte array to an integer <br> !   --->    CALL BytePackLE(ByteArr, IntVal) <br> !   ! convert a byte array starting at the specified offset to an integer <br> !   --->    CALL BytePackLE(ByteArr, Offset, IntVal) <br> !   ! convert a byte array to an integer array <br> !   --->    CALL BytePackLE(ByteArr, IntArr) <br> !   ! convert a byte array starting at the specified offset to an integer array <br> !   --->    CALL BytePackLE(ByteArr, Offset, IntArr) MODULE PROCEDURE PackBytesLE_Short MODULE PROCEDURE PackBytesLEWOffset_Short MODULE PROCEDURE PackBytesLE_Shorts MODULE PROCEDURE PackBytesLEWOffset_Shorts MODULE PROCEDURE PackBytesLE_Integer MODULE PROCEDURE PackBytesLEWOffset_Integer MODULE PROCEDURE PackBytesLE_Integers MODULE PROCEDURE PackBytesLEWOffset_Integers MODULE PROCEDURE PackBytesLE_Long MODULE PROCEDURE PackBytesLEWOffset_Long MODULE PROCEDURE PackBytesLE_Longs MODULE PROCEDURE PackBytesLEWOffset_Longs END INTERFACE INTERFACE ByteUnpackLE !&#94; **Subroutine Interface**: ByteUnpackLE <br> !  **Purpose**:  To convert an (16-bit, 32-bit or 64-bit) integer (or an array !                of integers) to a byte array stored in little-endian order. <br> !  **Usage**: <br> !   ! convert an integer to a byte array <br> !   --->    CALL ByteUnpackLE(IntVal, ByteArr) <br> !   ! convert an integer to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpackLE(IntVal, ByteArr, Offset) <br> !   ! convert an integer array to a byte array <br> !   --->    CALL ByteUnpackLE(IntArr, ByteArr) <br> !   ! convert an integer array to a byte array starting at the specified offset <br> !   --->    CALL ByteUnpackLE(IntArr, ByteArr, Offset) MODULE PROCEDURE UnpackBytesLE_Short MODULE PROCEDURE UnpackBytesLEWOffset_Short MODULE PROCEDURE UnpackBytesLE_Shorts MODULE PROCEDURE UnpackBytesLEWOffset_Shorts MODULE PROCEDURE UnpackBytesLE_Integer MODULE PROCEDURE UnpackBytesLEWOffset_Integer MODULE PROCEDURE UnpackBytesLE_Integers MODULE PROCEDURE UnpackBytesLEWOffset_Integers MODULE PROCEDURE UnpackBytesLE_Long MODULE PROCEDURE UnpackBytesLEWOffset_Long MODULE PROCEDURE UnpackBytesLE_Longs MODULE PROCEDURE UnpackBytesLEWOffset_Longs END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !------------------------------------------------------------------------------ !-----                          Pack Procedures                           ----- !------------------------------------------------------------------------------ SUBROUTINE PackBytes_Short ( ByteArr , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int16 ) !! byte array tShort , TARGET , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output ! FLOW ! get a C pointer to the output CPtr = C_LOC ( I16 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int16 ]) ! copy bit patterns fPtr = ByteArr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Short !****************************************************************************** SUBROUTINE PackBytesWOffset_Short ( ByteArr , Offset , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I16 ) RETURN END SUBROUTINE PackBytesWOffset_Short !****************************************************************************** SUBROUTINE PackBytes_Shorts ( ByteArr , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tShort , TARGET , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) * Bytes_Int16 ! get a C pointer to the output CPtr = C_LOC ( I16Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns fPtr = ByteArr ( 1 : MinBytes ) ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Shorts !****************************************************************************** SUBROUTINE PackBytesWOffset_Shorts ( ByteArr , Offset , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I16Arr ) RETURN END SUBROUTINE PackBytesWOffset_Shorts !****************************************************************************** SUBROUTINE PackBytes_Integer ( ByteArr , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int32 ) !! byte array tInteger , TARGET , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output ! FLOW ! get a C pointer to the output CPtr = C_LOC ( I32 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int32 ]) ! copy bit patterns fPtr = ByteArr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Integer !****************************************************************************** SUBROUTINE PackBytesWOffset_Integer ( ByteArr , Offset , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I32 ) RETURN END SUBROUTINE PackBytesWOffset_Integer !****************************************************************************** SUBROUTINE PackBytes_Integers ( ByteArr , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tInteger , TARGET , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) * Bytes_Int32 ! get a C pointer to the output CPtr = C_LOC ( I32Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns fPtr = ByteArr ( 1 : MinBytes ) ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Integers !****************************************************************************** SUBROUTINE PackBytesWOffset_Integers ( ByteArr , Offset , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I32Arr ) RETURN END SUBROUTINE PackBytesWOffset_Integers !****************************************************************************** SUBROUTINE PackBytes_Long ( ByteArr , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int64 ) !! byte array tLong , TARGET , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output ! FLOW ! get a C pointer to the output CPtr = C_LOC ( I64 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int64 ]) ! copy bit patterns fPtr = ByteArr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Long !****************************************************************************** SUBROUTINE PackBytesWOffset_Long ( ByteArr , Offset , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I64 ) RETURN END SUBROUTINE PackBytesWOffset_Long !****************************************************************************** SUBROUTINE PackBytes_Longs ( ByteArr , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tLong , TARGET , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) * Bytes_Int64 ! get a C pointer to the output CPtr = C_LOC ( I64Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns fPtr = ByteArr ( 1 : MinBytes ) ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE PackBytes_Longs !****************************************************************************** SUBROUTINE PackBytesWOffset_Longs ( ByteArr , Offset , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored according to the machine endianess) !  starting at the offset to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePack ( ByteArr ( Offset :), I64Arr ) RETURN END SUBROUTINE PackBytesWOffset_Longs !------------------------------------------------------------------------------ !-----                         Unpack Procedures                          ----- !------------------------------------------------------------------------------ SUBROUTINE UnpackBytes_Short ( I16 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored according to !  the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , TARGET , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int16 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! get a C pointer to the input CPtr = C_LOC ( I16 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int16 ]) ! copy bit patterns ByteArr = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Short !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Short ( I16 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored according to !  the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I16 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Short !****************************************************************************** SUBROUTINE UnpackBytes_Shorts ( I16Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  according to the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , TARGET , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) * Bytes_Int16 ! get a C pointer to the output CPtr = C_LOC ( I16Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns ByteArr ( 1 : MinBytes ) = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Shorts !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Shorts ( I16Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  according to the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I16Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Shorts !****************************************************************************** SUBROUTINE UnpackBytes_Integer ( I32 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored according to !  the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , TARGET , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int32 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! get a C pointer to the input CPtr = C_LOC ( I32 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int32 ]) ! copy bit patterns ByteArr = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Integer !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Integer ( I32 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored according to !  the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I32 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Integer !****************************************************************************** SUBROUTINE UnpackBytes_Integers ( I32Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  according to the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , TARGET , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) * Bytes_Int32 ! get a C pointer to the output CPtr = C_LOC ( I32Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns ByteArr ( 1 : MinBytes ) = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Integers !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Integers ( I32Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  according to the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I32Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Integers !****************************************************************************** SUBROUTINE UnpackBytes_Long ( I64 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored according to !  the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , TARGET , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int64 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! get a C pointer to the input CPtr = C_LOC ( I64 ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ Bytes_Int64 ]) ! copy bit patterns ByteArr = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Long !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Long ( I64 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored according to !  the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I64 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Long !****************************************************************************** SUBROUTINE UnpackBytes_Longs ( I64Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  according to the machine endianess). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , TARGET , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: fPtr (:) ! Fortran pointer to the output TYPE ( C_PTR ) :: CPtr ! C pointer to the output tInteger :: MinBytes ! minimum byte sizes to transfer data ! FLOW ! get minimum byte sizes MinBytes = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) * Bytes_Int64 ! get a C pointer to the output CPtr = C_LOC ( I64Arr ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ MinBytes ]) ! copy bit patterns ByteArr ( 1 : MinBytes ) = fPtr ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE UnpackBytes_Longs !****************************************************************************** SUBROUTINE UnpackBytesWOffset_Longs ( I64Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  according to the machine endianess) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpack ( I64Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesWOffset_Longs !------------------------------------------------------------------------------ !-----                         BytePackBE Procedures                      ----- !------------------------------------------------------------------------------ SUBROUTINE PackBytesBE_Short ( ByteArr , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int16 ) !! byte array tShort , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 I16 = IOR ( SHIFTL ( MaskShort ( ByteArr ( 1 )), 8 ), MaskShort ( ByteArr ( 2 ))) ! implementation algorithm #2 (comparable to #1) !    I16 = SHIFTL(MaskShort(ByteArr(1)), 8) + MaskShort(ByteArr(2)) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    I16 = ToInt16(UnsignedShort(ByteArr, 1)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I16 = 0 !    CALL MVBITS(MaskShort(ByteArr(1)), 0, 8, I16, 8) !    CALL MVBITS(MaskShort(ByteArr(2)), 0, 8, I16, 0) ! implementation algorithm #5 (slowest) !    I16 = TRANSFER([ByteArr(2), ByteArr(1)], 0_kInt16) RETURN END SUBROUTINE PackBytesBE_Short !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Short ( ByteArr , Offset , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I16 ) RETURN END SUBROUTINE PackBytesBEWOffset_Short !****************************************************************************** SUBROUTINE PackBytesBE_Shorts ( ByteArr , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tShort , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum size MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackBE ( ByteArr , Offset , I16Arr ( I )) Offset = Offset + 2 END DO RETURN END SUBROUTINE PackBytesBE_Shorts !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Shorts ( ByteArr , Offset , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I16Arr ) RETURN END SUBROUTINE PackBytesBEWOffset_Shorts !****************************************************************************** SUBROUTINE PackBytesBE_Integer ( ByteArr , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int32 ) !! byte array tInteger , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 I32 = IOR ( IOR ( IOR ( SHIFTL ( MaskInteger ( ByteArr ( 1 )), 24 ), & SHIFTL ( MaskInteger ( ByteArr ( 2 )), 16 )), & SHIFTL ( MaskInteger ( ByteArr ( 3 )), 8 )), & MaskInteger ( ByteArr ( 4 ))) ! implementation algorithm #2 (comparable to #1) !    I32 = SHIFTL(MaskInteger(ByteArr(1)), 24) + & !          SHIFTL(MaskInteger(ByteArr(2)), 16) + & !          SHIFTL(MaskInteger(ByteArr(3)),  8) + & !                 MaskInteger(ByteArr(4)) ! implementation algorithm #3 (comparable to #1) !#define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), ToInt32(Z'000000FF')) !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    I32 = IOR(UnsignedShort(ByteArr, 3), SHIFTL(UnsignedShort(ByteArr, 1), 16)) !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I32 = 0 !    DO I = 0, 3 !        CALL MVBITS(MaskInteger(ByteArr(1+I)), 0, 8, I32, 24-I*8) !    END DO ! implementation algorithm #5 (slowest) !    I32 = TRANSFER([ByteArr(4), ByteArr(3), ByteArr(2), ByteArr(1)], 0_kInt32) RETURN END SUBROUTINE PackBytesBE_Integer !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Integer ( ByteArr , Offset , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I32 ) RETURN END SUBROUTINE PackBytesBEWOffset_Integer !****************************************************************************** SUBROUTINE PackBytesBE_Integers ( ByteArr , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tInteger , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackBE ( ByteArr , Offset , I32Arr ( I )) Offset = Offset + 4 END DO RETURN END SUBROUTINE PackBytesBE_Integers !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Integers ( ByteArr , Offset , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I32Arr ) RETURN END SUBROUTINE PackBytesBEWOffset_Integers !****************************************************************************** SUBROUTINE PackBytesBE_Long ( ByteArr , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int64 ) !! byte array tLong , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 (second fastest) !    I64 = IOR(IOR(IOR(IOR(IOR(IOR(IOR(SHIFTL(MaskLong(ByteArr(1)), 56),   & !                                      SHIFTL(MaskLong(ByteArr(2)), 48)),  & !                                      SHIFTL(MaskLong(ByteArr(3)), 40)),  & !                                      SHIFTL(MaskLong(ByteArr(4)), 32)),  & !                                      SHIFTL(MaskLong(ByteArr(5)), 24)),  & !                                      SHIFTL(MaskLong(ByteArr(6)), 16)),  & !                                      SHIFTL(MaskLong(ByteArr(7)),  8)),  & !                                             MaskLong(ByteArr(8))) ! implementation algorithm #2 (comparable to #1) !    I64 = SHIFTL(MaskLong(ByteArr(1)), 56) + & !          SHIFTL(MaskLong(ByteArr(2)), 48) + & !          SHIFTL(MaskLong(ByteArr(3)), 40) + & !          SHIFTL(MaskLong(ByteArr(4)), 32) + & !          SHIFTL(MaskLong(ByteArr(5)), 24) + & !          SHIFTL(MaskLong(ByteArr(6)), 16) + & !          SHIFTL(MaskLong(ByteArr(7)),  8) + & !                 MaskLong(ByteArr(8)) ! implementation algorithm #3 (fastest) #define Byte2Integer(Val, Off)      ToInt32(Val(Off)) #define UnsignedByte(Val, Off)      IAND(Byte2Integer(Val, Off), Z'000000FF') #define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) #define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off+2), SHIFTL(UnsignedShort(Val, Off), 16)) #define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), Z'00000000FFFFFFFF') I64 = IOR ( UnsignedInteger ( ByteArr , 5 ), SHIFTL ( UnsignedInteger ( ByteArr , 1 ), 32 )) #undef Byte2Integer #undef UnsignedByte #undef UnsignedShort #undef SignedInteger #undef UnsignedInteger ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I64 = 0 !    DO I = 0, 7 !        CALL MVBITS(MaskLong(ByteArr(1+I)), 0, 8, I64, 56-I*8) !    END DO ! implementation algorithm #5 (slowest) !    I64 = TRANSFER([ByteArr(8), ByteArr(7), ByteArr(6), ByteArr(5), & !                   ByteArr(4), ByteArr(3), ByteArr(2), ByteArr(1)], 0_kInt64) RETURN END SUBROUTINE PackBytesBE_Long !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Long ( ByteArr , Offset , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I64 ) RETURN END SUBROUTINE PackBytesBEWOffset_Long !****************************************************************************** SUBROUTINE PackBytesBE_Longs ( ByteArr , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tLong , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackBE ( ByteArr , Offset , I64Arr ( I )) Offset = Offset + 8 END DO RETURN END SUBROUTINE PackBytesBE_Longs !****************************************************************************** SUBROUTINE PackBytesBEWOffset_Longs ( ByteArr , Offset , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in big-endian order) !  starting at the offset to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackBE ( ByteArr ( Offset :), I64Arr ) RETURN END SUBROUTINE PackBytesBEWOffset_Longs !------------------------------------------------------------------------------ !-----                        ByteUnpackBE Procedures                     ----- !------------------------------------------------------------------------------ SUBROUTINE UnpackBytesBE_Short ( I16 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int16 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( SHIFTR ( I16 , 8 )) ByteArr ( 2 ) = ToInt8 ( I16 ) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I16, 8, 8)) !    ByteArr(2) = ToInt8(IBITS(I16, 0, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I16, ByteArr) !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesBE_Short !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Short ( I16 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored in big-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I16 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Short !****************************************************************************** SUBROUTINE UnpackBytesBE_Shorts ( I16Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum byte sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackBE ( I16Arr ( I ), ByteArr , Offset ) Offset = Offset + 2 END DO RETURN END SUBROUTINE UnpackBytesBE_Shorts !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Shorts ( I16Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  in big-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I16Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Shorts !****************************************************************************** SUBROUTINE UnpackBytesBE_Integer ( I32 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int32 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( SHIFTR ( I32 , 24 )) ByteArr ( 2 ) = ToInt8 ( SHIFTR ( I32 , 16 )) ByteArr ( 3 ) = ToInt8 ( SHIFTR ( I32 , 8 )) ByteArr ( 4 ) = ToInt8 ( I32 ) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I32, 24, 8)) !    ByteArr(2) = ToInt8(IBITS(I32, 16, 8)) !    ByteArr(3) = ToInt8(IBITS(I32,  8, 8)) !    ByteArr(4) = ToInt8(IBITS(I32,  0, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I32, ByteArr) !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesBE_Integer !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Integer ( I32 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored in big-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I32 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Integer !****************************************************************************** SUBROUTINE UnpackBytesBE_Integers ( I32Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum byte sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackBE ( I32Arr ( I ), ByteArr , Offset ) Offset = Offset + 4 END DO RETURN END SUBROUTINE UnpackBytesBE_Integers !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Integers ( I32Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  in big-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I32Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Integers !****************************************************************************** SUBROUTINE UnpackBytesBE_Long ( I64 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int64 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( SHIFTR ( I64 , 56 )) ByteArr ( 2 ) = ToInt8 ( SHIFTR ( I64 , 48 )) ByteArr ( 3 ) = ToInt8 ( SHIFTR ( I64 , 40 )) ByteArr ( 4 ) = ToInt8 ( SHIFTR ( I64 , 32 )) ByteArr ( 5 ) = ToInt8 ( SHIFTR ( I64 , 24 )) ByteArr ( 6 ) = ToInt8 ( SHIFTR ( I64 , 16 )) ByteArr ( 7 ) = ToInt8 ( SHIFTR ( I64 , 8 )) ByteArr ( 8 ) = ToInt8 ( I64 ) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I64, 56, 8)) !    ByteArr(2) = ToInt8(IBITS(I64, 48, 8)) !    ByteArr(3) = ToInt8(IBITS(I64, 40, 8)) !    ByteArr(4) = ToInt8(IBITS(I64, 32, 8)) !    ByteArr(5) = ToInt8(IBITS(I64, 24, 8)) !    ByteArr(6) = ToInt8(IBITS(I64, 16, 8)) !    ByteArr(7) = ToInt8(IBITS(I64,  8, 8)) !    ByteArr(8) = ToInt8(IBITS(I64,  0, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I64, ByteArr) !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesBE_Long !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Long ( I64 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored in big-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I64 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Long !****************************************************************************** SUBROUTINE UnpackBytesBE_Longs ( I64Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  in big-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum byte sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackBE ( I64Arr ( I ), ByteArr , Offset ) Offset = Offset + 8 END DO RETURN END SUBROUTINE UnpackBytesBE_Longs !****************************************************************************** SUBROUTINE UnpackBytesBEWOffset_Longs ( I64Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  in big-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackBE ( I64Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesBEWOffset_Longs !------------------------------------------------------------------------------ !-----                         BytePackLE Procedures                      ----- !------------------------------------------------------------------------------ SUBROUTINE PackBytesLE_Short ( ByteArr , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int16 ) !! byte array tShort , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 I16 = IOR ( MaskShort ( ByteArr ( 1 )), SHIFTL ( MaskShort ( ByteArr ( 2 )), 8 )) ! implementation algorithm #2 (comparable to #1) !    I16 = MaskShort(ByteArr(1)) + SHIFTL(MaskShort(ByteArr(2)), 8) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) !    I16 = ToInt16(UnsignedShort(ByteArr, 1)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I16 = 0 !    CALL MVBITS(MaskShort(ByteArr(1)), 0, 8, I16, 0) !    CALL MVBITS(MaskShort(ByteArr(2)), 0, 8, I16, 8) ! implementation algorithm #5 (slowest) !    I16 = TRANSFER([ByteArr(1), ByteArr(2)], 0_kInt16) RETURN END SUBROUTINE PackBytesLE_Short !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Short ( ByteArr , Offset , I16 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to a 16-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16 !! 16-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I16 ) RETURN END SUBROUTINE PackBytesLEWOffset_Short !****************************************************************************** SUBROUTINE PackBytesLE_Shorts ( ByteArr , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tShort , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum size MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackLE ( ByteArr , Offset , I16Arr ( I )) Offset = Offset + 2 END DO RETURN END SUBROUTINE PackBytesLE_Shorts !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Shorts ( ByteArr , Offset , I16Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to an array of 16-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tShort , INTENT ( OUT ) :: I16Arr (:) !! array of 16-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I16Arr ) RETURN END SUBROUTINE PackBytesLEWOffset_Shorts !****************************************************************************** SUBROUTINE PackBytesLE_Integer ( ByteArr , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int32 ) !! byte array tInteger , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 I32 = IOR ( IOR ( IOR ( MaskInteger ( ByteArr ( 1 )), & SHIFTL ( MaskInteger ( ByteArr ( 2 )), 8 )), & SHIFTL ( MaskInteger ( ByteArr ( 3 )), 16 )), & SHIFTL ( MaskInteger ( ByteArr ( 4 )), 24 )) ! implementation algorithm #2 (comparable to #1) !    I32 =        MaskInteger(ByteArr(1))        + & !          SHIFTL(MaskInteger(ByteArr(2)),  8) + & !          SHIFTL(MaskInteger(ByteArr(3)), 16) + & !          SHIFTL(MaskInteger(ByteArr(4)), 24) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), ToInt32(Z'000000FF')) !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) !       I32 = IOR(UnsignedShort(ByteArr, 1), SHIFTL(UnsignedShort(ByteArr, 3), 16)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I32 = 0 !    DO I = 0, 3 !        CALL MVBITS(MaskInteger(ByteArr(1+I)), 0, 8, I32, I*8) !    END DO ! implementation algorithm #5 (slowest) !    I32 = TRANSFER([ByteArr(1), ByteArr(2), ByteArr(3), ByteArr(4)], 0_kInt32) RETURN END SUBROUTINE PackBytesLE_Integer !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Integer ( ByteArr , Offset , I32 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to a 32-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32 !! 32-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I32 ) RETURN END SUBROUTINE PackBytesLEWOffset_Integer !****************************************************************************** SUBROUTINE PackBytesLE_Integers ( ByteArr , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tInteger , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum byte sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackLE ( ByteArr , Offset , I32Arr ( I )) Offset = Offset + 4 END DO RETURN END SUBROUTINE PackBytesLE_Integers !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Integers ( ByteArr , Offset , I32Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to an array of 32-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tInteger , INTENT ( OUT ) :: I32Arr (:) !! array of 32-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I32Arr ) RETURN END SUBROUTINE PackBytesLEWOffset_Integers !****************************************************************************** SUBROUTINE PackBytesLE_Long ( ByteArr , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( Bytes_Int64 ) !! byte array tLong , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 (second fastest) !    I64 = IOR(IOR(IOR(IOR(IOR(IOR(IOR(       MaskLong(ByteArr(1)),          & !                                      SHIFTL(MaskLong(ByteArr(2)),  8)),  & !                                      SHIFTL(MaskLong(ByteArr(3)), 16)),  & !                                      SHIFTL(MaskLong(ByteArr(4)), 24)),  & !                                      SHIFTL(MaskLong(ByteArr(5)), 32)),  & !                                      SHIFTL(MaskLong(ByteArr(6)), 40)),  & !                                      SHIFTL(MaskLong(ByteArr(7)), 48)),  & !                                      SHIFTL(MaskLong(ByteArr(8)), 56)) ! implementation algorithm #2 (comparable to #1) !    I64 =        MaskLong(ByteArr(1))      + & !          SHIFTL(MaskLong(ByteArr(2)),  8) + & !          SHIFTL(MaskLong(ByteArr(3)), 16) + & !          SHIFTL(MaskLong(ByteArr(4)), 24) + & !          SHIFTL(MaskLong(ByteArr(5)), 32) + & !          SHIFTL(MaskLong(ByteArr(6)), 40) + & !          SHIFTL(MaskLong(ByteArr(7)), 48) + & !          SHIFTL(MaskLong(ByteArr(8)), 56) ! implementation algorithm #3 (fastest) #define UnsignedByte(Val, Off)      IAND(ToInt32(Val(Off)), ToInt32(Z'000000FF')) #define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) #define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off), SHIFTL(UnsignedShort(Val, Off+2), 16)) #define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), ToInt64(Z'00000000FFFFFFFF')) I64 = IOR ( UnsignedInteger ( ByteArr , 1 ), SHIFTL ( UnsignedInteger ( ByteArr , 5 ), 32 )) #undef UnsignedByte #undef UnsignedShort #undef SignedInteger #undef UnsignedInteger ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    I64 = 0_kInt64 !    DO I = 0, 7 !        CALL MVBITS(MaskLong(ByteArr(I+1)), 0, 8, I64, I*8) !    END DO ! implementation algorithm #5 (slowest) !    I64 = TRANSFER([ByteArr(1), ByteArr(2), ByteArr(3), ByteArr(4), & !                   ByteArr(5), ByteArr(6), ByteArr(7), ByteArr(8)], 0_kInt64) RETURN END SUBROUTINE PackBytesLE_Long !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Long ( ByteArr , Offset , I64 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to a 64-bit integer. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64 !! 64-bit integer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I64 ) RETURN END SUBROUTINE PackBytesLEWOffset_Long !****************************************************************************** SUBROUTINE PackBytesLE_Longs ( ByteArr , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr (:) !! byte array tLong , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum byte sizes MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) Offset = 0 DO I = 1 , MinSize CALL BytePackLE ( ByteArr , Offset , I64Arr ( I )) Offset = Offset + 8 END DO RETURN END SUBROUTINE PackBytesLE_Longs !****************************************************************************** SUBROUTINE PackBytesLEWOffset_Longs ( ByteArr , Offset , I64Arr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from the byte array (stored in little-endian order) !  starting at the offset to an array of 64-bit integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array tLong , INTENT ( OUT ) :: I64Arr (:) !! array of 64-bit integers !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BytePackLE ( ByteArr ( Offset :), I64Arr ) RETURN END SUBROUTINE PackBytesLEWOffset_Longs !------------------------------------------------------------------------------ !-----                        ByteUnpackLE Procedures                     ----- !------------------------------------------------------------------------------ SUBROUTINE UnpackBytesLE_Short ( I16 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int16 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( I16 ) ByteArr ( 2 ) = ToInt8 ( SHIFTR ( I16 , 8 )) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I16, 0, 8)) !    ByteArr(2) = ToInt8(IBITS(I16, 8, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I16, ByteArr) !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesLE_Short !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Short ( I16 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 16-bit integer to the byte array (stored in little-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16 !! 16-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I16 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Short !****************************************************************************** SUBROUTINE UnpackBytesLE_Shorts ( I16Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum size MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int16 , SIZE ( I16Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackLE ( I16Arr ( I ), ByteArr , Offset ) Offset = Offset + 2 END DO RETURN END SUBROUTINE UnpackBytesLE_Shorts !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Shorts ( I16Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 16-bit integers to the byte array (stored !  in little-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tShort , INTENT ( IN ) :: I16Arr (:) !! array of 16-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I16Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Shorts !****************************************************************************** SUBROUTINE UnpackBytesLE_Integer ( I32 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int32 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( I32 ) ByteArr ( 2 ) = ToInt8 ( SHIFTR ( I32 , 8 )) ByteArr ( 3 ) = ToInt8 ( SHIFTR ( I32 , 16 )) ByteArr ( 4 ) = ToInt8 ( SHIFTR ( I32 , 24 )) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I32,  0, 8)) !    ByteArr(2) = ToInt8(IBITS(I32,  8, 8)) !    ByteArr(3) = ToInt8(IBITS(I32, 16, 8)) !    ByteArr(4) = ToInt8(IBITS(I32, 24, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I32, ByteArr) !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesLE_Integer !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Integer ( I32 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 32-bit integer to the byte array (stored in little-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32 !! 32-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I32 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Integer !****************************************************************************** SUBROUTINE UnpackBytesLE_Integers ( I32Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum size MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int32 , SIZE ( I32Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackLE ( I32Arr ( I ), ByteArr , Offset ) Offset = Offset + 4 END DO RETURN END SUBROUTINE UnpackBytesLE_Integers !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Integers ( I32Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 32-bit integers to the byte array (stored !  in little-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( IN ) :: I32Arr (:) !! array of 32-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I32Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Integers !****************************************************************************** SUBROUTINE UnpackBytesLE_Long ( I64 , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( Bytes_Int64 ) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 ByteArr ( 1 ) = ToInt8 ( I64 ) ByteArr ( 2 ) = ToInt8 ( SHIFTR ( I64 , 8 )) ByteArr ( 3 ) = ToInt8 ( SHIFTR ( I64 , 16 )) ByteArr ( 4 ) = ToInt8 ( SHIFTR ( I64 , 24 )) ByteArr ( 5 ) = ToInt8 ( SHIFTR ( I64 , 32 )) ByteArr ( 6 ) = ToInt8 ( SHIFTR ( I64 , 40 )) ByteArr ( 7 ) = ToInt8 ( SHIFTR ( I64 , 48 )) ByteArr ( 8 ) = ToInt8 ( SHIFTR ( I64 , 56 )) ! implementation algorithm #2 (comparable to #1) !    ByteArr(1) = ToInt8(IBITS(I64,  0, 8)) !    ByteArr(2) = ToInt8(IBITS(I64,  8, 8)) !    ByteArr(3) = ToInt8(IBITS(I64, 16, 8)) !    ByteArr(4) = ToInt8(IBITS(I64, 24, 8)) !    ByteArr(5) = ToInt8(IBITS(I64, 32, 8)) !    ByteArr(6) = ToInt8(IBITS(I64, 40, 8)) !    ByteArr(7) = ToInt8(IBITS(I64, 48, 8)) !    ByteArr(8) = ToInt8(IBITS(I64, 56, 8)) ! implementation algorithm #3 (slowest) !    ByteArr = TRANSFER(I64, ByteArr) !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE UnpackBytesLE_Long !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Long ( I64 , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from a 64-bit integer to the byte array (stored in little-endian order) !  starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64 !! 64-bit integer tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I64 , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Long !****************************************************************************** SUBROUTINE UnpackBytesLE_Longs ( I64Arr , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  in little-endian order). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr (:) !! byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinSize , Offset , I ! FLOW ! get minimum size MinSize = MIN ( SIZE ( ByteArr ) / Bytes_Int64 , SIZE ( I64Arr )) Offset = 0 DO I = 1 , MinSize CALL ByteUnpackLE ( I64Arr ( I ), ByteArr , Offset ) Offset = Offset + 8 END DO RETURN END SUBROUTINE UnpackBytesLE_Longs !****************************************************************************** SUBROUTINE UnpackBytesLEWOffset_Longs ( I64Arr , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert from an array of 64-bit integers to the byte array (stored !  in little-endian order) starting at the offset. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( IN ) :: I64Arr (:) !! array of 64-bit integers tByte , INTENT ( OUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! starting index of the byte array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL ByteUnpackLE ( I64Arr , ByteArr ( Offset :)) RETURN END SUBROUTINE UnpackBytesLEWOffset_Longs !****************************************************************************** #undef MaskInteger #undef MaskLong END MODULE MBase_BytePack !******************************************************************************","tags":"","loc":"sourcefile\\mbase_bytepack.f90.html"},{"title":"MBase_ExperimentalHash64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_ExperimentalHash64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains an experimental implementation of various non-cryptographic !   hash function routines that output a hash value as a 64-bit integer.  The available !   hash functions are a subset of those reference hash functions implemented in the !   <a href=\"../module/mbase_referencehash64.html\">ModBase_ReferenceHash64</a> module. !   The API of these experimental routines are the same as those reference routines with !   the exception of an additional argument (*Algo*). <br> !   The *Algo* argument is an algorithm flag used to indicate which algorithm is employed !   to implement a *Pack_I64* procedure, which perform a conversion from an array of eight !   8-bit integers to a 64-bit integer.  There are a number of possible implementations !   of the *Pack_I64* procedure.  In this module, seven basic implementations are provided. !   A user can perform a benchmark of each specific hash function routine in order to know !   which one of the *Pack_I64* algorithms is the best one for a particular system (i.e. !   a combination of operating system, machine as well as compiler used).  The benchmark !   can then be used to implement an optimal implementation of the hash function. <br> !   <br> !&#94; **REFERENCES**: <br> !   See the <a href=\"../module/mbase_referencehash64.html\">ModBase_ReferenceHash64</a> !   module for references of the available hash functions in this module. !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_ByteUtil , ONLY : SwapBytes , SwapByteArray IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: City_Hash64_Exp PUBLIC :: FarmNa_Hash64_Exp PUBLIC :: FarmUo_Hash64_Exp PUBLIC :: Komi_Hash64_Exp PUBLIC :: Metro_Hash64_Exp PUBLIC :: Murmur3_Hash128_Exp PUBLIC :: PengyV02_Hash64_Exp PUBLIC :: PengyV03_Hash64_Exp PUBLIC :: Spooky_Hash128_Exp PUBLIC :: Wy_Hash64_Exp PUBLIC :: WyF3_Hash64_Exp PUBLIC :: XX_Hash64_Exp PUBLIC :: XX3_Hash64_Exp PUBLIC :: XX3_Hash128_Exp PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define MaskI64(X)      IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_ExperimentalHash64' ! The maximum (positive) number of hash code tUInt64 , PARAMETER :: MaxHash = ToInt64 ( Z '7FFFFFFFFFFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !---------------------------------------------------------------------- FUNCTION Pack_I64 ( ByteArr , Offset ) RESULT ( Res ) !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value. IMPORT tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result END FUNCTION Pack_I64 !---------------------------------------------------------------------- SUBROUTINE Unpack_I64 ( Val , ByteArr , Offset ) !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset to. IMPORT tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset END SUBROUTINE Unpack_I64 !---------------------------------------------------------------------- END INTERFACE INTERFACE MODULE FUNCTION Metro_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the MetroHash64 hash algorithm by J. Andrew !  Rogers [2]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Murmur3_Hash128_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the MurmurHash3 hash algorithm by Austin !  Appleby [1]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-14) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Wy_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using version 3 (?) of the WyHash hash algorithm by !  Wang Yi [3, 4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-11) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION WyF3_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the final version 3 of the WyHash hash algorithm !  by Wang Yi [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-10) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the XXHash hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX3_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Secret ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-10) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX3_Hash128_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Secret , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION City_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the CityHash hash algorithm by Google Inc [6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-10) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmNa_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmNaHash hash algorithm by Google Inc [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmUo_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmUoHash hash algorithm by Google Inc [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Spooky_Hash128_Exp ( Input , InpSize , Algo , StartHash , RemoveSign , & Seed , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using version 2 of the SpookyHash hash algorithm !  by Bob Jenkins [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-9) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION PengyV03_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.3) by !  Alberto Fajardo [15]. <br> TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION PengyV02_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.2) by !  Alberto Fajardo [9, 10]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-7) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Komi_Hash64_Exp ( Input , InpSize , Algo , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: Algo !! algorithm flag (1-8) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** FUNCTION Pack_I64_A1 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = IOR ( IOR ( IOR ( IOR ( IOR ( IOR ( IOR ( MaskI64 ( ByteArr ( Offset )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 1 )), 8 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 2 )), 16 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 3 )), 24 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 4 )), 32 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 5 )), 40 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 6 )), 48 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 7 )), 56 )) ! big-endian order !    Res = IOR(IOR(IOR(IOR(IOR(IOR(IOR(SHIFTL(MaskI64(ByteArr(Offset)),   56),  & !                                      SHIFTL(MaskI64(ByteArr(Offset+1)), 48)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+2)), 40)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+3)), 32)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+4)), 24)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+5)), 16)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+6)),  8)), & !                                             MaskI64(ByteArr(Offset+7))) RETURN END FUNCTION Pack_I64_A1 !************************************************************************** FUNCTION Pack_I64_A2 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *SHIFTL* intrinsic function !  and an addition operator. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = MaskI64 ( ByteArr ( Offset )) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 1 )), 8 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 2 )), 16 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 3 )), 24 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 4 )), 32 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 5 )), 40 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 6 )), 48 ) + & SHIFTL ( MaskI64 ( ByteArr ( Offset + 7 )), 56 ) ! big-endian order !    Res = SHIFTL(MaskI64(ByteArr(Offset)),   56) + & !          SHIFTL(MaskI64(ByteArr(Offset+1)), 48) + & !          SHIFTL(MaskI64(ByteArr(Offset+2)), 40) + & !          SHIFTL(MaskI64(ByteArr(Offset+3)), 32) + & !          SHIFTL(MaskI64(ByteArr(Offset+4)), 24) + & !          SHIFTL(MaskI64(ByteArr(Offset+5)), 16) + & !          SHIFTL(MaskI64(ByteArr(Offset+6)),  8) + & !                 MaskI64(ByteArr(Offset+7)) RETURN END FUNCTION Pack_I64_A2 !************************************************************************** FUNCTION Pack_I64_A3 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. <br> !  *Note*: Although this routine and the *Pack_I64_A3* routine employ !  the same intrinsic functions, orders of the functions being used !  are somewhat different. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order #define UnsignedByte(Val, Off)      IAND(ToInt32(Val(Off)), ToInt32(Z'000000FF')) #define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) #define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off), SHIFTL(UnsignedShort(Val, Off+2), 16)) #define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), ToInt64(Z'00000000FFFFFFFF')) Res = IOR ( UnsignedInteger ( ByteArr , Offset ), SHIFTL ( UnsignedInteger ( ByteArr , Offset + 4 ), 32 )) #undef UnsignedByte #undef UnsignedShort #undef SignedInteger #undef UnsignedInteger ! big-endian order !#define UnsignedByte(Val, Off)      IAND(ToInt32(Val(Off)), Z'000000FF') !#define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !#define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off+2), SHIFTL(UnsignedShort(Val, Off), 16)) !#define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), Z'00000000FFFFFFFF') !    Res = IOR(UnsignedInteger(ByteArr, Offset+4), SHIFTL(UnsignedInteger(ByteArr, Offset), 32)) !#undef UnsignedByte !#undef UnsignedShort !#undef SignedInteger !#undef UnsignedInteger RETURN END FUNCTION Pack_I64_A3 !************************************************************************** FUNCTION Pack_I64_A4 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *MVBITS* intrinsic subroutine. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = 0 CALL MVBITS ( MaskI64 ( ByteArr ( Offset )), 0 , 8 , Res , 0 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 1 )), 0 , 8 , Res , 8 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 2 )), 0 , 8 , Res , 16 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 3 )), 0 , 8 , Res , 24 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 4 )), 0 , 8 , Res , 32 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 5 )), 0 , 8 , Res , 40 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 6 )), 0 , 8 , Res , 48 ) CALL MVBITS ( MaskI64 ( ByteArr ( Offset + 7 )), 0 , 8 , Res , 56 ) ! big-endian order !    Res = 0 !    CALL MVBITS(MaskI64(ByteArr(Offset)),   0, 8, Res, 56) !    CALL MVBITS(MaskI64(ByteArr(Offset+1)), 0, 8, Res, 48) !    CALL MVBITS(MaskI64(ByteArr(Offset+2)), 0, 8, Res, 40) !    CALL MVBITS(MaskI64(ByteArr(Offset+3)), 0, 8, Res, 32) !    CALL MVBITS(MaskI64(ByteArr(Offset+4)), 0, 8, Res, 24) !    CALL MVBITS(MaskI64(ByteArr(Offset+5)), 0, 8, Res, 16) !    CALL MVBITS(MaskI64(ByteArr(Offset+6)), 0, 8, Res,  8) !    CALL MVBITS(MaskI64(ByteArr(Offset+7)), 0, 8, Res,  0) RETURN END FUNCTION Pack_I64_A4 !************************************************************************** FUNCTION Pack_I64_A5 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *TRANSFER* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = TRANSFER ([ ByteArr ( Offset ), ByteArr ( Offset + 1 ), ByteArr ( Offset + 2 ), & ByteArr ( Offset + 3 ), ByteArr ( Offset + 4 ), ByteArr ( Offset + 5 ), & ByteArr ( Offset + 6 ), ByteArr ( Offset + 7 )], 0_kInt64 ) ! big-endian order !    Res = TRANSFER([ByteArr(Offset+7), ByteArr(Offset+6), ByteArr(Offset+5), !                    ByteArr(Offset+4), ByteArr(Offset+3), ByteArr(Offset+2), & !                    ByteArr(Offset+1), ByteArr(Offset)], 0_kInt64) RETURN END FUNCTION Pack_I64_A5 !************************************************************************** FUNCTION Pack_I64_A6 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *C_LOC* and *C_F_POINTER* !  intrinsic module routines. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 , POINTER :: fPtr ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW !+++ get a C pointer to the input +++ CPtr = C_LOC ( ByteArr ( Offset )) !+++ associate a Fortran pointer with the C pointer +++ CALL C_F_POINTER ( cPtr , fPtr ) !+++ copy bit patterns +++ ! system (or machine) endian order Res = fPtr ! little endian order !    IF (IsLittleEndian) THEN !        Res = fPtr !    ELSE !        Res = SwapBytes(fPtr) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(fPtr) !    ELSE !        Res = fPtr !    END IF !+++ nullify pointers +++ NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END FUNCTION Pack_I64_A6 !************************************************************************** FUNCTION Pack_I64_A7 ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *EQUIVALENCE* statement. <br> !  *Note*:  This routine works best for system-endian order. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW !+++ copy input +++ Input ( 0 : 7 ) = ByteArr ( Offset : Offset + 7 ) !+++ copy output +++ ! system (or machine) endian order Res = Output ! little endian order !    IF (IsLittleEndian) THEN !        Res = Output !    ELSE !        Res = SwapBytes(Output) !    END IF ! big endian order !    IF (IsLittleEndian) THEN !        Res = SwapBytes(Output) !    ELSE !        Res = Output !    END IF RETURN END FUNCTION Pack_I64_A7 !************************************************************************** FUNCTION PackPartial ( Buf , Off , Length , PackFull ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack three or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res'. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 7) PROCEDURE ( Pack_I64 ) :: PackFull !! procedure to convert a byte array to 32-bit integer tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 7 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes in little-endian order Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! gather available bytes in big-endian order !    Wrk(Length-1:0:-1) = Buf(Off:Off+Length-1) ! pack bytes into word Res = PackFull ( Wrk , 0_kIndex ) RETURN END FUNCTION PackPartial !****************************************************************************** SUBROUTINE Unpack_I64_A1 ( Val , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset using the *SHIFTR* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order ByteArr ( Offset ) = ToInt8 ( Val ) ByteArr ( Offset + 1 ) = ToInt8 ( SHIFTR ( Val , 8 )) ByteArr ( Offset + 2 ) = ToInt8 ( SHIFTR ( Val , 16 )) ByteArr ( Offset + 3 ) = ToInt8 ( SHIFTR ( Val , 24 )) ByteArr ( Offset + 4 ) = ToInt8 ( SHIFTR ( Val , 32 )) ByteArr ( Offset + 5 ) = ToInt8 ( SHIFTR ( Val , 40 )) ByteArr ( Offset + 6 ) = ToInt8 ( SHIFTR ( Val , 48 )) ByteArr ( Offset + 7 ) = ToInt8 ( SHIFTR ( Val , 56 )) ! big-endian order !    ByteArr(Offset)   = ToInt8(SHIFTR(Val, 56)) !    ByteArr(Offset+1) = ToInt8(SHIFTR(Val, 48)) !    ByteArr(Offset+2) = ToInt8(SHIFTR(Val, 40)) !    ByteArr(Offset+3) = ToInt8(SHIFTR(Val, 32)) !    ByteArr(Offset+4) = ToInt8(SHIFTR(Val, 24)) !    ByteArr(Offset+5) = ToInt8(SHIFTR(Val, 16)) !    ByteArr(Offset+6) = ToInt8(SHIFTR(Val, 8)) !    ByteArr(Offset+7) = ToInt8(Val) RETURN END SUBROUTINE Unpack_I64_A1 !****************************************************************************** SUBROUTINE Unpack_I64_A2 ( Val , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset using the *IBITS* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order ByteArr ( Offset ) = ToInt8 ( IBITS ( Val , 0 , 8 )) ByteArr ( Offset + 1 ) = ToInt8 ( IBITS ( Val , 8 , 8 )) ByteArr ( Offset + 2 ) = ToInt8 ( IBITS ( Val , 16 , 8 )) ByteArr ( Offset + 3 ) = ToInt8 ( IBITS ( Val , 24 , 8 )) ByteArr ( Offset + 4 ) = ToInt8 ( IBITS ( Val , 32 , 8 )) ByteArr ( Offset + 5 ) = ToInt8 ( IBITS ( Val , 40 , 8 )) ByteArr ( Offset + 6 ) = ToInt8 ( IBITS ( Val , 48 , 8 )) ByteArr ( Offset + 7 ) = ToInt8 ( IBITS ( Val , 56 , 8 )) ! big-endian order !    ByteArr(Offset)   = ToInt8(IBITS(Val, 56, 8)) !    ByteArr(Offset+1) = ToInt8(IBITS(Val, 48, 8)) !    ByteArr(Offset+2) = ToInt8(IBITS(Val, 40, 8)) !    ByteArr(Offset+3) = ToInt8(IBITS(Val, 32, 8)) !    ByteArr(Offset+4) = ToInt8(IBITS(Val, 24, 8)) !    ByteArr(Offset+5) = ToInt8(IBITS(Val, 16, 8)) !    ByteArr(Offset+6) = ToInt8(IBITS(Val,  8, 8)) !    ByteArr(Offset+7) = ToInt8(IBITS(Val,  0, 8)) RETURN END SUBROUTINE Unpack_I64_A2 !****************************************************************************** SUBROUTINE Unpack_I64_A3 ( Val , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset using the *TRANSFER* intrinsic function. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! system (machine) endian order ByteArr ( Offset :) = TRANSFER ( Val , ByteArr ) ! little-endian order !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) ! big-endian order !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE Unpack_I64_A3 !****************************************************************************** SUBROUTINE Unpack_I64_A4 ( Val , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset using the *C_LOC* and *C_F_POINTER* !  intrinsic module routines. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: ByteSize = BIT_SIZE ( 0_kInt64 ) / BIT_SIZE ( 0_kInt8 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , POINTER :: fPtr (:) ! Fortran pointer to the input TYPE ( C_PTR ) :: CPtr ! C pointer to the input ! FLOW ! get a C pointer to the input CPtr = C_LOC ( Val ) ! associate a Fortran pointer with the C pointer CALL C_F_POINTER ( cPtr , fPtr , [ ByteSize ]) ! copy bit patterns (system-endian order) ByteArr ( Offset :) = fPtr ( 1 :) ! little-endian order !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) ! big-endian order !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) ! nullify pointers NULLIFY ( fPtr ) cPtr = C_NULL_PTR RETURN END SUBROUTINE Unpack_I64_A4 !****************************************************************************** SUBROUTINE Unpack_I64_A5 ( Val , ByteArr , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a 64-bit integer value to an array of 8-bit integers !  starting at the offset using the *EQUIVALENCE* statement. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , TARGET , INTENT ( IN ) :: Val !! 64-bit integer tUInt8 , INTENT ( INOUT ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: ByteSize = BIT_SIZE ( 0_kInt64 ) / BIT_SIZE ( 0_kInt8 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: ByteVals ( ByteSize ) tUInt64 :: LongVal EQUIVALENCE ( ByteVals , LongVal ) ! FLOW ! system (machine) endian order LongVal = Val ByteArr ( Offset :) = ByteVals ( 1 :) ! little-endian order !    IF (.NOT.IsLittleEndian) CALL SwapByteArray(ByteArr) ! big-endian order !    IF (IsLittleEndian) CALL SwapByteArray(ByteArr) RETURN END SUBROUTINE Unpack_I64_A5 !****************************************************************************** FUNCTION UnsignedLongMultiplyorFold ( LHS , RHS ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply or fold. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 :: Res !** SUBROUTINE PARAMETER DECLARATIONS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = IAND ( LHS , MaxU32 ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = IAND ( RHS , MaxU32 ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaxU32 ) + LHS_Lo * RHS_Hi Res = IEOR ( IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaxU32 )), & SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi ) RETURN END FUNCTION UnsignedLongMultiplyorFold !****************************************************************************** END MODULE MBase_ExperimentalHash64 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_experimentalhash64.f90.html"},{"title":"MClass_ShaviteB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ShaviteB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ShaviteB* type and its related routines. !   The *ShaviteB* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *ShaviteB* type implements an incremental cryptographic hash function !   by employing a *SHAvite-3 message-digest* algorithm (either the *SHAvite-384* !   or the *SHAvite-512*) [1].  The implementation here is based mainly on the !   *SPHLIB* implementation [2].  <br> !   By default, the *ShaviteB* type employs the *SHAvite-512 message-digest* !   algorithm.  However, a user can specify the *IsSHAvite384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SHAvite-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20161220074845mp_/http://www.cs.technion.ac.il/~orrd/SHAvite-3/\"> !       The SHAvite-3 hash function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: ShaviteB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: IV384_BE ( 0 : 15 ) = [ & ToInt32 ( Z '71F48510' ), ToInt32 ( Z 'A903A8AC' ), & ToInt32 ( Z 'FE3216DD' ), ToInt32 ( Z '0B2D2AD4' ), & ToInt32 ( Z '6672900A' ), ToInt32 ( Z '41032819' ), & ToInt32 ( Z '15A7D780' ), ToInt32 ( Z 'B3CAB8D9' ), & ToInt32 ( Z '34EF4711' ), ToInt32 ( Z 'DE019FE8' ), & ToInt32 ( Z '4D674DC4' ), ToInt32 ( Z 'E056D96B' ), & ToInt32 ( Z 'A35C016B' ), ToInt32 ( Z 'DD903BA7' ), & ToInt32 ( Z '8C1B09B4' ), ToInt32 ( Z '2C3E9F25' )] tInteger , PARAMETER :: IV384_LE ( 0 : 15 ) = [ & ToInt32 ( Z '83DF1545' ), ToInt32 ( Z 'F9AAEC13' ), & ToInt32 ( Z 'F4803CB0' ), ToInt32 ( Z '11FE1F47' ), & ToInt32 ( Z 'DA6CD269' ), ToInt32 ( Z '4F53FCD7' ), & ToInt32 ( Z '950529A2' ), ToInt32 ( Z '97908147' ), & ToInt32 ( Z 'B0A4D7AF' ), ToInt32 ( Z '2B9132BF' ), & ToInt32 ( Z '226E607D' ), ToInt32 ( Z '3C0F8D7C' ), & ToInt32 ( Z '487B3F0F' ), ToInt32 ( Z '04363E22' ), & ToInt32 ( Z '0155C99C' ), ToInt32 ( Z 'EC2E20D3' )] tInteger , PARAMETER :: IV512_BE ( 0 : 15 ) = [ & ToInt32 ( Z 'D5652B63' ), ToInt32 ( Z '25F1E6EA' ), & ToInt32 ( Z 'B18F48FA' ), ToInt32 ( Z 'A1EE3A47' ), & ToInt32 ( Z 'C8B67B07' ), ToInt32 ( Z 'BDCE48D3' ), & ToInt32 ( Z 'E3937B78' ), ToInt32 ( Z '05DB5186' ), & ToInt32 ( Z '613BE326' ), ToInt32 ( Z 'A11FA303' ), & ToInt32 ( Z '90C833D4' ), ToInt32 ( Z '79CEE316' ), & ToInt32 ( Z '1E1AF00F' ), ToInt32 ( Z '2829B165' ), & ToInt32 ( Z '23B25F80' ), ToInt32 ( Z '21E11499' )] tInteger , PARAMETER :: IV512_LE ( 0 : 15 ) = [ & ToInt32 ( Z '72FCCDD8' ), ToInt32 ( Z '79CA4727' ), & ToInt32 ( Z '128A077B' ), ToInt32 ( Z '40D55AEC' ), & ToInt32 ( Z 'D1901A06' ), ToInt32 ( Z '430AE307' ), & ToInt32 ( Z 'B29F5CD1' ), ToInt32 ( Z 'DF07FBFC' ), & ToInt32 ( Z '8E45D73D' ), ToInt32 ( Z '681AB538' ), & ToInt32 ( Z 'BDE86578' ), ToInt32 ( Z 'DD577E47' ), & ToInt32 ( Z 'E275EADE' ), ToInt32 ( Z '502D9FCD' ), & ToInt32 ( Z 'B9357178' ), ToInt32 ( Z '022A4B9A' )] !** DERIVED TYPE DEFINITIONS !> *ShaviteB* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *SHAvite-384* or the *SHAvite-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: ShaviteB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 15 ) = IV512_LE !% flag indicating whether the SHAvite-384 algorithm is employed or not. tLogical :: IsSHAvite384 = FalseVal !> flag indicating whether to use little-endian order for initial values !  and AES tables. tLogical :: LittleEndian = TrueVal !% pointer to a procedure that processes a block of data PROCEDURE ( ProcessData ), POINTER , NOPASS :: Process => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => ShaviteB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAvite-512). PROCEDURE :: Initialize => ShaviteB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => ShaviteB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => ShaviteB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => ShaviteB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => ShaviteB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => ShaviteB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => ShaviteB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => ShaviteB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => ShaviteB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => ShaviteB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHAvite-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHAvite-384 algorithm <br> !   --->    CALL MD%Create(IsSHAvite384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- FINAL :: ShaviteB_Finalize ! --------------------------------------------------------------------- END TYPE ShaviteB !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE ! To process input block SUBROUTINE ProcessData ( H , InpDat , Cnt0 , Cnt1 , Cnt2 ) IMPORT tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block tInteger , INTENT ( IN ) :: Cnt0 , Cnt1 , Cnt2 ! counter numbers END SUBROUTINE ProcessData END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE ShaviteB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHAvite-512 algorithm with little-endian order parameters CALL MD % Create ( FalseVal , FalseVal ) RETURN END SUBROUTINE ShaviteB_Initialize !****************************************************************************** SUBROUTINE ShaviteB_Initialize_wFlag ( MD , IsSHAvite384 , BigEndian ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object tLogical , INTENT ( IN ) :: IsSHAvite384 !&#94; flag indicating whether the SHAvite-384 algorithm is employed or not. <br> !  - If true, use the SHAvite-384 algorithm. <br> !  - Otherwise, use the SHAvite-512 algorithm. <br> tLogical , OPTIONAL , INTENT ( IN ) :: BigEndian !&#94; flag indicating whether to use the big-endian order for initial values and AES tables. <br> !  - If true, use the big-endian order. <br> !  - Otherwise, use little-endian order. <br> !  default value: false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSHAvite384 = IsSHAvite384 MD % LittleEndian = TrueVal IF ( PRESENT ( BigEndian )) MD % LittleEndian = . NOT . BigEndian CALL MD % Reset () RETURN END SUBROUTINE ShaviteB_Initialize_wFlag !****************************************************************************** SUBROUTINE ShaviteB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % LittleEndian ) THEN MD % Process => Process_LE IF ( MD % IsSHAvite384 ) THEN MD % H = IV384_LE ELSE MD % H = IV512_LE END IF ELSE MD % Process => Process_BE IF ( MD % IsSHAvite384 ) THEN MD % H = IV384_BE ELSE MD % H = IV512_BE END IF END IF CALL MD % EngineReset () RETURN END SUBROUTINE ShaviteB_Reset !****************************************************************************** SUBROUTINE ShaviteB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( ShaviteB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( ShaviteB ) CALL Dst % Create ( Src % IsSHAvite384 , . NOT . Src % LittleEndian ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE ShaviteB_GetClone !****************************************************************************** FUNCTION ShaviteB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( IN ) :: MD !! 'ShaviteB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHAvite384 ) THEN Name = 'SHAvite-384' ELSE Name = 'SHAvite-512' END IF RETURN END FUNCTION ShaviteB_GetName !****************************************************************************** FUNCTION ShaviteB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( IN ) :: MD !! 'ShaviteB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHAvite384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION ShaviteB_GetDigestLen !****************************************************************************** FUNCTION ShaviteB_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( IN ) :: MD !! 'ShaviteB' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION ShaviteB_GetBlockLen !****************************************************************************** SUBROUTINE ShaviteB_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), TARGET , INTENT ( INOUT ) :: MD !! 'ShaviteB' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE ShaviteB_SetBufPtr !****************************************************************************** SUBROUTINE ShaviteB_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: BitLen , BC tInteger :: Cnt0 , Cnt1 , Cnt2 ! FLOW BC = MD % GetBlockCount () + 1_kInt64 BitLen = SHIFTL ( BC , 10 ) Cnt0 = ToInt32 ( BitLen ) Cnt1 = ToInt32 ( SHIFTR ( BitLen , 32 )) Cnt2 = ToInt32 ( SHIFTR ( BC , 54 )) CALL MD % Process ( MD % H , BytesIn , Cnt0 , Cnt1 , Cnt2 ) RETURN END SUBROUTINE ShaviteB_ProcessBlock !****************************************************************************** SUBROUTINE ShaviteB_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE ShaviteB_DoPadding !****************************************************************************** SUBROUTINE ShaviteB_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , DLen , I tLong :: BC , BitLen tInteger :: Cnt0 , Cnt1 , Cnt2 tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () BC = MD % GetBlockCount () BitLen = SHIFTL ( BC , 10 ) + SHIFTL ( Ptr , 3 ) Cnt0 = ToInt32 ( BitLen ) + NBits Cnt1 = ToInt32 ( SHIFTR ( BitLen , 32 )) Cnt2 = ToInt32 ( SHIFTR ( BC , 54 )) Z = SHIFTR ( FByte80 , NBits ) Z = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) IF (( Ptr == 0_kIndex ). AND .( NBits == 0_kInt8 )) THEN TmpBuf ( 0 ) = FByte80 TmpBuf ( 1 : 109 ) = FByte00 Cnt0 = 0 Cnt1 = 0 Cnt2 = 0 ELSEIF ( Ptr < 110_kIndex ) THEN TmpBuf ( Ptr ) = Z Ptr = Ptr + 1_kIndex TmpBuf ( Ptr : 109 ) = FByte00 ELSE TmpBuf ( Ptr ) = Z Ptr = Ptr + 1_kIndex TmpBuf ( Ptr : 127 ) = FByte00 CALL MD % Process ( MD % H , TmpBuf , Cnt0 , Cnt1 , Cnt2 ) TmpBuf ( 0 : 109 ) = FByte00 Cnt0 = 0 Cnt1 = 0 Cnt2 = 0 END IF CALL ByteUnpackLE ( ToInt32 ( BitLen ) + NBits , TmpBuf , 110_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTR ( BitLen , 32 )), TmpBuf , 114_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTR ( BC , 54 )), TmpBuf , 118_kIndex ) TmpBuf ( 122 : 125 ) = FByte00 DLen = MD % GetDigestLen () TmpBuf ( 126 ) = ToInt8 ( SHIFTL ( DLen , 3 )) TmpBuf ( 127 ) = ToInt8 ( SHIFTR ( DLen , 5 )) CALL MD % Process ( MD % H , TmpBuf , Cnt0 , Cnt1 , Cnt2 ) END ASSOCIATE ! finalizing I = 0_kIndex DO WHILE ( I < DLen ) CALL ByteUnpackLE ( MD % H ( SHIFTR ( I , 2 )), BytesOut , Offset + I ) I = I + 4_kIndex END DO RETURN END SUBROUTINE ShaviteB_AddBitsNPad !****************************************************************************** SUBROUTINE ShaviteB_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ShaviteB ), INTENT ( INOUT ) :: MD !! 'ShaviteB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % Process ) RETURN END SUBROUTINE ShaviteB_Finalize !****************************************************************************** SUBROUTINE Process_BE ( H , InpDat , Cnt0 , Cnt1 , Cnt2 ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block.  This implementation supports up to about ! 2&#94;64 input blocks, i.e. 2&#94;74 bits.  Thus, the counter highest ! word (cnt3) is always zero. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block (128 bytes) tInteger , INTENT ( IN ) :: Cnt0 ! the first (least significant) bit counter word tInteger , INTENT ( IN ) :: Cnt1 ! the second bit count word tInteger , INTENT ( IN ) :: Cnt2 ! the third bit count word !** SUBROUTINE MACRO DEFINITIONS AND PARAMETER DECLARATIONS: #include    \"Includes/AES_BigEndian.f90\" #define     AES_ROUND_NOKEY(X0, X1, X2, X3)     \\ T0 = X0 ; T1 = X1 ; T2 = X2 ; T3 = X3 ; \\ AES_ROUND_NOKEY_BE ( T0 , T1 , T2 , T3 , X0 , X1 , X2 , X3 ); #define     C512_ELT(L0, L1, L2, L3, R0, R1, R2, R3)    \\ X0 = IEOR ( R0 , RK ( U )); \\ X1 = IEOR ( R1 , RK ( U + 1 )); \\ X2 = IEOR ( R2 , RK ( U + 2 )); \\ X3 = IEOR ( R3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ L0 = IEOR ( L0 , X0 ); \\ L1 = IEOR ( L1 , X1 ); \\ L2 = IEOR ( L2 , X2 ); \\ L3 = IEOR ( L3 , X3 ); #define     WROT(A, B, C, D)    \\ T = D ; \\ D = C ; \\ C = B ; \\ B = A ; \\ A = T ; !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: #include    \"Includes/AES_Constants.f90\" !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: T0 , T1 , T2 , T3 , T tInteger :: P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 tInteger :: P8 , P9 , PA , PB , PC , PD , PE , PF tInteger :: X0 , X1 , X2 , X3 tIndex :: U , R , S tInteger :: RK ( 0 : 447 ) ! FLOW DO U = 0 , 31 , 4 CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ), RK ( U )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 4 , RK ( U + 1 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 8 , RK ( U + 2 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 12 , RK ( U + 3 )) END DO U = 32 DO DO S = 0 , 3 X0 = RK ( U - 31 ) X1 = RK ( U - 30 ) X2 = RK ( U - 29 ) X3 = RK ( U - 32 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 32 ) THEN RK ( 32 ) = IEOR ( RK ( 32 ), Cnt0 ) RK ( 33 ) = IEOR ( RK ( 33 ), Cnt1 ) RK ( 34 ) = IEOR ( RK ( 34 ), Cnt2 ) RK ( 35 ) = IEOR ( RK ( 35 ), NOT ( 0 )) ELSEIF ( U == 440 ) THEN RK ( 440 ) = IEOR ( RK ( 440 ), Cnt1 ) RK ( 441 ) = IEOR ( RK ( 441 ), Cnt0 ) ! RK(442) = IEOR(RK(442), 0) RK ( 443 ) = IEOR ( RK ( 443 ), NOT ( Cnt2 )) END IF U = U + 4 X0 = RK ( U - 31 ) X1 = RK ( U - 30 ) X2 = RK ( U - 29 ) X3 = RK ( U - 32 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 164 ) THEN ! RK(164) = IEOR(RK(164), 0) RK ( 165 ) = IEOR ( RK ( 165 ), Cnt2 ) RK ( 166 ) = IEOR ( RK ( 166 ), Cnt1 ) RK ( 167 ) = IEOR ( RK ( 167 ), NOT ( Cnt0 )) ELSEIF ( U == 316 ) THEN RK ( 316 ) = IEOR ( RK ( 316 ), Cnt2 ) ! RK(317) = IEOR(RK(317), 0) RK ( 318 ) = IEOR ( RK ( 318 ), Cnt0 ) RK ( 319 ) = IEOR ( RK ( 319 ), NOT ( Cnt1 )) END IF U = U + 4 END DO IF ( U == 448 ) EXIT DO S = 0 , 7 RK ( U ) = IEOR ( RK ( U - 32 ), RK ( U - 7 )) RK ( U + 1 ) = IEOR ( RK ( U - 31 ), RK ( U - 6 )) RK ( U + 2 ) = IEOR ( RK ( U - 30 ), RK ( U - 5 )) RK ( U + 3 ) = IEOR ( RK ( U - 29 ), RK ( U - 4 )) U = U + 4 END DO END DO P0 = H ( 0 ) P1 = H ( 1 ) P2 = H ( 2 ) P3 = H ( 3 ) P4 = H ( 4 ) P5 = H ( 5 ) P6 = H ( 6 ) P7 = H ( 7 ) P8 = H ( 8 ) P9 = H ( 9 ) PA = H ( 10 ) PB = H ( 11 ) PC = H ( 12 ) PD = H ( 13 ) PE = H ( 14 ) PF = H ( 15 ) U = 0 DO R = 0 , 13 C512_ELT ( P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 ) C512_ELT ( P8 , P9 , PA , PB , PC , PD , PE , PF ) WROT ( P0 , P4 , P8 , PC ) WROT ( P1 , P5 , P9 , PD ) WROT ( P2 , P6 , PA , PE ) WROT ( P3 , P7 , PB , PF ) END DO H ( 0 ) = IEOR ( H ( 0 ), P0 ) H ( 1 ) = IEOR ( H ( 1 ), P1 ) H ( 2 ) = IEOR ( H ( 2 ), P2 ) H ( 3 ) = IEOR ( H ( 3 ), P3 ) H ( 4 ) = IEOR ( H ( 4 ), P4 ) H ( 5 ) = IEOR ( H ( 5 ), P5 ) H ( 6 ) = IEOR ( H ( 6 ), P6 ) H ( 7 ) = IEOR ( H ( 7 ), P7 ) H ( 8 ) = IEOR ( H ( 8 ), P8 ) H ( 9 ) = IEOR ( H ( 9 ), P9 ) H ( 10 ) = IEOR ( H ( 10 ), PA ) H ( 11 ) = IEOR ( H ( 11 ), PB ) H ( 12 ) = IEOR ( H ( 12 ), PC ) H ( 13 ) = IEOR ( H ( 13 ), PD ) H ( 14 ) = IEOR ( H ( 14 ), PE ) H ( 15 ) = IEOR ( H ( 15 ), PF ) RETURN #include    \"Includes/AES_Undef Macro.f90\" #undef      AES_ROUND_NOKEY #undef      C512_ELT #undef      WROT END SUBROUTINE Process_BE !****************************************************************************** SUBROUTINE Process_LE ( H , InpDat , Cnt0 , Cnt1 , Cnt2 ) !** PURPOSE OF THIS SUBROUTINE: ! To process one block.  This implementation supports up to about ! 2&#94;64 input blocks, i.e. 2&#94;74 bits.  Thus, the counter highest ! word (cnt3) is always zero. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block (128 bytes) tInteger , INTENT ( IN ) :: Cnt0 ! the first (least significant) bit counter word tInteger , INTENT ( IN ) :: Cnt1 ! the second bit count word tInteger , INTENT ( IN ) :: Cnt2 ! the third bit count word !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/AES_LittleEndian.f90\" #define     AES_ROUND_NOKEY(X0, X1, X2, X3)     \\ T0 = X0 ; T1 = X1 ; T2 = X2 ; T3 = X3 ; \\ AES_ROUND_NOKEY_LE ( T0 , T1 , T2 , T3 , X0 , X1 , X2 , X3 ); #define     C512_ELT(L0, L1, L2, L3, R0, R1, R2, R3)    \\ X0 = IEOR ( R0 , RK ( U )); \\ X1 = IEOR ( R1 , RK ( U + 1 )); \\ X2 = IEOR ( R2 , RK ( U + 2 )); \\ X3 = IEOR ( R3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ X0 = IEOR ( X0 , RK ( U )); \\ X1 = IEOR ( X1 , RK ( U + 1 )); \\ X2 = IEOR ( X2 , RK ( U + 2 )); \\ X3 = IEOR ( X3 , RK ( U + 3 )); \\ U = U + 4 ; \\ AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ); \\ L0 = IEOR ( L0 , X0 ); \\ L1 = IEOR ( L1 , X1 ); \\ L2 = IEOR ( L2 , X2 ); \\ L3 = IEOR ( L3 , X3 ); #define     WROT(A, B, C, D)    \\ T = D ; \\ D = C ; \\ C = B ; \\ B = A ; \\ A = T ; !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: #include    \"Includes/AES_Constants.f90\" !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: T0 , T1 , T2 , T3 , T tInteger :: P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 tInteger :: P8 , P9 , PA , PB , PC , PD , PE , PF tInteger :: X0 , X1 , X2 , X3 tIndex :: U , R , S tInteger :: RK ( 0 : 447 ) ! FLOW DO U = 0 , 31 , 4 CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ), RK ( U )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 4 , RK ( U + 1 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 8 , RK ( U + 2 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 12 , RK ( U + 3 )) END DO U = 32 DO DO S = 0 , 3 X0 = RK ( U - 31 ) X1 = RK ( U - 30 ) X2 = RK ( U - 29 ) X3 = RK ( U - 32 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 32 ) THEN RK ( 32 ) = IEOR ( RK ( 32 ), Cnt0 ) RK ( 33 ) = IEOR ( RK ( 33 ), Cnt1 ) RK ( 34 ) = IEOR ( RK ( 34 ), Cnt2 ) RK ( 35 ) = IEOR ( RK ( 35 ), NOT ( 0 )) ELSEIF ( U == 440 ) THEN RK ( 440 ) = IEOR ( RK ( 440 ), Cnt1 ) RK ( 441 ) = IEOR ( RK ( 441 ), Cnt0 ) ! RK(442) = IEOR(RK(442), 0) RK ( 443 ) = IEOR ( RK ( 443 ), NOT ( Cnt2 )) END IF U = U + 4 X0 = RK ( U - 31 ) X1 = RK ( U - 30 ) X2 = RK ( U - 29 ) X3 = RK ( U - 32 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 164 ) THEN ! RK(164) = IEOR(RK(164), 0) RK ( 165 ) = IEOR ( RK ( 165 ), Cnt2 ) RK ( 166 ) = IEOR ( RK ( 166 ), Cnt1 ) RK ( 167 ) = IEOR ( RK ( 167 ), NOT ( Cnt0 )) ELSEIF ( U == 316 ) THEN RK ( 316 ) = IEOR ( RK ( 316 ), Cnt2 ) ! RK(317) = IEOR(RK(317), 0) RK ( 318 ) = IEOR ( RK ( 318 ), Cnt0 ) RK ( 319 ) = IEOR ( RK ( 319 ), NOT ( Cnt1 )) END IF U = U + 4 END DO IF ( U == 448 ) EXIT DO S = 0 , 7 RK ( U ) = IEOR ( RK ( U - 32 ), RK ( U - 7 )) RK ( U + 1 ) = IEOR ( RK ( U - 31 ), RK ( U - 6 )) RK ( U + 2 ) = IEOR ( RK ( U - 30 ), RK ( U - 5 )) RK ( U + 3 ) = IEOR ( RK ( U - 29 ), RK ( U - 4 )) U = U + 4 END DO END DO P0 = H ( 0 ) P1 = H ( 1 ) P2 = H ( 2 ) P3 = H ( 3 ) P4 = H ( 4 ) P5 = H ( 5 ) P6 = H ( 6 ) P7 = H ( 7 ) P8 = H ( 8 ) P9 = H ( 9 ) PA = H ( 10 ) PB = H ( 11 ) PC = H ( 12 ) PD = H ( 13 ) PE = H ( 14 ) PF = H ( 15 ) U = 0 DO R = 0 , 13 C512_ELT ( P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 ) C512_ELT ( P8 , P9 , PA , PB , PC , PD , PE , PF ) WROT ( P0 , P4 , P8 , PC ) WROT ( P1 , P5 , P9 , PD ) WROT ( P2 , P6 , PA , PE ) WROT ( P3 , P7 , PB , PF ) END DO H ( 0 ) = IEOR ( H ( 0 ), P0 ) H ( 1 ) = IEOR ( H ( 1 ), P1 ) H ( 2 ) = IEOR ( H ( 2 ), P2 ) H ( 3 ) = IEOR ( H ( 3 ), P3 ) H ( 4 ) = IEOR ( H ( 4 ), P4 ) H ( 5 ) = IEOR ( H ( 5 ), P5 ) H ( 6 ) = IEOR ( H ( 6 ), P6 ) H ( 7 ) = IEOR ( H ( 7 ), P7 ) H ( 8 ) = IEOR ( H ( 8 ), P8 ) H ( 9 ) = IEOR ( H ( 9 ), P9 ) H ( 10 ) = IEOR ( H ( 10 ), PA ) H ( 11 ) = IEOR ( H ( 11 ), PB ) H ( 12 ) = IEOR ( H ( 12 ), PC ) H ( 13 ) = IEOR ( H ( 13 ), PD ) H ( 14 ) = IEOR ( H ( 14 ), PE ) H ( 15 ) = IEOR ( H ( 15 ), PF ) RETURN #include    \"Includes/AES_Undef Macro.f90\" #undef      AES_ROUND_NOKEY #undef      C512_ELT #undef      WROT END SUBROUTINE Process_LE !****************************************************************************** END MODULE MClass_ShaviteB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_shaviteb.f90.html"},{"title":"MClass_CubeHash.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_CubeHash !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *CubeHash* type and its related routines. !   The *CubeHash* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *CubeHash* type implements an incremental cryptographic hash !   function by employing the *CubeHash message-digest* algorithm [1]. !   The implementation here is mainly based on the references [2]. <br> !   The *CubeHash* type represents four cryptographic hash functions: !   the *CubeHash-224*, *CubeHash-256*, *CubeHash-384*, and *CubeHash-512* !   hash functions.  By default, the *CubeHash* type represents the !   *CubeHash-512* hash function.  However, a user can specify the !   *Security* argument (to one of the four applicable values: 224, 256, !   384 and 512) when initializing the digest object in order to use a !   different hash function and get a different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"http://cubehash.cr.yp.to/\">CubeHash: a simple hash function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: CubeHash PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 32_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: IV224 ( 0 : 31 ) = [ & ToInt32 ( Z 'B0FC8217' ), ToInt32 ( Z '1BEE1A90' ), ToInt32 ( Z '829E1A22' ), & ToInt32 ( Z '6362C342' ), ToInt32 ( Z '24D91C30' ), ToInt32 ( Z '03A7AA24' ), & ToInt32 ( Z 'A63721C8' ), ToInt32 ( Z '85B0E2EF' ), ToInt32 ( Z 'F35D13F3' ), & ToInt32 ( Z '41DA807D' ), ToInt32 ( Z '21A70CA6' ), ToInt32 ( Z '1F4E9774' ), & ToInt32 ( Z 'B3E1C932' ), ToInt32 ( Z 'EB0A79A8' ), ToInt32 ( Z 'CDDAAA66' ), & ToInt32 ( Z 'E2F6ECAA' ), ToInt32 ( Z '0A713362' ), ToInt32 ( Z 'AA3080E0' ), & ToInt32 ( Z 'D8F23A32' ), ToInt32 ( Z 'CEF15E28' ), ToInt32 ( Z 'DB086314' ), & ToInt32 ( Z '7F709DF7' ), ToInt32 ( Z 'ACD228A4' ), ToInt32 ( Z '704D6ECE' ), & ToInt32 ( Z 'AA3EC95F' ), ToInt32 ( Z 'E387C214' ), ToInt32 ( Z '3A6445FF' ), & ToInt32 ( Z '9CAB81C3' ), ToInt32 ( Z 'C73D4B98' ), ToInt32 ( Z 'D277AEBE' ), & ToInt32 ( Z 'FD20151C' ), ToInt32 ( Z '00CB573E' )] tInteger , PARAMETER :: IV256 ( 0 : 31 ) = [ & ToInt32 ( Z 'EA2BD4B4' ), ToInt32 ( Z 'CCD6F29F' ), ToInt32 ( Z '63117E71' ), & ToInt32 ( Z '35481EAE' ), ToInt32 ( Z '22512D5B' ), ToInt32 ( Z 'E5D94E63' ), & ToInt32 ( Z '7E624131' ), ToInt32 ( Z 'F4CC12BE' ), ToInt32 ( Z 'C2D0B696' ), & ToInt32 ( Z '42AF2070' ), ToInt32 ( Z 'D0720C35' ), ToInt32 ( Z '3361DA8C' ), & ToInt32 ( Z '28CCECA4' ), ToInt32 ( Z '8EF8AD83' ), ToInt32 ( Z '4680AC00' ), & ToInt32 ( Z '40E5FBAB' ), ToInt32 ( Z 'D89041C3' ), ToInt32 ( Z '6107FBD5' ), & ToInt32 ( Z '6C859D41' ), ToInt32 ( Z 'F0B26679' ), ToInt32 ( Z '09392549' ), & ToInt32 ( Z '5FA25603' ), ToInt32 ( Z '65C892FD' ), ToInt32 ( Z '93CB6285' ), & ToInt32 ( Z '2AF2B5AE' ), ToInt32 ( Z '9E4B4E60' ), ToInt32 ( Z '774ABFDD' ), & ToInt32 ( Z '85254725' ), ToInt32 ( Z '15815AEB' ), ToInt32 ( Z '4AB6AAD6' ), & ToInt32 ( Z '9CDAF8AF' ), ToInt32 ( Z 'D6032C0A' )] tInteger , PARAMETER :: IV384 ( 0 : 31 ) = [ & ToInt32 ( Z 'E623087E' ), ToInt32 ( Z '04C00C87' ), ToInt32 ( Z '5EF46453' ), & ToInt32 ( Z '69524B13' ), ToInt32 ( Z '1A05C7A9' ), ToInt32 ( Z '3528DF88' ), & ToInt32 ( Z '6BDD01B5' ), ToInt32 ( Z '5057B792' ), ToInt32 ( Z '6AA7A922' ), & ToInt32 ( Z '649C7EEE' ), ToInt32 ( Z 'F426309F' ), ToInt32 ( Z 'CB629052' ), & ToInt32 ( Z 'FC8E20ED' ), ToInt32 ( Z 'B3482BAB' ), ToInt32 ( Z 'F89E5E7E' ), & ToInt32 ( Z 'D83D4DE4' ), ToInt32 ( Z '44BFC10D' ), ToInt32 ( Z '5FC1E63D' ), & ToInt32 ( Z '2104E6CB' ), ToInt32 ( Z '17958F7F' ), ToInt32 ( Z 'DBEAEF70' ), & ToInt32 ( Z 'B4B97E1E' ), ToInt32 ( Z '32C195F6' ), ToInt32 ( Z '6184A8E4' ), & ToInt32 ( Z '796C2543' ), ToInt32 ( Z '23DE176D' ), ToInt32 ( Z 'D33BBAEC' ), & ToInt32 ( Z '0C12E5D2' ), ToInt32 ( Z '4EB95A7B' ), ToInt32 ( Z '2D18BA01' ), & ToInt32 ( Z '04EE475F' ), ToInt32 ( Z '1FC5F22E' )] tInteger , PARAMETER :: IV512 ( 0 : 31 ) = [ & ToInt32 ( Z '2AEA2A61' ), ToInt32 ( Z '50F494D4' ), ToInt32 ( Z '2D538B8B' ), & ToInt32 ( Z '4167D83E' ), ToInt32 ( Z '3FEE2313' ), ToInt32 ( Z 'C701CF8C' ), & ToInt32 ( Z 'CC39968E' ), ToInt32 ( Z '50AC5695' ), ToInt32 ( Z '4D42C787' ), & ToInt32 ( Z 'A647A8B3' ), ToInt32 ( Z '97CF0BEF' ), ToInt32 ( Z '825B4537' ), & ToInt32 ( Z 'EEF864D2' ), ToInt32 ( Z 'F22090C4' ), ToInt32 ( Z 'D0E5CD33' ), & ToInt32 ( Z 'A23911AE' ), ToInt32 ( Z 'FCD398D9' ), ToInt32 ( Z '148FE485' ), & ToInt32 ( Z '1B017BEF' ), ToInt32 ( Z 'B6444532' ), ToInt32 ( Z '6A536159' ), & ToInt32 ( Z '2FF5781C' ), ToInt32 ( Z '91FA7934' ), ToInt32 ( Z '0DBADEA9' ), & ToInt32 ( Z 'D65C8A2B' ), ToInt32 ( Z 'A5A70E75' ), ToInt32 ( Z 'B1C62456' ), & ToInt32 ( Z 'BC796576' ), ToInt32 ( Z '1921C8F7' ), ToInt32 ( Z 'E7989AF1' ), & ToInt32 ( Z '7795D246' ), ToInt32 ( Z 'D43E3B44' )] !** DERIVED TYPE DEFINITIONS !> *CubeHash* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the CubeHash hash functions. TYPE , EXTENDS ( MDEngine ) :: CubeHash PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 31 ) = IV512 ( 0 : 31 ) !% security strength in bits tInteger :: Security = 512 !% length of hash output in bytes tIndex :: DigestLen = DLen512 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => CubeHash_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (CubeHash-512). PROCEDURE :: Initialize => CubeHash_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => CubeHash_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => CubeHash_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => CubeHash_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => CubeHash_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => CubeHash_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => CubeHash_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => CubeHash_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => CubeHash_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => CubeHash_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (CubeHash-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the CubeHash-256 algorithm <br> !   --->    CALL MD%Create(256) <br> GENERIC :: Create => InitializeWSecurity END TYPE CubeHash !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE CubeHash_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % Security = 512 MD % DigestLen = DLen512 CALL MD % Reset () RETURN END SUBROUTINE CubeHash_Initialize !****************************************************************************** SUBROUTINE CubeHash_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (512) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 512 END SELECT SELECT CASE ( MD % Security ) CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT CALL MD % Reset () RETURN END SUBROUTINE CubeHash_Initialize_wSecurity !****************************************************************************** SUBROUTINE CubeHash_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 SELECT CASE ( MD % Security ) CASE ( 224 ) MD % State = IV224 CASE ( 256 ) MD % State = IV256 CASE ( 384 ) MD % State = IV384 CASE ( 512 ) MD % State = IV512 END SELECT CALL MD % EngineReset () RETURN END SUBROUTINE CubeHash_Reset !****************************************************************************** SUBROUTINE CubeHash_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( CubeHash :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( CubeHash ) CALL Dst % Create ( Src % Security ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE CubeHash_GetClone !****************************************************************************** FUNCTION CubeHash_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( IN ) :: MD !! 'CubeHash' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'CubeHash-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION CubeHash_GetName !****************************************************************************** FUNCTION CubeHash_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( IN ) :: MD !! 'CubeHash' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION CubeHash_GetDigestLen !****************************************************************************** FUNCTION CubeHash_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( IN ) :: MD !! 'CubeHash' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION CubeHash_GetBlockLen !****************************************************************************** SUBROUTINE CubeHash_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), TARGET , INTENT ( INOUT ) :: MD !! 'CubeHash' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE CubeHash_SetBufPtr !****************************************************************************** SUBROUTINE CubeHash_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J tInteger :: MW ! FLOW ! input block J = 0_kIndex DO I = 0_kIndex , 7_kIndex CALL BytePackLE ( BytesIn , J , MW ) MD % State ( I ) = IEOR ( MD % State ( I ), MW ) J = J + 4_kIndex END DO ! perform 16 rounds of mixing CALL MixState_16Rounds ( MD % State ) RETURN END SUBROUTINE CubeHash_ProcessBlock !****************************************************************************** SUBROUTINE CubeHash_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE CubeHash_DoPadding !****************************************************************************** SUBROUTINE CubeHash_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CubeHash ), INTENT ( INOUT ) :: MD !! 'CubeHash' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , I , J , DLen tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex IF ( Ptr < 32_kIndex ) THEN TmpBuf ( Ptr : 31 ) = FByte00 END IF CALL MD % ProcessBlock ( TmpBuf ) END ASSOCIATE ! finalizing MD % State ( 31 ) = IEOR ( MD % State ( 31 ), 1 ) DO I = 0 , 9 CALL MixState_16Rounds ( MD % State ) END DO DLen = MD % GetDigestLen () I = 0_kIndex J = 0_kIndex DO CALL ByteUnpackLE ( MD % State ( I ), BytesOut , Offset + J ) I = I + 1_kIndex J = J + 4_kIndex IF ( J == DLen ) EXIT END DO RETURN END SUBROUTINE CubeHash_AddBitsNPad !****************************************************************************** SUBROUTINE MixState_16Rounds ( H ) !** PURPOSE OF THIS SUBROUTINE: ! To perform mixing of the state. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 : 31 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: I !** SUBROUTINE MACRO DEFINITIONS: #define ROUND_EVEN(X)   \\ X ( 16 ) = ( X ( 0 ) + X ( 16 )); \\ X ( 0 ) = RotateLeft ( X ( 0 ), 7 ); \\ X ( 17 ) = ( X ( 1 ) + X ( 17 )); \\ X ( 1 ) = RotateLeft ( X ( 1 ), 7 ); \\ X ( 18 ) = ( X ( 2 ) + X ( 18 )); \\ X ( 2 ) = RotateLeft ( X ( 2 ), 7 ); \\ X ( 19 ) = ( X ( 3 ) + X ( 19 )); \\ X ( 3 ) = RotateLeft ( X ( 3 ), 7 ); \\ X ( 20 ) = ( X ( 4 ) + X ( 20 )); \\ X ( 4 ) = RotateLeft ( X ( 4 ), 7 ); \\ X ( 21 ) = ( X ( 5 ) + X ( 21 )); \\ X ( 5 ) = RotateLeft ( X ( 5 ), 7 ); \\ X ( 22 ) = ( X ( 6 ) + X ( 22 )); \\ X ( 6 ) = RotateLeft ( X ( 6 ), 7 ); \\ X ( 23 ) = ( X ( 7 ) + X ( 23 )); \\ X ( 7 ) = RotateLeft ( X ( 7 ), 7 ); \\ X ( 24 ) = ( X ( 8 ) + X ( 24 )); \\ X ( 8 ) = RotateLeft ( X ( 8 ), 7 ); \\ X ( 25 ) = ( X ( 9 ) + X ( 25 )); \\ X ( 9 ) = RotateLeft ( X ( 9 ), 7 ); \\ X ( 26 ) = ( X ( 10 ) + X ( 26 )); \\ X ( 10 ) = RotateLeft ( X ( 10 ), 7 ); \\ X ( 27 ) = ( X ( 11 ) + X ( 27 )); \\ X ( 11 ) = RotateLeft ( X ( 11 ), 7 ); \\ X ( 28 ) = ( X ( 12 ) + X ( 28 )); \\ X ( 12 ) = RotateLeft ( X ( 12 ), 7 ); \\ X ( 29 ) = ( X ( 13 ) + X ( 29 )); \\ X ( 13 ) = RotateLeft ( X ( 13 ), 7 ); \\ X ( 30 ) = ( X ( 14 ) + X ( 30 )); \\ X ( 14 ) = RotateLeft ( X ( 14 ), 7 ); \\ X ( 31 ) = ( X ( 15 ) + X ( 31 )); \\ X ( 15 ) = RotateLeft ( X ( 15 ), 7 ); \\ X ( 8 ) = IEOR ( X ( 8 ), X ( 16 )); \\ X ( 9 ) = IEOR ( X ( 9 ), X ( 17 )); \\ X ( 10 ) = IEOR ( X ( 10 ), X ( 18 )); \\ X ( 11 ) = IEOR ( X ( 11 ), X ( 19 )); \\ X ( 12 ) = IEOR ( X ( 12 ), X ( 20 )); \\ X ( 13 ) = IEOR ( X ( 13 ), X ( 21 )); \\ X ( 14 ) = IEOR ( X ( 14 ), X ( 22 )); \\ X ( 15 ) = IEOR ( X ( 15 ), X ( 23 )); \\ X ( 0 ) = IEOR ( X ( 0 ), X ( 24 )); \\ X ( 1 ) = IEOR ( X ( 1 ), X ( 25 )); \\ X ( 2 ) = IEOR ( X ( 2 ), X ( 26 )); \\ X ( 3 ) = IEOR ( X ( 3 ), X ( 27 )); \\ X ( 4 ) = IEOR ( X ( 4 ), X ( 28 )); \\ X ( 5 ) = IEOR ( X ( 5 ), X ( 29 )); \\ X ( 6 ) = IEOR ( X ( 6 ), X ( 30 )); \\ X ( 7 ) = IEOR ( X ( 7 ), X ( 31 )); \\ X ( 18 ) = ( X ( 8 ) + X ( 18 )); \\ X ( 8 ) = RotateLeft ( X ( 8 ), 11 ); \\ X ( 19 ) = ( X ( 9 ) + X ( 19 )); \\ X ( 9 ) = RotateLeft ( X ( 9 ), 11 ); \\ X ( 16 ) = ( X ( 10 ) + X ( 16 )); \\ X ( 10 ) = RotateLeft ( X ( 10 ), 11 ); \\ X ( 17 ) = ( X ( 11 ) + X ( 17 )); \\ X ( 11 ) = RotateLeft ( X ( 11 ), 11 ); \\ X ( 22 ) = ( X ( 12 ) + X ( 22 )); \\ X ( 12 ) = RotateLeft ( X ( 12 ), 11 ); \\ X ( 23 ) = ( X ( 13 ) + X ( 23 )); \\ X ( 13 ) = RotateLeft ( X ( 13 ), 11 ); \\ X ( 20 ) = ( X ( 14 ) + X ( 20 )); \\ X ( 14 ) = RotateLeft ( X ( 14 ), 11 ); \\ X ( 21 ) = ( X ( 15 ) + X ( 21 )); \\ X ( 15 ) = RotateLeft ( X ( 15 ), 11 ); \\ X ( 26 ) = ( X ( 0 ) + X ( 26 )); \\ X ( 0 ) = RotateLeft ( X ( 0 ), 11 ); \\ X ( 27 ) = ( X ( 1 ) + X ( 27 )); \\ X ( 1 ) = RotateLeft ( X ( 1 ), 11 ); \\ X ( 24 ) = ( X ( 2 ) + X ( 24 )); \\ X ( 2 ) = RotateLeft ( X ( 2 ), 11 ); \\ X ( 25 ) = ( X ( 3 ) + X ( 25 )); \\ X ( 3 ) = RotateLeft ( X ( 3 ), 11 ); \\ X ( 30 ) = ( X ( 4 ) + X ( 30 )); \\ X ( 4 ) = RotateLeft ( X ( 4 ), 11 ); \\ X ( 31 ) = ( X ( 5 ) + X ( 31 )); \\ X ( 5 ) = RotateLeft ( X ( 5 ), 11 ); \\ X ( 28 ) = ( X ( 6 ) + X ( 28 )); \\ X ( 6 ) = RotateLeft ( X ( 6 ), 11 ); \\ X ( 29 ) = ( X ( 7 ) + X ( 29 )); \\ X ( 7 ) = RotateLeft ( X ( 7 ), 11 ); \\ X ( 12 ) = IEOR ( X ( 12 ), X ( 18 )); \\ X ( 13 ) = IEOR ( X ( 13 ), X ( 19 )); \\ X ( 14 ) = IEOR ( X ( 14 ), X ( 16 )); \\ X ( 15 ) = IEOR ( X ( 15 ), X ( 17 )); \\ X ( 8 ) = IEOR ( X ( 8 ), X ( 22 )); \\ X ( 9 ) = IEOR ( X ( 9 ), X ( 23 )); \\ X ( 10 ) = IEOR ( X ( 10 ), X ( 20 )); \\ X ( 11 ) = IEOR ( X ( 11 ), X ( 21 )); \\ X ( 4 ) = IEOR ( X ( 4 ), X ( 26 )); \\ X ( 5 ) = IEOR ( X ( 5 ), X ( 27 )); \\ X ( 6 ) = IEOR ( X ( 6 ), X ( 24 )); \\ X ( 7 ) = IEOR ( X ( 7 ), X ( 25 )); \\ X ( 0 ) = IEOR ( X ( 0 ), X ( 30 )); \\ X ( 1 ) = IEOR ( X ( 1 ), X ( 31 )); \\ X ( 2 ) = IEOR ( X ( 2 ), X ( 28 )); \\ X ( 3 ) = IEOR ( X ( 3 ), X ( 29 )); #define ROUND_ODD(X)       \\ X ( 19 ) = ( X ( 12 ) + X ( 19 )); \\ X ( 12 ) = RotateLeft ( X ( 12 ), 7 ); \\ X ( 18 ) = ( X ( 13 ) + X ( 18 )); \\ X ( 13 ) = RotateLeft ( X ( 13 ), 7 ); \\ X ( 17 ) = ( X ( 14 ) + X ( 17 )); \\ X ( 14 ) = RotateLeft ( X ( 14 ), 7 ); \\ X ( 16 ) = ( X ( 15 ) + X ( 16 )); \\ X ( 15 ) = RotateLeft ( X ( 15 ), 7 ); \\ X ( 23 ) = ( X ( 8 ) + X ( 23 )); \\ X ( 8 ) = RotateLeft ( X ( 8 ), 7 ); \\ X ( 22 ) = ( X ( 9 ) + X ( 22 )); \\ X ( 9 ) = RotateLeft ( X ( 9 ), 7 ); \\ X ( 21 ) = ( X ( 10 ) + X ( 21 )); \\ X ( 10 ) = RotateLeft ( X ( 10 ), 7 ); \\ X ( 20 ) = ( X ( 11 ) + X ( 20 )); \\ X ( 11 ) = RotateLeft ( X ( 11 ), 7 ); \\ X ( 27 ) = ( X ( 4 ) + X ( 27 )); \\ X ( 4 ) = RotateLeft ( X ( 4 ), 7 ); \\ X ( 26 ) = ( X ( 5 ) + X ( 26 )); \\ X ( 5 ) = RotateLeft ( X ( 5 ), 7 ); \\ X ( 25 ) = ( X ( 6 ) + X ( 25 )); \\ X ( 6 ) = RotateLeft ( X ( 6 ), 7 ); \\ X ( 24 ) = ( X ( 7 ) + X ( 24 )); \\ X ( 7 ) = RotateLeft ( X ( 7 ), 7 ); \\ X ( 31 ) = ( X ( 0 ) + X ( 31 )); \\ X ( 0 ) = RotateLeft ( X ( 0 ), 7 ); \\ X ( 30 ) = ( X ( 1 ) + X ( 30 )); \\ X ( 1 ) = RotateLeft ( X ( 1 ), 7 ); \\ X ( 29 ) = ( X ( 2 ) + X ( 29 )); \\ X ( 2 ) = RotateLeft ( X ( 2 ), 7 ); \\ X ( 28 ) = ( X ( 3 ) + X ( 28 )); \\ X ( 3 ) = RotateLeft ( X ( 3 ), 7 ); \\ X ( 4 ) = IEOR ( X ( 4 ), X ( 19 )); \\ X ( 5 ) = IEOR ( X ( 5 ), X ( 18 )); \\ X ( 6 ) = IEOR ( X ( 6 ), X ( 17 )); \\ X ( 7 ) = IEOR ( X ( 7 ), X ( 16 )); \\ X ( 0 ) = IEOR ( X ( 0 ), X ( 23 )); \\ X ( 1 ) = IEOR ( X ( 1 ), X ( 22 )); \\ X ( 2 ) = IEOR ( X ( 2 ), X ( 21 )); \\ X ( 3 ) = IEOR ( X ( 3 ), X ( 20 )); \\ X ( 12 ) = IEOR ( X ( 12 ), X ( 27 )); \\ X ( 13 ) = IEOR ( X ( 13 ), X ( 26 )); \\ X ( 14 ) = IEOR ( X ( 14 ), X ( 25 )); \\ X ( 15 ) = IEOR ( X ( 15 ), X ( 24 )); \\ X ( 8 ) = IEOR ( X ( 8 ), X ( 31 )); \\ X ( 9 ) = IEOR ( X ( 9 ), X ( 30 )); \\ X ( 10 ) = IEOR ( X ( 10 ), X ( 29 )); \\ X ( 11 ) = IEOR ( X ( 11 ), X ( 28 )); \\ X ( 17 ) = ( X ( 4 ) + X ( 17 )); \\ X ( 4 ) = RotateLeft ( X ( 4 ), 11 ); \\ X ( 16 ) = ( X ( 5 ) + X ( 16 )); \\ X ( 5 ) = RotateLeft ( X ( 5 ), 11 ); \\ X ( 19 ) = ( X ( 6 ) + X ( 19 )); \\ X ( 6 ) = RotateLeft ( X ( 6 ), 11 ); \\ X ( 18 ) = ( X ( 7 ) + X ( 18 )); \\ X ( 7 ) = RotateLeft ( X ( 7 ), 11 ); \\ X ( 21 ) = ( X ( 0 ) + X ( 21 )); \\ X ( 0 ) = RotateLeft ( X ( 0 ), 11 ); \\ X ( 20 ) = ( X ( 1 ) + X ( 20 )); \\ X ( 1 ) = RotateLeft ( X ( 1 ), 11 ); \\ X ( 23 ) = ( X ( 2 ) + X ( 23 )); \\ X ( 2 ) = RotateLeft ( X ( 2 ), 11 ); \\ X ( 22 ) = ( X ( 3 ) + X ( 22 )); \\ X ( 3 ) = RotateLeft ( X ( 3 ), 11 ); \\ X ( 25 ) = ( X ( 12 ) + X ( 25 )); \\ X ( 12 ) = RotateLeft ( X ( 12 ), 11 ); \\ X ( 24 ) = ( X ( 13 ) + X ( 24 )); \\ X ( 13 ) = RotateLeft ( X ( 13 ), 11 ); \\ X ( 27 ) = ( X ( 14 ) + X ( 27 )); \\ X ( 14 ) = RotateLeft ( X ( 14 ), 11 ); \\ X ( 26 ) = ( X ( 15 ) + X ( 26 )); \\ X ( 15 ) = RotateLeft ( X ( 15 ), 11 ); \\ X ( 29 ) = ( X ( 8 ) + X ( 29 )); \\ X ( 8 ) = RotateLeft ( X ( 8 ), 11 ); \\ X ( 28 ) = ( X ( 9 ) + X ( 28 )); \\ X ( 9 ) = RotateLeft ( X ( 9 ), 11 ); \\ X ( 31 ) = ( X ( 10 ) + X ( 31 )); \\ X ( 10 ) = RotateLeft ( X ( 10 ), 11 ); \\ X ( 30 ) = ( X ( 11 ) + X ( 30 )); \\ X ( 11 ) = RotateLeft ( X ( 11 ), 11 ); \\ X ( 0 ) = IEOR ( X ( 0 ), X ( 17 )); \\ X ( 1 ) = IEOR ( X ( 1 ), X ( 16 )); \\ X ( 2 ) = IEOR ( X ( 2 ), X ( 19 )); \\ X ( 3 ) = IEOR ( X ( 3 ), X ( 18 )); \\ X ( 4 ) = IEOR ( X ( 4 ), X ( 21 )); \\ X ( 5 ) = IEOR ( X ( 5 ), X ( 20 )); \\ X ( 6 ) = IEOR ( X ( 6 ), X ( 23 )); \\ X ( 7 ) = IEOR ( X ( 7 ), X ( 22 )); \\ X ( 8 ) = IEOR ( X ( 8 ), X ( 25 )); \\ X ( 9 ) = IEOR ( X ( 9 ), X ( 24 )); \\ X ( 10 ) = IEOR ( X ( 10 ), X ( 27 )); \\ X ( 11 ) = IEOR ( X ( 11 ), X ( 26 )); \\ X ( 12 ) = IEOR ( X ( 12 ), X ( 29 )); \\ X ( 13 ) = IEOR ( X ( 13 ), X ( 28 )); \\ X ( 14 ) = IEOR ( X ( 14 ), X ( 31 )); \\ X ( 15 ) = IEOR ( X ( 15 ), X ( 30 )); ! FLOW DO I = 1 , 8 ROUND_EVEN ( H ) ROUND_ODD ( H ) END DO RETURN END SUBROUTINE MixState_16Rounds !****************************************************************************** END MODULE MClass_CubeHash !******************************************************************************","tags":"","loc":"sourcefile\\mclass_cubehash.f90.html"},{"title":"MClass_MetroHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MetroHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MetroHasher64* type and its related routines. !   The *MetroHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *MetroHasher64* type employs the *Metro* hash algorithm for 64-bit integer !   output by J. Andrew Rogers [1, 2].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/jandrewrogers/MetroHash\">MetroHash: Faster, Better !       Hash Functions. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MetroHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskI8(X)               IAND(ToInt64(X), Z'00000000000000FF') #define MaskI16(X)              IAND(ToInt64(X), Z'000000000000FFFF') #define MaskI32(X)              IAND(ToInt64(X), Z'00000000FFFFFFFF') #define Pack_U16(Buf,Index)     MaskI16(PackShort(Buf, Index)) #define Pack_U32(Buf,Index)     MaskI32(PackInteger(Buf, Index)) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: K0 = ToInt64 ( Z '00000000D6D018F5' ) tUInt64 , PARAMETER :: K1 = ToInt64 ( Z '00000000A2AA033B' ) tUInt64 , PARAMETER :: K2 = ToInt64 ( Z '0000000062992FC1' ) tUInt64 , PARAMETER :: K3 = ToInt64 ( Z '0000000030BC5B29' ) tIndex , PARAMETER :: BlockLen = 32_kIndex !** DERIVED TYPE DEFINITIONS !> *MetroHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *Metro* hash algorithm by J. Andrew Rogers. TYPE , EXTENDS ( Hasher64 ) :: MetroHasher64 PRIVATE tUInt64 :: InitHash = 0_kInt64 !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Metro_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Metro_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Metro_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Metro_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Metro_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Metro_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Metro_HashDirect END TYPE MetroHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Metro_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Metro_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Metro_GetName !****************************************************************************** FUNCTION Metro_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Metro_BlockLength !****************************************************************************** SUBROUTINE Metro_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Metro_SetBufPtr !****************************************************************************** SUBROUTINE Metro_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) V0 = V0 + PackLong ( BytesIn , 0_kIndex ) * K0 V0 = RotateRight ( V0 , 29 ) + V2 V1 = V1 + PackLong ( BytesIn , 8_kIndex ) * K1 V1 = RotateRight ( V1 , 29 ) + V3 V2 = V2 + PackLong ( BytesIn , 16_kIndex ) * K2 V2 = RotateRight ( V2 , 29 ) + V0 V3 = V3 + PackLong ( BytesIn , 24_kIndex ) * K3 V3 = RotateRight ( V3 , 29 ) + V1 END ASSOCIATE RETURN END SUBROUTINE Metro_ProcessBlock !****************************************************************************** SUBROUTINE Metro_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) V0 = ( Seed + K2 ) * K0 V1 = V0 V2 = V0 V3 = V0 HS % InitHash = V0 END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Metro_Initialize !****************************************************************************** FUNCTION Metro_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining , Offset !** FLOW Remaining = HS % GetBufLen () Offset = 0_kIndex IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF IF ( Length >= 32_kIndex ) THEN ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) V2 = IEOR ( V2 , RotateRight ((( V0 + V3 ) * K0 ) + V1 , 37 ) * K1 ) V3 = IEOR ( V3 , RotateRight ((( V1 + V2 ) * K1 ) + V0 , 37 ) * K0 ) V0 = IEOR ( V0 , RotateRight ((( V0 + V2 ) * K0 ) + V3 , 37 ) * K1 ) V1 = IEOR ( V1 , RotateRight ((( V1 + V3 ) * K1 ) + V2 , 37 ) * K0 ) HashCode = HS % InitHash + IEOR ( V0 , V1 ) END ASSOCIATE ELSE HashCode = HS % State ( 1 ) END IF ASSOCIATE ( Input => HS % BufArr ) IF ( Remaining >= 16_kIndex ) THEN BLOCK tUInt64 :: V0 , V1 V0 = HashCode + ( PackLong ( Input , Offset ) * K2 ) V0 = RotateRight ( V0 , 29 ) * K3 V1 = HashCode + ( PackLong ( Input , Offset + 8_kIndex ) * K2 ) V1 = RotateRight ( V1 , 29 ) * K3 V0 = IEOR ( V0 , RotateRight ( V0 * K0 , 21 ) + V1 ) V1 = IEOR ( V1 , RotateRight ( V1 * K3 , 21 ) + V0 ) HashCode = HashCode + V1 END BLOCK ! update indices Offset = Offset + 16_kIndex Remaining = Remaining - 16_kIndex END IF IF ( Remaining >= 8_kIndex ) THEN HashCode = HashCode + PackLong ( Input , Offset ) * K3 HashCode = IEOR ( HashCode , RotateRight ( HashCode , 55 ) * K1 ) ! update indices Offset = Offset + 8_kIndex Remaining = Remaining - 8_kIndex END IF IF ( Remaining >= 4_kIndex ) THEN HashCode = HashCode + Pack_U32 ( Input , Offset ) * K3 HashCode = IEOR ( HashCode , RotateRight ( HashCode , 26 ) * K1 ) ! update indices Offset = Offset + 4_kIndex Remaining = Remaining - 4_kIndex END IF IF ( Remaining >= 2_kIndex ) THEN HashCode = HashCode + Pack_U16 ( Input , Offset ) * K3 HashCode = IEOR ( HashCode , RotateRight ( HashCode , 48 ) * K1 ) ! update indices Offset = Offset + 2_kIndex Remaining = Remaining - 2_kIndex END IF IF ( Remaining >= 1_kIndex ) THEN HashCode = HashCode + MaskI8 ( Input ( Offset )) * K3 HashCode = IEOR ( HashCode , RotateRight ( HashCode , 37 ) * K1 ) END IF END ASSOCIATE HashCode = IEOR ( HashCode , RotateRight ( HashCode , 28 )) HashCode = HashCode * K0 HashCode = IEOR ( HashCode , RotateRight ( HashCode , 29 )) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Metro_Finalize !****************************************************************************** FUNCTION Metro_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MetroHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Metro_HashDirect !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Output , Input ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackLong !************************************************************************** PURE FUNCTION PackInteger ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 32-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #undef MaskInt32 RETURN END FUNCTION PackInteger !****************************************************************************** PURE FUNCTION PackShort ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt16 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #3 (comparable to #1) #define UnsignedByte(Val, Off)  IAND(ToInt32(Val(Off)), Z'000000FF') #define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) Res = ToInt16 ( UnsignedShort ( Buf , Off )) #undef UnsignedByte #undef UnsignedShort RETURN END FUNCTION PackShort !****************************************************************************** END MODULE MClass_MetroHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_metrohasher64.f90.html"},{"title":"MClass_MD2.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MD2 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MD2* type and its related routines. !   The *MD2* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *MD2* type implements an incremental cryptographic hash !   function by employing the *MD2 message-digest* algorithm [1] !   where the algorithm is described in RFC 1319.  The implementation !   here is mainly based on the *SPHLIB* implementation [2].  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://datatracker.ietf.org/doc/html/rfc1319\">RFC1319: !       The MD2 Message-Digest Algorithm. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MD2 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 16_kIndex tIndex , PARAMETER :: DigestLen = 16_kIndex ! Internal \"magic\" table tInteger , PARAMETER :: S ( 0 : 255 ) = [ & 41 , 46 , 67 , 201 , 162 , 216 , 124 , 1 , & 61 , 54 , 84 , 161 , 236 , 240 , 6 , 19 , & 98 , 167 , 5 , 243 , 192 , 199 , 115 , 140 , & 152 , 147 , 43 , 217 , 188 , 76 , 130 , 202 , & 30 , 155 , 87 , 60 , 253 , 212 , 224 , 22 , & 103 , 66 , 111 , 24 , 138 , 23 , 229 , 18 , & 190 , 78 , 196 , 214 , 218 , 158 , 222 , 73 , & 160 , 251 , 245 , 142 , 187 , 47 , 238 , 122 , & 169 , 104 , 121 , 145 , 21 , 178 , 7 , 63 , & 148 , 194 , 16 , 137 , 11 , 34 , 95 , 33 , & 128 , 127 , 93 , 154 , 90 , 144 , 50 , 39 , & 53 , 62 , 204 , 231 , 191 , 247 , 151 , 3 , & 255 , 25 , 48 , 179 , 72 , 165 , 181 , 209 , & 215 , 94 , 146 , 42 , 172 , 86 , 170 , 198 , & 79 , 184 , 56 , 210 , 150 , 164 , 125 , 182 , & 118 , 252 , 107 , 226 , 156 , 116 , 4 , 241 , & 69 , 157 , 112 , 89 , 100 , 113 , 135 , 32 , & 134 , 91 , 207 , 101 , 230 , 45 , 168 , 2 , & 27 , 96 , 37 , 173 , 174 , 176 , 185 , 246 , & 28 , 70 , 97 , 105 , 52 , 64 , 126 , 15 , & 85 , 71 , 163 , 35 , 221 , 81 , 175 , 58 , & 195 , 92 , 249 , 206 , 186 , 197 , 234 , 38 , & 44 , 83 , 13 , 110 , 133 , 40 , 132 , 9 , & 211 , 223 , 205 , 244 , 65 , 129 , 77 , 82 , & 106 , 220 , 55 , 200 , 108 , 193 , 171 , 250 , & 36 , 225 , 123 , 8 , 12 , 189 , 177 , 74 , & 120 , 136 , 149 , 139 , 227 , 99 , 232 , 109 , & 233 , 203 , 213 , 254 , 59 , 0 , 29 , 57 , & 242 , 239 , 183 , 14 , 102 , 88 , 208 , 228 , & 166 , 119 , 114 , 248 , 235 , 117 , 75 , 10 , & 49 , 68 , 80 , 180 , 143 , 237 , 31 , 26 , & 219 , 153 , 141 , 51 , 159 , 17 , 131 , 20 ] !** DERIVED TYPE DEFINITIONS !> *MD2* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing !  the *MD2 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: MD2 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: X ( 0 : 47 ) = 0_kInt32 tInteger :: C ( 0 : 15 ) = 0_kInt32 tInteger :: L = 0_kInt32 CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD2_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD2_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD2_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD2_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD2_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD2_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD2_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD2_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD2_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD2_AddBitsNPad END TYPE MD2 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE MD2_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: MD !! 'MD2' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Reset () RETURN END SUBROUTINE MD2_Initialize !****************************************************************************** SUBROUTINE MD2_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: MD !! 'MD2' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % X = 0_kInt32 MD % C = 0_kInt32 MD % L = 0_kInt32 CALL MD % EngineReset () RETURN END SUBROUTINE MD2_Reset !****************************************************************************** SUBROUTINE MD2_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( MD2 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( MD2 ) CALL Dst % Create () Dst % X = Src % X Dst % C = Src % C Dst % L = Src % L Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE MD2_GetClone !****************************************************************************** FUNCTION MD2_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( IN ) :: MD !! 'MD2' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'MD2' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD2_GetName !****************************************************************************** FUNCTION MD2_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( IN ) :: MD !! 'MD2' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = DigestLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD2_GetDigestLen !****************************************************************************** FUNCTION MD2_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( IN ) :: MD !! 'MD2' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD2_GetBlockLen !****************************************************************************** SUBROUTINE MD2_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), TARGET , INTENT ( INOUT ) :: MD !! 'MD2' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE MD2_SetBufPtr !****************************************************************************** SUBROUTINE MD2_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: MD !! 'MD2' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: TL , U tIndex :: I , J , K , L , T ! FLOW TL = MD % L DO I = 0 , 15 U = IAND ( ToInt32 ( BytesIn ( I )), ToInt32 ( Z '000000FF' )) MD % X ( 16 + I ) = U MD % X ( 32 + I ) = IEOR ( MD % X ( I ), U ) MD % C ( I ) = IEOR ( MD % C ( I ), S ( IEOR ( U , TL ))) TL = MD % C ( I ) END DO MD % L = TL T = 0 DO J = 0 , 17 DO K = 0 , 47 , 8 DO L = 0 , 7 MD % X ( K + L ) = IEOR ( MD % X ( K + L ), S ( T )) T = ToIndex ( MD % X ( K + L )) END DO END DO T = IAND (( T + J ), ToIndex ( Z '000000FF' )) END DO RETURN END SUBROUTINE MD2_ProcessBlock !****************************************************************************** SUBROUTINE MD2_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: MD !! 'MD2' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: D ( 0 : 15 ) tIndex :: Pending , I , J ! FLOW Pending = MD % GetBufLen () DO I = 0 , ( 15 - Pending ) CALL MD % Update ( ToInt8 ( 16_kIndex - Pending ), 1_kIndex ) END DO J = MD % GetBufLen () DO I = 0 , 15 D ( I ) = ToInt8 ( MD % C ( I )) END DO CALL MD % ProcessBlock ( D ) DO I = 0 , 15 BytesOut ( Offset + I ) = ToInt8 ( MD % X ( I )) END DO RETURN END SUBROUTINE MD2_DoPadding !****************************************************************************** SUBROUTINE MD2_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD2 ), INTENT ( INOUT ) :: MD !! 'MD2' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! MD2 algorithm does not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE MD2_AddBitsNPad !****************************************************************************** END MODULE MClass_MD2 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_md2.f90.html"},{"title":"MClass_GroestlS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_GroestlS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *GroestlS* type and its related routines. !   The *GroestlS* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *GroestlS* type implements an incremental cryptographic hash function !   by employing either the *Groestl-224* or the *Groestl-256 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *GroestlS* type employs the *Groestl-256 message-digest* !   algorithm.  However, a user can specify the *IsGroestl224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *Groestl-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"http://www.groestl.info/\">Grostl - a SHA-3 candidate. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: GroestlS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #define BX64(X, Pos)    ToInt32(SHIFTR(X, Pos)) #define BY64(X, Pos)    IAND(ToInt32(SHIFTR(X, Pos)), ToInt32(Z'000000FF')) #define RSTT(A, I0, I1, I2, I3, I4, I5, I6, I7) \\ IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( T0 ( BX64 ( A ( I0 ), 56 )), \\ T1 ( BY64 ( A ( I1 ), 48 ))), \\ T2 ( BY64 ( A ( I2 ), 40 ))), \\ T3 ( BY64 ( A ( I3 ), 32 ))), \\ T4 ( BY64 ( A ( I4 ), 24 ))), \\ T5 ( BY64 ( A ( I5 ), 16 ))), \\ T6 ( BY64 ( A ( I6 ), 8 ))), \\ T7 ( BY64 ( A ( I7 ), 0 ))) #define PC64(A, J, R)   IEOR(A, SHIFTL(ToInt64(J + R), 56)) #define QC64(A, J, R)   IEOR(A, IEOR(-ToInt64(J), ToInt64(R))) !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tLong , PARAMETER , PUBLIC :: T0 ( 0 : 255 ) = [ & ToInt64 ( Z 'C632F4A5F497A5C6' ), ToInt64 ( Z 'F86F978497EB84F8' ), & ToInt64 ( Z 'EE5EB099B0C799EE' ), ToInt64 ( Z 'F67A8C8D8CF78DF6' ), & ToInt64 ( Z 'FFE8170D17E50DFF' ), ToInt64 ( Z 'D60ADCBDDCB7BDD6' ), & ToInt64 ( Z 'DE16C8B1C8A7B1DE' ), ToInt64 ( Z '916DFC54FC395491' ), & ToInt64 ( Z '6090F050F0C05060' ), ToInt64 ( Z '0207050305040302' ), & ToInt64 ( Z 'CE2EE0A9E087A9CE' ), ToInt64 ( Z '56D1877D87AC7D56' ), & ToInt64 ( Z 'E7CC2B192BD519E7' ), ToInt64 ( Z 'B513A662A67162B5' ), & ToInt64 ( Z '4D7C31E6319AE64D' ), ToInt64 ( Z 'EC59B59AB5C39AEC' ), & ToInt64 ( Z '8F40CF45CF05458F' ), ToInt64 ( Z '1FA3BC9DBC3E9D1F' ), & ToInt64 ( Z '8949C040C0094089' ), ToInt64 ( Z 'FA68928792EF87FA' ), & ToInt64 ( Z 'EFD03F153FC515EF' ), ToInt64 ( Z 'B29426EB267FEBB2' ), & ToInt64 ( Z '8ECE40C94007C98E' ), ToInt64 ( Z 'FBE61D0B1DED0BFB' ), & ToInt64 ( Z '416E2FEC2F82EC41' ), ToInt64 ( Z 'B31AA967A97D67B3' ), & ToInt64 ( Z '5F431CFD1CBEFD5F' ), ToInt64 ( Z '456025EA258AEA45' ), & ToInt64 ( Z '23F9DABFDA46BF23' ), ToInt64 ( Z '535102F702A6F753' ), & ToInt64 ( Z 'E445A196A1D396E4' ), ToInt64 ( Z '9B76ED5BED2D5B9B' ), & ToInt64 ( Z '75285DC25DEAC275' ), ToInt64 ( Z 'E1C5241C24D91CE1' ), & ToInt64 ( Z '3DD4E9AEE97AAE3D' ), ToInt64 ( Z '4CF2BE6ABE986A4C' ), & ToInt64 ( Z '6C82EE5AEED85A6C' ), ToInt64 ( Z '7EBDC341C3FC417E' ), & ToInt64 ( Z 'F5F3060206F102F5' ), ToInt64 ( Z '8352D14FD11D4F83' ), & ToInt64 ( Z '688CE45CE4D05C68' ), ToInt64 ( Z '515607F407A2F451' ), & ToInt64 ( Z 'D18D5C345CB934D1' ), ToInt64 ( Z 'F9E1180818E908F9' ), & ToInt64 ( Z 'E24CAE93AEDF93E2' ), ToInt64 ( Z 'AB3E9573954D73AB' ), & ToInt64 ( Z '6297F553F5C45362' ), ToInt64 ( Z '2A6B413F41543F2A' ), & ToInt64 ( Z '081C140C14100C08' ), ToInt64 ( Z '9563F652F6315295' ), & ToInt64 ( Z '46E9AF65AF8C6546' ), ToInt64 ( Z '9D7FE25EE2215E9D' ), & ToInt64 ( Z '3048782878602830' ), ToInt64 ( Z '37CFF8A1F86EA137' ), & ToInt64 ( Z '0A1B110F11140F0A' ), ToInt64 ( Z '2FEBC4B5C45EB52F' ), & ToInt64 ( Z '0E151B091B1C090E' ), ToInt64 ( Z '247E5A365A483624' ), & ToInt64 ( Z '1BADB69BB6369B1B' ), ToInt64 ( Z 'DF98473D47A53DDF' ), & ToInt64 ( Z 'CDA76A266A8126CD' ), ToInt64 ( Z '4EF5BB69BB9C694E' ), & ToInt64 ( Z '7F334CCD4CFECD7F' ), ToInt64 ( Z 'EA50BA9FBACF9FEA' ), & ToInt64 ( Z '123F2D1B2D241B12' ), ToInt64 ( Z '1DA4B99EB93A9E1D' ), & ToInt64 ( Z '58C49C749CB07458' ), ToInt64 ( Z '3446722E72682E34' ), & ToInt64 ( Z '3641772D776C2D36' ), ToInt64 ( Z 'DC11CDB2CDA3B2DC' ), & ToInt64 ( Z 'B49D29EE2973EEB4' ), ToInt64 ( Z '5B4D16FB16B6FB5B' ), & ToInt64 ( Z 'A4A501F60153F6A4' ), ToInt64 ( Z '76A1D74DD7EC4D76' ), & ToInt64 ( Z 'B714A361A37561B7' ), ToInt64 ( Z '7D3449CE49FACE7D' ), & ToInt64 ( Z '52DF8D7B8DA47B52' ), ToInt64 ( Z 'DD9F423E42A13EDD' ), & ToInt64 ( Z '5ECD937193BC715E' ), ToInt64 ( Z '13B1A297A2269713' ), & ToInt64 ( Z 'A6A204F50457F5A6' ), ToInt64 ( Z 'B901B868B86968B9' ), & ToInt64 ( Z '0000000000000000' ), ToInt64 ( Z 'C1B5742C74992CC1' ), & ToInt64 ( Z '40E0A060A0806040' ), ToInt64 ( Z 'E3C2211F21DD1FE3' ), & ToInt64 ( Z '793A43C843F2C879' ), ToInt64 ( Z 'B69A2CED2C77EDB6' ), & ToInt64 ( Z 'D40DD9BED9B3BED4' ), ToInt64 ( Z '8D47CA46CA01468D' ), & ToInt64 ( Z '671770D970CED967' ), ToInt64 ( Z '72AFDD4BDDE44B72' ), & ToInt64 ( Z '94ED79DE7933DE94' ), ToInt64 ( Z '98FF67D4672BD498' ), & ToInt64 ( Z 'B09323E8237BE8B0' ), ToInt64 ( Z '855BDE4ADE114A85' ), & ToInt64 ( Z 'BB06BD6BBD6D6BBB' ), ToInt64 ( Z 'C5BB7E2A7E912AC5' ), & ToInt64 ( Z '4F7B34E5349EE54F' ), ToInt64 ( Z 'EDD73A163AC116ED' ), & ToInt64 ( Z '86D254C55417C586' ), ToInt64 ( Z '9AF862D7622FD79A' ), & ToInt64 ( Z '6699FF55FFCC5566' ), ToInt64 ( Z '11B6A794A7229411' ), & ToInt64 ( Z '8AC04ACF4A0FCF8A' ), ToInt64 ( Z 'E9D9301030C910E9' ), & ToInt64 ( Z '040E0A060A080604' ), ToInt64 ( Z 'FE66988198E781FE' ), & ToInt64 ( Z 'A0AB0BF00B5BF0A0' ), ToInt64 ( Z '78B4CC44CCF04478' ), & ToInt64 ( Z '25F0D5BAD54ABA25' ), ToInt64 ( Z '4B753EE33E96E34B' ), & ToInt64 ( Z 'A2AC0EF30E5FF3A2' ), ToInt64 ( Z '5D4419FE19BAFE5D' ), & ToInt64 ( Z '80DB5BC05B1BC080' ), ToInt64 ( Z '0580858A850A8A05' ), & ToInt64 ( Z '3FD3ECADEC7EAD3F' ), ToInt64 ( Z '21FEDFBCDF42BC21' ), & ToInt64 ( Z '70A8D848D8E04870' ), ToInt64 ( Z 'F1FD0C040CF904F1' ), & ToInt64 ( Z '63197ADF7AC6DF63' ), ToInt64 ( Z '772F58C158EEC177' ), & ToInt64 ( Z 'AF309F759F4575AF' ), ToInt64 ( Z '42E7A563A5846342' ), & ToInt64 ( Z '2070503050403020' ), ToInt64 ( Z 'E5CB2E1A2ED11AE5' ), & ToInt64 ( Z 'FDEF120E12E10EFD' ), ToInt64 ( Z 'BF08B76DB7656DBF' ), & ToInt64 ( Z '8155D44CD4194C81' ), ToInt64 ( Z '18243C143C301418' ), & ToInt64 ( Z '26795F355F4C3526' ), ToInt64 ( Z 'C3B2712F719D2FC3' ), & ToInt64 ( Z 'BE8638E13867E1BE' ), ToInt64 ( Z '35C8FDA2FD6AA235' ), & ToInt64 ( Z '88C74FCC4F0BCC88' ), ToInt64 ( Z '2E654B394B5C392E' ), & ToInt64 ( Z '936AF957F93D5793' ), ToInt64 ( Z '55580DF20DAAF255' ), & ToInt64 ( Z 'FC619D829DE382FC' ), ToInt64 ( Z '7AB3C947C9F4477A' ), & ToInt64 ( Z 'C827EFACEF8BACC8' ), ToInt64 ( Z 'BA8832E7326FE7BA' ), & ToInt64 ( Z '324F7D2B7D642B32' ), ToInt64 ( Z 'E642A495A4D795E6' ), & ToInt64 ( Z 'C03BFBA0FB9BA0C0' ), ToInt64 ( Z '19AAB398B3329819' ), & ToInt64 ( Z '9EF668D16827D19E' ), ToInt64 ( Z 'A322817F815D7FA3' ), & ToInt64 ( Z '44EEAA66AA886644' ), ToInt64 ( Z '54D6827E82A87E54' ), & ToInt64 ( Z '3BDDE6ABE676AB3B' ), ToInt64 ( Z '0B959E839E16830B' ), & ToInt64 ( Z '8CC945CA4503CA8C' ), ToInt64 ( Z 'C7BC7B297B9529C7' ), & ToInt64 ( Z '6B056ED36ED6D36B' ), ToInt64 ( Z '286C443C44503C28' ), & ToInt64 ( Z 'A72C8B798B5579A7' ), ToInt64 ( Z 'BC813DE23D63E2BC' ), & ToInt64 ( Z '1631271D272C1D16' ), ToInt64 ( Z 'AD379A769A4176AD' ), & ToInt64 ( Z 'DB964D3B4DAD3BDB' ), ToInt64 ( Z '649EFA56FAC85664' ), & ToInt64 ( Z '74A6D24ED2E84E74' ), ToInt64 ( Z '1436221E22281E14' ), & ToInt64 ( Z '92E476DB763FDB92' ), ToInt64 ( Z '0C121E0A1E180A0C' ), & ToInt64 ( Z '48FCB46CB4906C48' ), ToInt64 ( Z 'B88F37E4376BE4B8' ), & ToInt64 ( Z '9F78E75DE7255D9F' ), ToInt64 ( Z 'BD0FB26EB2616EBD' ), & ToInt64 ( Z '43692AEF2A86EF43' ), ToInt64 ( Z 'C435F1A6F193A6C4' ), & ToInt64 ( Z '39DAE3A8E372A839' ), ToInt64 ( Z '31C6F7A4F762A431' ), & ToInt64 ( Z 'D38A593759BD37D3' ), ToInt64 ( Z 'F274868B86FF8BF2' ), & ToInt64 ( Z 'D583563256B132D5' ), ToInt64 ( Z '8B4EC543C50D438B' ), & ToInt64 ( Z '6E85EB59EBDC596E' ), ToInt64 ( Z 'DA18C2B7C2AFB7DA' ), & ToInt64 ( Z '018E8F8C8F028C01' ), ToInt64 ( Z 'B11DAC64AC7964B1' ), & ToInt64 ( Z '9CF16DD26D23D29C' ), ToInt64 ( Z '49723BE03B92E049' ), & ToInt64 ( Z 'D81FC7B4C7ABB4D8' ), ToInt64 ( Z 'ACB915FA1543FAAC' ), & ToInt64 ( Z 'F3FA090709FD07F3' ), ToInt64 ( Z 'CFA06F256F8525CF' ), & ToInt64 ( Z 'CA20EAAFEA8FAFCA' ), ToInt64 ( Z 'F47D898E89F38EF4' ), & ToInt64 ( Z '476720E9208EE947' ), ToInt64 ( Z '1038281828201810' ), & ToInt64 ( Z '6F0B64D564DED56F' ), ToInt64 ( Z 'F073838883FB88F0' ), & ToInt64 ( Z '4AFBB16FB1946F4A' ), ToInt64 ( Z '5CCA967296B8725C' ), & ToInt64 ( Z '38546C246C702438' ), ToInt64 ( Z '575F08F108AEF157' ), & ToInt64 ( Z '732152C752E6C773' ), ToInt64 ( Z '9764F351F3355197' ), & ToInt64 ( Z 'CBAE6523658D23CB' ), ToInt64 ( Z 'A125847C84597CA1' ), & ToInt64 ( Z 'E857BF9CBFCB9CE8' ), ToInt64 ( Z '3E5D6321637C213E' ), & ToInt64 ( Z '96EA7CDD7C37DD96' ), ToInt64 ( Z '611E7FDC7FC2DC61' ), & ToInt64 ( Z '0D9C9186911A860D' ), ToInt64 ( Z '0F9B9485941E850F' ), & ToInt64 ( Z 'E04BAB90ABDB90E0' ), ToInt64 ( Z '7CBAC642C6F8427C' ), & ToInt64 ( Z '712657C457E2C471' ), ToInt64 ( Z 'CC29E5AAE583AACC' ), & ToInt64 ( Z '90E373D8733BD890' ), ToInt64 ( Z '06090F050F0C0506' ), & ToInt64 ( Z 'F7F4030103F501F7' ), ToInt64 ( Z '1C2A36123638121C' ), & ToInt64 ( Z 'C23CFEA3FE9FA3C2' ), ToInt64 ( Z '6A8BE15FE1D45F6A' ), & ToInt64 ( Z 'AEBE10F91047F9AE' ), ToInt64 ( Z '69026BD06BD2D069' ), & ToInt64 ( Z '17BFA891A82E9117' ), ToInt64 ( Z '9971E858E8295899' ), & ToInt64 ( Z '3A5369276974273A' ), ToInt64 ( Z '27F7D0B9D04EB927' ), & ToInt64 ( Z 'D991483848A938D9' ), ToInt64 ( Z 'EBDE351335CD13EB' ), & ToInt64 ( Z '2BE5CEB3CE56B32B' ), ToInt64 ( Z '2277553355443322' ), & ToInt64 ( Z 'D204D6BBD6BFBBD2' ), ToInt64 ( Z 'A9399070904970A9' ), & ToInt64 ( Z '07878089800E8907' ), ToInt64 ( Z '33C1F2A7F266A733' ), & ToInt64 ( Z '2DECC1B6C15AB62D' ), ToInt64 ( Z '3C5A66226678223C' ), & ToInt64 ( Z '15B8AD92AD2A9215' ), ToInt64 ( Z 'C9A96020608920C9' ), & ToInt64 ( Z '875CDB49DB154987' ), ToInt64 ( Z 'AAB01AFF1A4FFFAA' ), & ToInt64 ( Z '50D8887888A07850' ), ToInt64 ( Z 'A52B8E7A8E517AA5' ), & ToInt64 ( Z '03898A8F8A068F03' ), ToInt64 ( Z '594A13F813B2F859' ), & ToInt64 ( Z '09929B809B128009' ), ToInt64 ( Z '1A2339173934171A' ), & ToInt64 ( Z '651075DA75CADA65' ), ToInt64 ( Z 'D784533153B531D7' ), & ToInt64 ( Z '84D551C65113C684' ), ToInt64 ( Z 'D003D3B8D3BBB8D0' ), & ToInt64 ( Z '82DC5EC35E1FC382' ), ToInt64 ( Z '29E2CBB0CB52B029' ), & ToInt64 ( Z '5AC3997799B4775A' ), ToInt64 ( Z '1E2D3311333C111E' ), & ToInt64 ( Z '7B3D46CB46F6CB7B' ), ToInt64 ( Z 'A8B71FFC1F4BFCA8' ), & ToInt64 ( Z '6D0C61D661DAD66D' ), ToInt64 ( Z '2C624E3A4E583A2C' )] tInteger :: Indx tLong , PARAMETER , PUBLIC :: T1 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 56 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T2 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 48 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T3 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 40 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T4 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 32 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T5 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 24 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T6 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 16 ), Indx = 0 , 255 )] tLong , PARAMETER , PUBLIC :: T7 ( 0 : 255 ) = [( RotateLeft ( T0 ( Indx ), 8 ), Indx = 0 , 255 )] !** DERIVED TYPE DEFINITIONS !> *GroestlS* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *Groestl-224* or the *Groestl-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: GroestlS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 7 ) = 0_kInt64 !% flag indicating whether the Groestl-224 algorithm is employed or not. tLogical :: IsGroestl224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => GroestlS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Groestl-256). PROCEDURE :: Initialize => GroestlS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => GroestlS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => GroestlS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => GroestlS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => GroestlS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => GroestlS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => GroestlS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => GroestlS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => GroestlS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => GroestlS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Groestl-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Groestl-224 algorithm <br> !   --->    CALL MD%Create(IsGroestl224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE GroestlS !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE GroestlS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the Groestl-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE GroestlS_Initialize !****************************************************************************** SUBROUTINE GroestlS_Initialize_wFlag ( MD , IsGroestl224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object tLogical , INTENT ( IN ) :: IsGroestl224 !&#94; flag indicating whether the Groestl-224 algorithm is employed or not. <br> !  - If true, use the Groestl-224 algorithm. <br> !  - Otherwise, use the Groestl-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsGroestl224 = IsGroestl224 CALL MD % Reset () RETURN END SUBROUTINE GroestlS_Initialize_wFlag !****************************************************************************** SUBROUTINE GroestlS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % H ( 0 : 6 ) = 0_kInt64 MD % H ( 7 ) = SHIFTL ( ToInt64 ( MD % GetDigestLen ()), 3 ) CALL MD % EngineReset () RETURN END SUBROUTINE GroestlS_Reset !****************************************************************************** SUBROUTINE GroestlS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( GroestlS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( GroestlS ) CALL Dst % Create ( Src % IsGroestl224 ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE GroestlS_GetClone !****************************************************************************** FUNCTION GroestlS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( IN ) :: MD !! 'GroestlS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsGroestl224 ) THEN Name = 'Groestl-224' ELSE Name = 'Groestl-256' END IF RETURN END FUNCTION GroestlS_GetName !****************************************************************************** FUNCTION GroestlS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( IN ) :: MD !! 'GroestlS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsGroestl224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION GroestlS_GetDigestLen !****************************************************************************** FUNCTION GroestlS_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( IN ) :: MD !! 'GroestlS' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION GroestlS_GetBlockLen !****************************************************************************** SUBROUTINE GroestlS_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), TARGET , INTENT ( INOUT ) :: MD !! 'GroestlS' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE GroestlS_SetBufPtr !****************************************************************************** SUBROUTINE GroestlS_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: G ( 0 : 7 ) tLong :: MS ( 0 : 7 ) tIndex :: I ! FLOW ! input block CALL BytePackBE ( BytesIn , 0_kIndex , MS ) DO I = 0 , 7 G ( I ) = IEOR ( MS ( I ), MD % H ( I )) END DO ! perform permutations CALL DoPermP ( G ) CALL DoPermQ ( MS ) ! get output states DO I = 0 , 7 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR ( G ( I ), MS ( I ))) END DO RETURN CONTAINS SUBROUTINE DoPermQ ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To perform permutation Q. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T ( 0 : 7 ) tInteger :: R , RP1 ! FLOW DO R = 0 , 9 , 2 X ( 0 ) = QC64 ( X ( 0 ), ToInt32 ( Z '00000001' ), R ) X ( 1 ) = QC64 ( X ( 1 ), ToInt32 ( Z '00000011' ), R ) X ( 2 ) = QC64 ( X ( 2 ), ToInt32 ( Z '00000021' ), R ) X ( 3 ) = QC64 ( X ( 3 ), ToInt32 ( Z '00000031' ), R ) X ( 4 ) = QC64 ( X ( 4 ), ToInt32 ( Z '00000041' ), R ) X ( 5 ) = QC64 ( X ( 5 ), ToInt32 ( Z '00000051' ), R ) X ( 6 ) = QC64 ( X ( 6 ), ToInt32 ( Z '00000061' ), R ) X ( 7 ) = QC64 ( X ( 7 ), ToInt32 ( Z '00000071' ), R ) T ( 0 ) = RSTT ( X , 1 , 3 , 5 , 7 , 0 , 2 , 4 , 6 ) T ( 1 ) = RSTT ( X , 2 , 4 , 6 , 0 , 1 , 3 , 5 , 7 ) T ( 2 ) = RSTT ( X , 3 , 5 , 7 , 1 , 2 , 4 , 6 , 0 ) T ( 3 ) = RSTT ( X , 4 , 6 , 0 , 2 , 3 , 5 , 7 , 1 ) T ( 4 ) = RSTT ( X , 5 , 7 , 1 , 3 , 4 , 6 , 0 , 2 ) T ( 5 ) = RSTT ( X , 6 , 0 , 2 , 4 , 5 , 7 , 1 , 3 ) T ( 6 ) = RSTT ( X , 7 , 1 , 3 , 5 , 6 , 0 , 2 , 4 ) T ( 7 ) = RSTT ( X , 0 , 2 , 4 , 6 , 7 , 1 , 3 , 5 ) RP1 = R + 1 T ( 0 ) = QC64 ( T ( 0 ), ToInt32 ( Z '00000001' ), RP1 ) T ( 1 ) = QC64 ( T ( 1 ), ToInt32 ( Z '00000011' ), RP1 ) T ( 2 ) = QC64 ( T ( 2 ), ToInt32 ( Z '00000021' ), RP1 ) T ( 3 ) = QC64 ( T ( 3 ), ToInt32 ( Z '00000031' ), RP1 ) T ( 4 ) = QC64 ( T ( 4 ), ToInt32 ( Z '00000041' ), RP1 ) T ( 5 ) = QC64 ( T ( 5 ), ToInt32 ( Z '00000051' ), RP1 ) T ( 6 ) = QC64 ( T ( 6 ), ToInt32 ( Z '00000061' ), RP1 ) T ( 7 ) = QC64 ( T ( 7 ), ToInt32 ( Z '00000071' ), RP1 ) X ( 0 ) = RSTT ( T , 1 , 3 , 5 , 7 , 0 , 2 , 4 , 6 ) X ( 1 ) = RSTT ( T , 2 , 4 , 6 , 0 , 1 , 3 , 5 , 7 ) X ( 2 ) = RSTT ( T , 3 , 5 , 7 , 1 , 2 , 4 , 6 , 0 ) X ( 3 ) = RSTT ( T , 4 , 6 , 0 , 2 , 3 , 5 , 7 , 1 ) X ( 4 ) = RSTT ( T , 5 , 7 , 1 , 3 , 4 , 6 , 0 , 2 ) X ( 5 ) = RSTT ( T , 6 , 0 , 2 , 4 , 5 , 7 , 1 , 3 ) X ( 6 ) = RSTT ( T , 7 , 1 , 3 , 5 , 6 , 0 , 2 , 4 ) X ( 7 ) = RSTT ( T , 0 , 2 , 4 , 6 , 7 , 1 , 3 , 5 ) END DO RETURN END SUBROUTINE DoPermQ !************************************************************************** END SUBROUTINE GroestlS_ProcessBlock !****************************************************************************** SUBROUTINE DoPermP ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To perform permutation P. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T ( 0 : 7 ) tInteger :: R , RP1 ! FLOW DO R = 0 , 9 , 2 X ( 0 ) = PC64 ( X ( 0 ), ToInt32 ( Z '00000000' ), R ) X ( 1 ) = PC64 ( X ( 1 ), ToInt32 ( Z '00000010' ), R ) X ( 2 ) = PC64 ( X ( 2 ), ToInt32 ( Z '00000020' ), R ) X ( 3 ) = PC64 ( X ( 3 ), ToInt32 ( Z '00000030' ), R ) X ( 4 ) = PC64 ( X ( 4 ), ToInt32 ( Z '00000040' ), R ) X ( 5 ) = PC64 ( X ( 5 ), ToInt32 ( Z '00000050' ), R ) X ( 6 ) = PC64 ( X ( 6 ), ToInt32 ( Z '00000060' ), R ) X ( 7 ) = PC64 ( X ( 7 ), ToInt32 ( Z '00000070' ), R ) T ( 0 ) = RSTT ( X , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) T ( 1 ) = RSTT ( X , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 0 ) T ( 2 ) = RSTT ( X , 2 , 3 , 4 , 5 , 6 , 7 , 0 , 1 ) T ( 3 ) = RSTT ( X , 3 , 4 , 5 , 6 , 7 , 0 , 1 , 2 ) T ( 4 ) = RSTT ( X , 4 , 5 , 6 , 7 , 0 , 1 , 2 , 3 ) T ( 5 ) = RSTT ( X , 5 , 6 , 7 , 0 , 1 , 2 , 3 , 4 ) T ( 6 ) = RSTT ( X , 6 , 7 , 0 , 1 , 2 , 3 , 4 , 5 ) T ( 7 ) = RSTT ( X , 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ) RP1 = R + 1 T ( 0 ) = PC64 ( T ( 0 ), ToInt32 ( Z '00000000' ), RP1 ) T ( 1 ) = PC64 ( T ( 1 ), ToInt32 ( Z '00000010' ), RP1 ) T ( 2 ) = PC64 ( T ( 2 ), ToInt32 ( Z '00000020' ), RP1 ) T ( 3 ) = PC64 ( T ( 3 ), ToInt32 ( Z '00000030' ), RP1 ) T ( 4 ) = PC64 ( T ( 4 ), ToInt32 ( Z '00000040' ), RP1 ) T ( 5 ) = PC64 ( T ( 5 ), ToInt32 ( Z '00000050' ), RP1 ) T ( 6 ) = PC64 ( T ( 6 ), ToInt32 ( Z '00000060' ), RP1 ) T ( 7 ) = PC64 ( T ( 7 ), ToInt32 ( Z '00000070' ), RP1 ) X ( 0 ) = RSTT ( T , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ) X ( 1 ) = RSTT ( T , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 0 ) X ( 2 ) = RSTT ( T , 2 , 3 , 4 , 5 , 6 , 7 , 0 , 1 ) X ( 3 ) = RSTT ( T , 3 , 4 , 5 , 6 , 7 , 0 , 1 , 2 ) X ( 4 ) = RSTT ( T , 4 , 5 , 6 , 7 , 0 , 1 , 2 , 3 ) X ( 5 ) = RSTT ( T , 5 , 6 , 7 , 0 , 1 , 2 , 3 , 4 ) X ( 6 ) = RSTT ( T , 6 , 7 , 0 , 1 , 2 , 3 , 4 , 5 ) X ( 7 ) = RSTT ( T , 7 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ) END DO RETURN END SUBROUTINE DoPermP !****************************************************************************** SUBROUTINE GroestlS_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE GroestlS_DoPadding !****************************************************************************** SUBROUTINE GroestlS_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlS ), INTENT ( INOUT ) :: MD !! 'GroestlS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: G ( 0 : 7 ) tIndex :: I , Ptr , DLen tLong :: Count tByte :: Z ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex Count = MD % GetBlockCount () IF ( Ptr <= 56_kIndex ) THEN TmpBuf ( Ptr : 55 ) = FByte00 Count = Count + 1_kInt64 ELSE TmpBuf ( Ptr : 63 ) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) TmpBuf ( 0 : 55 ) = FByte00 Count = Count + 2_kInt64 END IF CALL ByteUnpackBE ( Count , TmpBuf , 56_kIndex ) CALL MD % ProcessBlock ( TmpBuf ) G = MD % H CALL DoPermP ( G ) DO I = 0_kIndex , 3_kIndex CALL ByteUnpackBE ( IEOR ( MD % H ( I + 4_kIndex ), G ( I + 4_kIndex )), TmpBuf , I * 8_kIndex ) END DO DLen = MD % GetDigestLen () BytesOut ( Offset : Offset + DLen - 1 ) = TmpBuf ( 32 - DLen : 31 ) END ASSOCIATE RETURN END SUBROUTINE GroestlS_AddBitsNPad !****************************************************************************** END MODULE MClass_GroestlS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_groestls.f90.html"},{"title":"MClass_ByteConverter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ByteConverter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ByteConverter* type and its related routines.  The !   *ByteConverter* type performs a conversion of bit patterns between a byte !   array (an array of 8-bit integers) and an other integer type (i.e. a 16-bit, !   32-bit or 64-bit integer).  The *ByteConverter* type is intended to be used !   with a general-purpose (non-cryptographic) hash function. <br> !   It is important to note that the *ByteConverter* type MUST be initialized !   before being used.  Otherwise, unexpected behaviors or a crash may occur. !   The initialization provides a way to specify how the byte values are stored !   in a byte array.  The byte values can be stored in either the big-endian !   or the little-endian order.  If the optional flag is not specified during !   the initialization, it assumes that the byte values are stored according to !   machine-endian order. !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ByteConverter PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_ByteConverter' !** DERIVED TYPE DEFINITIONS !> The *ByteConverter* type is a converter type that performs a conversion !  of bit patterns between a byte (an array of 8-bit integers) array and !  an other integer type (i.e. a 16-bit, 32-bit or 64-bit integer). TYPE :: ByteConverter !> **Function Pointer**: Pack_I16 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 16-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I16(ByteArr, Offset) PROCEDURE ( PackShort ), POINTER , NOPASS :: Pack_I16 => NULL () !> **Function Pointer**: Pack_I32 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 32-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I32(ByteArr, Offset) PROCEDURE ( PackInt ), POINTER , NOPASS :: Pack_I32 => NULL () !> **Function Pointer**: Pack_I64 <br> ! **Purpose**:  To convert a byte array (starting at the specified offset) !               to a 64-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = Pack_I64(ByteArr, Offset) PROCEDURE ( PackLong ), POINTER , NOPASS :: Pack_I64 => NULL () !> **Subroutine Pointer**: Unpack_I16 <br> ! **Purpose**:  To convert a 16-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I16(IntVal, ByteArr, Offset) PROCEDURE ( UnpackShort ), POINTER , NOPASS :: Unpack_I16 => NULL () !> **Subroutine Pointer**: Unpack_I32 <br> ! **Purpose**:  To convert a 32-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I32(IntVal, ByteArr, Offset) PROCEDURE ( UnpackInt ), POINTER , NOPASS :: Unpack_I32 => NULL () !> **Subroutine Pointer**: Unpack_I64 <br> ! **Purpose**:  To convert a 64-bit integer to a byte array (starting at the !                specified offset). <br> !  **Usage**: <br> !   --->    CALL Unpack_I64(IntVal, ByteArr, Offset) PROCEDURE ( UnpackLong ), POINTER , NOPASS :: Unpack_I64 => NULL () CONTAINS !> **Type-Bound Subroutine**: Initialize <br> ! **Purpose**:  To initialize the *ByteConverter* object according to the !               optionally specified endianess flag. <br> !  **Usage**: <br> !   --->    CALL ByteConv%Initialize()          ! machine endian <br> !   --->    CALL ByteConv%Initialize(.TRUE.)    ! big endian <br> !   --->    CALL ByteConv%Initialize(.FALSE.)   ! little endian PROCEDURE :: Initialize => ByteConverter_Initialize !> **Type-Bound Subroutine**: Reset <br> ! **Purpose**:  To reset the *ByteConverter* object. <br> !  **Usage**: <br> !   --->    CALL ByteConv%Reset() PROCEDURE :: Reset => ByteConverter_Reset !> **Type-Bound Function**: Get_I8 <br> ! **Purpose**:  To get a single byte at the specified offset of the given byte !               array and return the result widened to default integer type. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Get_I8(ByteArr, Offset) PROCEDURE :: Get_I8 => Get_Byte !> **Type-Bound Function**: Get_U8 <br> ! **Purpose**:  To get a single byte at the specified offset of the given byte !               array and return the result widened to default integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Get_U8(ByteArr, Offset) PROCEDURE :: Get_U8 => Get_Unsigned_Byte !> **Type-Bound Function**: Pack_U16 <br> ! **Purpose**:  To get two bytes starting at the specified offset of the given byte !               array and return the result widened to default integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_U16(ByteArr, Offset) PROCEDURE :: Pack_U16 => Pack_Unsigned_Short !> **Type-Bound Function**: Pack_U32 <br> ! **Purpose**:  To get four bytes starting at the specified offset of the given byte !               array and return the result widened to 64-bit integer type with !               the signed of the requested byte removed. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_U32(ByteArr, Offset) PROCEDURE :: Pack_U32 => Pack_Unsigned_Integer !> **Type-Bound Function**: Pack_I32_Partial <br> ! **Purpose**:  To get three or fewer bytes of the given byte array starting at !               the specified offset and return the result as 32-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_I32_Partial(ByteArr, Offset, Length) <br> !  **Note**: Length must be between 1 and 3. PROCEDURE :: Pack_I32_Partial => Pack_Integer_Partial !> **Type-Bound Function**: Pack_I64_Partial <br> ! **Purpose**:  To get seven or fewer bytes of the given byte array starting at !               the specified offset and return the result as 64-bit integer. <br> !  **Usage**: <br> !   --->    IntVal = ByteConv%Pack_I64_Partial(ByteArr, Offset, Length) <br> !  **Note**: Length must be between 1 and 7. PROCEDURE :: Pack_I64_Partial => Pack_Long_Partial END TYPE ByteConverter !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !--------------------------------------------------------------------------- FUNCTION PackShort ( Buf , Off ) RESULT ( Res ) !&#94; To pack (convert) the array 'Buf' at offset 'Off' into the 16-bit word 'Res'. IMPORT tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Off !! starting index into the byte sequence tUInt16 :: Res !! result END FUNCTION PackShort !--------------------------------------------------------------------------- FUNCTION PackInt ( Buf , Off ) RESULT ( Res ) !&#94; To pack (convert) the array 'Buf' at offset 'Off' into the 32-bit word 'Res'. IMPORT tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Off !! starting index into the byte sequence tUInt32 :: Res !! result END FUNCTION PackInt !--------------------------------------------------------------------------- FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !&#94; To pack (convert) the array 'Buf' at offset 'Off' into the 64-bit word 'Res'. IMPORT tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Off !! starting index into the byte sequence tUInt64 :: Res !! result END FUNCTION PackLong !--------------------------------------------------------------------------- SUBROUTINE UnpackShort ( Val , Buf , Off ) !&#94; To unpack (convert) the 16-bit word 'Val' into the array 'Buf' at offset 'Off'. IMPORT tUInt16 , INTENT ( IN ) :: Val !! the value to convert tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset END SUBROUTINE UnpackShort !--------------------------------------------------------------------------- SUBROUTINE UnpackInt ( Val , Buf , Off ) !&#94; To unpack (convert) the 32-bit word 'Val' into the array 'Buf' at offset 'Off'. IMPORT tUInt32 , INTENT ( IN ) :: Val !! the value to convert tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset END SUBROUTINE UnpackInt !--------------------------------------------------------------------------- SUBROUTINE UnpackLong ( Val , Buf , Off ) !&#94; To unpack (convert) the 64-bit word 'Val' into the array 'Buf' at offset 'Off'. IMPORT tUInt64 , INTENT ( IN ) :: Val !! the value to convert tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset END SUBROUTINE UnpackLong !--------------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName tCharAlloc :: Message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                               + !                       INSTANTIATION PROCEDURES                                + !                                                                               + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE ByteConverter_Initialize ( BC , IsBigEndian ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the *ByteConverter* object according to the optionally !  specified endianess flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( INOUT ) :: BC !! byte converter tLogical , OPTIONAL , INTENT ( IN ) :: IsBigEndian !&#94; the endianess flag indicating whether the byte array is stored in big-endian !  order or not. <br> !  - True if the byte array is stored in big-endian order. <br> !  - False if the byte array is stored in little-endian order. <br> !  - If not present, the byte array is stored in machine-endian order. !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: tLogical :: IsBE !** FLOW SET_OPTION ( IsBE , . NOT . IsLittleEndian , IsBigEndian ) IF ( IsBE ) THEN BC % Pack_I16 => Pack_I16_BE BC % Pack_I32 => Pack_I32_BE BC % Pack_I64 => Pack_I64_BE BC % Unpack_I16 => Unpack_I16_BE BC % Unpack_I32 => Unpack_I32_BE BC % Unpack_I64 => Unpack_I64_BE ELSE BC % Pack_I16 => Pack_I16_LE BC % Pack_I32 => Pack_I32_LE BC % Pack_I64 => Pack_I64_LE BC % Unpack_I16 => Unpack_I16_LE BC % Unpack_I32 => Unpack_I32_LE BC % Unpack_I64 => Unpack_I64_LE END IF RETURN END SUBROUTINE ByteConverter_Initialize !****************************************************************************** SUBROUTINE ByteConverter_Reset ( BC ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the *ByteConverter* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( INOUT ) :: BC !! byte converter !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW BC % Pack_I16 => NULL () BC % Pack_I32 => NULL () BC % Pack_I64 => NULL () BC % Unpack_I16 => NULL () BC % Unpack_I32 => NULL () BC % Unpack_I64 => NULL () RETURN END SUBROUTINE ByteConverter_Reset !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                               + !                           COMMON PROCEDURES                                   + !                                                                               + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION Get_Byte ( BC , Buf , Offset ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a single byte at the given 'Offset' in the specified byte sequence 'Buf' !  and return the result widened to default integer type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Offset !! offset to the byte to read within the byte sequence tUInt32 :: OutVal !! the requested byte, widened to default integer type !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Get_Byte' , & 'Offset is not in the valid range.' ) OutVal = ToInt32 ( Buf ( Offset )) ASSOCIATE ( Dummy => BC ); END ASSOCIATE RETURN END FUNCTION Get_Byte !****************************************************************************** FUNCTION Get_Unsigned_Byte ( BC , Buf , Offset ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a single byte at the given 'Offset' in the specified byte sequence 'Buf' !  and return the result widened to default integer type with the signed of the !  requested byte removed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Offset !! offset to the byte to read within the byte sequence tUInt32 :: OutVal !! the requested byte, widened to default integer type !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Get_Unsigned_Byte' , & 'Offset is not in the valid range.' ) OutVal = IAND ( BC % Get_I8 ( Buf , Offset ), ToInt32 ( Z '000000FF' )) RETURN END FUNCTION Get_Unsigned_Byte !****************************************************************************** FUNCTION Pack_Unsigned_Short ( BC , Buf , Offset ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get two bytes at Offset and Offset+1 positions in the specified byte sequence !  'Buf' and return the result widened to default integer type with the signed of the !  requested result removed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Offset !! offset to the byte to read within the byte sequence tUInt32 :: OutVal !! the requested result, widened to default integer type !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Pack_Unsigned_Short' , & 'Offset is not in the valid range.' ) OutVal = IAND ( ToInt32 ( BC % Pack_I16 ( Buf , Offset )), ToInt32 ( Z '0000FFFF' )) RETURN END FUNCTION Pack_Unsigned_Short !****************************************************************************** FUNCTION Pack_Unsigned_Integer ( BC , Buf , Offset ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get four bytes starting at Offset positions in the specified byte sequence !  'Buf' and return the result widened to long integer type with the signed of the !  requested result removed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! byte sequence tIndex , INTENT ( IN ) :: Offset !! offset to the byte to read within the byte sequence tUInt64 :: OutVal !! the requested result, widened to long integer type !** SUBROUTINE LOCAL VARIABLE DECLARATIONS: ! na !** FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Pack_Unsigned_Integer' , & 'Offset is not in the valid range.' ) OutVal = IAND ( ToInt64 ( BC % Pack_I32 ( Buf , Offset )), ToInt64 ( Z '00000000FFFFFFFF' )) RETURN END FUNCTION Pack_Unsigned_Integer !****************************************************************************** FUNCTION Pack_Integer_Partial ( BC , Buf , Offset , Length ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack three or fewer bytes of the array 'Buf' starting at Offset positions !  in the specified byte sequence 'Buf' into the 32-bit word 'OutVal'. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Offset !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 3) tUInt32 :: OutVal !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 3 ) ! FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Pack_Integer_Partial' , & 'Offset is not in the valid range.' ) ASSERT_MSG ( IN_RANGE ( Length , 1 , 3 ), 'Pack_Integer_Partial' , & 'Length is not in the valid range.' ) ASSERT_MSG ( IN_RANGE ( Offset + Length , 1 , SIZE ( Buf )), 'Pack_Integer_Partial' , & 'Length is not in the valid range.' ) ! initialize Wrk = 0_kInt8 ! gather available bytes Wrk ( 0 : Length - 1 ) = Buf ( Offset : Offset + Length - 1 ) ! pack bytes into word OutVal = BC % Pack_I32 ( Wrk , 0_kIndex ) RETURN END FUNCTION Pack_Integer_Partial !****************************************************************************** FUNCTION Pack_Long_Partial ( BC , Buf , Offset , Length ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack seven or fewer bytes of the array 'Buf' starting at Offset positions !  in the specified byte sequence 'Buf' into the 64-bit word 'OutVal'. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ByteConverter ), INTENT ( IN ) :: BC !! byte converter tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Offset !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 7) tUInt64 :: OutVal !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 7 ) ! FLOW ASSERT_MSG ( IN_RANGE ( Offset , 0 , SIZE ( Buf ) - 1 ), 'Pack_Long_Partial' , & 'Offset is not in the valid range.' ) ASSERT_MSG ( IN_RANGE ( Length , 1 , 7 ), 'Pack_Long_Partial' , & 'Length is not in the valid range.' ) ASSERT_MSG ( IN_RANGE ( Offset + Length , 1 , SIZE ( Buf )), 'Pack_Long_Partial' , & 'Length is not in the valid range.' ) ! initialize Wrk = 0_kInt8 ! gather available bytes Wrk ( 0 : Length - 1 ) = Buf ( Offset : Offset + Length - 1 ) ! pack bytes into word OutVal = BC % Pack_I64 ( Wrk , 0_kIndex ) RETURN END FUNCTION Pack_Long_Partial !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                               + !                           BIG-ENDIAN PROCEDURES                               + !                                                                               + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #define MaskInt16(X)    IAND(ToInt16(X), ToInt16(Z'00FF')) #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') #define MaskInt64(X)     IAND(ToInt64(X), Z'00000000000000FF') PURE FUNCTION Pack_I16_BE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt16 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Res = IOR ( SHIFTL ( MaskInt16 ( Buf ( Off )), 8 ), MaskInt16 ( Buf ( Off + 1 ))) ! implementation algorithm #2 (comparable to #1) !    Res = SHIFTL(MaskInt16(Buf(Off)), 8) + MaskInt16(Buf(Off+1)) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    Res = ToInt16(UnsignedShort(Buf, Off)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    CALL MVBITS(MaskInt16(Buf(Off)), 0, 8, Res, 8) !    CALL MVBITS(MaskInt16(Buf(Off+1)), 0, 8, Res, 0) ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off+1), Buf(Off)], 0_kInt16) RETURN END FUNCTION Pack_I16_BE !****************************************************************************** PURE FUNCTION Pack_I32_BE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 32-bit word 'Res', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !        tIndex      :: I ! FLOW ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( SHIFTL ( MaskInt32 ( Buf ( Off )), 24 ), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 8 )), & MaskInt32 ( Buf ( Off + 3 ))) ! implementation algorithm #2 (comparable to #1) !    Res = SHIFTL(MaskInt32(Buf(Off)),   24) + & !          SHIFTL(MaskInt32(Buf(Off+1)), 16) + & !          SHIFTL(MaskInt32(Buf(Off+2)),  8) + & !                 MaskInt32(Buf(Off+3)) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) !    Res = IOR(UnsignedShort(Buf, Off+2), SHIFTL(UnsignedShort(Buf, Off), 16)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    DO I = 0, 3 !        CALL MVBITS(MaskInt32(Buf(Off+I)), 0, 8, Res, 24-I*8) !    END DO ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off+3), Buf(Off+2), Buf(Off+1), Buf(Off)], 0_kInt32) RETURN END FUNCTION Pack_I32_BE !****************************************************************************** PURE FUNCTION Pack_I64_BE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 64-bit word 'Res', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 (second fastest) !    Res = IOR(IOR(IOR(IOR(IOR(IOR(IOR(SHIFTL(MaskInt64(Buf(Off)),   56),   & !                                      SHIFTL(MaskInt64(Buf(Off+1)), 48)),  & !                                      SHIFTL(MaskInt64(Buf(Off+2)), 40)),  & !                                      SHIFTL(MaskInt64(Buf(Off+3)), 32)),  & !                                      SHIFTL(MaskInt64(Buf(Off+4)), 24)),  & !                                      SHIFTL(MaskInt64(Buf(Off+5)), 16)),  & !                                      SHIFTL(MaskInt64(Buf(Off+6)),  8)),  & !                                             MaskInt64(Buf(Off+7))) ! implementation algorithm #2 (comparable to #1) !    Res = SHIFTL(MaskInt64(Buf(Off)),   56) + & !          SHIFTL(MaskInt64(Buf(Off+1)), 48) + & !          SHIFTL(MaskInt64(Buf(Off+2)), 40) + & !          SHIFTL(MaskInt64(Buf(Off+3)), 32) + & !          SHIFTL(MaskInt64(Buf(Off+4)), 24) + & !          SHIFTL(MaskInt64(Buf(Off+5)), 16) + & !          SHIFTL(MaskInt64(Buf(Off+6)),  8) + & !                 MaskInt64(Buf(Off+7)) ! implementation algorithm #3 (fastest) #define Byte2Integer(Val, Off)      ToInt32(Val(Off)) #define UnsignedByte(Val, Off)      IAND(Byte2Integer(Val, Off), Z'000000FF') #define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off+1), SHIFTL(UnsignedByte(Val, Off), 8)) #define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off+2), SHIFTL(UnsignedShort(Val, Off), 16)) #define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), Z'00000000FFFFFFFF') Res = IOR ( UnsignedInteger ( Buf , Off + 4 ), SHIFTL ( UnsignedInteger ( Buf , Off ), 32 )) #undef Byte2Integer #undef UnsignedByte #undef UnsignedShort #undef SignedInteger #undef UnsignedInteger ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    DO I = 0, 7 !        CALL MVBITS(MaskInt64(Buf(Off+I)), 0, 8, Res, 56-I*8) !    END DO ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off+7), Buf(Off+6), Buf(Off+5), Buf(Off+4), & !                   Buf(Off+3), Buf(Off+2), Buf(Off+1), Buf(Off)], 0_kInt64) RETURN END FUNCTION Pack_I64_BE !****************************************************************************** SUBROUTINE Unpack_I16_BE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 16-bit word 'Val' into the array 'Buf' at offset 'Off', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt16 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tUInt8      :: Tmp ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( SHIFTR ( Val , 8 )) Buf ( Off + 1 ) = ToInt8 ( Val ) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val, 8, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val, 0, 8)) ! implementation algorithm #3 (slowest) !    Buf = TRANSFER(Val, Buf) !    IF (IsLittleEndian) THEN !        ! swap !        Tmp = Buf(Off) !        Buf(Off) = Buf(Off+1) !        Buf(Off+1) = Tmp !    END IF RETURN END SUBROUTINE Unpack_I16_BE !****************************************************************************** SUBROUTINE Unpack_I32_BE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 32-bit word 'Val' into the array 'Buf' at offset 'Off', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tUInt8      :: Tmp(0:3) ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( SHIFTR ( Val , 24 )) Buf ( Off + 1 ) = ToInt8 ( SHIFTR ( Val , 16 )) Buf ( Off + 2 ) = ToInt8 ( SHIFTR ( Val , 8 )) Buf ( Off + 3 ) = ToInt8 ( Val ) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val, 24, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val, 16, 8)) !    Buf(Off+2) = ToInt8(IBITS(Val,  8, 8)) !    Buf(Off+3) = ToInt8(IBITS(Val,  0, 8)) ! implementation algorithm #3 (slowest) !    Tmp = TRANSFER(Val, Tmp) !    IF (IsLittleEndian) THEN !        Buf(Off)   = Tmp(3) !        Buf(Off+1) = Tmp(2) !        Buf(Off+2) = Tmp(1) !        Buf(Off+3) = Tmp(0) !    ELSE !        Buf(Off:) = Tmp(0:) !    END IF RETURN END SUBROUTINE Unpack_I32_BE !****************************************************************************** SUBROUTINE Unpack_I64_BE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 64-bit word 'Val' into the array 'Buf' at offset 'Off', !  in big-endian convention (most significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tUInt8      :: Tmp(0:7) ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( SHIFTR ( Val , 56 )) Buf ( Off + 1 ) = ToInt8 ( SHIFTR ( Val , 48 )) Buf ( Off + 2 ) = ToInt8 ( SHIFTR ( Val , 40 )) Buf ( Off + 3 ) = ToInt8 ( SHIFTR ( Val , 32 )) Buf ( Off + 4 ) = ToInt8 ( SHIFTR ( Val , 24 )) Buf ( Off + 5 ) = ToInt8 ( SHIFTR ( Val , 16 )) Buf ( Off + 6 ) = ToInt8 ( SHIFTR ( Val , 8 )) Buf ( Off + 7 ) = ToInt8 ( Val ) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val, 56, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val, 48, 8)) !    Buf(Off+2) = ToInt8(IBITS(Val, 40, 8)) !    Buf(Off+3) = ToInt8(IBITS(Val, 32, 8)) !    Buf(Off+4) = ToInt8(IBITS(Val, 24, 8)) !    Buf(Off+5) = ToInt8(IBITS(Val, 16, 8)) !    Buf(Off+6) = ToInt8(IBITS(Val,  8, 8)) !    Buf(Off+7) = ToInt8(IBITS(Val,  0, 8)) ! implementation algorithm #3 (slowest) !    Tmp = TRANSFER(Val, Tmp) !    IF (IsLittleEndian) THEN !        Buf(Off)   = Tmp(7) !        Buf(Off+1) = Tmp(6) !        Buf(Off+2) = Tmp(5) !        Buf(Off+3) = Tmp(4) !        Buf(Off+4) = Tmp(3) !        Buf(Off+5) = Tmp(2) !        Buf(Off+6) = Tmp(1) !        Buf(Off+7) = Tmp(0) !    ELSE !        Buf(Off:) = Tmp(0:) !    END IF RETURN END SUBROUTINE Unpack_I64_BE !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                               + !                          LITTLE-ENDIAN PROCEDURES                             + !                                                                               + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION Pack_I16_LE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 16-bit word 'Res', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt16 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Res = IOR ( MaskInt16 ( Buf ( Off )), SHIFTL ( MaskInt16 ( Buf ( Off + 1 )), 8 )) ! implementation algorithm #2 (comparable to #1) !    Res = MaskInt16(Buf(Off)) + SHIFTL(MaskInt16(Buf(Off+1)), 8) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) !    Res = ToInt16(UnsignedShort(Buf, Off)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    CALL MVBITS(MaskInt16(Buf(Off)), 0, 8, Res, 0) !    CALL MVBITS(MaskInt16(Buf(Off+1)), 0, 8, Res, 8) ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off), Buf(Off+1)], 0_kInt16) RETURN END FUNCTION Pack_I16_LE !****************************************************************************** PURE FUNCTION Pack_I32_LE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 32-bit word 'Res', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) ! implementation algorithm #2 (comparable to #1) !    Res =        MaskInt32(Buf(Off))        + & !          SHIFTL(MaskInt32(Buf(Off+1)),  8) + & !          SHIFTL(MaskInt32(Buf(Off+2)), 16) + & !          SHIFTL(MaskInt32(Buf(Off+3)), 24) ! implementation algorithm #3 (comparable to #1) !#define Byte2Integer(Val, Off)  ToInt32(Val(Off)) !#define UnsignedByte(Val, Off)  IAND(Byte2Integer(Val, Off), Z'000000FF') !#define UnsignedShort(Val, Off) IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) !    Res = IOR(UnsignedShort(Buf, Off), SHIFTL(UnsignedShort(Buf, Off+2), 16)) !#undef Byte2Integer !#undef UnsignedByte !#undef UnsignedShort ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    DO I = 0, 3 !        CALL MVBITS(MaskInt32(Buf(Off+I)), 0, 8, Res, I*8) !    END DO ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off), Buf(Off+1), Buf(Off+2), Buf(Off+3)], 0_kInt32) RETURN END FUNCTION Pack_I32_LE !****************************************************************************** FUNCTION Pack_I64_LE ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pack the array 'Buf' at offset 'Off' into the 64-bit word 'Res', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: !    tIndex      :: I ! FLOW ! implementation algorithm #1 (second fastest) !    Res = IOR(IOR(IOR(IOR(IOR(IOR(IOR(       MaskInt64(Buf(Off)),          & !                                      SHIFTL(MaskInt64(Buf(Off+1)),  8)),  & !                                      SHIFTL(MaskInt64(Buf(Off+2)), 16)),  & !                                      SHIFTL(MaskInt64(Buf(Off+3)), 24)),  & !                                      SHIFTL(MaskInt64(Buf(Off+4)), 32)),  & !                                      SHIFTL(MaskInt64(Buf(Off+5)), 40)),  & !                                      SHIFTL(MaskInt64(Buf(Off+6)), 48)),  & !                                      SHIFTL(MaskInt64(Buf(Off+7)), 56)) ! implementation algorithm #2 (comparable to #1) !    Res =        MaskInt64(Buf(Off))        + & !          SHIFTL(MaskInt64(Buf(Off+1)),  8) + & !          SHIFTL(MaskInt64(Buf(Off+2)), 16) + & !          SHIFTL(MaskInt64(Buf(Off+3)), 24) + & !          SHIFTL(MaskInt64(Buf(Off+4)), 32) + & !          SHIFTL(MaskInt64(Buf(Off+5)), 40) + & !          SHIFTL(MaskInt64(Buf(Off+6)), 48) + & !          SHIFTL(MaskInt64(Buf(Off+7)), 56) ! implementation algorithm #3 (fastest) #define Byte2Integer(Val, Off)      ToInt32(Val(Off)) #define UnsignedByte(Val, Off)      IAND(Byte2Integer(Val, Off), Z'000000FF') #define UnsignedShort(Val, Off)     IOR(UnsignedByte(Val, Off), SHIFTL(UnsignedByte(Val, Off+1), 8)) #define SignedInteger(Val, Off)     IOR(UnsignedShort(Val, Off), SHIFTL(UnsignedShort(Val, Off+2), 16)) #define UnsignedInteger(Val, Off)   IAND(ToInt64(SignedInteger(Val, Off)), Z'00000000FFFFFFFF') Res = IOR ( UnsignedInteger ( Buf , Off ), SHIFTL ( UnsignedInteger ( Buf , Off + 4 ), 32 )) #undef Byte2Integer #undef UnsignedByte #undef UnsignedShort #undef SignedInteger #undef UnsignedInteger ! implementation algorithm #4 (second slowest) ! initialize because that argument of MVBITS is INTENT(INOUT) !    Res = 0 !    DO I = 0, 7 !        CALL MVBITS(MaskInt64(Buf(Off+I)), 0, 8, Res, I*8) !    END DO ! implementation algorithm #5 (slowest) !    Res = TRANSFER([Buf(Off), Buf(Off+1), Buf(Off+2), Buf(Off+3), & !                   Buf(Off+4), Buf(Off+5), Buf(Off+6), Buf(Off+7)], 0_kInt64) RETURN END FUNCTION Pack_I64_LE !****************************************************************************** SUBROUTINE Unpack_I16_LE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 16-bit word 'Val' into the array 'Buf' at offset 'Off', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt16 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( Val ) Buf ( Off + 1 ) = ToInt8 ( SHIFTR ( Val , 8 )) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val,  0, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val,  8, 8)) ! implementation algorithm #3 (slowest) !    Buf(Off:Off+1) = TRANSFER(Val, Buf) RETURN END SUBROUTINE Unpack_I16_LE !****************************************************************************** SUBROUTINE Unpack_I32_LE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 32-bit word 'Val' into the array 'Buf' at offset 'Off', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( Val ) Buf ( Off + 1 ) = ToInt8 ( SHIFTR ( Val , 8 )) Buf ( Off + 2 ) = ToInt8 ( SHIFTR ( Val , 16 )) Buf ( Off + 3 ) = ToInt8 ( SHIFTR ( Val , 24 )) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val,  0, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val,  8, 8)) !    Buf(Off+2) = ToInt8(IBITS(Val, 16, 8)) !    Buf(Off+3) = ToInt8(IBITS(Val, 24, 8)) ! implementation algorithm #3 (slowest) !    Buf(Off:Off+3) = TRANSFER(Val, Buf) RETURN END SUBROUTINE Unpack_I32_LE !****************************************************************************** SUBROUTINE Unpack_I64_LE ( Val , Buf , Off ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To unpack the 64-bit word 'Val' into the array 'Buf' at offset 'Off', !  in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: Val !! the value to encode tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) !! the destination buffer tIndex , INTENT ( IN ) :: Off !! the destination offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! implementation algorithm #1 Buf ( Off ) = ToInt8 ( Val ) Buf ( Off + 1 ) = ToInt8 ( SHIFTR ( Val , 8 )) Buf ( Off + 2 ) = ToInt8 ( SHIFTR ( Val , 16 )) Buf ( Off + 3 ) = ToInt8 ( SHIFTR ( Val , 24 )) Buf ( Off + 4 ) = ToInt8 ( SHIFTR ( Val , 32 )) Buf ( Off + 5 ) = ToInt8 ( SHIFTR ( Val , 40 )) Buf ( Off + 6 ) = ToInt8 ( SHIFTR ( Val , 48 )) Buf ( Off + 7 ) = ToInt8 ( SHIFTR ( Val , 56 )) ! implementation algorithm #2 (comparable to #1) !    Buf(Off)   = ToInt8(IBITS(Val,  0, 8)) !    Buf(Off+1) = ToInt8(IBITS(Val,  8, 8)) !    Buf(Off+2) = ToInt8(IBITS(Val, 16, 8)) !    Buf(Off+3) = ToInt8(IBITS(Val, 24, 8)) !    Buf(Off+4) = ToInt8(IBITS(Val, 32, 8)) !    Buf(Off+5) = ToInt8(IBITS(Val, 40, 8)) !    Buf(Off+6) = ToInt8(IBITS(Val, 48, 8)) !    Buf(Off+7) = ToInt8(IBITS(Val, 56, 8)) ! implementation algorithm #3 (slowest) !    Buf(Off:Off+7) = TRANSFER(Val, Buf) RETURN END SUBROUTINE Unpack_I64_LE !****************************************************************************** #undef MaskInt16 #undef MaskInt32 #undef MaskInt64 END MODULE MClass_ByteConverter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_byteconverter.f90.html"},{"title":"MClass_KomiHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_KomiHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *KomiHasher64* type and its related routines. !   The *KomiHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *KomiHasher64* type employs the *Komi* hash algorithm for 64-bit integer !   output by Aleksey Vaneev [1].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/avaneev/komihash\">KOMIHASH - Very fast, high-quality !       hash function, discrete-incremental and streamed hashing-capable (non-cryptographic, !       in C) + PRNG.</a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: KomiHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskI32(X)              IAND(ToInt64(X), Z'00000000FFFFFFFF') #define KOMIHASH_HASHROUND() \\ CALL KH_M128 ( Seed1 , Seed5 , R2L , R2H ); \\ Seed5 = Seed5 + R2H ; \\ Seed1 = IEOR ( Seed5 , R2L ); #define KOMIHASH_HASHFINAL() \\ CALL KH_M128 ( R2L , R2H , R1L , R1H ); \\ Seed5 = Seed5 + R1H ; \\ Seed1 = IEOR ( Seed5 , R1L ); \\ KOMIHASH_HASHROUND (); !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *KomiHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *Komi* hash algorithm by Aleksey Vaneev. TYPE , EXTENDS ( Hasher64 ) :: KomiHasher64 PRIVATE !% state tUInt64 :: State ( 8 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Komi_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Komi_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Komi_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Komi_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Komi_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Komi_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Komi_HashDirect END TYPE KomiHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Komi_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Komi_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Komi_GetName !****************************************************************************** FUNCTION Komi_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Komi_BlockLength !****************************************************************************** SUBROUTINE Komi_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Komi_SetBufPtr !****************************************************************************** SUBROUTINE Komi_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: R1L , R1H , R2L , R2H tUInt64 :: R3L , R3H , R4L , R4H tUInt8 :: I64Bytes ( 0 : 63 ) tUInt64 :: I64Val ( 1 : 8 ) EQUIVALENCE ( I64Bytes , I64Val ) !** FLOW ASSOCIATE ( Seed1 => HS % State ( 1 ), Seed2 => HS % State ( 2 ), & Seed3 => HS % State ( 3 ), Seed4 => HS % State ( 4 ), & Seed5 => HS % State ( 5 ), Seed6 => HS % State ( 6 ), & Seed7 => HS % State ( 7 ), Seed8 => HS % State ( 8 )) IF ( HS % GetBlockCount () == 0_kIndex ) THEN Seed2 = IEOR ( Z '13198A2E03707344' , Seed1 ) Seed3 = IEOR ( Z 'A4093822299F31D0' , Seed1 ) Seed4 = IEOR ( Z '082EFA98EC4E6C89' , Seed1 ) Seed6 = IEOR ( Z 'BE5466CF34E90C6C' , Seed5 ) Seed7 = IEOR ( Z 'C0AC29B7C97C50DD' , Seed5 ) Seed8 = IEOR ( Z '3F84D5B5B5470917' , Seed5 ) END IF ! convert data stored in BufArr to I64Val via EQUIVALENCE statement and assignment I64Bytes = BytesIn CALL KH_M128 ( IEOR ( Seed1 , I64Val ( 1 )), IEOR ( Seed5 , I64Val ( 2 )), R1L , R1H ) CALL KH_M128 ( IEOR ( Seed2 , I64Val ( 3 )), IEOR ( Seed6 , I64Val ( 4 )), R2L , R2H ) CALL KH_M128 ( IEOR ( Seed3 , I64Val ( 5 )), IEOR ( Seed7 , I64Val ( 6 )), R3L , R3H ) CALL KH_M128 ( IEOR ( Seed4 , I64Val ( 7 )), IEOR ( Seed8 , I64Val ( 8 )), R4L , R4H ) ! Such \"shifting\" arrangement (below) does not increase ! individual SeedN's PRNG period beyond 2&#94;64, but reduces a ! chance of any occasional synchronization between PRNG lanes ! happening. Practically, Seed1-4 together become a single ! \"fused\" 256-bit PRNG value, having a summary PRNG period of ! 2&#94;66. Seed5 = Seed5 + R1H Seed6 = Seed6 + R2H Seed7 = Seed7 + R3H Seed8 = Seed8 + R4H Seed2 = IEOR ( Seed5 , R2L ) Seed3 = IEOR ( Seed6 , R3L ) Seed4 = IEOR ( Seed7 , R4L ) Seed1 = IEOR ( Seed8 , R1L ) END ASSOCIATE RETURN END SUBROUTINE Komi_ProcessBlock !****************************************************************************** SUBROUTINE Komi_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: R2L , R2H !** FLOW ASSOCIATE ( Seed1 => HS % State ( 1 ), Seed5 => HS % State ( 5 )) ! The seeds are initialized to the first mantissa bits of PI. Seed1 = IEOR ( Z '243F6A8885A308D3' , IAND ( Seed , Z '5555555555555555' )) Seed5 = IEOR ( Z '452821E638D01377' , IAND ( Seed , Z 'AAAAAAAAAAAAAAAA' )) ! The three instructions in the \"KOMIHASH_HASHROUND\" macro represent the ! simplest constant-less PRNG, scalable to any even-sized state ! variables, with the `Seed1` being the PRNG output (2&#94;64 PRNG period). ! It passes `PractRand` tests with rare non-systematic \"unusual\" ! evaluations. ! ! To make this PRNG reliable, self-starting, and eliminate a risk of ! stopping, the following variant can be used, which is a \"register ! checker-board\", a source of raw entropy. The PRNG is available as the ! komirand() function. Not required for hashing (but works for it) since ! the input entropy is usually available in abundance during hashing. ! ! Seed5 += R2H + 0xAAAAAAAAAAAAAAAA ! ! (the `0xAAAA...` constant should match register's size essentially, ! it is a replication of the `10` bit-pair it is not an arbitrary ! constant). KOMIHASH_HASHROUND () ! Required for PerlinNoise. END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Komi_Initialize !****************************************************************************** FUNCTION Komi_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: R1L , R1H , R2L , R2H tUInt64 :: FByte , Inp64 tIndex :: Length , BLShift , Remaining , Offset ! variables used to quickly access input and secret bytes tUInt8 :: I64Bytes ( 0 : 63 ) tUInt64 :: I64Val ( 1 : 8 ) EQUIVALENCE ( I64Bytes , I64Val ) tUInt8 :: I32Bytes ( 0 : 7 ) tUInt32 :: I32Val ( 2 ) EQUIVALENCE ( I32Bytes , I32Val ) !** FLOW Length = HS % GetBufLen () FByte = SHIFTL ( 1 , SHIFTR ( HS % BufArr ( Length - 1 ), 7 )) IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Length END IF ASSOCIATE ( Seed1 => HS % State ( 1 ), Seed5 => HS % State ( 5 ), Input => HS % BufArr ) IF ( Length < 16 ) THEN R2L = Seed1 R2H = Seed5 IF ( Length > 7 ) THEN ! The following two XOR instructions are equivalent to mixing a ! message with a cryptographic one-time-pad (bitwise modulo 2 ! addition). Message's statistics and distribution are thus ! unimportant. BLShift = SHIFTL ( Length - 8 , 3 ) IF ( Length < 12 ) THEN I64Bytes ( 0 : 2 ) = Input ( Length - 3 : Length - 1 ) I64Bytes ( 3 : 7 ) = 0_kInt8 Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( I64Val ( 1 ), ( 24 - BLShift ))) ELSE I32Bytes ( 0 : 3 ) = Input ( 8 : 11 ) I32Bytes ( 4 : 7 ) = Input ( Length - 4 : Length - 1 ) Inp64 = IOR ( IOR ( SHIFTL ( FByte , BLShift ), MaskI32 ( I32Val ( 1 ))), & SHIFTL ( SHIFTR ( MaskI32 ( I32Val ( 2 )), ( 64 - BLShift )), 32 )) END IF R2H = IEOR ( R2H , Inp64 ) I64Bytes ( 0 : 7 ) = Input ( 0 : 7 ) R2L = IEOR ( R2L , I64Val ( 1 )) ELSEIF ( Length /= 0 ) THEN BLShift = SHIFTL ( Length , 3 ) IF ( Length < 4 ) THEN I64Bytes ( 0 : Length - 1 ) = Input ( 0 : Length - 1 ) I64Bytes ( Length : 7 ) = 0_kInt8 Inp64 = IOR ( SHIFTL ( FByte , BLShift ), I64Val ( 1 )) ELSE I32Bytes ( 0 : 3 ) = Input ( 0 : 3 ) I32Bytes ( 4 : 7 ) = Input ( Length - 4 : Length - 1 ) Inp64 = IOR ( IOR ( SHIFTL ( FByte , BLShift ), MaskI32 ( I32Val ( 1 ))), & SHIFTL ( SHIFTR ( MaskI32 ( I32Val ( 2 )), ( 64 - BLShift )), 32 )) END IF R2L = IEOR ( R2L , Inp64 ) END IF KOMIHASH_HASHFINAL () HashCode = Seed1 ELSEIF ( Length < 32 ) THEN I64Bytes ( 0 : 15 ) = Input ( 0 : 15 ) CALL KH_M128 ( IEOR ( Seed1 , I64Val ( 1 )), IEOR ( Seed5 , I64Val ( 2 )), R1L , R1H ) Seed5 = Seed5 + R1H Seed1 = IEOR ( Seed5 , R1L ) IF ( Length > 23 ) THEN BLShift = SHIFTL ( Length - 24 , 3 ) IF ( Length < 29 ) THEN I32Bytes ( 0 : 3 ) = Input ( Length - 4 : Length - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( MaskI32 ( I32Val ( 1 )), ( 32 - BLShift ))) ELSE I64Bytes ( 0 : 7 ) = Input ( Length - 8 : Length - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( I64Val ( 1 ), ( 64 - BLShift ))) END IF R2H = IEOR ( Seed5 , Inp64 ) I64Bytes ( 0 : 7 ) = Input ( 16 : 23 ) R2L = IEOR ( Seed1 , I64Val ( 1 )) ELSE BLShift = SHIFTL ( Length - 16 , 3 ) IF ( Length < 21 ) THEN I32Bytes ( 0 : 3 ) = Input ( Length - 4 : Length - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( MaskI32 ( I32Val ( 1 )), ( 32 - BLShift ))) ELSE I64Bytes ( 0 : 7 ) = Input ( Length - 8 : Length - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( I64Val ( 1 ), ( 64 - BLShift ))) END IF R2L = IEOR ( Seed1 , Inp64 ) R2H = Seed5 END IF KOMIHASH_HASHFINAL () HashCode = Seed1 ELSE IF ( Length >= 64 ) THEN ASSOCIATE ( Seed2 => HS % State ( 2 ), Seed3 => HS % State ( 3 ), Seed4 => HS % State ( 4 ), & Seed6 => HS % State ( 6 ), Seed7 => HS % State ( 7 ), Seed8 => HS % State ( 8 )) Seed5 = IEOR ( Seed5 , IEOR ( IEOR ( Seed6 , Seed7 ), Seed8 )) Seed1 = IEOR ( Seed1 , IEOR ( IEOR ( Seed2 , Seed3 ), Seed4 )) END ASSOCIATE END IF Remaining = HS % GetBufLen () Offset = 0_kIndex IF ( Remaining > 31 ) THEN I64Bytes ( 0 : 15 ) = Input ( Offset : Offset + 15 ) CALL KH_M128 ( IEOR ( Seed1 , I64Val ( 1 )), IEOR ( Seed5 , I64Val ( 2 )), R1L , R1H ) Seed5 = Seed5 + R1H Seed1 = IEOR ( Seed5 , R1L ) I64Bytes ( 16 : 31 ) = Input ( Offset + 16 : Offset + 31 ) CALL KH_M128 ( IEOR ( Seed1 , I64Val ( 3 )), IEOR ( Seed5 , I64Val ( 4 )), R1L , R1H ) Seed5 = Seed5 + R1H Seed1 = IEOR ( Seed5 , R1L ) ! update indices Offset = Offset + 32 Remaining = Remaining - 32 END IF IF ( Remaining > 15 ) THEN I64Bytes ( 0 : 15 ) = Input ( Offset : Offset + 15 ) CALL KH_M128 ( IEOR ( Seed1 , I64Val ( 1 )), IEOR ( Seed5 , I64Val ( 2 )), R1L , R1H ) Seed5 = Seed5 + R1H Seed1 = IEOR ( Seed5 , R1L ) ! update indices Offset = Offset + 16 Remaining = Remaining - 16 END IF IF ( Remaining > 7 ) THEN BLShift = SHIFTL ( Remaining - 8 , 3 ) IF ( Remaining < 13 ) THEN I32Bytes ( 0 : 3 ) = Input ( Offset + Remaining - 4 : Offset + Remaining - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( MaskI32 ( I32Val ( 1 )), ( 32 - BLShift ))) ELSE I64Bytes ( 0 : 7 ) = Input ( Offset + Remaining - 8 : Offset + Remaining - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( I64Val ( 1 ), ( 64 - BLShift ))) END IF R2H = IEOR ( Seed5 , Inp64 ) I64Bytes ( 0 : 7 ) = Input ( Offset : Offset + 7 ) R2L = IEOR ( Seed1 , I64Val ( 1 )) ELSE BLShift = SHIFTL ( Remaining , 3 ) IF ( Remaining < 5 ) THEN I32Bytes ( 0 : 3 ) = Input ( Offset + Remaining - 4 : Offset + Remaining - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( MaskI32 ( I32Val ( 1 )), ( 32 - BLShift ))) ELSE I64Bytes ( 0 : 7 ) = Input ( Offset + Remaining - 8 : Offset + Remaining - 1 ) Inp64 = IOR ( SHIFTL ( FByte , BLShift ), SHIFTR ( I64Val ( 1 ), ( 64 - BLShift ))) END IF R2L = IEOR ( Seed1 , Inp64 ) R2H = Seed5 END IF KOMIHASH_HASHFINAL () HashCode = Seed1 END IF END ASSOCIATE ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Komi_Finalize !****************************************************************************** FUNCTION Komi_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KomiHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Komi_HashDirect !****************************************************************************** SUBROUTINE KH_M128 ( LHS , RHS , ResLo , ResHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute 128-bit result of multiplication of two 64-bit unsigned integers. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 , INTENT ( OUT ) :: ResLo tUInt64 , INTENT ( OUT ) :: ResHi !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = MaskI32 ( LHS ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = MaskI32 ( RHS ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + MaskI32 ( Hi_Lo ) + LHS_Lo * RHS_Hi ResLo = IOR ( SHIFTL ( Cross , 32 ), MaskI32 ( Lo_Lo )) ResHi = SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi RETURN END SUBROUTINE KH_M128 !****************************************************************************** END MODULE MClass_KomiHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_komihasher64.f90.html"},{"title":"MClass_BaseHasher.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BaseHasher !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BaseHasher* type and its related routines. !   The *BaseHasher* type is an abstract type representing a base type for !   a *hasher* object, which is an incremental non-cryptographic hash function. !   By design, it defines a somewhat *incomplete* application programming !   interface (API) for some operations of an incremental hash function. !   The <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> !   type, which is an abstract type representing a 32-bit-integer hasher, !   defines additional methods and completes the API of an incremental !   32-bit-integer hash function. !   Also, the <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> !   type, which is an abstract type representing a 64-bit-integer hasher, !   defines additional methods and completes the API of an incremental !   64-bit-integer hash function. !   All other (concrete) hasher types that implement specific hash functions !   extend from either the *Hasher32* type or the *Hasher64* type. !** USE STATEMENTS: USE MBase_Common USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseHasher PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *BaseHasher* is an abstract type representing a base hasher that !  defines an *incomplete* application programming interface (API) !  for an incremental non-cryptographic hash function. TYPE , ABSTRACT :: BaseHasher PRIVATE !% the number of blocks of input processed tIndex :: BlockCount = 0_kIndex !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *GetName* is a binding name of the *HSName* deferred procedure. <br> !  **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE ( HSName ), DEFERRED :: GetName !> *GetBlockLength* is a binding name of the *HSBlockLen* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSBlockLen ), DEFERRED :: GetBlockLength !> *SetBufPtr* is a binding name of the *HSSetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSSetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *HSProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( HSProcess ), DEFERRED :: ProcessBlock ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *Reset* is a procedure to reset components of the hasher to their initial values. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: Reset => HS_Reset !> *GetBlockCount* is a procedure to get the number of blocks of input processed. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockCount => HS_BlockCount !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => HS_BufLen !> **Type-Bound Subroutine**: Update <br> !  **Purpose**:  To insert input data into the hasher (i.e. temporarily stored in the !                buffer array) and process block(s) of data if necessary. <br> !  **Usage**: <br> !   --->    CALL Hasher%Update(Input, InpSize) <br> !  **Important Note**: The specified input can be any type and any rank where !               its size is the number of bytes of storage used by the input. PROCEDURE :: Update => HS_Update END TYPE BaseHasher !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> HSName is a deferred procedure to return the name of the hasher. <br> FUNCTION HSName ( HS ) RESULT ( Name ) IMPORT CLASS ( BaseHasher ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function END FUNCTION !> HSBlockLen is a deferred procedure to return the *block length* !  for the hash function. <br> FUNCTION HSBlockLen ( HS ) RESULT ( Length ) IMPORT CLASS ( BaseHasher ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length END FUNCTION !> HSSetPtr is a deferred procedure to set the pointer *BufPtr* to !  the actual buffer array with starting index of zero. <br> SUBROUTINE HSSetPtr ( HS , BufPtr ) IMPORT CLASS ( BaseHasher ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer END SUBROUTINE !> HSProcess is a deferred procedure to process one block of data. <br> SUBROUTINE HSProcess ( HS , BytesIn ) IMPORT CLASS ( BaseHasher ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE HS_Reset ( HS ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseHasher ), INTENT ( INOUT ) :: HS !! a hasher (HS) object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % BufLen = 0_kIndex HS % BlockCount = 0_kIndex RETURN END SUBROUTINE HS_Reset !****************************************************************************** FUNCTION HS_BlockCount ( HS ) RESULT ( BlockCount ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of blocks of input processed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseHasher ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: BlockCount !! number of blocks !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BlockCount = HS % BlockCount RETURN END FUNCTION HS_BlockCount !****************************************************************************** FUNCTION HS_BufLen ( HS ) RESULT ( BufLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of bytes of input currently stored in the buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseHasher ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: BufLen !! number of bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufLen = HS % BufLen RETURN END FUNCTION HS_BufLen !****************************************************************************** SUBROUTINE HS_Update ( HS , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data into the hasher (i.e. temporary stored in the buffer array) !  and process block(s) of data if necessary. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseHasher ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , POINTER :: InpPtr (:) tUInt8 , POINTER :: BufPtr (:) tIndex :: CurrLen , CopyLen , Offset !** FLOW ! set pointers CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) CALL HS % SetBufPtr ( BufPtr ) ! copy input data to the buffer array and process block if necessary CurrLen = InpSize Offset = 1_kIndex DO WHILE ( CurrLen > 0_kIndex ) CopyLen = HS % GetBlockLength () - HS % BufLen IF ( CopyLen > CurrLen ) CopyLen = CurrLen ! Important note: BufPtr has the starting index of zero whereas !                 InpPtr has the starting index of one. BufPtr ( HS % BufLen : HS % BufLen + CopyLen - 1_kIndex ) = InpPtr ( Offset : Offset + CopyLen - 1_kIndex ) Offset = Offset + CopyLen HS % BufLen = HS % BufLen + CopyLen CurrLen = CurrLen - CopyLen IF ( HS % BufLen == HS % GetBlockLength ()) THEN CALL HS % ProcessBlock ( BufPtr ) HS % BlockCount = HS % BlockCount + 1_kIndex HS % BufLen = 0_kIndex END IF END DO ! free pointer NULLIFY ( InpPtr ) NULLIFY ( BufPtr ) RETURN END SUBROUTINE HS_Update !****************************************************************************** END MODULE MClass_BaseHasher !******************************************************************************","tags":"","loc":"sourcefile\\mclass_basehasher.f90.html"},{"title":"MClass_BmwS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BmwS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BmwS* type and its related routines. !   The *BmwS* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *BmwS* type implements an incremental cryptographic hash function !   by employing a *Blue Midnight Wish (BMW) message-digest* algorithm !   (either the *BMW-224* or the *BMW-256*) [1].  The implementation here !   is based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *BmwS* type employs the *BMW-256 message-digest* !   algorithm.  However, a user can specify the *IsBMW224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *BMW-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"http://people.item.ntnu.no/~danilog/Hash/BMW-SecondRound/\"> !       The Blue Midnight Wish cryptographic hash function package submitted !       to the second round of the NIST's SHA-3 hash competition. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: BmwS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: IV224 ( 0 : 15 ) = [ & ToInt32 ( Z '00010203' ), ToInt32 ( Z '04050607' ), & ToInt32 ( Z '08090A0B' ), ToInt32 ( Z '0C0D0E0F' ), & ToInt32 ( Z '10111213' ), ToInt32 ( Z '14151617' ), & ToInt32 ( Z '18191A1B' ), ToInt32 ( Z '1C1D1E1F' ), & ToInt32 ( Z '20212223' ), ToInt32 ( Z '24252627' ), & ToInt32 ( Z '28292A2B' ), ToInt32 ( Z '2C2D2E2F' ), & ToInt32 ( Z '30313233' ), ToInt32 ( Z '34353637' ), & ToInt32 ( Z '38393A3B' ), ToInt32 ( Z '3C3D3E3F' )] tInteger , PARAMETER :: IV256 ( 0 : 15 ) = [ & ToInt32 ( Z '40414243' ), ToInt32 ( Z '44454647' ), & ToInt32 ( Z '48494A4B' ), ToInt32 ( Z '4C4D4E4F' ), & ToInt32 ( Z '50515253' ), ToInt32 ( Z '54555657' ), & ToInt32 ( Z '58595A5B' ), ToInt32 ( Z '5C5D5E5F' ), & ToInt32 ( Z '60616263' ), ToInt32 ( Z '64656667' ), & ToInt32 ( Z '68696A6B' ), ToInt32 ( Z '6C6D6E6F' ), & ToInt32 ( Z '70717273' ), ToInt32 ( Z '74757677' ), & ToInt32 ( Z '78797A7B' ), ToInt32 ( Z '7C7D7E7F' )] tInteger , PARAMETER :: FINAL_PARAM ( 0 : 15 ) = [ & ToInt32 ( Z 'AAAAAAA0' ), ToInt32 ( Z 'AAAAAAA1' ), & ToInt32 ( Z 'AAAAAAA2' ), ToInt32 ( Z 'AAAAAAA3' ), & ToInt32 ( Z 'AAAAAAA4' ), ToInt32 ( Z 'AAAAAAA5' ), & ToInt32 ( Z 'AAAAAAA6' ), ToInt32 ( Z 'AAAAAAA7' ), & ToInt32 ( Z 'AAAAAAA8' ), ToInt32 ( Z 'AAAAAAA9' ), & ToInt32 ( Z 'AAAAAAAA' ), ToInt32 ( Z 'AAAAAAAB' ), & ToInt32 ( Z 'AAAAAAAC' ), ToInt32 ( Z 'AAAAAAAD' ), & ToInt32 ( Z 'AAAAAAAE' ), ToInt32 ( Z 'AAAAAAAF' )] !** DERIVED TYPE DEFINITIONS !> *BmwS* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *BMW-224* or the *BMW-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: BmwS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: H ( 0 : 15 ) = IV256 ( 0 : 15 ) !% flag indicating whether the BMW-224 algorithm is employed or not. tLogical :: IsBMW224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => BmwS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BMW-256). PROCEDURE :: Initialize => BmwS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => BmwS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => BmwS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => BmwS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => BmwS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => BmwS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => BmwS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => BmwS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => BmwS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => BmwS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BMW-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BMW-224 algorithm <br> !   --->    CALL MD%Create(IsBMW224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE BmwS !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE BmwS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the BMW-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE BmwS_Initialize !****************************************************************************** SUBROUTINE BmwS_Initialize_wFlag ( MD , IsBMW224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object tLogical , INTENT ( IN ) :: IsBMW224 !&#94; flag indicating whether the BMW-224 algorithm is employed or not. <br> !  - If true, use the BMW-224 algorithm. <br> !  - Otherwise, use the BMW-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsBMW224 = IsBMW224 CALL MD % Reset () RETURN END SUBROUTINE BmwS_Initialize_wFlag !****************************************************************************** SUBROUTINE BmwS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsBMW224 ) THEN MD % H = IV224 ELSE MD % H = IV256 END IF CALL MD % EngineReset () RETURN END SUBROUTINE BmwS_Reset !****************************************************************************** SUBROUTINE BmwS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( BmwS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( BmwS ) CALL Dst % Create ( Src % IsBMW224 ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE BmwS_GetClone !****************************************************************************** FUNCTION BmwS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( IN ) :: MD !! 'BmwS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBMW224 ) THEN Name = 'BMW-224' ELSE Name = 'BMW-256' END IF RETURN END FUNCTION BmwS_GetName !****************************************************************************** FUNCTION BmwS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( IN ) :: MD !! 'BmwS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBMW224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION BmwS_GetDigestLen !****************************************************************************** FUNCTION BmwS_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( IN ) :: MD !! 'BmwS' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION BmwS_GetBlockLen !****************************************************************************** SUBROUTINE BmwS_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), TARGET , INTENT ( INOUT ) :: MD !! 'BmwS' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE BmwS_SetBufPtr !****************************************************************************** SUBROUTINE BmwS_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 15 ) ! FLOW ! input block CALL BytePackLE ( BytesIn , 0_kIndex , M ) ! perform 16 rounds of mixing CALL Compress ( MD % H , M ) RETURN END SUBROUTINE BmwS_ProcessBlock !****************************************************************************** SUBROUTINE BmwS_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE BmwS_DoPadding !****************************************************************************** SUBROUTINE BmwS_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwS ), INTENT ( INOUT ) :: MD !! 'BmwS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: H2 ( 0 : 15 ) tIndex :: Ptr , I , J , DLen tLong :: BitLen tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () BitLen = SHIFTL ( ToInt64 ( MD % GetBlockCount ()), 9 ) + SHIFTL ( ToInt64 ( Ptr ), 3 ) Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex IF ( Ptr > 56_kIndex ) THEN TmpBuf ( Ptr : 63 ) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) Ptr = 0_kIndex END IF TmpBuf ( Ptr : 55 ) = FByte00 CALL ByteUnpackLE ( ToInt32 ( BitLen ) + NBits , TmpBuf , 56_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTR ( BitLen , 32 )), TmpBuf , 60_kIndex ) CALL MD % ProcessBlock ( TmpBuf ) END ASSOCIATE ! finalizing H2 = MD % H MD % H = FINAL_PARAM CALL Compress ( MD % H , H2 ) DLen = SHIFTR ( MD % GetDigestLen (), 2 ) J = 16_kIndex - DLen DO I = 0_kIndex , DLen - 1_kIndex CALL ByteUnpackLE ( MD % H ( J ), BytesOut , Offset + I * 4_kIndex ) J = J + 1_kIndex END DO RETURN END SUBROUTINE BmwS_AddBitsNPad !****************************************************************************** SUBROUTINE Compress ( H , M ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the compression of the given message. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 : 15 ) tInteger , INTENT ( IN ) :: M ( 0 : 15 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Q ( 0 : 31 ) tInteger :: Xl , Xh !** SUBROUTINE MACRO DEFINITIONS: #define SS0(x)      IEOR(IEOR(IEOR(SHIFTR(x, 1), SHIFTL(x, 3)), RotateLeft(x,  4)), RotateLeft(x, 19)) #define SS1(x)      IEOR(IEOR(IEOR(SHIFTR(x, 1), SHIFTL(x, 2)), RotateLeft(x,  8)), RotateLeft(x, 23)) #define SS2(x)      IEOR(IEOR(IEOR(SHIFTR(x, 2), SHIFTL(x, 1)), RotateLeft(x,  12)), RotateLeft(x, 25)) #define SS3(x)      IEOR(IEOR(IEOR(SHIFTR(x, 2), SHIFTL(x, 2)), RotateLeft(x,  15)), RotateLeft(x, 29)) #define SS4(x)      IEOR(SHIFTR(x, 1), x) #define SS5(x)      IEOR(SHIFTR(x, 2), x) #define RS1(x)      RotateLeft(x,  3) #define RS2(x)      RotateLeft(x,  7) #define RS3(x)      RotateLeft(x, 13) #define RS4(x)      RotateLeft(x, 16) #define RS5(x)      RotateLeft(x, 19) #define RS6(x)      RotateLeft(x, 23) #define RS7(x)      RotateLeft(x, 27) #define KS(j)       (j * ToInt32(Z'05555555')) #define Add_Elt_S(mf, hf, j0m, j1m, j3m, j4m, j7m, j10m, j11m, j16) \\ IEOR (( RotateLeft ( mf ( j0m ), j1m ) + RotateLeft ( mf ( j3m ), j4m ) - \\ RotateLeft ( mf ( j10m ), j11m ) + KS ( j16 )), hf ( j7m )) #define Expand1S_Inner(qf, mf, hf, i16, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i0m, i1m, i3m, i4m, i7m, i10m, i11m) \\ ( SS1 ( qf ( i0 )) + SS2 ( qf ( i1 )) + SS3 ( qf ( i2 )) + SS0 ( qf ( i3 )) \\ + SS1 ( qf ( i4 )) + SS2 ( qf ( i5 )) + SS3 ( qf ( i6 )) + SS0 ( qf ( i7 )) \\ + SS1 ( qf ( i8 )) + SS2 ( qf ( i9 )) + SS3 ( qf ( i10 )) + SS0 ( qf ( i11 )) \\ + SS1 ( qf ( i12 )) + SS2 ( qf ( i13 )) + SS3 ( qf ( i14 )) + SS0 ( qf ( i15 )) \\ + Add_Elt_S ( mf , hf , i0m , i1m , i3m , i4m , i7m , i10m , i11m , i16 )) #define Expand1S16(qf, mf, hf, i16)     Expand1S_Inner(qf, mf, hf, i16, 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 0,  1,  3,  4,  7, 10, 11) #define Expand1S17(qf, mf, hf, i16)     Expand1S_Inner(qf, mf, hf, i16, 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 1,  2,  4,  5,  8, 11, 12) #define Expand2S_Inner(qf, mf, hf, i16, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i0m, i1m, i3m, i4m, i7m, i10m, i11m) \\ ( qf ( i0 ) + RS1 ( qf ( i1 )) + qf ( i2 ) + RS2 ( qf ( i3 )) \\ + qf ( i4 ) + RS3 ( qf ( i5 )) + qf ( i6 ) + RS4 ( qf ( i7 )) \\ + qf ( i8 ) + RS5 ( qf ( i9 )) + qf ( i10 ) + RS6 ( qf ( i11 )) \\ + qf ( i12 ) + RS7 ( qf ( i13 )) + SS4 ( qf ( i14 )) + SS5 ( qf ( i15 )) \\ + Add_Elt_S ( mf , hf , i0m , i1m , i3m , i4m , i7m , i10m , i11m , i16 )) #define Expand2S18(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 2,  3,  5,  6,  9, 12, 13) #define Expand2S19(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 3,  4,  6,  7, 10, 13, 14) #define Expand2S20(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 4,  5,  7,  8, 11, 14, 15) #define Expand2S21(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 5,  6,  8,  9, 12, 15, 16) #define Expand2S22(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 6,  7,  9, 10, 13,  0,  1) #define Expand2S23(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 7,  8, 10, 11, 14,  1,  2) #define Expand2S24(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 8,  9, 11, 12, 15,  2,  3) #define Expand2S25(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 9, 10, 12, 13,  0,  3,  4) #define Expand2S26(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 10, 11, 13, 14,  1,  4,  5) #define Expand2S27(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 11, 12, 14, 15,  2,  5,  6) #define Expand2S28(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 12, 13, 15, 16,  3,  6,  7) #define Expand2S29(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 13, 14,  0,  1,  4,  7,  8) #define Expand2S30(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 14, 15,  1,  2,  5,  8,  9) #define Expand2S31(qf, mf, hf, i16)     Expand2S_Inner(qf, mf, hf, i16, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 15, 16,  2,  3,  6,  9, 10) #define MAKE_W(i0, op01, i1, op12, i2, op23, i3, op34, i4) \\ ( IEOR ( M ( i0 ), H ( i0 )) op01 IEOR ( M ( i1 ), H ( i1 )) op12 IEOR ( M ( i2 ), H ( i2 )) op23 IEOR ( M ( i3 ), H ( i3 )) op34 IEOR ( M ( i4 ), H ( i4 ))) #define Ws0             MAKE_W( 5, -,  7, +, 10, +, 13, +, 14) #define Ws1             MAKE_W( 6, -,  8, +, 11, +, 14, -, 15) #define Ws2             MAKE_W( 0, +,  7, +,  9, -, 12, +, 15) #define Ws3             MAKE_W( 0, -,  1, +,  8, -, 10, +, 13) #define Ws4             MAKE_W( 1, +,  2, +,  9, -, 11, -, 14) #define Ws5             MAKE_W( 3, -,  2, +, 10, -, 12, +, 15) #define Ws6             MAKE_W( 4, -,  0, -,  3, -, 11, +, 13) #define Ws7             MAKE_W( 1, -,  4, -,  5, -, 12, -, 14) #define Ws8             MAKE_W( 2, -,  5, -,  6, +, 13, -, 15) #define Ws9             MAKE_W( 0, -,  3, +,  6, -,  7, +, 14) #define Ws10            MAKE_W( 8, -,  1, -,  4, -,  7, +, 15) #define Ws11            MAKE_W( 8, -,  0, -,  2, -,  5, +,  9) #define Ws12            MAKE_W( 1, +,  3, -,  6, -,  9, +, 10) #define Ws13            MAKE_W( 2, +,  4, +,  7, +, 10, +, 11) #define Ws14            MAKE_W( 3, -,  5, +,  8, -, 11, -, 12) #define Ws15            MAKE_W(12, -,  4, -,  6, -,  9, +, 13) #define IEOR3(A, B, C)  IEOR(IEOR(A, B), C) ! FLOW Q ( 0 ) = SS0 ( Ws0 ) + H ( 1 ) Q ( 1 ) = SS1 ( Ws1 ) + H ( 2 ) Q ( 2 ) = SS2 ( Ws2 ) + H ( 3 ) Q ( 3 ) = SS3 ( Ws3 ) + H ( 4 ) Q ( 4 ) = SS4 ( Ws4 ) + H ( 5 ) Q ( 5 ) = SS0 ( Ws5 ) + H ( 6 ) Q ( 6 ) = SS1 ( Ws6 ) + H ( 7 ) Q ( 7 ) = SS2 ( Ws7 ) + H ( 8 ) Q ( 8 ) = SS3 ( Ws8 ) + H ( 9 ) Q ( 9 ) = SS4 ( Ws9 ) + H ( 10 ) Q ( 10 ) = SS0 ( Ws10 ) + H ( 11 ) Q ( 11 ) = SS1 ( Ws11 ) + H ( 12 ) Q ( 12 ) = SS2 ( Ws12 ) + H ( 13 ) Q ( 13 ) = SS3 ( Ws13 ) + H ( 14 ) Q ( 14 ) = SS4 ( Ws14 ) + H ( 15 ) Q ( 15 ) = SS0 ( Ws15 ) + H ( 0 ) Q ( 16 ) = Expand1S16 ( Q , M , H , 16 ) Q ( 17 ) = Expand1S17 ( Q , M , H , 17 ) Q ( 18 ) = Expand2S18 ( Q , M , H , 18 ) Q ( 19 ) = Expand2S19 ( Q , M , H , 19 ) Q ( 20 ) = Expand2S20 ( Q , M , H , 20 ) Q ( 21 ) = Expand2S21 ( Q , M , H , 21 ) Q ( 22 ) = Expand2S22 ( Q , M , H , 22 ) Q ( 23 ) = Expand2S23 ( Q , M , H , 23 ) Q ( 24 ) = Expand2S24 ( Q , M , H , 24 ) Q ( 25 ) = Expand2S25 ( Q , M , H , 25 ) Q ( 26 ) = Expand2S26 ( Q , M , H , 26 ) Q ( 27 ) = Expand2S27 ( Q , M , H , 27 ) Q ( 28 ) = Expand2S28 ( Q , M , H , 28 ) Q ( 29 ) = Expand2S29 ( Q , M , H , 29 ) Q ( 30 ) = Expand2S30 ( Q , M , H , 30 ) Q ( 31 ) = Expand2S31 ( Q , M , H , 31 ) XL = IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( Q ( 16 ), Q ( 17 )), Q ( 18 )), Q ( 19 )), & Q ( 20 )), Q ( 21 )), Q ( 22 )), Q ( 23 )) XH = IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( XL , Q ( 24 )), Q ( 25 )), Q ( 26 )), Q ( 27 )), & Q ( 28 )), Q ( 29 )), Q ( 30 )), Q ( 31 )) H ( 0 ) = IEOR3 ( SHIFTL ( XH , 5 ), SHIFTR ( Q ( 16 ), 5 ), M ( 0 )) + IEOR3 ( XL , Q ( 24 ), Q ( 0 )) H ( 1 ) = IEOR3 ( SHIFTR ( XH , 7 ), SHIFTL ( Q ( 17 ), 8 ), M ( 1 )) + IEOR3 ( XL , Q ( 25 ), Q ( 1 )) H ( 2 ) = IEOR3 ( SHIFTR ( XH , 5 ), SHIFTL ( Q ( 18 ), 5 ), M ( 2 )) + IEOR3 ( XL , Q ( 26 ), Q ( 2 )) H ( 3 ) = IEOR3 ( SHIFTR ( XH , 1 ), SHIFTL ( Q ( 19 ), 5 ), M ( 3 )) + IEOR3 ( XL , Q ( 27 ), Q ( 3 )) H ( 4 ) = IEOR3 ( SHIFTR ( XH , 3 ), SHIFTL ( Q ( 20 ), 0 ), M ( 4 )) + IEOR3 ( XL , Q ( 28 ), Q ( 4 )) H ( 5 ) = IEOR3 ( SHIFTL ( XH , 6 ), SHIFTR ( Q ( 21 ), 6 ), M ( 5 )) + IEOR3 ( XL , Q ( 29 ), Q ( 5 )) H ( 6 ) = IEOR3 ( SHIFTR ( XH , 4 ), SHIFTL ( Q ( 22 ), 6 ), M ( 6 )) + IEOR3 ( XL , Q ( 30 ), Q ( 6 )) H ( 7 ) = IEOR3 ( SHIFTR ( XH , 11 ), SHIFTL ( Q ( 23 ), 2 ), M ( 7 )) + IEOR3 ( XL , Q ( 31 ), Q ( 7 )) H ( 8 ) = RotateLeft ( H ( 4 ), 9 ) + IEOR3 ( XH , Q ( 24 ), M ( 8 )) + IEOR3 ( SHIFTL ( XL , 8 ), Q ( 23 ), Q ( 8 )) H ( 9 ) = RotateLeft ( H ( 5 ), 10 ) + IEOR3 ( XH , Q ( 25 ), M ( 9 )) + IEOR3 ( SHIFTR ( XL , 6 ), Q ( 16 ), Q ( 9 )) H ( 10 ) = RotateLeft ( H ( 6 ), 11 ) + IEOR3 ( XH , Q ( 26 ), M ( 10 )) + IEOR3 ( SHIFTL ( XL , 6 ), Q ( 17 ), Q ( 10 )) H ( 11 ) = RotateLeft ( H ( 7 ), 12 ) + IEOR3 ( XH , Q ( 27 ), M ( 11 )) + IEOR3 ( SHIFTL ( XL , 4 ), Q ( 18 ), Q ( 11 )) H ( 12 ) = RotateLeft ( H ( 0 ), 13 ) + IEOR3 ( XH , Q ( 28 ), M ( 12 )) + IEOR3 ( SHIFTR ( XL , 3 ), Q ( 19 ), Q ( 12 )) H ( 13 ) = RotateLeft ( H ( 1 ), 14 ) + IEOR3 ( XH , Q ( 29 ), M ( 13 )) + IEOR3 ( SHIFTR ( XL , 4 ), Q ( 20 ), Q ( 13 )) H ( 14 ) = RotateLeft ( H ( 2 ), 15 ) + IEOR3 ( XH , Q ( 30 ), M ( 14 )) + IEOR3 ( SHIFTR ( XL , 7 ), Q ( 21 ), Q ( 14 )) H ( 15 ) = RotateLeft ( H ( 3 ), 16 ) + IEOR3 ( XH , Q ( 31 ), M ( 15 )) + IEOR3 ( SHIFTR ( XL , 2 ), Q ( 22 ), Q ( 15 )) RETURN END SUBROUTINE Compress !****************************************************************************** END MODULE MClass_BmwS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_bmws.f90.html"},{"title":"MClass_MDHelper.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MDHelper !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MDHelper* type and its related routines. !   The *MDHelper* type is an abstract *digest* type extending from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  It is a helper type that implements the padding common to !   MD4, MD5, and the SHA family.  The implementation works as long as !   the internal block length is a power of 2, which is the case for all !   these algorithms. <br> !   <br> !   **REFERENCES**: <br> !   [1] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_BytePack , ONLY : ByteUnpackBE , ByteUnpackLE USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MDHelper PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_MDHelper' tIndex , PARAMETER :: MaxLen = 16_kIndex !** DERIVED TYPE DEFINITIONS !> *MDHelper* is an abstract *digest* type acting as a helper by !  implementing the padding common to MD4, MD5, and the SHA family. TYPE , ABSTRACT , EXTENDS ( MDEngine ) :: MDHelper PRIVATE !% flag indicating whether the padding is in little-endian order or not tLogical :: LittleEndian = FalseVal !% the length encoding length, in bytes (must be at least 8 and less than MaxLen tIndex :: LenLen = 8_kIndex !% the first padding byte tUInt8 :: FByte = FByte80 CONTAINS ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *HelperInit* is a procedure to initialize components of the *MDHelper* type. <br> !  This procedure is NOT intended to be used by a user but the *Create* method !  implemented by a *concrete* digest type that extends from this type should !  call this method. PROCEDURE :: HelperInit => MDHelper_Init !> *HelperPadding* is a procedure to perform padding required by the hash functions. <br> !  This procedure is NOT intended to be used by a user but the *DoPadding* method !  implemented by a *concrete* digest type that extends from this type should !  call this method. PROCEDURE :: HelperPadding => MDHelper_DoPadding !> *HelperReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: HelperReset => MDHelper_Reset !> *HelperClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: HelperClone => MDHelper_Clone ! --------------------------------------------------------------------- END TYPE MDHelper !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE MDHelper_Init ( MDH , LittleEndian , LenLen , FByte ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the object with the specified first padding byte. !  The padding byte is normally Z'80'. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDHelper ), INTENT ( INOUT ) :: MDH !! 'MDHelper' object tLogical , INTENT ( IN ) :: LittleEndian !! true for little-endian padding tIndex , INTENT ( IN ) :: LenLen !! the length encoding length, in bytes (must be at least 8) tUInt8 , OPTIONAL , INTENT ( IN ) :: FByte !! the first padding byte !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MDH % LittleEndian = LittleEndian IF ( LenLen > MaxLen ) THEN CALL Handle_ErrLevel ( 'MDHelper_Init_wFByte' , ModName , ErrSevere , & 'The specified length must be less than or equal to 16.' ) RETURN END IF MDH % LenLen = LenLen IF ( PRESENT ( FByte )) THEN MDH % FByte = FByte ELSE MDH % FByte = FByte80 END IF RETURN END SUBROUTINE MDHelper_Init !****************************************************************************** SUBROUTINE MDHelper_DoPadding ( MDH ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the padding.  The padding data is input into the engine. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDHelper ), INTENT ( INOUT ) :: MDH !! 'MDHelper' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: CountBuf ( 0 : MDH % LenLen - 1 ) tIndex :: DataLen , BlockLen , LenLen , EndLen , I tUInt64 :: CurrLen ! FLOW !+++ initialize +++ DataLen = MDH % GetBufLen () BlockLen = MDH % GetBlockLen () CurrLen = MDH % GetBlockCount () * ToInt64 ( BlockLen ) CurrLen = ( CurrLen + ToInt64 ( DataLen )) * 8_kInt64 LenLen = MDH % LenLen CountBuf = 0_kInt8 !+++ unpack current length into a byte array +++ IF ( MDH % LittleEndian ) THEN CALL ByteUnpackLE ( CurrLen , CountBuf , LenLen - 8_kIndex ) ELSE CALL ByteUnpackBE ( CurrLen , CountBuf , LenLen - 8_kIndex ) END IF !+++ perform padding +++ EndLen = IAND (( DataLen + LenLen + BlockLen ), NOT ( BlockLen - 1_kIndex )) ! insert the first padding byte CALL MDH % Update ( MDH % Fbyte , 1_kIndex ) ! add zeros DO I = DataLen + 1 , ( EndLen - LenLen ) - 1 CALL MDH % Update ( FByte00 , 1_kIndex ) END DO ! add the current length CALL MDH % Update ( CountBuf , 0_kIndex , LenLen ) RETURN END SUBROUTINE MDHelper_DoPadding !****************************************************************************** SUBROUTINE MDHelper_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDHelper ), INTENT ( INOUT ) :: MD !! 'MDHelper' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW MD % LittleEndian = FalseVal MD % LenLen = 8_kIndex MD % FByte = FByte80 CALL MD % EngineReset () RETURN END SUBROUTINE MDHelper_Reset !****************************************************************************** SUBROUTINE MDHelper_Clone ( SrcMD , DstMD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy components of the source digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDHelper ), INTENT ( IN ) :: SrcMD !! source object CLASS ( MDHelper ), INTENT ( INOUT ) :: DstMD !! destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DstMD % LittleEndian = SrcMD % LittleEndian DstMD % LenLen = SrcMD % LenLen DstMD % FByte = SrcMD % FByte CALL SrcMD % EngineClone ( DstMD ) RETURN END SUBROUTINE MDHelper_Clone !****************************************************************************** END MODULE MClass_MDHelper !******************************************************************************","tags":"","loc":"sourcefile\\mclass_mdhelper.f90.html"},{"title":"MClass_WyHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_WyHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *WyHasher64* type and its related routines. !   The *WyHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *WyHasher64* type employs the *Wy* hash algorithm for 64-bit integer !   output by Wang Yi [1].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/wangyi-fudan/wyhash\">WYHASH and WYRAND - The FASTEST !       QUALITY hash function, random number generators (PRNG) and hash map. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: WyHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskI32(X)              IAND(ToInt64(X), ToInt64(Z'00000000FFFFFFFF')) #define MaskI8(X)               IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) #define Pack_U32(Buf,Index)     MaskI32(PackInteger(Buf, Index)) #define WyMix(A, B)             UnsignedLongMultiplyorFold(A, B) #define WyR3(Buf,Index,K)                                     \\ IOR ( IOR ( SHIFTL ( MaskI8 ( Buf ( Index )), 16 ), \\ SHIFTL ( MaskI8 ( Buf ( Index + SHIFTR ( K , 1 ))), 8 )), \\ MaskI8 ( Buf ( Index + K - 1 ))) #define WyR4(Buf,Index)         Pack_U32(Buf, Index) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: WyP0 = ToInt64 ( Z 'A0761D6478BD642F' ) tUInt64 , PARAMETER :: WyP1 = ToInt64 ( Z 'E7037ED1A0B428DB' ) tUInt64 , PARAMETER :: WyP2 = ToInt64 ( Z '8EBC6AF09C88C6E3' ) tUInt64 , PARAMETER :: WyP3 = ToInt64 ( Z '589965CC75374CC3' ) tIndex , PARAMETER :: BlockLen = 48_kIndex !** DERIVED TYPE DEFINITIONS !> *WyHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the final version 3 of the *Wy* hash algorithm by Wang Yi. TYPE , EXTENDS ( Hasher64 ) :: WyHasher64 PRIVATE !% state tUInt64 :: State ( 3 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Wy_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Wy_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Wy_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Wy_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Wy_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Wy_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Wy_HashDirect END TYPE WyHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Wy_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Wy_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Wy_GetName !****************************************************************************** FUNCTION Wy_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Wy_BlockLength !****************************************************************************** SUBROUTINE Wy_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Wy_SetBufPtr !****************************************************************************** SUBROUTINE Wy_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS1 , RHS1 !** FLOW ASSOCIATE ( Seed => HS % State ( 1 ), Seed1 => HS % State ( 2 ), Seed2 => HS % State ( 3 )) LHS1 = IEOR ( PackLong ( BytesIn , 0_kIndex ), WyP1 ) RHS1 = IEOR ( PackLong ( BytesIn , 8_kIndex ), Seed ) Seed = WyMix ( LHS1 , RHS1 ) LHS1 = IEOR ( PackLong ( BytesIn , 16_kIndex ), WyP2 ) RHS1 = IEOR ( PackLong ( BytesIn , 24_kIndex ), Seed1 ) Seed1 = WyMix ( LHS1 , RHS1 ) LHS1 = IEOR ( PackLong ( BytesIn , 32_kIndex ), WyP3 ) RHS1 = IEOR ( PackLong ( BytesIn , 40_kIndex ), Seed2 ) Seed2 = WyMix ( LHS1 , RHS1 ) END ASSOCIATE RETURN END SUBROUTINE Wy_ProcessBlock !****************************************************************************** SUBROUTINE Wy_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( Seed0 => HS % State ( 1 ), Seed1 => HS % State ( 2 ), Seed2 => HS % State ( 3 )) Seed0 = IEOR ( Seed , WyP0 ) Seed1 = Seed0 Seed2 = Seed0 END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Wy_Initialize !****************************************************************************** FUNCTION Wy_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: A , B tUInt64 :: LHS1 , RHS1 , LHS2 , RHS2 tIndex :: Length , Remaining , Offset , ShiftLen !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining HS % State ( 1 ) = IEOR ( HS % State ( 1 ), IEOR ( HS % State ( 2 ), HS % State ( 3 ))) ELSE Length = Remaining IF ( Length <= 16_kIndex ) THEN IF ( Length >= 4_kIndex ) THEN ShiftLen = SHIFTL ( SHIFTR ( Length , 3 ), 2 ) Offset = Length - 4 A = IOR ( SHIFTL ( WyR4 ( HS % BufArr , 0_kIndex ), 32 ), WyR4 ( HS % BufArr , ShiftLen )) B = IOR ( SHIFTL ( WyR4 ( HS % BufArr , Offset ), 32 ), WyR4 ( HS % BufArr , Offset - ShiftLen )) ELSEIF ( Length > 0_kIndex ) THEN A = WyR3 ( HS % BufArr , 0_kIndex , Length ) B = 0_kInt64 ELSE A = 0_kInt64 B = 0_kInt64 END IF Remaining = 0_kIndex END IF END IF ASSOCIATE ( Seed => HS % State ( 1 ), Input => HS % BufArr ) IF ( Remaining > 0_kIndex ) THEN Offset = 0_kIndex DO WHILE ( Remaining > 16_kIndex ) LHS1 = IEOR ( PackLong ( Input , Offset ), WyP1 ) RHS1 = IEOR ( PackLong ( Input , Offset + 8_kIndex ), Seed ) Seed = WyMix ( LHS1 , RHS1 ) Remaining = Remaining - 16_kIndex Offset = Offset + 16_kIndex END DO A = PackLong ( Input , Offset + Remaining - 16_kIndex ) B = PackLong ( Input , Offset + Remaining - 8_kIndex ) END IF LHS1 = IEOR ( A , WyP1 ) RHS1 = IEOR ( B , Seed ) LHS2 = IEOR ( WyP1 , ToInt64 ( Length )) RHS2 = WyMix ( LHS1 , RHS1 ) HashCode = WyMix ( LHS2 , RHS2 ) END ASSOCIATE ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Wy_Finalize !****************************************************************************** FUNCTION Wy_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( WyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Wy_HashDirect !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ PURE FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackLong !************************************************************************** PURE FUNCTION PackInteger ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 32-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #undef MaskInt32 RETURN END FUNCTION PackInteger !****************************************************************************** FUNCTION UnsignedLongMultiplyorFold ( LHS , RHS ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply or fold. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 :: Res !** SUBROUTINE PARAMETER DECLARATIONS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = IAND ( LHS , MaxU32 ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = IAND ( RHS , MaxU32 ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaxU32 ) + LHS_Lo * RHS_Hi Res = IEOR ( IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaxU32 )), & SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi ) RETURN END FUNCTION UnsignedLongMultiplyorFold !****************************************************************************** END MODULE MClass_WyHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_wyhasher64.f90.html"},{"title":"MClass_Hasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Hasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Hasher32* type and its related routines. !   The *Hasher32* type is an abstract type that extends from the !   <a href=\"../module/mclass_basehasher.html#type-basehasher\">BaseHasher</a> !   type.  It represents a 32-bit integer hasher where additional methods, !   specific for 32-bit integer hash functions, are defined to complete !   the API for an incremental non-cryptographic hash function.  All !   hashers that output a hash value as a 32-bit integer should extends !   from this abstract type. <br> !   <br> !  **USAGE**: <br> !   Although there are a number of methods provided, several of them are !   intended for internal use (by developers).  Only five methods are !   intentionally provided for users including: <br> !   - the *Initialize* method that initializes the hasher, <br> !   - the *Update* method that inputs data into the hasher, <br> !   - the *Finalize* method that returns the hash value, <br> !   - the *GetName* method that returns the hasher name, and <br> !   - the *HashDirect* method that compute the hash value directly. <br> !   The first three methods mentioned are provided for the incremental !   hash computations where the *Initialize* method is first called !   (once), the *Update* method is then called (many times), and the !   *Finalize* method is finally called (once). <br> !   If the *Update* method is to be called only one time, then the !   *HashDirect* method (for non-incremental hash computations) should !   be employed in place of those three methods. !** USE STATEMENTS: USE MBase_Common USE MClass_BaseHasher IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Hasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *Hasher32* is an abstract type representing a hasher that outputs the hash value !  as a 32-bit integer for an incremental non-cryptographic hash function. TYPE , ABSTRACT , EXTENDS ( BaseHasher ) :: Hasher32 CONTAINS !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE ( HS32Init ), DEFERRED :: Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE ( HS32Final ), DEFERRED :: Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE ( HS32Hash ), DEFERRED :: HashDirect END TYPE Hasher32 !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> HS32Init is a deferred procedure to initialize the hasher. <br> SUBROUTINE HS32Init ( HS , Seed , RemoveSign ) IMPORT CLASS ( Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. END SUBROUTINE !> HS32Final is a deferred procedure to finalize the current hash computation !  and return the hash value in a 32-bit integer.  The object is reset. <br> FUNCTION HS32Final ( HS ) RESULT ( HashCode ) IMPORT CLASS ( Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code END FUNCTION HS32Final !> HS32Hash is a deferred procedure to compute the hash value directly !  (non-incrementally). <br> FUNCTION HS32Hash ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) IMPORT CLASS ( Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** END MODULE MClass_Hasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hasher32.f90.html"},{"title":"MClass_Murmur3Hasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Murmur3Hasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Murmur3Hasher64* and *Murmur3Hasher128* types and their !   related routines.  The *Murmur3Hasher64* type is a hasher type that extends directly !   from the <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and outputs the !   hash value as a 64-bit integer.  The *Murmur3Hasher128* type is a hasher type that !   extends from the *Murmur3Hasher64* type and provides two additional methods (the !   *Finalize128* and *HashDirect128* methods) to output the hash value as a 128-bit !   integer. <br> !   Both hashers employ the *Murmur3* hash algorithm by Austin Appleby [1, 2].  As hashers, !   they can be used to compute the hash value incrementally.  They also provide a method !   to compute the hash value directly (i.e. non-incrementally).  The following code snippet !   shows a typical usage of the hashers. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the *HashDirect* !   method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !   To compute the hash value as a 128-bit integer, simply replace the *Finalize* and !   *HashDirect* methods by the *Finalize128* and *HashDirect128* methods, respectively. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/aappleby/smhasher\">SMHasher: a test suite designed to !       test the distribution, collision, and performance properties of non-cryptographic !       hash functions. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_SInt128 USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Murmur3Hasher64 PUBLIC :: Murmur3Hasher128 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define     tSInt128        TYPE(SInt128) #define     MaskI8(X)       IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) #define     K1_Mixing(K) \\ K = K * C1 ; \\ K = RotateLeft ( K , 31 ); \\ K = K * C2 ; #define     K2_Mixing(K) \\ K = K * C2 ; \\ K = RotateLeft ( K , 33 ); \\ K = K * C1 ; #define     FinalMixing(H) \\ H = IEOR ( H , SHIFTR ( H , 33 )); \\ H = H * ToInt64 ( Z 'FF51AFD7ED558CCD' ); \\ H = IEOR ( H , SHIFTR ( H , 33 )); \\ H = H * ToInt64 ( Z 'C4CEB9FE1A85EC53' ); \\ H = IEOR ( H , SHIFTR ( H , 33 )); !** MODULE PARAMETERS: tUInt64 , PARAMETER :: C1 = ToInt64 ( Z '87C37B91114253D5' ) tUInt64 , PARAMETER :: C2 = ToInt64 ( Z '4CF5AD432745937F' ) tIndex , PARAMETER :: BlockLen = 16_kIndex !** DERIVED TYPE DEFINITIONS !> *Murmur3Hasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *Murmur3* hash algorithm by Austin Appleby. TYPE , EXTENDS ( Hasher64 ) :: Murmur3Hasher64 PRIVATE !% state tUInt64 :: State ( 2 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% pointer to the buffer array as 64-bit integers tUInt64 , POINTER :: BufLong (:) => NULL () !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Murmur3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Murmur3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Murmur3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Murmur3_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Murmur3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Murmur3_HashDirect END TYPE Murmur3Hasher64 !> *Murmur3Hasher128* is a hasher type that outputs the hash value as a 128-bit integer. !  It is a subtype of the *Murmur3Hasher64* type. TYPE , EXTENDS ( Murmur3Hasher64 ) :: Murmur3Hasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName128 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => Murmur3_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => Murmur3_HashDirect128 END TYPE Murmur3Hasher128 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Murmur3_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Murmur3_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Murmur3_GetName !****************************************************************************** FUNCTION Murmur3_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Murmur3_BlockLength !****************************************************************************** SUBROUTINE Murmur3_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Murmur3_SetBufPtr !****************************************************************************** SUBROUTINE Murmur3_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: K1 , K2 !** FLOW ! Important Note: HS%BufLong is an alias of HS%BufArr, which is the same as !                 BytesIn so this routine does not use BytesIn directly but !                 through HS%BufLong instead. ASSOCIATE ( H1 => HS % State ( 1 ), H2 => HS % State ( 2 ), & LongVal => HS % BufLong , Dummy => BytesIn ) K1 = LongVal ( 1 ) K2 = LongVal ( 2 ) K1_Mixing ( K1 ) H1 = IEOR ( H1 , K1 ) H1 = RotateLeft ( H1 , 27 ) H1 = H1 + H2 H1 = H1 * 5_kInt64 + ToInt64 ( Z '0000000052DCE729' ) K2_Mixing ( K2 ) H2 = IEOR ( H2 , K2 ) H2 = RotateLeft ( H2 , 31 ) H2 = H2 + H1 H2 = H2 * 5_kInt64 + ToInt64 ( Z '0000000038495AB5' ) END ASSOCIATE RETURN END SUBROUTINE Murmur3_ProcessBlock !****************************************************************************** SUBROUTINE Murmur3_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( C_PTR ) :: CPtr ! C pointer to the input !** FLOW HS % State = Seed CPtr = C_LOC ( HS % BufArr ) CALL C_F_POINTER ( CPtr , HS % BufLong , SHAPE = [ BlockLen / 8 ]) SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () cPtr = C_NULL_PTR RETURN END SUBROUTINE Murmur3_Initialize !****************************************************************************** FUNCTION Murmur3_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF CALL Murmur3_Finalize64 ( HS , Length , Remaining ) HashCode = HS % State ( 1 ) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 NULLIFY ( HS % BufLong ) HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Murmur3_Finalize !****************************************************************************** FUNCTION Murmur3_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Murmur3_HashDirect !****************************************************************************** FUNCTION Murmur3_GetName128 ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher128 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Murmur3_Hahser128' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Murmur3_GetName128 !****************************************************************************** FUNCTION Murmur3_Finalize128 ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 128-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF CALL Murmur3_Finalize64 ( HS , Length , Remaining ) HashCode % Low = HS % State ( 1 ) HashCode % High = HS % State ( 1 ) + HS % State ( 2 ) ! remove sign if needed IF ( HS % RemoveSign ) HashCode % High = IAND ( HashCode % High , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 NULLIFY ( HS % BufLong ) HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Murmur3_Finalize128 !****************************************************************************** FUNCTION Murmur3_HashDirect128 ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize128 () RETURN END FUNCTION Murmur3_HashDirect128 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE Murmur3_Finalize64 ( HS , Length , Remaining ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tIndex , INTENT ( IN ) :: Length !! total length tIndex , INTENT ( IN ) :: Remaining !! remaining length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: K1 , K2 !** FLOW ASSOCIATE ( H1 => HS % State ( 1 ), H2 => HS % State ( 2 ), & LongVal => HS % BufLong , Input => HS % BufArr ) IF ( Remaining > 0_kIndex ) THEN K1 = 0_kInt64 K2 = 0_kInt64 SELECT CASE ( Remaining ) CASE ( 8 : 15 ) K1 = LongVal ( 1 ) K2 = PackPartial ( Input , 8_kIndex , Remaining - 8_kIndex ) CASE ( 1 : 7 ) K1 = PackPartial ( Input , 0_kIndex , Remaining ) END SELECT K1_Mixing ( K1 ) H1 = IEOR ( H1 , K1 ) K2_Mixing ( K2 ) H2 = IEOR ( H2 , K2 ) END IF ! Do a few final mixes of the hash to ensure the last few bytes are well-incorporated H1 = IEOR ( H1 , ToInt64 ( Length )) H2 = IEOR ( H2 , ToInt64 ( Length )) H1 = H1 + H2 H2 = H2 + H1 FinalMixing ( H1 ) FinalMixing ( H2 ) H1 = H1 + H2 END ASSOCIATE RETURN END SUBROUTINE Murmur3_Finalize64 !****************************************************************************** FUNCTION PackPartial ( Buf , Off , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack seven or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res', in little-endian convention ! (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tIndex , INTENT ( IN ) :: Length ! the number of bytes to pack (between 1 to 7) tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 7 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! pack bytes into word #define MaskInt64(X)     IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) Res = MaskInt64 ( Wrk ( 0 )) + SHIFTL ( MaskInt64 ( Wrk ( 1 )), 8 ) + & SHIFTL ( MaskInt64 ( Wrk ( 2 )), 16 ) + SHIFTL ( MaskInt64 ( Wrk ( 3 )), 24 ) + & SHIFTL ( MaskInt64 ( Wrk ( 4 )), 32 ) + SHIFTL ( MaskInt64 ( Wrk ( 5 )), 40 ) + & SHIFTL ( MaskInt64 ( Wrk ( 6 )), 48 ) + SHIFTL ( MaskInt64 ( Wrk ( 7 )), 56 ) #undef MaskInt64 RETURN END FUNCTION PackPartial !************************************************************************** END MODULE MClass_Murmur3Hasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_murmur3hasher64.f90.html"},{"title":"MClass_Shabal.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Shabal !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Shabal* type and its related routines. !   The *Shabal* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Shabal* type implements an incremental cryptographic hash !   function by employing the *Shabal message-digest* algorithm [1]. !   The implementation here is mainly based on the references [2]. <br> !   The *Shabal* type represents five cryptographic hash functions: !   the *Shabal-192*,  *Shabal-224*, *Shabal-256*, *Shabal-384*, and !   *Shabal-512* hash functions.  By default, the *Shabal* type !   represents the *Shabal-256* hash function.  However, a user can !   specify the *Security* argument (to one of the five applicable !   values: 192, 224, 256, 384 and 512) when initializing the digest !   object in order to use a different hash function and get a !   different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20170611041218mp_/http://www.shabal.com/\"> !       SHABAL: A submission to NIST's Cryptographic Hash Algorithm Competition. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Shabal PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/Shabal_Def Macro.f90\" !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen192 = 24_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex #include    \"Includes/Shabal_Constants.f90\" !** DERIVED TYPE DEFINITIONS !> *Shabal* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Shabal hash functions. TYPE , EXTENDS ( MDEngine ) :: Shabal PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% states and counters tInteger :: A ( 0 : 11 ) = AIV_256 ( 0 : 11 ) tInteger :: B ( 0 : 15 ) = BIV_256 ( 0 : 15 ) tInteger :: C ( 0 : 15 ) = CIV_256 ( 0 : 15 ) tInteger :: WLo = 1 tInteger :: WHi = 0 !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => Shabal_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Shabal-256). PROCEDURE :: Initialize => Shabal_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Shabal_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Shabal_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Shabal_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Shabal_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Shabal_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Shabal_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Shabal_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Shabal_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Shabal_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Shabal-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Shabal-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity ! --------------------------------------------------------------------- END TYPE Shabal !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Shabal_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Create ( 256 ) RETURN END SUBROUTINE Shabal_Initialize !****************************************************************************** SUBROUTINE Shabal_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), TARGET , INTENT ( INOUT ) :: MD !! 'Shabal' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with five possible values: 192, 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Security ) CASE ( 192 , 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT SELECT CASE ( MD % Security ) CASE ( 192 ) MD % DigestLen = DLen192 CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT CALL MD % Reset () RETURN END SUBROUTINE Shabal_Initialize_wSecurity !****************************************************************************** SUBROUTINE Shabal_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 SELECT CASE ( MD % Security ) CASE ( 192 ) MD % A = AIV_192 MD % B = BIV_192 MD % C = CIV_192 CASE ( 224 ) MD % A = AIV_224 MD % B = BIV_224 MD % C = CIV_224 CASE ( 256 ) MD % A = AIV_256 MD % B = BIV_256 MD % C = CIV_256 CASE ( 384 ) MD % A = AIV_384 MD % B = BIV_384 MD % C = CIV_384 CASE ( 512 ) MD % A = AIV_512 MD % B = BIV_512 MD % C = CIV_512 END SELECT MD % WLo = 1 MD % WHi = 0 CALL MD % EngineReset () RETURN END SUBROUTINE Shabal_Reset !****************************************************************************** SUBROUTINE Shabal_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Shabal :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Shabal ) CALL Dst % Create ( Src % Security ) Dst % A = Src % A Dst % B = Src % B Dst % C = Src % C Dst % WLo = Src % WLo Dst % WHi = Src % WHi Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE Shabal_GetClone !****************************************************************************** FUNCTION Shabal_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( IN ) :: MD !! 'Shabal' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'Shabal-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION Shabal_GetName !****************************************************************************** FUNCTION Shabal_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( IN ) :: MD !! 'Shabal' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Shabal_GetDigestLen !****************************************************************************** FUNCTION Shabal_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( IN ) :: MD !! 'Shabal' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION Shabal_GetBlockLen !****************************************************************************** SUBROUTINE Shabal_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), TARGET , INTENT ( INOUT ) :: MD !! 'Shabal' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Shabal_SetBufPtr !****************************************************************************** SUBROUTINE Shabal_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: MWords ( 0 : 15 ) tInteger :: Temp tIndex :: I ! FLOW CALL BytePackLE ( BytesIn , 0_kIndex , MWords ) INPUT_BLOCK_ADD ( MD % B , MWords ) XOR_W ( MD % A , MD % WLo , MD % WHi ) CALL ApplyPermutation ( MD , MWords ) INPUT_BLOCK_SUB ( MD % C , MWords ) SWAP_BC ( MD % B , MD % C ) INCR_W ( MD % WLo , MD % WHi ) RETURN END SUBROUTINE Shabal_ProcessBlock !****************************************************************************** SUBROUTINE ApplyPermutation ( MD , MWords ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform permutation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object tInteger , INTENT ( IN ) :: MWords ( 0 :) !! message block in words !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW STATE_ROTL ( MD % B ) PERM_STEP_0 ( MD % A , MD % B , MD % C , MWords ) PERM_STEP_1 ( MD % A , MD % B , MD % C , MWords ) PERM_STEP_2 ( MD % A , MD % B , MD % C , MWords ) STATE_ADD ( MD % A , MD % C ) RETURN END SUBROUTINE ApplyPermutation !****************************************************************************** SUBROUTINE Shabal_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE Shabal_DoPadding !****************************************************************************** SUBROUTINE Shabal_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Shabal ), INTENT ( INOUT ) :: MD !! 'Shabal' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: MWords ( 0 : 15 ) tInteger :: Temp , BStart , OutWordSize tIndex :: Ptr , I , J , CurrOff tByte :: Z ! FLOW Ptr = MD % GetBufLen () Z = SHIFTR ( FByte80 , NBits ) MD % BufArr ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) MD % BufArr ( Ptr + 1 : 63 ) = FByte00 CALL BytePackLE ( MD % BufArr , 0_kIndex , MWords ) INPUT_BLOCK_ADD ( MD % B , MWords ) XOR_W ( MD % A , MD % WLo , MD % WHi ) CALL ApplyPermutation ( MD , MWords ) DO J = 0 , 2 SWAP_BC ( MD % B , MD % C ) XOR_W ( MD % A , MD % WLo , MD % WHi ) CALL ApplyPermutation ( MD , MWords ) END DO OutWordSize = SHIFTR ( MD % Security , 5 ) BStart = 16_kIndex - OutWordSize CurrOff = Offset DO I = BStart , 15_kIndex CALL ByteUnpackLE ( MD % B ( I ), BytesOut , CurrOff ) CurrOff = CurrOff + 4_kIndex END DO RETURN END SUBROUTINE Shabal_AddBitsNPad !****************************************************************************** #include    \"Includes/Shabal_Undef Macro.f90\" END MODULE MClass_Shabal !******************************************************************************","tags":"","loc":"sourcefile\\mclass_shabal.f90.html"},{"title":"MClass_ShaviteS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ShaviteS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ShaviteS* type and its related routines. !   The *ShaviteS* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *ShaviteS* type implements an incremental cryptographic hash function !   by employing a *SHAvite-3 message-digest* algorithm (either the *SHAvite-224* !   or the *SHAvite-256*) [1].  The implementation here is based mainly on the !   *SPHLIB* implementation [2].  <br> !   By default, the *ShaviteS* type employs the *SHAvite-256 message-digest* !   algorithm.  However, a user can specify the *IsSHAvite224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SHAvite-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20161220074845mp_/http://www.cs.technion.ac.il/~orrd/SHAvite-3/\"> !       The SHAvite-3 hash function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: ShaviteS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: IV224_BE ( 0 : 7 ) = [ & ToInt32 ( Z 'C4C67795' ), ToInt32 ( Z 'C0B1817F' ), & ToInt32 ( Z 'EAD88924' ), ToInt32 ( Z '1ABB1BB0' ), & ToInt32 ( Z 'E0C29152' ), ToInt32 ( Z 'BDE046BA' ), & ToInt32 ( Z 'AEEECF99' ), ToInt32 ( Z '58D509D8' )] tInteger , PARAMETER :: IV224_LE ( 0 : 7 ) = [ & ToInt32 ( Z '6774F31C' ), ToInt32 ( Z '990AE210' ), & ToInt32 ( Z 'C87D4274' ), ToInt32 ( Z 'C9546371' ), & ToInt32 ( Z '62B2AEA8' ), ToInt32 ( Z '4B5801D8' ), & ToInt32 ( Z '1B702860' ), ToInt32 ( Z '842F3017' )] tInteger , PARAMETER :: IV256_BE ( 0 : 7 ) = [ & ToInt32 ( Z '3EECF551' ), ToInt32 ( Z 'BF10819B' ), & ToInt32 ( Z 'E6DC8559' ), ToInt32 ( Z 'F3E23FD5' ), & ToInt32 ( Z '431AEC73' ), ToInt32 ( Z '79E3F731' ), & ToInt32 ( Z '98325F05' ), ToInt32 ( Z 'A92A31F1' )] tInteger , PARAMETER :: IV256_LE ( 0 : 7 ) = [ & ToInt32 ( Z '49BB3E47' ), ToInt32 ( Z '2674860D' ), & ToInt32 ( Z 'A8B392AC' ), ToInt32 ( Z '021AC4E6' ), & ToInt32 ( Z '409283CF' ), ToInt32 ( Z '620E5D86' ), & ToInt32 ( Z '6D929DCB' ), ToInt32 ( Z '96CC2A8B' )] !** DERIVED TYPE DEFINITIONS !> *ShaviteS* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *SHAvite-224* or the *SHAvite-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: ShaviteS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 7 ) = IV256_LE !% flag indicating whether the SHAvite-224 algorithm is employed or not. tLogical :: IsSHAvite224 = FalseVal !> flag indicating whether to use little-endian order for initial values !  and AES tables. tLogical :: LittleEndian = TrueVal !% pointer to a procedure that processes a block of data PROCEDURE ( ProcessData ), POINTER , NOPASS :: Process => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => ShaviteS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAvite-256). PROCEDURE :: Initialize => ShaviteS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => ShaviteS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => ShaviteS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => ShaviteS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => ShaviteS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => ShaviteS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => ShaviteS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => ShaviteS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => ShaviteS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => ShaviteS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHAvite-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHAvite-224 algorithm <br> !   --->    CALL MD%Create(IsSHAvite224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- FINAL :: ShaviteS_Finalize ! --------------------------------------------------------------------- END TYPE ShaviteS !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE ! To process input block SUBROUTINE ProcessData ( H , InpDat , Cnt0 , Cnt1 ) IMPORT tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block tInteger , INTENT ( IN ) :: Cnt0 , Cnt1 ! counter numbers END SUBROUTINE ProcessData END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE ShaviteS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHAvite-256 algorithm with little-endian order parameters CALL MD % Create ( FalseVal , FalseVal ) RETURN END SUBROUTINE ShaviteS_Initialize !****************************************************************************** SUBROUTINE ShaviteS_Initialize_wFlag ( MD , IsSHAvite224 , BigEndian ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object tLogical , INTENT ( IN ) :: IsSHAvite224 !&#94; flag indicating whether the SHAvite-224 algorithm is employed or not. <br> !  - If true, use the SHAvite-224 algorithm. <br> !  - Otherwise, use the SHAvite-256 algorithm. <br> tLogical , OPTIONAL , INTENT ( IN ) :: BigEndian !&#94; flag indicating whether to use the big-endian order for initial values and AES tables. <br> !  - If true, use the big-endian order. <br> !  - Otherwise, use little-endian order. <br> !  default value: false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSHAvite224 = IsSHAvite224 MD % LittleEndian = TrueVal IF ( PRESENT ( BigEndian )) MD % LittleEndian = . NOT . BigEndian CALL MD % Reset () RETURN END SUBROUTINE ShaviteS_Initialize_wFlag !****************************************************************************** SUBROUTINE ShaviteS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % LittleEndian ) THEN MD % Process => Process_LE IF ( MD % IsSHAvite224 ) THEN MD % H = IV224_LE ELSE MD % H = IV256_LE END IF ELSE MD % Process => Process_BE IF ( MD % IsSHAvite224 ) THEN MD % H = IV224_BE ELSE MD % H = IV256_BE END IF END IF CALL MD % EngineReset () RETURN END SUBROUTINE ShaviteS_Reset !****************************************************************************** SUBROUTINE ShaviteS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( ShaviteS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( ShaviteS ) CALL Dst % Create ( Src % IsSHAvite224 , . NOT . Src % LittleEndian ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE ShaviteS_GetClone !****************************************************************************** FUNCTION ShaviteS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( IN ) :: MD !! 'ShaviteS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHAvite224 ) THEN Name = 'SHAvite-224' ELSE Name = 'SHAvite-256' END IF RETURN END FUNCTION ShaviteS_GetName !****************************************************************************** FUNCTION ShaviteS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( IN ) :: MD !! 'ShaviteS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHAvite224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION ShaviteS_GetDigestLen !****************************************************************************** FUNCTION ShaviteS_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( IN ) :: MD !! 'ShaviteS' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION ShaviteS_GetBlockLen !****************************************************************************** SUBROUTINE ShaviteS_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), TARGET , INTENT ( INOUT ) :: MD !! 'ShaviteS' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE ShaviteS_SetBufPtr !****************************************************************************** SUBROUTINE ShaviteS_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: BitLen tInteger :: Cnt0 , Cnt1 ! FLOW BitLen = SHIFTL ( MD % GetBlockCount () + 1_kInt64 , 9 ) Cnt0 = ToInt32 ( BitLen ) Cnt1 = ToInt32 ( SHIFTR ( BitLen , 32 )) CALL MD % Process ( MD % H , BytesIn , Cnt0 , Cnt1 ) RETURN END SUBROUTINE ShaviteS_ProcessBlock !****************************************************************************** SUBROUTINE ShaviteS_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE ShaviteS_DoPadding !****************************************************************************** SUBROUTINE ShaviteS_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , DLen , I tLong :: BC , BitLen tInteger :: Cnt0 , Cnt1 tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () BC = MD % GetBlockCount () BitLen = SHIFTL ( BC , 9 ) + SHIFTL ( Ptr , 3 ) Cnt0 = ToInt32 ( BitLen ) + NBits Cnt1 = ToInt32 ( SHIFTR ( BitLen , 32 )) Z = SHIFTR ( FByte80 , NBits ) Z = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) IF (( Ptr == 0_kIndex ). AND .( NBits == 0_kInt8 )) THEN TmpBuf ( 0 ) = FByte80 TmpBuf ( 1 : 53 ) = FByte00 Cnt0 = 0 Cnt1 = 0 ELSEIF ( Ptr < 54_kIndex ) THEN TmpBuf ( Ptr ) = Z Ptr = Ptr + 1_kIndex TmpBuf ( Ptr : 53 ) = FByte00 ELSE TmpBuf ( Ptr ) = Z Ptr = Ptr + 1_kIndex TmpBuf ( Ptr : 63 ) = FByte00 CALL MD % Process ( MD % H , TmpBuf , Cnt0 , Cnt1 ) TmpBuf ( 0 : 53 ) = FByte00 Cnt0 = 0 Cnt1 = 0 END IF CALL ByteUnpackLE ( ToInt32 ( BitLen ) + NBits , TmpBuf , 54_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTR ( BitLen , 32 )), TmpBuf , 58_kIndex ) DLen = MD % GetDigestLen () TmpBuf ( 62 ) = ToInt8 ( SHIFTL ( DLen , 3 )) TmpBuf ( 63 ) = ToInt8 ( SHIFTR ( DLen , 5 )) CALL MD % Process ( MD % H , TmpBuf , Cnt0 , Cnt1 ) END ASSOCIATE ! finalizing I = 0_kIndex DO WHILE ( I < DLen ) CALL ByteUnpackLE ( MD % H ( SHIFTR ( I , 2 )), BytesOut , Offset + I ) I = I + 4_kIndex END DO RETURN END SUBROUTINE ShaviteS_AddBitsNPad !****************************************************************************** SUBROUTINE ShaviteS_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ShaviteS ), INTENT ( INOUT ) :: MD !! 'ShaviteS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % Process ) RETURN END SUBROUTINE ShaviteS_Finalize !****************************************************************************** SUBROUTINE Process_BE ( H , InpDat , Cnt0 , Cnt1 ) !** PURPOSE OF THIS SUBROUTINE: ! To process input block. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block tInteger , INTENT ( IN ) :: Cnt0 , Cnt1 ! count numbers !** SUBROUTINE MACRO DEFINITIONS AND PARAMETER DECLARATIONS: #include    \"Includes/AES_BigEndian.f90\" #define     AES_ROUND_NOKEY(X0, X1, X2, X3)     \\ T0 = X0 ; T1 = X1 ; T2 = X2 ; T3 = X3 ; \\ AES_ROUND_NOKEY_BE ( T0 , T1 , T2 , T3 , X0 , X1 , X2 , X3 ); !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: #include    \"Includes/AES_Constants.f90\" !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: T0 , T1 , T2 , T3 tInteger :: P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 tInteger :: X0 , X1 , X2 , X3 tIndex :: U , R , S tInteger :: RK ( 0 : 143 ) ! FLOW DO U = 0 , 15 , 4 CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ), RK ( U )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 4 , RK ( U + 1 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 8 , RK ( U + 2 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 12 , RK ( U + 3 )) END DO U = 16 DO R = 0 , 3 DO S = 0 , 1 X0 = RK ( U - 15 ) X1 = RK ( U - 14 ) X2 = RK ( U - 13 ) X3 = RK ( U - 16 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 16 ) THEN RK ( 16 ) = IEOR ( RK ( 16 ), Cnt0 ) RK ( 17 ) = IEOR ( RK ( 17 ), NOT ( Cnt1 )) ELSEIF ( U == 56 ) THEN RK ( 57 ) = IEOR ( RK ( 57 ), Cnt1 ) RK ( 58 ) = IEOR ( RK ( 58 ), NOT ( Cnt0 )) END IF U = U + 4 X0 = RK ( U - 15 ) X1 = RK ( U - 14 ) X2 = RK ( U - 13 ) X3 = RK ( U - 16 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 84 ) THEN RK ( 86 ) = IEOR ( RK ( 86 ), Cnt1 ) RK ( 87 ) = IEOR ( RK ( 87 ), NOT ( Cnt0 )) ELSEIF ( U == 124 ) THEN RK ( 124 ) = IEOR ( RK ( 124 ), Cnt0 ) RK ( 127 ) = IEOR ( RK ( 127 ), NOT ( Cnt1 )) END IF U = U + 4 END DO DO S = 0 , 3 RK ( U ) = IEOR ( RK ( U - 16 ), RK ( U - 3 )) RK ( U + 1 ) = IEOR ( RK ( U - 15 ), RK ( U - 2 )) RK ( U + 2 ) = IEOR ( RK ( U - 14 ), RK ( U - 1 )) RK ( U + 3 ) = IEOR ( RK ( U - 13 ), RK ( U )) U = U + 4 END DO END DO P0 = H ( 0 ) P1 = H ( 1 ) P2 = H ( 2 ) P3 = H ( 3 ) P4 = H ( 4 ) P5 = H ( 5 ) P6 = H ( 6 ) P7 = H ( 7 ) U = 0 DO R = 0 , 5 X0 = IEOR ( P4 , RK ( U )) X1 = IEOR ( P5 , RK ( U + 1 )) X2 = IEOR ( P6 , RK ( U + 2 )) X3 = IEOR ( P7 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) P0 = IEOR ( P0 , X0 ) P1 = IEOR ( P1 , X1 ) P2 = IEOR ( P2 , X2 ) P3 = IEOR ( P3 , X3 ) X0 = IEOR ( P0 , RK ( U )) X1 = IEOR ( P1 , RK ( U + 1 )) X2 = IEOR ( P2 , RK ( U + 2 )) X3 = IEOR ( P3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) P4 = IEOR ( P4 , X0 ) P5 = IEOR ( P5 , X1 ) P6 = IEOR ( P6 , X2 ) P7 = IEOR ( P7 , X3 ) END DO H ( 0 ) = IEOR ( H ( 0 ), P0 ) H ( 1 ) = IEOR ( H ( 1 ), P1 ) H ( 2 ) = IEOR ( H ( 2 ), P2 ) H ( 3 ) = IEOR ( H ( 3 ), P3 ) H ( 4 ) = IEOR ( H ( 4 ), P4 ) H ( 5 ) = IEOR ( H ( 5 ), P5 ) H ( 6 ) = IEOR ( H ( 6 ), P6 ) H ( 7 ) = IEOR ( H ( 7 ), P7 ) RETURN #include    \"Includes/AES_Undef Macro.f90\" #undef      AES_ROUND_NOKEY END SUBROUTINE Process_BE !****************************************************************************** SUBROUTINE Process_LE ( H , InpDat , Cnt0 , Cnt1 ) !** PURPOSE OF THIS SUBROUTINE: ! To process input block. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: H ( 0 :) ! state values tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block tInteger , INTENT ( IN ) :: Cnt0 , Cnt1 ! count numbers !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/AES_LittleEndian.f90\" #define     AES_ROUND_NOKEY(X0, X1, X2, X3)     \\ T0 = X0 ; T1 = X1 ; T2 = X2 ; T3 = X3 ; \\ AES_ROUND_NOKEY_LE ( T0 , T1 , T2 , T3 , X0 , X1 , X2 , X3 ); !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: #include    \"Includes/AES_Constants.f90\" !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: T0 , T1 , T2 , T3 tInteger :: P0 , P1 , P2 , P3 , P4 , P5 , P6 , P7 tInteger :: X0 , X1 , X2 , X3 tIndex :: U , R , S tInteger :: RK ( 0 : 143 ) ! FLOW DO U = 0 , 15 , 4 CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ), RK ( U )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 4 , RK ( U + 1 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 8 , RK ( U + 2 )) CALL BytePackLE ( InpDat , SHIFTL ( U , 2 ) + 12 , RK ( U + 3 )) END DO U = 16 DO R = 0 , 3 DO S = 0 , 1 X0 = RK ( U - 15 ) X1 = RK ( U - 14 ) X2 = RK ( U - 13 ) X3 = RK ( U - 16 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 16 ) THEN RK ( 16 ) = IEOR ( RK ( 16 ), Cnt0 ) RK ( 17 ) = IEOR ( RK ( 17 ), NOT ( Cnt1 )) ELSEIF ( U == 56 ) THEN RK ( 57 ) = IEOR ( RK ( 57 ), Cnt1 ) RK ( 58 ) = IEOR ( RK ( 58 ), NOT ( Cnt0 )) END IF U = U + 4 X0 = RK ( U - 15 ) X1 = RK ( U - 14 ) X2 = RK ( U - 13 ) X3 = RK ( U - 16 ) AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) RK ( U ) = IEOR ( X0 , RK ( U - 4 )) RK ( U + 1 ) = IEOR ( X1 , RK ( U - 3 )) RK ( U + 2 ) = IEOR ( X2 , RK ( U - 2 )) RK ( U + 3 ) = IEOR ( X3 , RK ( U - 1 )) IF ( U == 84 ) THEN RK ( 86 ) = IEOR ( RK ( 86 ), Cnt1 ) RK ( 87 ) = IEOR ( RK ( 87 ), NOT ( Cnt0 )) ELSEIF ( U == 124 ) THEN RK ( 124 ) = IEOR ( RK ( 124 ), Cnt0 ) RK ( 127 ) = IEOR ( RK ( 127 ), NOT ( Cnt1 )) END IF U = U + 4 END DO DO S = 0 , 3 RK ( U ) = IEOR ( RK ( U - 16 ), RK ( U - 3 )) RK ( U + 1 ) = IEOR ( RK ( U - 15 ), RK ( U - 2 )) RK ( U + 2 ) = IEOR ( RK ( U - 14 ), RK ( U - 1 )) RK ( U + 3 ) = IEOR ( RK ( U - 13 ), RK ( U )) U = U + 4 END DO END DO P0 = H ( 0 ) P1 = H ( 1 ) P2 = H ( 2 ) P3 = H ( 3 ) P4 = H ( 4 ) P5 = H ( 5 ) P6 = H ( 6 ) P7 = H ( 7 ) U = 0 DO R = 0 , 5 X0 = IEOR ( P4 , RK ( U )) X1 = IEOR ( P5 , RK ( U + 1 )) X2 = IEOR ( P6 , RK ( U + 2 )) X3 = IEOR ( P7 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) P0 = IEOR ( P0 , X0 ) P1 = IEOR ( P1 , X1 ) P2 = IEOR ( P2 , X2 ) P3 = IEOR ( P3 , X3 ) X0 = IEOR ( P0 , RK ( U )) X1 = IEOR ( P1 , RK ( U + 1 )) X2 = IEOR ( P2 , RK ( U + 2 )) X3 = IEOR ( P3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) X0 = IEOR ( X0 , RK ( U )) X1 = IEOR ( X1 , RK ( U + 1 )) X2 = IEOR ( X2 , RK ( U + 2 )) X3 = IEOR ( X3 , RK ( U + 3 )) U = U + 4 AES_ROUND_NOKEY ( X0 , X1 , X2 , X3 ) P4 = IEOR ( P4 , X0 ) P5 = IEOR ( P5 , X1 ) P6 = IEOR ( P6 , X2 ) P7 = IEOR ( P7 , X3 ) END DO H ( 0 ) = IEOR ( H ( 0 ), P0 ) H ( 1 ) = IEOR ( H ( 1 ), P1 ) H ( 2 ) = IEOR ( H ( 2 ), P2 ) H ( 3 ) = IEOR ( H ( 3 ), P3 ) H ( 4 ) = IEOR ( H ( 4 ), P4 ) H ( 5 ) = IEOR ( H ( 5 ), P5 ) H ( 6 ) = IEOR ( H ( 6 ), P6 ) H ( 7 ) = IEOR ( H ( 7 ), P7 ) RETURN #include    \"Includes/AES_Undef Macro.f90\" #undef      AES_ROUND_NOKEY END SUBROUTINE Process_LE !****************************************************************************** END MODULE MClass_ShaviteS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_shavites.f90.html"},{"title":"MClass_SHAKE.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHAKE !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHAKE* type and its related routines. !   The *SHAKE* type is a *Keccak-based digest* type that extends from !   the <a href=\"../module/mclass_kp1600core.html#type-kp1600core\"> !   KP1600Core</a> type.  As a *concrete* derived type, it provides !   all remaining deferred procedures required by all its parent types. <br> !   Unlike the <a href=\"../module/mclass_keccak.html#type-keccak\"> !   Keccak</a> type, which produces a fixed-length hash output for the !   specified strength of security, the *SHAKE* type allows an arbitrary !   output length, which is useful in applications such as optimal !   asymmetric encryption padding.  Similar to the *Keccak* type, the !   *SHAKE* type represents a family of incremental cryptographic hash !   functions (two functions, exactly), rather than just one hash function. <br> !   By default, the *SHAKE* type employs the *SHAKE-128* hash function as !   a default algorithm.  However, a user can specify the *IsSHAKE256* !   flag to true when initializing the digest object (by calling the !   *Create* method) in order to use the *SHAKE-256* hash function, in !   place of the *SHAKE-128* hash function.  As previously mentioned, !   the *SHAKE* type is capable of producing variable-length hash output. !   Therefore, a user can specify an output length through the optional !   *OutputLen* argument when initializing the digest object.  If the !   optional argument is NOT present, the *SHAKE* type produces the hash !   output length based on a default length for a specific algorithm. !   In addition, a user may use the *SHAKE* type as an extendable-output !   function (XOF) by specifying the hash output length during a finalization !   of the digest object where the *DigestWOutLen* method is called.  This !   method will ignore the output length specified during initialization if !   the specified length is valid (greater than or equal to 1). <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , & ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest USE MClass_KP1600Core IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SHAKE PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *SHAKE* is a concrete *Keccak-based digest* type that implements an !  incremental cryptographic hash function by employing either the !  *SHAKE-128* or the *SHAKE-256 message-digest* algorithm. TYPE , EXTENDS ( KP1600Core ) :: SHAKE PRIVATE !% flag indicating whether the SHAKE-256 algorithm is employed or not. tLogical :: IsSHAKE256 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => SHAKE_Initialize_wOption PROCEDURE , PRIVATE :: SHAKE_ByteDigest_wOutLen PROCEDURE , PRIVATE :: SHAKE_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: SHAKE_HexDigest_wOutLen PROCEDURE , PRIVATE :: SHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHAKE-128) !  and default hash output length. PROCEDURE :: Initialize => SHAKE_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHAKE_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHAKE_GetName ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! employ the default (SHAKE-256) algorithm and default output length <br> !   --->    CALL MD%Create() <br> !   ! employ the SHAKE-256 algorithm and default output length <br> !   --->    CALL MD%Create(IsSHAKE256=.TRUE.) <br> !   ! employ the SHAKE-128 algorithm with specified output length <br> !   --->    CALL MD%Create(IsSHAKE256=.FALSE., OutputLen=64) <br> !   ! employ the SHAKE-256 algorithm with specified output length <br> !   --->    CALL MD%Create(IsSHAKE256=.TRUE., OutputLen=128) <br> GENERIC :: Create => InitializeWOption !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> !  **Important Note**: If the specified output length is applicable, the output !   length specified during initialization will be ignored. <br> GENERIC :: DigestWOutLen => SHAKE_ByteDigest_wOutLen , & SHAKE_ByteDigest_wInputNOutLen , & SHAKE_HexDigest_wOutLen , & SHAKE_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE SHAKE !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHAKE_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with !  default algorithm and default hash output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'SHAKE' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHAKE-128 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SHAKE_Initialize !****************************************************************************** SUBROUTINE SHAKE_Initialize_wOption ( MD , IsSHAKE256 , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified options. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'SHAKE' object tLogical , INTENT ( IN ) :: IsSHAKE256 !&#94; flag indicating whether the SHAKE-256 algorithm is employed or not. <br> !  - If true, use the SHAKE-256 algorithm. <br> !  - Otherwise, use the SHAKE-128 algorithm. <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; the hash output length in bytes (must be positive; otherwise, !  the default length produced). !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , PARAMETER :: Suffix = ToInt8 ( Z '1F' ) tInteger , PARAMETER :: NRounds = 24 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: Security ! security strength in bits tInteger :: Capacity ! the value of the capacity C in bits tIndex :: DigestLen ! the desired length of output in bytes ! FLOW ! set security strength MD % IsSHAKE256 = IsSHAKE256 IF ( IsSHAKE256 ) THEN Security = 256 ELSE Security = 128 END IF ! set input parameters for the *CoreInit* method Capacity = SHIFTL ( Security , 1 ) ! Security*2 DigestLen = SHIFTR ( Security , 3 ) ! Security/8 ! check optional input IF ( PRESENT ( OutputLen )) THEN IF ( OutputLen > 0_kIndex ) THEN ! valid input DigestLen = OutputLen END IF END IF ! initialize the core components CALL MD % CoreInit ( Capacity , Suffix , DigestLen , NRounds ) RETURN END SUBROUTINE SHAKE_Initialize_wOption !****************************************************************************** SUBROUTINE SHAKE_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHAKE :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHAKE ) CALL Dst % Create ( Src % IsSHAKE256 , Src % GetDigestLen ()) CALL Src % CopyState ( Dst ) END SELECT RETURN END SUBROUTINE SHAKE_GetClone !****************************************************************************** FUNCTION SHAKE_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( IN ) :: MD !! 'SHAKE' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHAKE256 ) THEN Name = 'SHAKE-256' ELSE Name = 'SHAKE-128' END IF RETURN END FUNCTION SHAKE_GetName !****************************************************************************** SUBROUTINE SHAKE_ByteDigest_wOutLen ( MD , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes. The digest object is reset. <br> !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'SHAKE' object tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE SHAKE_ByteDigest_wOutLen !****************************************************************************** SUBROUTINE SHAKE_ByteDigest_wInputNOutLen ( MD , Input , InpSize , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'SHAKE' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE SHAKE_ByteDigest_wInputNOutLen !****************************************************************************** SUBROUTINE SHAKE_HexDigest_wOutLen ( MD , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DoFinalWOutLen ( ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE SHAKE_HexDigest_wOutLen !****************************************************************************** SUBROUTINE SHAKE_HexDigest_wInputNOutLen ( MD , Input , InpSize , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash computation !  and return the hash value as a hexadecimal string in a newly-allocated character string. !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHAKE ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( Input , InpSize , ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE SHAKE_HexDigest_wInputNOutLen !****************************************************************************** END MODULE MClass_SHAKE !******************************************************************************","tags":"","loc":"sourcefile\\mclass_shake.f90.html"},{"title":"MClass_Blake2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake2B* type and its related routines. !   The *Blake2B* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_blake2core.html#type-blake2core\">Blake2Core</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Blake2B* type implements an incremental cryptographic hash !   function by employing the *BLAKE2b* message-digest algorithm, which !   is optimized for 64-bit platforms and can produce the hash output of !   any size between 1 and 64 bytes [1, 2].  The implementation here is !   based mainly on the references [3, 4].  Unlike most of other *digest* !   types, the *Blake2B* type can perform keyed hashing providing that a !   user specifies the key during an initialization of the digest object !   by calling the *CreateHMAC* method instead of the *Create* method. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.aumasson.jp/blake/book/\">J.P. Aumasson, W. Meier, !       R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. </a> <br> !   [2] <a href=\"https://www.blake2.net/\">BLAKE2 - Fast Secure Hashing. </a> <br> !   [3] <a href=\"https://github.com/kocakosm/jblake2\">JBlake2: A pure Java !       implementation of BLAKE2 (RFC 7693). </a> <br> !   [4] <a href=\"https://github.com/BLAKE2/BLAKE2\">BLAKE2 official implementations. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_Blake2Core IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Blake2B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DigestLen = 64_kIndex tLong , PARAMETER :: IV ( 0 : 7 ) = [ & ToInt64 ( Z '6A09E667F3BCC908' ), ToInt64 ( Z 'BB67AE8584CAA73B' ), & ToInt64 ( Z '3C6EF372FE94F82B' ), ToInt64 ( Z 'A54FF53A5F1D36F1' ), & ToInt64 ( Z '510E527FADE682D1' ), ToInt64 ( Z '9B05688C2B3E6C1F' ), & ToInt64 ( Z '1F83D9ABFB41BD6B' ), ToInt64 ( Z '5BE0CD19137E2179' )] tIndex , PARAMETER :: SIGMA ( 0 : 15 , 0 : 11 ) = RESHAPE ([ & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 , & 9 , 0 , 5 , 7 , 2 , 4 , 10 , 15 , 14 , 1 , 11 , 12 , 6 , 8 , 3 , 13 , & 2 , 12 , 6 , 10 , 0 , 11 , 8 , 3 , 4 , 13 , 7 , 5 , 15 , 14 , 1 , 9 , & 12 , 5 , 1 , 15 , 14 , 13 , 4 , 10 , 0 , 7 , 6 , 3 , 9 , 2 , 8 , 11 , & 13 , 11 , 7 , 14 , 12 , 1 , 3 , 9 , 5 , 0 , 15 , 4 , 8 , 6 , 2 , 10 , & 6 , 15 , 14 , 9 , 11 , 3 , 0 , 8 , 12 , 2 , 13 , 7 , 1 , 4 , 10 , 5 , & 10 , 2 , 8 , 4 , 7 , 6 , 1 , 5 , 15 , 11 , 9 , 14 , 3 , 12 , 13 , 0 , & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 ], [ 16 , 12 ]) !** DERIVED TYPE DEFINITIONS !> *Blake2B* is a concrete *digest* type that implements an incremental cryptographic !  hash function by employing the *BLAKE2b message-digest* algorithm.  It can also be !  utilized as a hash-based message authentication code (HMAC). TYPE , EXTENDS ( Blake2Core ) :: Blake2B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% internal state tLong :: H ( 0 : 7 ) = IV ( 0 : 7 ) !% counter's LSB tLong :: T0 = 0_kInt64 !% counter's MSB tLong :: T1 = 0_kInt64 CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitWOutLen* method to !  initialize the *digest* object with the specified hash output length. PROCEDURE , PRIVATE :: InitWOutLen => Blake2B_InitWOutLen !> Use the *Create* method in place of the *InitWKey* method to initialize !  the *digest* object with the specified key for keyed hashing (and the !  optionally specified hash output length). PROCEDURE , PRIVATE :: InitWKey => Blake2B_InitWKey ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default hash output length. PROCEDURE :: Initialize => Blake2B_InitDefault !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake2B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake2B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake2B_GetName !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake2B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake2B_ProcessBlock !> *EncodeOutput* is a procedure to encode the hash output. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: EncodeOutput => Blake2B_EncodeOutput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                (as a hasher). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%Create() <br> !   ! initialization with specified output length <br> GENERIC :: Create => InitWOutLen !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%CreateHMAC(Key) <br> !   ! initialization with specified output length <br> !   --->    CALL MD%CreateHMAC(Key, OutputLen) <br> GENERIC :: CreateHMAC => InitWKey ! --------------------------------------------------------------------- END TYPE Blake2B !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake2B_InitDefault ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform default initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % CoreInit ( BlockLen , DigestLen ) RETURN END SUBROUTINE Blake2B_InitDefault !****************************************************************************** SUBROUTINE Blake2B_InitWOutLen ( MD , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object tIndex , INTENT ( IN ) :: OutputLen !&#94; the desired length of hash output, which must be between 1 and 32 bytes. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % CoreInit ( BlockLen , OutputLen ) RETURN END SUBROUTINE Blake2B_InitWOutLen !****************************************************************************** SUBROUTINE Blake2B_InitWKey ( MD , Key , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified key and !  the optionally specified length of hash output. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object tByte , INTENT ( IN ) :: Key ( 0 :) !&#94; an (8-bit integer) byte array representing a key for a keyed hashing <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; desired length of hash output; must be between 1 and 32 bytes. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( OutputLen )) THEN CALL MD % CoreInit ( BlockLen , OutputLen , Key ) ELSE CALL MD % CoreInit ( BlockLen , DigestLen , Key ) END IF RETURN END SUBROUTINE Blake2B_InitWKey !****************************************************************************** SUBROUTINE Blake2B_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % T0 = 0_kInt64 MD % T1 = 0_kInt64 MD % H ( 0 : 7 ) = IV ( 0 : 7 ) MD % H ( 0 ) = IEOR ( MD % H ( 0 ), ToInt64 ( IOR ( IOR ( MD % GetDigestLen (), SHIFTL ( MD % GetKeyLen (), 8 )), ToIndex ( Z '01010000' )))) CALL MD % CoreReset () RETURN END SUBROUTINE Blake2B_Reset !****************************************************************************** SUBROUTINE Blake2B_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Blake2B :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Blake2B ) Dst % H = Src % H Dst % T0 = Src % T0 Dst % T1 = Src % T1 Dst % BufArr = Src % BufArr CALL Src % CoreClone ( Dst ) END SELECT RETURN END SUBROUTINE Blake2B_GetClone !****************************************************************************** FUNCTION Blake2B_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( IN ) :: MD !! 'Blake2B' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % GetKeyLen () > 0_kIndex ) THEN Name = 'BLAKE2b HMAC' ELSE Name = 'BLAKE2b Hasher' END IF RETURN END FUNCTION Blake2B_GetName !****************************************************************************** SUBROUTINE Blake2B_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), TARGET , INTENT ( INOUT ) :: MD !! 'Blake2B' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Blake2B_SetBufPtr !****************************************************************************** SUBROUTINE Blake2B_ProcessBlock ( MD , BytesIn , LastBlock ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the input data block tLogical , INTENT ( IN ) :: LastBlock !! true if the input is the last block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! update counters MD % T0 = MD % T0 + MD % GetBufLen () IF (( MD % T0 == 0_kInt64 ). AND .( MD % GetBufLen () > 0_kIndex )) MD % T1 = MD % T1 + 1_kInt64 CALL F ( BytesIn , LastBlock ) RETURN CONTAINS SUBROUTINE F ( Input , LastBlock ) ! To perform data compression process. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: Input ( 0 :) ! the data block tLogical , INTENT ( IN ) :: LastBlock ! true if the buffer is the last block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: M ( 0 : 15 ) tLong :: V ( 0 : 15 ) tIndex :: I ! FLOW ! initialize V ( 0 : 7 ) = MD % H ( 0 : 7 ) V ( 8 : 15 ) = IV ( 0 : 7 ) V ( 12 ) = IEOR ( V ( 12 ), MD % T0 ) V ( 13 ) = IEOR ( V ( 13 ), MD % T1 ) IF ( LastBlock ) V ( 14 ) = NOT ( V ( 14 )) ! input block CALL BytePackLE ( BytesIn , 0_kIndex , M ) ! perform block transformation DO I = 0 , 11 CALL G ( V , 0 , 4 , 8 , 12 , M ( SIGMA ( 0 , I )), M ( SIGMA ( 1 , I ))) CALL G ( V , 1 , 5 , 9 , 13 , M ( SIGMA ( 2 , I )), M ( SIGMA ( 3 , I ))) CALL G ( V , 2 , 6 , 10 , 14 , M ( SIGMA ( 4 , I )), M ( SIGMA ( 5 , I ))) CALL G ( V , 3 , 7 , 11 , 15 , M ( SIGMA ( 6 , I )), M ( SIGMA ( 7 , I ))) CALL G ( V , 0 , 5 , 10 , 15 , M ( SIGMA ( 8 , I )), M ( SIGMA ( 9 , I ))) CALL G ( V , 1 , 6 , 11 , 12 , M ( SIGMA ( 10 , I )), M ( SIGMA ( 11 , I ))) CALL G ( V , 2 , 7 , 8 , 13 , M ( SIGMA ( 12 , I )), M ( SIGMA ( 13 , I ))) CALL G ( V , 3 , 4 , 9 , 14 , M ( SIGMA ( 14 , I )), M ( SIGMA ( 15 , I ))) END DO ! update H DO I = 0 , 7 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR ( V ( I ), V ( I + 8 ))) END DO RETURN END SUBROUTINE F !************************************************************************** SUBROUTINE G ( V , A , B , C , D , X , Y ) ! To perform block transformation !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: V ( 0 : 15 ) tInteger , INTENT ( IN ) :: A , B , C , D tLong , INTENT ( IN ) :: X , Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW V ( A ) = V ( A ) + ( V ( B ) + X ) V ( D ) = RotateRight ( IEOR ( V ( D ), V ( A )), 32 ) V ( C ) = V ( C ) + V ( D ) V ( B ) = RotateRight ( IEOR ( V ( B ), V ( C )), 24 ) V ( A ) = V ( A ) + ( V ( B ) + Y ) V ( D ) = RotateRight ( IEOR ( V ( D ), V ( A )), 16 ) V ( C ) = V ( C ) + V ( D ) V ( B ) = RotateRight ( IEOR ( V ( B ), V ( C )), 63 ) RETURN END SUBROUTINE G !************************************************************************** END SUBROUTINE Blake2B_ProcessBlock !****************************************************************************** SUBROUTINE Blake2B_EncodeOutput ( MD , BytesOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the encoding of the hash output (i.e. !  unpacking the internal state into the output byte array). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2B ), INTENT ( INOUT ) :: MD !! 'Blake2B' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , OutLen tByte :: Last ( 0 : 7 ) ! FLOW ! initialize indices I = 0_kIndex J = 0_kIndex OutLen = MD % GetDigestLen () ! unpack the internal states to the output array DO WHILE ( I < 8_kIndex ) CALL ByteUnpackLE ( MD % H ( I ), BytesOut , J ) I = I + 1_kIndex J = J + 8_kIndex IF ( J >= OutLen - 8_kIndex ) EXIT END DO ! unpack the last internal state to the buffer CALL ByteUnpackLE ( MD % H ( I ), Last , 0_kIndex ) ! copy the buffer to the output array BytesOut ( J : OutLen - 1 ) = Last ( 0 : OutLen - J - 1 ) RETURN END SUBROUTINE Blake2B_EncodeOutput !****************************************************************************** END MODULE MClass_Blake2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake2b.f90.html"},{"title":"MClass_Blake2S.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake2S !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake2S* type and its related routines. !   The *Blake2S* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_blake2core.html#type-blake2core\">Blake2Core</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Blake2S* type implements an incremental cryptographic hash !   function by employing the *BLAKE2s* message-digest algorithm, !   which is optimized for 8-bit to 32-bit platforms and can produce !   the hash output of any size between 1 and 32 bytes [1, 2].  The !   implementation here is based mainly on the references [3, 4]. !   Unlike most of other *digest* types, the *Blake2S* type can !   perform keyed hashing providing that a user specifies the key !   during an initialization of the digest object by calling the !   *CreateHMAC* method instead of the *Create* method. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.aumasson.jp/blake/book/\">J.P. Aumasson, W. Meier, !       R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. </a> <br> !   [2] <a href=\"https://www.blake2.net/\">BLAKE2 - Fast Secure Hashing. </a> <br> !   [3] <a href=\"https://github.com/kocakosm/jblake2\">JBlake2: A pure Java !       implementation of BLAKE2 (RFC 7693). </a> <br> !   [4] <a href=\"https://github.com/BLAKE2/BLAKE2\">BLAKE2 official implementations. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_Blake2Core IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Blake2S PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DigestLen = 32_kIndex tInteger , PARAMETER :: IV ( 0 : 7 ) = [ & ToInt32 ( Z '6A09E667' ), ToInt32 ( Z 'BB67AE85' ), & ToInt32 ( Z '3C6EF372' ), ToInt32 ( Z 'A54FF53A' ), & ToInt32 ( Z '510E527F' ), ToInt32 ( Z '9B05688C' ), & ToInt32 ( Z '1F83D9AB' ), ToInt32 ( Z '5BE0CD19' )] tIndex , PARAMETER :: SIGMA ( 0 : 15 , 0 : 9 ) = RESHAPE ([ & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 , & 9 , 0 , 5 , 7 , 2 , 4 , 10 , 15 , 14 , 1 , 11 , 12 , 6 , 8 , 3 , 13 , & 2 , 12 , 6 , 10 , 0 , 11 , 8 , 3 , 4 , 13 , 7 , 5 , 15 , 14 , 1 , 9 , & 12 , 5 , 1 , 15 , 14 , 13 , 4 , 10 , 0 , 7 , 6 , 3 , 9 , 2 , 8 , 11 , & 13 , 11 , 7 , 14 , 12 , 1 , 3 , 9 , 5 , 0 , 15 , 4 , 8 , 6 , 2 , 10 , & 6 , 15 , 14 , 9 , 11 , 3 , 0 , 8 , 12 , 2 , 13 , 7 , 1 , 4 , 10 , 5 , & 10 , 2 , 8 , 4 , 7 , 6 , 1 , 5 , 15 , 11 , 9 , 14 , 3 , 12 , 13 , 0 ], [ 16 , 10 ]) !** DERIVED TYPE DEFINITIONS !> *Blake2S* is a concrete *digest* type that implements an incremental cryptographic !  hash function by employing the *BLAKE2s message-digest* algorithm.  It can also be !  utilized as a hash-based message authentication code (HMAC). TYPE , EXTENDS ( Blake2Core ) :: Blake2S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% internal state tInteger :: H ( 0 : 7 ) = IV ( 0 : 7 ) !% counter's LSB tInteger :: T0 = 0 !% counter's MSB tInteger :: T1 = 0 CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitWOutLen* method to !  initialize the *digest* object with the specified hash output length. PROCEDURE , PRIVATE :: InitWOutLen => Blake2S_InitWOutLen !> Use the *Create* method in place of the *InitWKey* method to initialize !  the *digest* object with the specified key for keyed hashing (and the !  optionally specified hash output length). PROCEDURE , PRIVATE :: InitWKey => Blake2S_InitWKey ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default hash output length. PROCEDURE :: Initialize => Blake2S_InitDefault !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake2S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake2S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake2S_GetName !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake2S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake2S_ProcessBlock !> *EncodeOutput* is a procedure to encode the hash output. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: EncodeOutput => Blake2S_EncodeOutput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                (as a hasher). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%Create() <br> !   ! initialization with specified output length <br> GENERIC :: Create => InitWOutLen !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   ! initialization with default output length <br> !   --->    CALL MD%CreateHMAC(Key) <br> !   ! initialization with specified output length <br> !   --->    CALL MD%CreateHMAC(Key, OutputLen) <br> GENERIC :: CreateHMAC => InitWKey ! --------------------------------------------------------------------- END TYPE Blake2S !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake2S_InitDefault ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform default initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % CoreInit ( BlockLen , DigestLen ) RETURN END SUBROUTINE Blake2S_InitDefault !****************************************************************************** SUBROUTINE Blake2S_InitWOutLen ( MD , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object tIndex , INTENT ( IN ) :: OutputLen !&#94; the desired length of hash output, which must be between 1 and 32 bytes. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % CoreInit ( BlockLen , OutputLen ) RETURN END SUBROUTINE Blake2S_InitWOutLen !****************************************************************************** SUBROUTINE Blake2S_InitWKey ( MD , Key , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified key and !  the optionally specified length of hash output. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object tByte , INTENT ( IN ) :: Key ( 0 :) !&#94; an (8-bit integer) byte array representing a key for a keyed hashing <br> tIndex , OPTIONAL , INTENT ( IN ) :: OutputLen !&#94; desired length of hash output; must be between 1 and 32 bytes. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( OutputLen )) THEN CALL MD % CoreInit ( BlockLen , OutputLen , Key ) ELSE CALL MD % CoreInit ( BlockLen , DigestLen , Key ) END IF RETURN END SUBROUTINE Blake2S_InitWKey !****************************************************************************** SUBROUTINE Blake2S_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % T0 = 0 MD % T1 = 0 MD % H ( 0 : 7 ) = IV ( 0 : 7 ) MD % H ( 0 ) = IEOR ( MD % H ( 0 ), ToInt32 ( IOR ( IOR ( MD % GetDigestLen (), SHIFTL ( MD % GetKeyLen (), 8 )), ToIndex ( Z '01010000' )))) CALL MD % CoreReset () RETURN END SUBROUTINE Blake2S_Reset !****************************************************************************** SUBROUTINE Blake2S_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Blake2S :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Blake2S ) Dst % H = Src % H Dst % T0 = Src % T0 Dst % T1 = Src % T1 Dst % BufArr = Src % BufArr CALL Src % CoreClone ( Dst ) END SELECT RETURN END SUBROUTINE Blake2S_GetClone !****************************************************************************** FUNCTION Blake2S_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( IN ) :: MD !! 'Blake2S' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % GetKeyLen () > 0_kIndex ) THEN Name = 'BLAKE2s HMAC' ELSE Name = 'BLAKE2s Hasher' END IF RETURN END FUNCTION Blake2S_GetName !****************************************************************************** SUBROUTINE Blake2S_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), TARGET , INTENT ( INOUT ) :: MD !! 'Blake2S' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Blake2S_SetBufPtr !****************************************************************************** SUBROUTINE Blake2S_ProcessBlock ( MD , BytesIn , LastBlock ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the input data block tLogical , INTENT ( IN ) :: LastBlock !! true if the input is the last block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! update counters MD % T0 = MD % T0 + MD % GetBufLen () IF (( MD % T0 == 0 ). AND .( MD % GetBufLen () > 0_kIndex )) MD % T1 = MD % T1 + 1 CALL F ( BytesIn , LastBlock ) RETURN CONTAINS SUBROUTINE F ( Input , LastBlock ) ! To perform data compression process. !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: Input ( 0 :) ! the data block tLogical , INTENT ( IN ) :: LastBlock ! true if the buffer is the last block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 15 ) tInteger :: V ( 0 : 15 ) tIndex :: I ! FLOW ! initialize V ( 0 : 7 ) = MD % H ( 0 : 7 ) V ( 8 : 15 ) = IV ( 0 : 7 ) V ( 12 ) = IEOR ( V ( 12 ), MD % T0 ) V ( 13 ) = IEOR ( V ( 13 ), MD % T1 ) IF ( LastBlock ) V ( 14 ) = NOT ( V ( 14 )) ! input block CALL BytePackLE ( Input , 0_kIndex , M ) ! perform block transformation DO I = 0 , 9 CALL G ( V , 0 , 4 , 8 , 12 , M ( SIGMA ( 0 , I )), M ( SIGMA ( 1 , I ))) CALL G ( V , 1 , 5 , 9 , 13 , M ( SIGMA ( 2 , I )), M ( SIGMA ( 3 , I ))) CALL G ( V , 2 , 6 , 10 , 14 , M ( SIGMA ( 4 , I )), M ( SIGMA ( 5 , I ))) CALL G ( V , 3 , 7 , 11 , 15 , M ( SIGMA ( 6 , I )), M ( SIGMA ( 7 , I ))) CALL G ( V , 0 , 5 , 10 , 15 , M ( SIGMA ( 8 , I )), M ( SIGMA ( 9 , I ))) CALL G ( V , 1 , 6 , 11 , 12 , M ( SIGMA ( 10 , I )), M ( SIGMA ( 11 , I ))) CALL G ( V , 2 , 7 , 8 , 13 , M ( SIGMA ( 12 , I )), M ( SIGMA ( 13 , I ))) CALL G ( V , 3 , 4 , 9 , 14 , M ( SIGMA ( 14 , I )), M ( SIGMA ( 15 , I ))) END DO ! update H DO I = 0 , 7 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR ( V ( I ), V ( I + 8 ))) END DO RETURN END SUBROUTINE F !************************************************************************** SUBROUTINE G ( V , A , B , C , D , X , Y ) ! To perform block transformation !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: V ( 0 : 15 ) tInteger , INTENT ( IN ) :: A , B , C , D tInteger , INTENT ( IN ) :: X , Y !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW V ( A ) = V ( A ) + ( V ( B ) + X ) V ( D ) = RotateRight ( IEOR ( V ( D ), V ( A )), 16 ) V ( C ) = V ( C ) + V ( D ) V ( B ) = RotateRight ( IEOR ( V ( B ), V ( C )), 12 ) V ( A ) = V ( A ) + ( V ( B ) + Y ) V ( D ) = RotateRight ( IEOR ( V ( D ), V ( A )), 8 ) V ( C ) = V ( C ) + V ( D ) V ( B ) = RotateRight ( IEOR ( V ( B ), V ( C )), 7 ) RETURN END SUBROUTINE G !************************************************************************** END SUBROUTINE Blake2S_ProcessBlock !****************************************************************************** SUBROUTINE Blake2S_EncodeOutput ( MD , BytesOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the encoding of the hash output (i.e. !  unpacking the internal state into the output byte array). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake2S ), INTENT ( INOUT ) :: MD !! 'Blake2S' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , OutLen tByte :: Last ( 0 : 3 ) ! FLOW ! initialize indices I = 0_kIndex J = 0_kIndex OutLen = MD % GetDigestLen () ! unpack the internal states to the output array DO WHILE ( I < 8_kIndex ) CALL ByteUnpackLE ( MD % H ( I ), BytesOut , J ) I = I + 1_kIndex J = J + 4_kIndex IF ( J >= OutLen - 4_kIndex ) EXIT END DO ! unpack the last internal state to the buffer CALL ByteUnpackLE ( MD % H ( I ), Last , 0_kIndex ) ! copy the buffer to the output array BytesOut ( J : OutLen - 1 ) = Last ( 0 : OutLen - J - 1 ) RETURN END SUBROUTINE Blake2S_EncodeOutput !****************************************************************************** END MODULE MClass_Blake2S !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake2s.f90.html"},{"title":"MClass_MD4.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MD4 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MD4* type and its related routines. !   The *MD4* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *MD4* type implements an incremental cryptographic hash !   function by employing the *MD4 message-digest* algorithm [1] !   where the algorithm is described in RFC 1320.  The implementation !   here is mainly based on the *SPHLIB* implementation [2].  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://datatracker.ietf.org/doc/html/rfc1320\">RFC1320: !       The MD4 Message-Digest Algorithm. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MD4 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DigestLen = 16_kIndex tInteger , PARAMETER :: IV ( 0 : 3 ) = [ & ToInt32 ( Z '67452301' ), ToInt32 ( Z 'EFCDAB89' ), & ToInt32 ( Z '98BADCFE' ), ToInt32 ( Z '10325476' )] !** DERIVED TYPE DEFINITIONS !> *MD4* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing !  the *MD4 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: MD4 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 3 ) = IV ( 0 : 3 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD4_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD4_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD4_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD4_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD4_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD4_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD4_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD4_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD4_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD4_AddBitsNPad END TYPE MD4 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE MD4_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: MD !! 'MD4' object !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = TrueVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperInit ( LittleEndian , 8_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE MD4_Initialize !****************************************************************************** SUBROUTINE MD4_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: MD !! 'MD4' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % State = IV CALL MD % HelperReset () RETURN END SUBROUTINE MD4_Reset !****************************************************************************** SUBROUTINE MD4_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( MD4 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( MD4 ) CALL Dst % Create () Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE MD4_GetClone !****************************************************************************** FUNCTION MD4_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( IN ) :: MD !! 'MD4' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'MD4' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD4_GetName !****************************************************************************** FUNCTION MD4_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( IN ) :: MD !! 'MD4' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = DigestLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD4_GetDigestLen !****************************************************************************** FUNCTION MD4_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( IN ) :: MD !! 'MD4' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD4_GetBlockLen !****************************************************************************** SUBROUTINE MD4_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), TARGET , INTENT ( INOUT ) :: MD !! 'MD4' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE MD4_SetBufPtr !****************************************************************************** SUBROUTINE MD4_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: MD !! 'MD4' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D tInteger :: X ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define FRound(B, C, D)     IEOR(IAND(IEOR(C, D), B), D) #define GRound(B, C, D)     IOR(IAND(D, C), IAND(IOR(D, C), B)) #define HRound(B, C, D)     IEOR(IEOR(B, C), D) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) CALL BytePackLE ( BytesIn , 0_kIndex , X ) A = RotateLeft ( A + FRound ( B , C , D ) + X ( 0 ), 3 ) D = RotateLeft ( D + FRound ( A , B , C ) + X ( 1 ), 7 ) C = RotateLeft ( C + FRound ( D , A , B ) + X ( 2 ), 11 ) B = RotateLeft ( B + FRound ( C , D , A ) + X ( 3 ), 19 ) A = RotateLeft ( A + FRound ( B , C , D ) + X ( 4 ), 3 ) D = RotateLeft ( D + FRound ( A , B , C ) + X ( 5 ), 7 ) C = RotateLeft ( C + FRound ( D , A , B ) + X ( 6 ), 11 ) B = RotateLeft ( B + FRound ( C , D , A ) + X ( 7 ), 19 ) A = RotateLeft ( A + FRound ( B , C , D ) + X ( 8 ), 3 ) D = RotateLeft ( D + FRound ( A , B , C ) + X ( 9 ), 7 ) C = RotateLeft ( C + FRound ( D , A , B ) + X ( 10 ), 11 ) B = RotateLeft ( B + FRound ( C , D , A ) + X ( 11 ), 19 ) A = RotateLeft ( A + FRound ( B , C , D ) + X ( 12 ), 3 ) D = RotateLeft ( D + FRound ( A , B , C ) + X ( 13 ), 7 ) C = RotateLeft ( C + FRound ( D , A , B ) + X ( 14 ), 11 ) B = RotateLeft ( B + FRound ( C , D , A ) + X ( 15 ), 19 ) A = RotateLeft ( A + GRound ( B , C , D ) + X ( 0 ) + ToInt32 ( Z '5A827999' ), 3 ) D = RotateLeft ( D + GRound ( A , B , C ) + X ( 4 ) + ToInt32 ( Z '5A827999' ), 5 ) C = RotateLeft ( C + GRound ( D , A , B ) + X ( 8 ) + ToInt32 ( Z '5A827999' ), 9 ) B = RotateLeft ( B + GRound ( C , D , A ) + X ( 12 ) + ToInt32 ( Z '5A827999' ), 13 ) A = RotateLeft ( A + GRound ( B , C , D ) + X ( 1 ) + ToInt32 ( Z '5A827999' ), 3 ) D = RotateLeft ( D + GRound ( A , B , C ) + X ( 5 ) + ToInt32 ( Z '5A827999' ), 5 ) C = RotateLeft ( C + GRound ( D , A , B ) + X ( 9 ) + ToInt32 ( Z '5A827999' ), 9 ) B = RotateLeft ( B + GRound ( C , D , A ) + X ( 13 ) + ToInt32 ( Z '5A827999' ), 13 ) A = RotateLeft ( A + GRound ( B , C , D ) + X ( 2 ) + ToInt32 ( Z '5A827999' ), 3 ) D = RotateLeft ( D + GRound ( A , B , C ) + X ( 6 ) + ToInt32 ( Z '5A827999' ), 5 ) C = RotateLeft ( C + GRound ( D , A , B ) + X ( 10 ) + ToInt32 ( Z '5A827999' ), 9 ) B = RotateLeft ( B + GRound ( C , D , A ) + X ( 14 ) + ToInt32 ( Z '5A827999' ), 13 ) A = RotateLeft ( A + GRound ( B , C , D ) + X ( 3 ) + ToInt32 ( Z '5A827999' ), 3 ) D = RotateLeft ( D + GRound ( A , B , C ) + X ( 7 ) + ToInt32 ( Z '5A827999' ), 5 ) C = RotateLeft ( C + GRound ( D , A , B ) + X ( 11 ) + ToInt32 ( Z '5A827999' ), 9 ) B = RotateLeft ( B + GRound ( C , D , A ) + X ( 15 ) + ToInt32 ( Z '5A827999' ), 13 ) A = RotateLeft ( A + HRound ( B , C , D ) + X ( 0 ) + ToInt32 ( Z '6ED9EBA1' ), 3 ) D = RotateLeft ( D + HRound ( A , B , C ) + X ( 8 ) + ToInt32 ( Z '6ED9EBA1' ), 9 ) C = RotateLeft ( C + HRound ( D , A , B ) + X ( 4 ) + ToInt32 ( Z '6ED9EBA1' ), 11 ) B = RotateLeft ( B + HRound ( C , D , A ) + X ( 12 ) + ToInt32 ( Z '6ED9EBA1' ), 15 ) A = RotateLeft ( A + HRound ( B , C , D ) + X ( 2 ) + ToInt32 ( Z '6ED9EBA1' ), 3 ) D = RotateLeft ( D + HRound ( A , B , C ) + X ( 10 ) + ToInt32 ( Z '6ED9EBA1' ), 9 ) C = RotateLeft ( C + HRound ( D , A , B ) + X ( 6 ) + ToInt32 ( Z '6ED9EBA1' ), 11 ) B = RotateLeft ( B + HRound ( C , D , A ) + X ( 14 ) + ToInt32 ( Z '6ED9EBA1' ), 15 ) A = RotateLeft ( A + HRound ( B , C , D ) + X ( 1 ) + ToInt32 ( Z '6ED9EBA1' ), 3 ) D = RotateLeft ( D + HRound ( A , B , C ) + X ( 9 ) + ToInt32 ( Z '6ED9EBA1' ), 9 ) C = RotateLeft ( C + HRound ( D , A , B ) + X ( 5 ) + ToInt32 ( Z '6ED9EBA1' ), 11 ) B = RotateLeft ( B + HRound ( C , D , A ) + X ( 13 ) + ToInt32 ( Z '6ED9EBA1' ), 15 ) A = RotateLeft ( A + HRound ( B , C , D ) + X ( 3 ) + ToInt32 ( Z '6ED9EBA1' ), 3 ) D = RotateLeft ( D + HRound ( A , B , C ) + X ( 11 ) + ToInt32 ( Z '6ED9EBA1' ), 9 ) C = RotateLeft ( C + HRound ( D , A , B ) + X ( 7 ) + ToInt32 ( Z '6ED9EBA1' ), 11 ) B = RotateLeft ( B + HRound ( C , D , A ) + X ( 15 ) + ToInt32 ( Z '6ED9EBA1' ), 15 ) MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D RETURN #undef FRound #undef GRound #undef HRound END SUBROUTINE MD4_ProcessBlock !****************************************************************************** SUBROUTINE MD4_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: MD !! 'MD4' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperPadding () CALL ByteUnpackLE ( MD % State , BytesOut , Offset ) RETURN END SUBROUTINE MD4_DoPadding !****************************************************************************** SUBROUTINE MD4_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD4 ), INTENT ( INOUT ) :: MD !! 'MD4' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! MD4 algorithm does not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE MD4_AddBitsNPad !****************************************************************************** END MODULE MClass_MD4 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_md4.f90.html"},{"title":"MClass_SipHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SipHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SipHasher64* type and its related routines. !   The *SipHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *SipHasher64* type employs the *Sip* hash algorithm for 64-bit integer !   output by Jean-Philippe Aumasson [1].  As a hasher, it can be used to compute !   the hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/veorq/SipHash\">SipHash: high-speed secure pseudorandom !       function for short messages. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SipHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define     MaskI64(X)      IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) #define     SipRound(A,B,C,D) \\ A = A + B ; \\ B = RotateLeft ( B , 13 ); \\ B = IEOR ( B , A ); \\ A = RotateLeft ( A , 32 ); \\ C = C + D ; \\ D = RotateLeft ( D , 16 ); \\ D = IEOR ( D , C ); \\ A = A + D ; \\ D = RotateLeft ( D , 21 ); \\ D = IEOR ( D , A ); \\ C = C + B ; \\ B = RotateLeft ( B , 17 ); \\ B = IEOR ( B , C ); \\ C = RotateLeft ( C , 32 ); !** MODULE PARAMETERS: tUInt64 , PARAMETER :: IV0 = ToInt64 ( Z '736F6D6570736575' ) tUInt64 , PARAMETER :: IV1 = ToInt64 ( Z '646F72616E646F6D' ) tUInt64 , PARAMETER :: IV2 = ToInt64 ( Z '6C7967656E657261' ) tUInt64 , PARAMETER :: IV3 = ToInt64 ( Z '7465646279746573' ) tUInt8 , PARAMETER :: DefaultKey ( 16 ) = [ & ToInt8 ( Z 'F7' ), ToInt8 ( Z '43' ), ToInt8 ( Z '24' ), ToInt8 ( Z '8E' ), & ToInt8 ( Z 'E0' ), ToInt8 ( Z '35' ), ToInt8 ( Z '90' ), ToInt8 ( Z 'E6' ), & ToInt8 ( Z '81' ), ToInt8 ( Z '3A' ), ToInt8 ( Z '26' ), ToInt8 ( Z '4C' ), & ToInt8 ( Z '3C' ), ToInt8 ( Z '28' ), ToInt8 ( Z '52' ), ToInt8 ( Z 'BB' )] tIndex , PARAMETER :: BlockLen = 8_kIndex !** DERIVED TYPE DEFINITIONS !> *SipHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *Sip* hash algorithm by Jean-Philippe Aumasson. TYPE , EXTENDS ( Hasher64 ) :: SipHasher64 PRIVATE !% state tUInt64 :: State ( 4 ) = 0_kInt64 !% number of C rounds tIndex :: cRound = 2_kIndex !% number of D rounds tIndex :: dRound = 4_kIndex !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Sip_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Sip_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Sip_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Sip_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with default keys and rounds (i.e. Sip24). <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Sip_Initialize !> **Type-Bound Subroutine**: InitializeWKey <br> !  **Purpose**:  To initialize the hasher with keys and optionally the number of rounds. <br> !  **Usage**: <br> !   ! hash value (with default rounds and sign) <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key) <br> !   ! hash value with specified rounds <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, cRound=1, dRound=3) <br> !   ! hash value with specified remove sign flag <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, RemoveSign=.TRUE.) <br> PROCEDURE :: InitializeWKey => Sip_Initialize_wKey !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Sip_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) with optional !                seed and remove sign flag (and default key and number of rounds). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Sip_HashDirect !> **Type-Bound Function**: HashDirectWKey <br> !  **Purpose**:  To compute the hash value directly with specified seed and keys !                and optionally the number of rounds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key) <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, cRound=2, dRound=4) <br> !   --->    HashCode = Hasher%HashDirectWKey(Input, InpSize, Seed, Key, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWKey => Sip_HashDirect_wKey END TYPE SipHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Sip_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Sip_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Sip_GetName !****************************************************************************** FUNCTION Sip_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Sip_BlockLength !****************************************************************************** SUBROUTINE Sip_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Sip_SetBufPtr !****************************************************************************** SUBROUTINE Sip_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: M tIndex :: I !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) M = PackFull ( BytesIn , 0_kIndex ) V3 = IEOR ( V3 , M ) DO I = 1 , HS % cRound SipRound ( V0 , V1 , V2 , V3 ) END DO V0 = IEOR ( V0 , M ) END ASSOCIATE RETURN END SUBROUTINE Sip_ProcessBlock !****************************************************************************** SUBROUTINE Sip_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL HS % InitializeWKey ( Seed , DefaultKey , RemoveSign = RemoveSign ) RETURN END SUBROUTINE Sip_Initialize !****************************************************************************** SUBROUTINE Sip_Initialize_wKey ( HS , Seed , Key , cRound , dRound , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher with keys and optionally the number of rounds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tUInt8 , INTENT ( IN ) :: Key ( 0 : 15 ) !! key bytes tIndex , OPTIONAL , INTENT ( IN ) :: cRound !! number of C rounds tIndex , OPTIONAL , INTENT ( IN ) :: dRound !! number of D rounds tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: K0 , K1 !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) K0 = PackFull ( Key , 0_kIndex ) K1 = PackFull ( Key , 8_kIndex ) V0 = IEOR ( IV0 , K0 ) V1 = IEOR ( IV1 , K1 ) + Seed V2 = IEOR ( IV2 , K0 ) V3 = IEOR ( IV3 , K1 ) END ASSOCIATE SET_OPTION ( HS % cRound , 2_kIndex , cRound ) SET_OPTION ( HS % dRound , 4_kIndex , dRound ) SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Sip_Initialize_wKey !****************************************************************************** FUNCTION Sip_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: B tIndex :: Length , Remaining , I !** FLOW ! initialize Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF ! process remaining bytes B = SHIFTL ( ToInt64 ( Length ), 56 ) IF ( Remaining > 0 ) B = IOR ( B , PackPartial ( HS % BufArr , 0_kIndex , Remaining )) ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) ! mix states with B V3 = IEOR ( V3 , B ) DO I = 1 , HS % cRound SipRound ( V0 , V1 , V2 , V3 ) END DO V0 = IEOR ( V0 , B ) ! final mix V2 = IEOR ( V2 , ToInt64 ( Z '00000000000000FF' )) DO I = 1 , HS % dRound SipRound ( V0 , V1 , V2 , V3 ) END DO HashCode = IEOR ( IEOR ( IEOR ( V0 , V1 ), V2 ), V3 ) END ASSOCIATE ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % cRound = 2_kIndex HS % dRound = 4_kIndex HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Sip_Finalize !****************************************************************************** FUNCTION Sip_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Sip_HashDirect !****************************************************************************** FUNCTION Sip_HashDirect_wKey ( HS , Input , InpSize , Seed , Key , cRound , & dRound , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly with specified seed and keys !  and optionally the number of rounds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SipHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , INTENT ( IN ) :: Seed !! seed tUInt8 , INTENT ( IN ) :: Key ( 0 : 15 ) !! key bytes tIndex , OPTIONAL , INTENT ( IN ) :: cRound !! number of C rounds tIndex , OPTIONAL , INTENT ( IN ) :: dRound !! number of D rounds tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following code illustrates simple use of the hasher. CALL HS % InitializeWKey ( Seed , Key , cRound , dRound , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Sip_HashDirect_wKey !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION PackFull ( ByteArr , Offset ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert an array of 8-bit integers starting at the offset to !  a 64-bit integer value using the *SHIFTL* and *IOR* intrinsic !  functions. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! little-endian order Res = IOR ( IOR ( IOR ( IOR ( IOR ( IOR ( IOR ( MaskI64 ( ByteArr ( Offset )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 1 )), 8 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 2 )), 16 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 3 )), 24 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 4 )), 32 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 5 )), 40 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 6 )), 48 )), & SHIFTL ( MaskI64 ( ByteArr ( Offset + 7 )), 56 )) ! big-endian order !    Res = IOR(IOR(IOR(IOR(IOR(IOR(IOR(SHIFTL(MaskI64(ByteArr(Offset)),   56),  & !                                      SHIFTL(MaskI64(ByteArr(Offset+1)), 48)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+2)), 40)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+3)), 32)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+4)), 24)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+5)), 16)), & !                                      SHIFTL(MaskI64(ByteArr(Offset+6)),  8)), & !                                             MaskI64(ByteArr(Offset+7))) RETURN END FUNCTION PackFull !************************************************************************** FUNCTION PackPartial ( Buf , Off , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack three or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res'. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 7) tUInt64 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 7 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes in little-endian order Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! gather available bytes in big-endian order !    Wrk(Length-1:0:-1) = Buf(Off:Off+Length-1) ! pack bytes into word Res = PackFull ( Wrk , 0_kIndex ) RETURN END FUNCTION PackPartial !****************************************************************************** END MODULE MClass_SipHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_siphasher64.f90.html"},{"title":"MClass_SpookyHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SpookyHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SpookyHasher64* and *SpookyHasher128* types and their !   related routines.  The *SpookyHasher64* type is a hasher type that extends directly !   from the <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and outputs the !   hash value as a 64-bit integer.  The *SpookyHasher128* type is a hasher type that !   extends from the *SpookyHasher64* type and provides two additional methods (the !   *Finalize128* and *HashDirect128* methods) to output the hash value as a 128-bit !   integer. <br> !   Both hashers employ the *Spooky* hash algorithm by Bob Jenkins [1].  As hashers, !   they can be used to compute the hash value incrementally.  They also provide a method !   to compute the hash value directly (i.e. non-incrementally).  The following code snippet !   shows a typical usage of the hashers. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the *HashDirect* !   method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !   To compute the hash value as a 128-bit integer, simply replace the *Finalize* and !   *HashDirect* methods by the *Finalize128* and *HashDirect128* methods, respectively. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://burtleburtle.net/bob/hash/spooky.html\">SpookyHash: a 128-bit !       non-cryptographic hash. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SInt128 USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SpookyHasher64 PUBLIC :: SpookyHasher128 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define     tSInt128        TYPE(SInt128) #define     MixData(A, B, C, D, E, Pos, Inp, Off) \\ A = A + PackFull ( Inp , Off ); \\ B = IEOR ( B , C ); \\ D = IEOR ( D , A ); \\ A = RotateLeft ( A , Pos ); \\ D = D + E ; #define     MixH(A, B, C, Pos) \\ A = A + B ; \\ C = IEOR ( C , A ); \\ B = RotateLeft ( B , Pos ); #define     MixH1(A, B, C, P) \\ A = RotateLeft ( A , P ); \\ A = A + B ; \\ C = IEOR ( C , A ); #define     MixH2(A, B, P) \\ A = IEOR ( A , B ); \\ B = RotateLeft ( B , P ); \\ A = A + B ; #define     ShortMix(A, B, C, D) \\ MixH1 ( C , D , A , 50 ); \\ MixH1 ( D , A , B , 52 ); \\ MixH1 ( A , B , C , 30 ); \\ MixH1 ( B , C , D , 41 ); \\ MixH1 ( C , D , A , 54 ); \\ MixH1 ( D , A , B , 48 ); \\ MixH1 ( A , B , C , 38 ); \\ MixH1 ( B , C , D , 37 ); \\ MixH1 ( C , D , A , 62 ); \\ MixH1 ( D , A , B , 34 ); \\ MixH1 ( A , B , C , 5 ); \\ MixH1 ( B , C , D , 36 ); !** MODULE PARAMETERS: tUInt64 , PARAMETER :: GOLDEN_RATIO_64 = ToInt64 ( Z '9E3779B97F4A7C15' ) tUInt64 , PARAMETER :: SC = ToInt64 ( Z 'DEADBEEFDEADBEEF' ) tIndex , PARAMETER :: StateSize = 12_kIndex tIndex , PARAMETER :: BlockSize = StateSize * 8_kIndex tIndex , PARAMETER :: SmallLimit = BlockSize * 2_kIndex tIndex , PARAMETER :: BlockLen = SmallLimit !** DERIVED TYPE DEFINITIONS !> *SpookyHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *Spooky* hash algorithm by Bob Jenkins. TYPE , EXTENDS ( Hasher64 ) :: SpookyHasher64 PRIVATE !% state tUInt64 :: State ( StateSize ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Spooky_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Spooky_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Spooky_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Spooky_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Spooky_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => Spooky_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Spooky_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Spooky_HashDirect END TYPE SpookyHasher64 !> *SpookyHasher128* is a hasher type that outputs the hash value as a 128-bit integer. !  It is a subtype of the *SpookyHasher64* type. TYPE , EXTENDS ( SpookyHasher64 ) :: SpookyHasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Spooky_GetName128 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => Spooky_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => Spooky_HashDirect128 END TYPE SpookyHasher128 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Spooky_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Spooky_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Spooky_GetName !****************************************************************************** FUNCTION Spooky_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Spooky_BlockLength !****************************************************************************** SUBROUTINE Spooky_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Spooky_SetBufPtr !****************************************************************************** SUBROUTINE Spooky_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Offset , I !** FLOW ! Important Note: HS%BufLong is an alias of HS%BufArr, which is the same as !                 BytesIn so this routine does not use BytesIn directly but !                 through HS%BufLong instead. ASSOCIATE ( H0 => HS % State ( 1 ), H1 => HS % State ( 2 ), H2 => HS % State ( 3 ), & H3 => HS % State ( 4 ), H4 => HS % State ( 5 ), H5 => HS % State ( 6 ), & H6 => HS % State ( 7 ), H7 => HS % State ( 8 ), H8 => HS % State ( 9 ), & H9 => HS % State ( 10 ), H10 => HS % State ( 11 ), H11 => HS % State ( 12 )) Offset = 0_kIndex DO I = 1 , 2 ! mixing internal states and data MixData ( H0 , H2 , H10 , H11 , H1 , 11 , BytesIn , Offset ) MixData ( H1 , H3 , H11 , H0 , H2 , 32 , BytesIn , Offset + 8_kIndex ) MixData ( H2 , H4 , H0 , H1 , H3 , 43 , BytesIn , Offset + 16_kIndex ) MixData ( H3 , H5 , H1 , H2 , H4 , 31 , BytesIn , Offset + 24_kIndex ) MixData ( H4 , H6 , H2 , H3 , H5 , 17 , BytesIn , Offset + 32_kIndex ) MixData ( H5 , H7 , H3 , H4 , H6 , 28 , BytesIn , Offset + 40_kIndex ) MixData ( H6 , H8 , H4 , H5 , H7 , 39 , BytesIn , Offset + 48_kIndex ) MixData ( H7 , H9 , H5 , H6 , H8 , 57 , BytesIn , Offset + 56_kIndex ) MixData ( H8 , H10 , H6 , H7 , H9 , 55 , BytesIn , Offset + 64_kIndex ) MixData ( H9 , H11 , H7 , H8 , H10 , 54 , BytesIn , Offset + 72_kIndex ) MixData ( H10 , H0 , H8 , H9 , H11 , 22 , BytesIn , Offset + 80_kIndex ) MixData ( H11 , H1 , H9 , H10 , H0 , 46 , BytesIn , Offset + 88_kIndex ) Offset = Offset + BlockSize END DO END ASSOCIATE RETURN END SUBROUTINE Spooky_ProcessBlock !****************************************************************************** SUBROUTINE Spooky_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL HS % InitializeWSeeds ( Seed , Seed + GOLDEN_RATIO_64 , RemoveSign ) RETURN END SUBROUTINE Spooky_Initialize !****************************************************************************** SUBROUTINE Spooky_Initialize_WithSeeds ( HS , Seed1 , Seed2 , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher with two seeds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed1 !! seed1 tUInt64 , INTENT ( IN ) :: Seed2 !! seed2 tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( H0 => HS % State ( 1 ), H1 => HS % State ( 2 ), H2 => HS % State ( 3 ), & H3 => HS % State ( 4 ), H4 => HS % State ( 5 ), H5 => HS % State ( 6 ), & H6 => HS % State ( 7 ), H7 => HS % State ( 8 ), H8 => HS % State ( 9 ), & H9 => HS % State ( 10 ), H10 => HS % State ( 11 ), H11 => HS % State ( 12 )) H0 = Seed1 H3 = Seed1 H6 = Seed1 H9 = Seed1 H1 = Seed2 H4 = Seed2 H7 = Seed2 H10 = Seed2 H2 = SC H5 = SC H8 = SC H11 = SC END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Spooky_Initialize_WithSeeds !****************************************************************************** FUNCTION Spooky_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN CALL Spooky_Finalize64 ( HS , Remaining ) HashCode = HS % State ( 1 ) ELSE HashCode = SmallHash ( HS % BufArr , Remaining , HS % State ( 1 ), HS % State ( 2 )) END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Spooky_Finalize !****************************************************************************** FUNCTION Spooky_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Spooky_HashDirect !****************************************************************************** FUNCTION Spooky_GetName128 ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher128 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Spooky_Hahser128' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Spooky_GetName128 !****************************************************************************** FUNCTION Spooky_Finalize128 ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 128-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN CALL Spooky_Finalize64 ( HS , Remaining ) HashCode % Low = HS % State ( 1 ) HashCode % High = HS % State ( 2 ) ELSE HashCode % Low = SmallHash ( HS % BufArr , Remaining , HS % State ( 1 ), HS % State ( 2 ), HashCode % High ) END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode % High = IAND ( HashCode % High , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION Spooky_Finalize128 !****************************************************************************** FUNCTION Spooky_HashDirect128 ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize128 () RETURN END FUNCTION Spooky_HashDirect128 !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   OPTIMAL VERSIONS OF AUXILIARY ROUTINES                    + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION SmallHash ( Input , Length , Seed1 , Seed2 , HashHigh ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code for small input using the SpookyHash (version 2) ! hash algorithm by Bob Jenkins. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tIndex , INTENT ( IN ) :: Length ! size of input bytes tUInt64 , INTENT ( IN ) :: Seed1 ! seed tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed2 ! seed tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHigh ! 64-bit upper hash code tUInt64 :: HashCode ! 64-bit lower hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: H0 , H1 , H2 , H3 tIndex :: Remaining , Offset !** FLOW ! initialize H0 = Seed1 H1 = Seed1 + GOLDEN_RATIO_64 IF ( PRESENT ( Seed2 )) H1 = Seed2 H2 = SC H3 = SC Remaining = Length Offset = 0 DO WHILE ( Remaining >= 32 ) H2 = H2 + PackFull ( Input , Offset ) H3 = H3 + PackFull ( Input , Offset + 8 ) ShortMix ( H0 , H1 , H2 , H3 ) H0 = H0 + PackFull ( Input , Offset + 16 ) H1 = H1 + PackFull ( Input , Offset + 24 ) ! update indices Offset = Offset + 32 Remaining = Remaining - 32 END DO IF ( Remaining >= 16 ) THEN H2 = H2 + PackFull ( Input , Offset ) H3 = H3 + PackFull ( Input , Offset + 8 ) ShortMix ( H0 , H1 , H2 , H3 ) ! update indices Offset = Offset + 16 Remaining = Remaining - 16 END IF H3 = H3 + SHIFTL ( ToInt64 ( Length ), 56 ) IF ( Remaining >= 8 ) THEN H2 = H2 + PackFull ( Input , Offset ) ! update indices Offset = Offset + 8 Remaining = Remaining - 8 IF ( Remaining > 0 ) H3 = H3 + PackPartial ( Input , Offset , Remaining ) ELSEIF ( Remaining > 0 ) THEN H2 = H2 + PackPartial ( Input , Offset , Remaining ) ELSE H2 = H2 + SC H3 = H3 + SC END IF ! ShortEnd MixH2 ( H3 , H2 , 15 ) MixH2 ( H0 , H3 , 52 ) MixH2 ( H1 , H0 , 26 ) MixH2 ( H2 , H1 , 51 ) MixH2 ( H3 , H2 , 28 ) MixH2 ( H0 , H3 , 9 ) MixH2 ( H1 , H0 , 47 ) MixH2 ( H2 , H1 , 54 ) MixH2 ( H3 , H2 , 32 ) MixH2 ( H0 , H3 , 25 ) MixH2 ( H1 , H0 , 63 ) ! set output HashCode = H0 IF ( PRESENT ( HashHigh )) HashHigh = H1 RETURN END FUNCTION SmallHash !****************************************************************************** SUBROUTINE Spooky_Finalize64 ( HS , Remaining ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SpookyHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tIndex , INTENT ( IN ) :: Remaining !! remaining length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: PartialSize , WholeWords , I tUInt64 :: Partial !** FLOW ASSOCIATE ( H0 => HS % State ( 1 ), H1 => HS % State ( 2 ), H2 => HS % State ( 3 ), & H3 => HS % State ( 4 ), H4 => HS % State ( 5 ), H5 => HS % State ( 6 ), & H6 => HS % State ( 7 ), H7 => HS % State ( 8 ), H8 => HS % State ( 9 ), & H9 => HS % State ( 10 ), H10 => HS % State ( 11 ), H11 => HS % State ( 12 ), & Input => HS % BufArr ) PartialSize = IAND ( Remaining , 7_kIndex ) WholeWords = SHIFTR ( Remaining , 3 ) IF ( PartialSize > 0 ) THEN Partial = PackPartial ( Input , SHIFTL ( WholeWords , 3 ), PartialSize ) SELECT CASE ( WholeWords ) CASE ( 0 ) H0 = H0 + Partial CASE ( 1 ) H1 = H1 + Partial CASE ( 2 ) H2 = H2 + Partial CASE ( 3 ) H3 = H3 + Partial CASE ( 4 ) H4 = H4 + Partial CASE ( 5 ) H5 = H5 + Partial CASE ( 6 ) H6 = H6 + Partial CASE ( 7 ) H7 = H7 + Partial CASE ( 8 ) H8 = H8 + Partial CASE ( 9 ) H9 = H9 + Partial CASE ( 10 ) H10 = H10 + Partial CASE ( 11 ) H11 = H11 + Partial END SELECT END IF ! fall-through is intentional IF ( WholeWords >= 11_kIndex ) H10 = H10 + PackFull ( Input , 80_kIndex ) IF ( WholeWords >= 10_kIndex ) H9 = H9 + PackFull ( Input , 72_kIndex ) IF ( WholeWords >= 9_kIndex ) H8 = H8 + PackFull ( Input , 64_kIndex ) IF ( WholeWords >= 8_kIndex ) H7 = H7 + PackFull ( Input , 56_kIndex ) IF ( WholeWords >= 7_kIndex ) H6 = H6 + PackFull ( Input , 48_kIndex ) IF ( WholeWords >= 6_kIndex ) H5 = H5 + PackFull ( Input , 40_kIndex ) IF ( WholeWords >= 5_kIndex ) H4 = H4 + PackFull ( Input , 32_kIndex ) IF ( WholeWords >= 4_kIndex ) H3 = H3 + PackFull ( Input , 24_kIndex ) IF ( WholeWords >= 3_kIndex ) H2 = H2 + PackFull ( Input , 16_kIndex ) IF ( WholeWords >= 2_kIndex ) H1 = H1 + PackFull ( Input , 8_kIndex ) IF ( WholeWords >= 1_kIndex ) H0 = H0 + PackFull ( Input , 0_kIndex ) H11 = H11 + SHIFTL ( ToInt64 ( Remaining ), 56 ) ! end mixing with 3 iterations DO I = 1 , 3 MixH ( H11 , H1 , H2 , 44 ) MixH ( H0 , H2 , H3 , 15 ) MixH ( H1 , H3 , H4 , 34 ) MixH ( H2 , H4 , H5 , 21 ) MixH ( H3 , H5 , H6 , 38 ) MixH ( H4 , H6 , H7 , 33 ) MixH ( H5 , H7 , H8 , 10 ) MixH ( H6 , H8 , H9 , 13 ) MixH ( H7 , H9 , H10 , 38 ) MixH ( H8 , H10 , H11 , 53 ) MixH ( H9 , H11 , H0 , 42 ) MixH ( H10 , H0 , H1 , 54 ) END DO END ASSOCIATE RETURN END SUBROUTINE Spooky_Finalize64 !****************************************************************************** PURE FUNCTION PackFull ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackFull !****************************************************************************** PURE FUNCTION PackPartial ( Buf , Off , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack seven or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res', in little-endian convention ! (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tIndex , INTENT ( IN ) :: Length ! the number of bytes to pack (between 1 to 7) tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 7 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! pack bytes into word Res = PackFull ( Wrk , 0_kIndex ) RETURN END FUNCTION PackPartial !****************************************************************************** END MODULE MClass_SpookyHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_spookyhasher64.f90.html"},{"title":"MClass_SHA0.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHA0 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHA0* type and its related routines. !   The *SHA0* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SHA0* type implements an incremental cryptographic hash !   function by employing the *SHA-0 message-digest* algorithm [1]. !   The implementation here is mainly based on the *SPHLIB* !   implementation [2].  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Secure_Hash_Algorithms\">Secure !       Hash Algorithms. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SHA0 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DigestLen = 20_kIndex tInteger , PARAMETER :: IV ( 0 : 4 ) = [ & ToInt32 ( Z '67452301' ), ToInt32 ( Z 'EFCDAB89' ), & ToInt32 ( Z '98BADCFE' ), ToInt32 ( Z '10325476' ), & ToInt32 ( Z 'C3D2E1F0' )] !** DERIVED TYPE DEFINITIONS !> *SHA0* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing !  the *SHA-0 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: SHA0 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 4 ) = IV ( 0 : 4 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => SHA0_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA0_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA0_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA0_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA0_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA0_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA0_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA0_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA0_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA0_AddBitsNPad END TYPE SHA0 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHA0_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: MD !! 'SHA0' object !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperInit ( LittleEndian , 8_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE SHA0_Initialize !****************************************************************************** SUBROUTINE SHA0_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: MD !! 'SHA0' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % State = IV CALL MD % HelperReset () RETURN END SUBROUTINE SHA0_Reset !****************************************************************************** SUBROUTINE SHA0_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHA0 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHA0 ) CALL Dst % Create () Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE SHA0_GetClone !****************************************************************************** FUNCTION SHA0_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( IN ) :: MD !! 'SHA0' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'SHA-0' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA0_GetName !****************************************************************************** FUNCTION SHA0_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( IN ) :: MD !! 'SHA0' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = DigestLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA0_GetDigestLen !****************************************************************************** FUNCTION SHA0_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( IN ) :: MD !! 'SHA0' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA0_GetBlockLen !****************************************************************************** SUBROUTINE SHA0_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), TARGET , INTENT ( INOUT ) :: MD !! 'SHA0' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SHA0_SetBufPtr !****************************************************************************** SUBROUTINE SHA0_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: MD !! 'SHA0' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: tInteger , PARAMETER :: K1 = ToInt32 ( Z '5A827999' ) tInteger , PARAMETER :: K2 = ToInt32 ( Z '6ED9EBA1' ) tInteger , PARAMETER :: K3 = ToInt32 ( Z '8F1BBCDC' ) tInteger , PARAMETER :: K4 = ToInt32 ( Z 'CA62C1D6' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D , E tInteger :: W ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define FRound(X, Y, Z)     IEOR(IAND(IEOR(Y, Z), X), Z) #define GRound(X, Y, Z)     IEOR(IEOR(X, Y), Z) #define HRound(X, Y, Z)     IOR(IAND(Z, Y), IAND(IOR(Z, Y), X)) #define IRound(X, Y, Z)     GRound(X, Y, Z) #define XOR4(A, B, C, D)    IEOR(IEOR(IEOR(A, B), C), D) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) E = MD % State ( 4 ) CALL BytePackBE ( BytesIn , 0_kIndex , W ) ! F round E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 0 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 1 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 2 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 3 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 4 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 5 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 6 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 7 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 8 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 9 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 10 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 11 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 12 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 13 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 14 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 15 ) + K1 B = RotateLeft ( B , 30 ) W ( 0 ) = XOR4 ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 0 ) + K1 A = RotateLeft ( A , 30 ) W ( 1 ) = XOR4 ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 1 ) + K1 E = RotateLeft ( E , 30 ) W ( 2 ) = XOR4 ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 2 ) + K1 D = RotateLeft ( D , 30 ) W ( 3 ) = XOR4 ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 3 ) + K1 C = RotateLeft ( C , 30 ) ! G round W ( 4 ) = XOR4 ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 4 ) + K2 B = RotateLeft ( B , 30 ) W ( 5 ) = XOR4 ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 5 ) + K2 A = RotateLeft ( A , 30 ) W ( 6 ) = XOR4 ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 6 ) + K2 E = RotateLeft ( E , 30 ) W ( 7 ) = XOR4 ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 7 ) + K2 D = RotateLeft ( D , 30 ) W ( 8 ) = XOR4 ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 8 ) + K2 C = RotateLeft ( C , 30 ) W ( 9 ) = XOR4 ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 9 ) + K2 B = RotateLeft ( B , 30 ) W ( 10 ) = XOR4 ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 10 ) + K2 A = RotateLeft ( A , 30 ) W ( 11 ) = XOR4 ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 11 ) + K2 E = RotateLeft ( E , 30 ) W ( 12 ) = XOR4 ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 12 ) + K2 D = RotateLeft ( D , 30 ) W ( 13 ) = XOR4 ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 13 ) + K2 C = RotateLeft ( C , 30 ) W ( 14 ) = XOR4 ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 14 ) + K2 B = RotateLeft ( B , 30 ) W ( 15 ) = XOR4 ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 15 ) + K2 A = RotateLeft ( A , 30 ) W ( 0 ) = XOR4 ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 0 ) + K2 E = RotateLeft ( E , 30 ) W ( 1 ) = XOR4 ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 1 ) + K2 D = RotateLeft ( D , 30 ) W ( 2 ) = XOR4 ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 2 ) + K2 C = RotateLeft ( C , 30 ) W ( 3 ) = XOR4 ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 3 ) + K2 B = RotateLeft ( B , 30 ) W ( 4 ) = XOR4 ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 4 ) + K2 A = RotateLeft ( A , 30 ) W ( 5 ) = XOR4 ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 5 ) + K2 E = RotateLeft ( E , 30 ) W ( 6 ) = XOR4 ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 6 ) + K2 D = RotateLeft ( D , 30 ) W ( 7 ) = XOR4 ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 7 ) + K2 C = RotateLeft ( C , 30 ) ! H round W ( 8 ) = XOR4 ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 8 ) + K3 B = RotateLeft ( B , 30 ) W ( 9 ) = XOR4 ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 9 ) + K3 A = RotateLeft ( A , 30 ) W ( 10 ) = XOR4 ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 10 ) + K3 E = RotateLeft ( E , 30 ) W ( 11 ) = XOR4 ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 11 ) + K3 D = RotateLeft ( D , 30 ) W ( 12 ) = XOR4 ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 12 ) + K3 C = RotateLeft ( C , 30 ) W ( 13 ) = XOR4 ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 13 ) + K3 B = RotateLeft ( B , 30 ) W ( 14 ) = XOR4 ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 14 ) + K3 A = RotateLeft ( A , 30 ) W ( 15 ) = XOR4 ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 15 ) + K3 E = RotateLeft ( E , 30 ) W ( 0 ) = XOR4 ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 0 ) + K3 D = RotateLeft ( D , 30 ) W ( 1 ) = XOR4 ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 1 ) + K3 C = RotateLeft ( C , 30 ) W ( 2 ) = XOR4 ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 2 ) + K3 B = RotateLeft ( B , 30 ) W ( 3 ) = XOR4 ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 3 ) + K3 A = RotateLeft ( A , 30 ) W ( 4 ) = XOR4 ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 4 ) + K3 E = RotateLeft ( E , 30 ) W ( 5 ) = XOR4 ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 5 ) + K3 D = RotateLeft ( D , 30 ) W ( 6 ) = XOR4 ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 6 ) + K3 C = RotateLeft ( C , 30 ) W ( 7 ) = XOR4 ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 7 ) + K3 B = RotateLeft ( B , 30 ) W ( 8 ) = XOR4 ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 8 ) + K3 A = RotateLeft ( A , 30 ) W ( 9 ) = XOR4 ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 9 ) + K3 E = RotateLeft ( E , 30 ) W ( 10 ) = XOR4 ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 10 ) + K3 D = RotateLeft ( D , 30 ) W ( 11 ) = XOR4 ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 11 ) + K3 C = RotateLeft ( C , 30 ) ! I round where IRound = GRound W ( 12 ) = XOR4 ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 12 ) + K4 B = RotateLeft ( B , 30 ) W ( 13 ) = XOR4 ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 13 ) + K4 A = RotateLeft ( A , 30 ) W ( 14 ) = XOR4 ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 14 ) + K4 E = RotateLeft ( E , 30 ) W ( 15 ) = XOR4 ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 15 ) + K4 D = RotateLeft ( D , 30 ) W ( 0 ) = XOR4 ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 0 ) + K4 C = RotateLeft ( C , 30 ) W ( 1 ) = XOR4 ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 1 ) + K4 B = RotateLeft ( B , 30 ) W ( 2 ) = XOR4 ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 2 ) + K4 A = RotateLeft ( A , 30 ) W ( 3 ) = XOR4 ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 3 ) + K4 E = RotateLeft ( E , 30 ) W ( 4 ) = XOR4 ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 4 ) + K4 D = RotateLeft ( D , 30 ) W ( 5 ) = XOR4 ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 5 ) + K4 C = RotateLeft ( C , 30 ) W ( 6 ) = XOR4 ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 6 ) + K4 B = RotateLeft ( B , 30 ) W ( 7 ) = XOR4 ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 7 ) + K4 A = RotateLeft ( A , 30 ) W ( 8 ) = XOR4 ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 8 ) + K4 E = RotateLeft ( E , 30 ) W ( 9 ) = XOR4 ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 9 ) + K4 D = RotateLeft ( D , 30 ) W ( 10 ) = XOR4 ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 10 ) + K4 C = RotateLeft ( C , 30 ) W ( 11 ) = XOR4 ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 11 ) + K4 B = RotateLeft ( B , 30 ) W ( 12 ) = XOR4 ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 12 ) + K4 A = RotateLeft ( A , 30 ) W ( 13 ) = XOR4 ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 13 ) + K4 E = RotateLeft ( E , 30 ) W ( 14 ) = XOR4 ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 14 ) + K4 D = RotateLeft ( D , 30 ) W ( 15 ) = XOR4 ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 15 ) + K4 C = RotateLeft ( C , 30 ) MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D MD % State ( 4 ) = MD % State ( 4 ) + E RETURN #undef FRound #undef GRound #undef HRound #undef IRound #undef XOR4 END SUBROUTINE SHA0_ProcessBlock !****************************************************************************** SUBROUTINE SHA0_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: MD !! 'SHA0' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperPadding () CALL ByteUnpackBE ( MD % State , BytesOut , Offset ) RETURN END SUBROUTINE SHA0_DoPadding !****************************************************************************** SUBROUTINE SHA0_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA0 ), INTENT ( INOUT ) :: MD !! 'SHA0' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! SHA-0 algorithm does not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE SHA0_AddBitsNPad !****************************************************************************** END MODULE MClass_SHA0 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_sha0.f90.html"},{"title":"MClass_SHA2S.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHA2S !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHA2S* type and its related routines. !   The *SHA2S* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SHA2S* type implements an incremental cryptographic hash !   function by employing the *SHA-224 or SHA-256 message-digest* !   algorithm where both algorithms are described in FIPS 180-4 [1]. !   The implementation here is mainly based on the references [2, 3].  <br> !   By default, the *SHA2S* type employs the *SHA-256 message-digest* !   algorithm.  However, a user can specify the *IsSHA224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SHA-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028%2FNIST.FIPS.180-4\">FIPS PUB 180-4: !       Secure Hash Standard (SHS). </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !   [3] <a href=\"https://github.com/bcgit/bc-java\">The Bouncy Castle Crypto !       Package For Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SHA2S PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: IV224 ( 0 : 7 ) = [ & ToInt32 ( Z 'C1059ED8' ), ToInt32 ( Z '367CD507' ), & ToInt32 ( Z '3070DD17' ), ToInt32 ( Z 'F70E5939' ), & ToInt32 ( Z 'FFC00B31' ), ToInt32 ( Z '68581511' ), & ToInt32 ( Z '64F98FA7' ), ToInt32 ( Z 'BEFA4FA4' )] tInteger , PARAMETER :: IV256 ( 0 : 7 ) = [ & ToInt32 ( Z '6A09E667' ), ToInt32 ( Z 'BB67AE85' ), & ToInt32 ( Z '3C6EF372' ), ToInt32 ( Z 'A54FF53A' ), & ToInt32 ( Z '510E527F' ), ToInt32 ( Z '9B05688C' ), & ToInt32 ( Z '1F83D9AB' ), ToInt32 ( Z '5BE0CD19' )] tInteger , PARAMETER :: K ( 0 : 63 ) = [ & ToInt32 ( Z '428A2F98' ), ToInt32 ( Z '71374491' ), ToInt32 ( Z 'B5C0FBCF' ), ToInt32 ( Z 'E9B5DBA5' ), & ToInt32 ( Z '3956C25B' ), ToInt32 ( Z '59F111F1' ), ToInt32 ( Z '923F82A4' ), ToInt32 ( Z 'AB1C5ED5' ), & ToInt32 ( Z 'D807AA98' ), ToInt32 ( Z '12835B01' ), ToInt32 ( Z '243185BE' ), ToInt32 ( Z '550C7DC3' ), & ToInt32 ( Z '72BE5D74' ), ToInt32 ( Z '80DEB1FE' ), ToInt32 ( Z '9BDC06A7' ), ToInt32 ( Z 'C19BF174' ), & ToInt32 ( Z 'E49B69C1' ), ToInt32 ( Z 'EFBE4786' ), ToInt32 ( Z '0FC19DC6' ), ToInt32 ( Z '240CA1CC' ), & ToInt32 ( Z '2DE92C6F' ), ToInt32 ( Z '4A7484AA' ), ToInt32 ( Z '5CB0A9DC' ), ToInt32 ( Z '76F988DA' ), & ToInt32 ( Z '983E5152' ), ToInt32 ( Z 'A831C66D' ), ToInt32 ( Z 'B00327C8' ), ToInt32 ( Z 'BF597FC7' ), & ToInt32 ( Z 'C6E00BF3' ), ToInt32 ( Z 'D5A79147' ), ToInt32 ( Z '06CA6351' ), ToInt32 ( Z '14292967' ), & ToInt32 ( Z '27B70A85' ), ToInt32 ( Z '2E1B2138' ), ToInt32 ( Z '4D2C6DFC' ), ToInt32 ( Z '53380D13' ), & ToInt32 ( Z '650A7354' ), ToInt32 ( Z '766A0ABB' ), ToInt32 ( Z '81C2C92E' ), ToInt32 ( Z '92722C85' ), & ToInt32 ( Z 'A2BFE8A1' ), ToInt32 ( Z 'A81A664B' ), ToInt32 ( Z 'C24B8B70' ), ToInt32 ( Z 'C76C51A3' ), & ToInt32 ( Z 'D192E819' ), ToInt32 ( Z 'D6990624' ), ToInt32 ( Z 'F40E3585' ), ToInt32 ( Z '106AA070' ), & ToInt32 ( Z '19A4C116' ), ToInt32 ( Z '1E376C08' ), ToInt32 ( Z '2748774C' ), ToInt32 ( Z '34B0BCB5' ), & ToInt32 ( Z '391C0CB3' ), ToInt32 ( Z '4ED8AA4A' ), ToInt32 ( Z '5B9CCA4F' ), ToInt32 ( Z '682E6FF3' ), & ToInt32 ( Z '748F82EE' ), ToInt32 ( Z '78A5636F' ), ToInt32 ( Z '84C87814' ), ToInt32 ( Z '8CC70208' ), & ToInt32 ( Z '90BEFFFA' ), ToInt32 ( Z 'A4506CEB' ), ToInt32 ( Z 'BEF9A3F7' ), ToInt32 ( Z 'C67178F2' )] !** DERIVED TYPE DEFINITIONS !> *SHA2B* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either the !  *SHA-224* or the *SHA-256 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: SHA2S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 7 ) = IV256 ( 0 : 7 ) !% flag indicating whether the SHA-224 algorithm is employed or not. tLogical :: IsSHA224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SHA2S_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA-256). PROCEDURE :: Initialize => SHA2S_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA2S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA2S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA2S_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA2S_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA2S_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA2S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA2S_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA2S_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA2S_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA-224 algorithm <br> !   --->    CALL MD%Create(IsSHA224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag END TYPE SHA2S !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHA2S_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHA-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SHA2S_Initialize !****************************************************************************** SUBROUTINE SHA2S_Initialize_wFlag ( MD , IsSHA224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object tLogical , INTENT ( IN ) :: IsSHA224 !&#94; flag indicating whether the SHA-224 algorithm is employed or not. <br> !  - If true, use the SHA-224 algorithm. <br> !  - Otherwise, use the SHA-256 algorithm. <br> !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSHA224 = IsSHA224 CALL MD % HelperInit ( LittleEndian , 8_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE SHA2S_Initialize_wFlag !****************************************************************************** SUBROUTINE SHA2S_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsSHA224 ) THEN MD % State = IV224 ELSE MD % State = IV256 END IF CALL MD % HelperReset () RETURN END SUBROUTINE SHA2S_Reset !****************************************************************************** SUBROUTINE SHA2S_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHA2S :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHA2S ) CALL Dst % Create ( Src % IsSHA224 ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE SHA2S_GetClone !****************************************************************************** FUNCTION SHA2S_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( IN ) :: MD !! 'SHA2S' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHA224 ) THEN Name = 'SHA-224' ELSE Name = 'SHA-256' END IF RETURN END FUNCTION SHA2S_GetName !****************************************************************************** FUNCTION SHA2S_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( IN ) :: MD !! 'SHA2S' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHA224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION SHA2S_GetDigestLen !****************************************************************************** FUNCTION SHA2S_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( IN ) :: MD !! 'SHA2S' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA2S_GetBlockLen !****************************************************************************** SUBROUTINE SHA2S_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), TARGET , INTENT ( INOUT ) :: MD !! 'SHA2S' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SHA2S_SetBufPtr !****************************************************************************** SUBROUTINE SHA2S_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D , E , F , G , H tInteger :: T1 , T2 tInteger :: W ( 0 : 63 ) tIndex :: I , J !** SUBROUTINE MACRO DEFINITIONS: #define BSigma0(X)      IEOR(IEOR(RotateLeft(X, 30), RotateLeft(X, 19)), RotateLeft(X, 10)) #define BSigma1(X)      IEOR(IEOR(RotateLeft(X, 26), RotateLeft(X, 21)), RotateLeft(X, 7)) #define SSigma0(X)      IEOR(IEOR(RotateLeft(X, 25), RotateLeft(X, 14)), SHIFTR(X, 3)) #define SSigma1(X)      IEOR(IEOR(RotateLeft(X, 15), RotateLeft(X, 13)), SHIFTR(X, 10)) #define CH(X, Y, Z)     IEOR(IAND(IEOR(Y, Z), X), Z) #define MAJ(X, Y, Z)    IOR(IAND(Y, Z), IAND(IOR(Y, Z), X)) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) E = MD % State ( 4 ) F = MD % State ( 5 ) G = MD % State ( 6 ) H = MD % State ( 7 ) CALL BytePackBE ( BytesIn , 0_kIndex , W ( 0 : 15 )) DO J = 16 , 63 W ( J ) = SSigma1 ( W ( J - 2 )) + W ( J - 7 ) + SSigma0 ( W ( J - 15 )) + W ( J - 16 ) END DO DO I = 0 , 63 T1 = H + BSigma1 ( E ) + CH ( E , F , G ) + K ( I ) + W ( I ) T2 = BSigma0 ( A ) + MAJ ( A , B , C ) H = G G = F F = E E = D + T1 D = C C = B B = A A = T1 + T2 END DO MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D MD % State ( 4 ) = MD % State ( 4 ) + E MD % State ( 5 ) = MD % State ( 5 ) + F MD % State ( 6 ) = MD % State ( 6 ) + G MD % State ( 7 ) = MD % State ( 7 ) + H RETURN #undef BSigma0 #undef BSigma1 #undef SSigma0 #undef SSigma1 #undef CH #undef MAJ END SUBROUTINE SHA2S_ProcessBlock !****************************************************************************** SUBROUTINE SHA2S_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW CALL MD % HelperPadding () DO I = 0_kIndex , ( MD % GetDigestLen () / 4_kIndex - 1_kIndex ) CALL ByteUnpackBE ( MD % State ( I ), BytesOut , Offset + 4_kIndex * I ) END DO RETURN END SUBROUTINE SHA2S_DoPadding !****************************************************************************** SUBROUTINE SHA2S_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2S ), INTENT ( INOUT ) :: MD !! 'SHA2S' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! SHA-2 algorithms do not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE SHA2S_AddBitsNPad !****************************************************************************** END MODULE MClass_SHA2S !******************************************************************************","tags":"","loc":"sourcefile\\mclass_sha2s.f90.html"},{"title":"MClass_GroestlB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_GroestlB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *GroestlB* type and its related routines. !   The *GroestlB* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *GroestlB* type implements an incremental cryptographic hash function !   by employing either the *Groestl-384* or the *Groestl-512 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *GroestlB* type employs the *Groestl-512 message-digest* !   algorithm.  However, a user can specify the *IsGroestl384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *Groestl-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"http://www.groestl.info/\">Grostl - a SHA-3 candidate. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine USE MClass_GroestlS , ONLY : T0 , T1 , T2 , T3 , T4 , T5 , T6 , T7 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: GroestlB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #define BX64(X, Pos)    ToInt32(SHIFTR(X, Pos)) #define BY64(X, Pos)    IAND(ToInt32(SHIFTR(X, Pos)), ToInt32(Z'000000FF')) #define RBTT(A, I0, I1, I2, I3, I4, I5, I6, I7) \\ IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( T0 ( BX64 ( A ( I0 ), 56 )), \\ T1 ( BY64 ( A ( I1 ), 48 ))), \\ T2 ( BY64 ( A ( I2 ), 40 ))), \\ T3 ( BY64 ( A ( I3 ), 32 ))), \\ T4 ( BY64 ( A ( I4 ), 24 ))), \\ T5 ( BY64 ( A ( I5 ), 16 ))), \\ T6 ( BY64 ( A ( I6 ), 8 ))), \\ T7 ( BY64 ( A ( I7 ), 0 ))) #define PC64(A, J, R)   IEOR(A, SHIFTL(ToInt64(J + R), 56)) #define QC64(A, J, R)   IEOR(A, IEOR(-ToInt64(J), ToInt64(R))) !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *GroestlB* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *Groestl-384* or the *Groestl-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: GroestlB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 15 ) = 0_kInt64 !% flag indicating whether the Groestl-384 algorithm is employed or not. tLogical :: IsGroestl384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => GroestlB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Groestl-512). PROCEDURE :: Initialize => GroestlB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => GroestlB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => GroestlB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => GroestlB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => GroestlB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => GroestlB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => GroestlB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => GroestlB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => GroestlB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => GroestlB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Groestl-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Groestl-384 algorithm <br> !   --->    CALL MD%Create(IsGroestl384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE GroestlB !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE GroestlB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the Groestl-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE GroestlB_Initialize !****************************************************************************** SUBROUTINE GroestlB_Initialize_wFlag ( MD , IsGroestl384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object tLogical , INTENT ( IN ) :: IsGroestl384 !&#94; flag indicating whether the Groestl-384 algorithm is employed or not. <br> !  - If true, use the Groestl-384 algorithm. <br> !  - Otherwise, use the Groestl-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsGroestl384 = IsGroestl384 CALL MD % Reset () RETURN END SUBROUTINE GroestlB_Initialize_wFlag !****************************************************************************** SUBROUTINE GroestlB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % H ( 0 : 14 ) = 0_kInt64 MD % H ( 15 ) = SHIFTL ( ToInt64 ( MD % GetDigestLen ()), 3 ) CALL MD % EngineReset () RETURN END SUBROUTINE GroestlB_Reset !****************************************************************************** SUBROUTINE GroestlB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( GroestlB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( GroestlB ) CALL Dst % Create ( Src % IsGroestl384 ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE GroestlB_GetClone !****************************************************************************** FUNCTION GroestlB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( IN ) :: MD !! 'GroestlB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsGroestl384 ) THEN Name = 'Groestl-384' ELSE Name = 'Groestl-512' END IF RETURN END FUNCTION GroestlB_GetName !****************************************************************************** FUNCTION GroestlB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( IN ) :: MD !! 'GroestlB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsGroestl384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION GroestlB_GetDigestLen !****************************************************************************** FUNCTION GroestlB_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( IN ) :: MD !! 'GroestlB' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION GroestlB_GetBlockLen !****************************************************************************** SUBROUTINE GroestlB_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), TARGET , INTENT ( INOUT ) :: MD !! 'GroestlB' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE GroestlB_SetBufPtr !****************************************************************************** SUBROUTINE GroestlB_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: G ( 0 : 15 ) tLong :: MS ( 0 : 15 ) tIndex :: I ! FLOW ! input block CALL BytePackBE ( BytesIn , 0_kIndex , MS ) DO I = 0 , 15 G ( I ) = IEOR ( MS ( I ), MD % H ( I )) END DO ! perform permutations CALL DoPermP ( G ) CALL DoPermQ ( MS ) ! get output states DO I = 0 , 15 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR ( G ( I ), MS ( I ))) END DO RETURN CONTAINS SUBROUTINE DoPermQ ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To perform permutation Q. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T ( 0 : 15 ) tInteger :: R , RP1 ! FLOW DO R = 0 , 13 , 2 X ( 0 ) = QC64 ( X ( 0 ), ToInt32 ( Z '00000001' ), R ) X ( 1 ) = QC64 ( X ( 1 ), ToInt32 ( Z '00000011' ), R ) X ( 2 ) = QC64 ( X ( 2 ), ToInt32 ( Z '00000021' ), R ) X ( 3 ) = QC64 ( X ( 3 ), ToInt32 ( Z '00000031' ), R ) X ( 4 ) = QC64 ( X ( 4 ), ToInt32 ( Z '00000041' ), R ) X ( 5 ) = QC64 ( X ( 5 ), ToInt32 ( Z '00000051' ), R ) X ( 6 ) = QC64 ( X ( 6 ), ToInt32 ( Z '00000061' ), R ) X ( 7 ) = QC64 ( X ( 7 ), ToInt32 ( Z '00000071' ), R ) X ( 8 ) = QC64 ( X ( 8 ), ToInt32 ( Z '00000081' ), R ) X ( 9 ) = QC64 ( X ( 9 ), ToInt32 ( Z '00000091' ), R ) X ( 10 ) = QC64 ( X ( 10 ), ToInt32 ( Z '000000A1' ), R ) X ( 11 ) = QC64 ( X ( 11 ), ToInt32 ( Z '000000B1' ), R ) X ( 12 ) = QC64 ( X ( 12 ), ToInt32 ( Z '000000C1' ), R ) X ( 13 ) = QC64 ( X ( 13 ), ToInt32 ( Z '000000D1' ), R ) X ( 14 ) = QC64 ( X ( 14 ), ToInt32 ( Z '000000E1' ), R ) X ( 15 ) = QC64 ( X ( 15 ), ToInt32 ( Z '000000F1' ), R ) T ( 0 ) = RBTT ( X , 1 , 3 , 5 , 11 , 0 , 2 , 4 , 6 ) T ( 1 ) = RBTT ( X , 2 , 4 , 6 , 12 , 1 , 3 , 5 , 7 ) T ( 2 ) = RBTT ( X , 3 , 5 , 7 , 13 , 2 , 4 , 6 , 8 ) T ( 3 ) = RBTT ( X , 4 , 6 , 8 , 14 , 3 , 5 , 7 , 9 ) T ( 4 ) = RBTT ( X , 5 , 7 , 9 , 15 , 4 , 6 , 8 , 10 ) T ( 5 ) = RBTT ( X , 6 , 8 , 10 , 0 , 5 , 7 , 9 , 11 ) T ( 6 ) = RBTT ( X , 7 , 9 , 11 , 1 , 6 , 8 , 10 , 12 ) T ( 7 ) = RBTT ( X , 8 , 10 , 12 , 2 , 7 , 9 , 11 , 13 ) T ( 8 ) = RBTT ( X , 9 , 11 , 13 , 3 , 8 , 10 , 12 , 14 ) T ( 9 ) = RBTT ( X , 10 , 12 , 14 , 4 , 9 , 11 , 13 , 15 ) T ( 10 ) = RBTT ( X , 11 , 13 , 15 , 5 , 10 , 12 , 14 , 0 ) T ( 11 ) = RBTT ( X , 12 , 14 , 0 , 6 , 11 , 13 , 15 , 1 ) T ( 12 ) = RBTT ( X , 13 , 15 , 1 , 7 , 12 , 14 , 0 , 2 ) T ( 13 ) = RBTT ( X , 14 , 0 , 2 , 8 , 13 , 15 , 1 , 3 ) T ( 14 ) = RBTT ( X , 15 , 1 , 3 , 9 , 14 , 0 , 2 , 4 ) T ( 15 ) = RBTT ( X , 0 , 2 , 4 , 10 , 15 , 1 , 3 , 5 ) RP1 = R + 1 T ( 0 ) = QC64 ( T ( 0 ), ToInt32 ( Z '00000001' ), RP1 ) T ( 1 ) = QC64 ( T ( 1 ), ToInt32 ( Z '00000011' ), RP1 ) T ( 2 ) = QC64 ( T ( 2 ), ToInt32 ( Z '00000021' ), RP1 ) T ( 3 ) = QC64 ( T ( 3 ), ToInt32 ( Z '00000031' ), RP1 ) T ( 4 ) = QC64 ( T ( 4 ), ToInt32 ( Z '00000041' ), RP1 ) T ( 5 ) = QC64 ( T ( 5 ), ToInt32 ( Z '00000051' ), RP1 ) T ( 6 ) = QC64 ( T ( 6 ), ToInt32 ( Z '00000061' ), RP1 ) T ( 7 ) = QC64 ( T ( 7 ), ToInt32 ( Z '00000071' ), RP1 ) T ( 8 ) = QC64 ( T ( 8 ), ToInt32 ( Z '00000081' ), RP1 ) T ( 9 ) = QC64 ( T ( 9 ), ToInt32 ( Z '00000091' ), RP1 ) T ( 10 ) = QC64 ( T ( 10 ), ToInt32 ( Z '000000A1' ), RP1 ) T ( 11 ) = QC64 ( T ( 11 ), ToInt32 ( Z '000000B1' ), RP1 ) T ( 12 ) = QC64 ( T ( 12 ), ToInt32 ( Z '000000C1' ), RP1 ) T ( 13 ) = QC64 ( T ( 13 ), ToInt32 ( Z '000000D1' ), RP1 ) T ( 14 ) = QC64 ( T ( 14 ), ToInt32 ( Z '000000E1' ), RP1 ) T ( 15 ) = QC64 ( T ( 15 ), ToInt32 ( Z '000000F1' ), RP1 ) X ( 0 ) = RBTT ( T , 1 , 3 , 5 , 11 , 0 , 2 , 4 , 6 ) X ( 1 ) = RBTT ( T , 2 , 4 , 6 , 12 , 1 , 3 , 5 , 7 ) X ( 2 ) = RBTT ( T , 3 , 5 , 7 , 13 , 2 , 4 , 6 , 8 ) X ( 3 ) = RBTT ( T , 4 , 6 , 8 , 14 , 3 , 5 , 7 , 9 ) X ( 4 ) = RBTT ( T , 5 , 7 , 9 , 15 , 4 , 6 , 8 , 10 ) X ( 5 ) = RBTT ( T , 6 , 8 , 10 , 0 , 5 , 7 , 9 , 11 ) X ( 6 ) = RBTT ( T , 7 , 9 , 11 , 1 , 6 , 8 , 10 , 12 ) X ( 7 ) = RBTT ( T , 8 , 10 , 12 , 2 , 7 , 9 , 11 , 13 ) X ( 8 ) = RBTT ( T , 9 , 11 , 13 , 3 , 8 , 10 , 12 , 14 ) X ( 9 ) = RBTT ( T , 10 , 12 , 14 , 4 , 9 , 11 , 13 , 15 ) X ( 10 ) = RBTT ( T , 11 , 13 , 15 , 5 , 10 , 12 , 14 , 0 ) X ( 11 ) = RBTT ( T , 12 , 14 , 0 , 6 , 11 , 13 , 15 , 1 ) X ( 12 ) = RBTT ( T , 13 , 15 , 1 , 7 , 12 , 14 , 0 , 2 ) X ( 13 ) = RBTT ( T , 14 , 0 , 2 , 8 , 13 , 15 , 1 , 3 ) X ( 14 ) = RBTT ( T , 15 , 1 , 3 , 9 , 14 , 0 , 2 , 4 ) X ( 15 ) = RBTT ( T , 0 , 2 , 4 , 10 , 15 , 1 , 3 , 5 ) END DO RETURN END SUBROUTINE DoPermQ !************************************************************************** END SUBROUTINE GroestlB_ProcessBlock !****************************************************************************** SUBROUTINE DoPermP ( X ) !** PURPOSE OF THIS SUBROUTINE: ! To perform permutation P. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: X ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T ( 0 : 15 ) tInteger :: R , RP1 ! FLOW DO R = 0 , 13 , 2 X ( 0 ) = PC64 ( X ( 0 ), ToInt32 ( Z '00000000' ), R ) X ( 1 ) = PC64 ( X ( 1 ), ToInt32 ( Z '00000010' ), R ) X ( 2 ) = PC64 ( X ( 2 ), ToInt32 ( Z '00000020' ), R ) X ( 3 ) = PC64 ( X ( 3 ), ToInt32 ( Z '00000030' ), R ) X ( 4 ) = PC64 ( X ( 4 ), ToInt32 ( Z '00000040' ), R ) X ( 5 ) = PC64 ( X ( 5 ), ToInt32 ( Z '00000050' ), R ) X ( 6 ) = PC64 ( X ( 6 ), ToInt32 ( Z '00000060' ), R ) X ( 7 ) = PC64 ( X ( 7 ), ToInt32 ( Z '00000070' ), R ) X ( 8 ) = PC64 ( X ( 8 ), ToInt32 ( Z '00000080' ), R ) X ( 9 ) = PC64 ( X ( 9 ), ToInt32 ( Z '00000090' ), R ) X ( 10 ) = PC64 ( X ( 10 ), ToInt32 ( Z '000000A0' ), R ) X ( 11 ) = PC64 ( X ( 11 ), ToInt32 ( Z '000000B0' ), R ) X ( 12 ) = PC64 ( X ( 12 ), ToInt32 ( Z '000000C0' ), R ) X ( 13 ) = PC64 ( X ( 13 ), ToInt32 ( Z '000000D0' ), R ) X ( 14 ) = PC64 ( X ( 14 ), ToInt32 ( Z '000000E0' ), R ) X ( 15 ) = PC64 ( X ( 15 ), ToInt32 ( Z '000000F0' ), R ) T ( 0 ) = RBTT ( X , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 11 ) T ( 1 ) = RBTT ( X , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 12 ) T ( 2 ) = RBTT ( X , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 13 ) T ( 3 ) = RBTT ( X , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 14 ) T ( 4 ) = RBTT ( X , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 15 ) T ( 5 ) = RBTT ( X , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 0 ) T ( 6 ) = RBTT ( X , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 1 ) T ( 7 ) = RBTT ( X , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 2 ) T ( 8 ) = RBTT ( X , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 3 ) T ( 9 ) = RBTT ( X , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 4 ) T ( 10 ) = RBTT ( X , 10 , 11 , 12 , 13 , 14 , 15 , 0 , 5 ) T ( 11 ) = RBTT ( X , 11 , 12 , 13 , 14 , 15 , 0 , 1 , 6 ) T ( 12 ) = RBTT ( X , 12 , 13 , 14 , 15 , 0 , 1 , 2 , 7 ) T ( 13 ) = RBTT ( X , 13 , 14 , 15 , 0 , 1 , 2 , 3 , 8 ) T ( 14 ) = RBTT ( X , 14 , 15 , 0 , 1 , 2 , 3 , 4 , 9 ) T ( 15 ) = RBTT ( X , 15 , 0 , 1 , 2 , 3 , 4 , 5 , 10 ) RP1 = R + 1 T ( 0 ) = PC64 ( T ( 0 ), ToInt32 ( Z '00000000' ), RP1 ) T ( 1 ) = PC64 ( T ( 1 ), ToInt32 ( Z '00000010' ), RP1 ) T ( 2 ) = PC64 ( T ( 2 ), ToInt32 ( Z '00000020' ), RP1 ) T ( 3 ) = PC64 ( T ( 3 ), ToInt32 ( Z '00000030' ), RP1 ) T ( 4 ) = PC64 ( T ( 4 ), ToInt32 ( Z '00000040' ), RP1 ) T ( 5 ) = PC64 ( T ( 5 ), ToInt32 ( Z '00000050' ), RP1 ) T ( 6 ) = PC64 ( T ( 6 ), ToInt32 ( Z '00000060' ), RP1 ) T ( 7 ) = PC64 ( T ( 7 ), ToInt32 ( Z '00000070' ), RP1 ) T ( 8 ) = PC64 ( T ( 8 ), ToInt32 ( Z '00000080' ), RP1 ) T ( 9 ) = PC64 ( T ( 9 ), ToInt32 ( Z '00000090' ), RP1 ) T ( 10 ) = PC64 ( T ( 10 ), ToInt32 ( Z '000000A0' ), RP1 ) T ( 11 ) = PC64 ( T ( 11 ), ToInt32 ( Z '000000B0' ), RP1 ) T ( 12 ) = PC64 ( T ( 12 ), ToInt32 ( Z '000000C0' ), RP1 ) T ( 13 ) = PC64 ( T ( 13 ), ToInt32 ( Z '000000D0' ), RP1 ) T ( 14 ) = PC64 ( T ( 14 ), ToInt32 ( Z '000000E0' ), RP1 ) T ( 15 ) = PC64 ( T ( 15 ), ToInt32 ( Z '000000F0' ), RP1 ) X ( 0 ) = RBTT ( T , 0 , 1 , 2 , 3 , 4 , 5 , 6 , 11 ) X ( 1 ) = RBTT ( T , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 12 ) X ( 2 ) = RBTT ( T , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 13 ) X ( 3 ) = RBTT ( T , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 14 ) X ( 4 ) = RBTT ( T , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 15 ) X ( 5 ) = RBTT ( T , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 0 ) X ( 6 ) = RBTT ( T , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 1 ) X ( 7 ) = RBTT ( T , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 2 ) X ( 8 ) = RBTT ( T , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 3 ) X ( 9 ) = RBTT ( T , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 4 ) X ( 10 ) = RBTT ( T , 10 , 11 , 12 , 13 , 14 , 15 , 0 , 5 ) X ( 11 ) = RBTT ( T , 11 , 12 , 13 , 14 , 15 , 0 , 1 , 6 ) X ( 12 ) = RBTT ( T , 12 , 13 , 14 , 15 , 0 , 1 , 2 , 7 ) X ( 13 ) = RBTT ( T , 13 , 14 , 15 , 0 , 1 , 2 , 3 , 8 ) X ( 14 ) = RBTT ( T , 14 , 15 , 0 , 1 , 2 , 3 , 4 , 9 ) X ( 15 ) = RBTT ( T , 15 , 0 , 1 , 2 , 3 , 4 , 5 , 10 ) END DO RETURN END SUBROUTINE DoPermP !****************************************************************************** SUBROUTINE GroestlB_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE GroestlB_DoPadding !****************************************************************************** SUBROUTINE GroestlB_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GroestlB ), INTENT ( INOUT ) :: MD !! 'GroestlB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: G ( 0 : 15 ) tIndex :: I , Ptr , DLen tLong :: Count tByte :: Z ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex Count = MD % GetBlockCount () IF ( Ptr <= 120_kIndex ) THEN TmpBuf ( Ptr : 119 ) = FByte00 Count = Count + 1_kInt64 ELSE TmpBuf ( Ptr : 127 ) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) TmpBuf ( 0 : 119 ) = FByte00 Count = Count + 2_kInt64 END IF CALL ByteUnpackBE ( Count , TmpBuf , 120_kIndex ) CALL MD % ProcessBlock ( TmpBuf ) G = MD % H CALL DoPermP ( G ) DO I = 0_kIndex , 7_kIndex CALL ByteUnpackBE ( IEOR ( MD % H ( I + 8_kIndex ), G ( I + 8_kIndex )), TmpBuf , I * 8_kIndex ) END DO DLen = MD % GetDigestLen () BytesOut ( Offset : Offset + DLen - 1 ) = TmpBuf ( 64 - DLen : 63 ) END ASSOCIATE RETURN END SUBROUTINE GroestlB_AddBitsNPad !****************************************************************************** END MODULE MClass_GroestlB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_groestlb.f90.html"},{"title":"MClass_FarmNaHasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_FarmNaHasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *FarmNaHasher64* type and its related routines. !   The *FarmNaHasher64* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and !   outputs the hash value as a 64-bit integer. <br> !   The *FarmNaHasher64* type employs the *FarmNa* hash algorithm for 64-bit integer !   output by Google Inc [1, 2].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/google/farmhash\">FarmHash: a family of hash functions. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: FarmNaHasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define ShiftMix(V)             IEOR(V, SHIFTR(V, 47)) #define HashLen16_3(U,V,M)      ShiftMix(IEOR(V, ShiftMix(IEOR(U, V)*M))*M)*M #define HashLen16_2(U,V)        HashLen16_3(U, V, K_MUL) #define Mul(L)                  K2 + SHIFTL(ToInt64(L), 1) #define MaskI8(X)               IAND(ToInt64(X), Z'00000000000000FF') #define MaskI32(X)              IAND(ToInt64(X), Z'00000000FFFFFFFF') #define Pack_U32(Buf,Index)     MaskI32(PackInteger(Buf, Index)) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: K0 = ToInt64 ( Z 'C3A5C85C97CB3127' ) tUInt64 , PARAMETER :: K1 = ToInt64 ( Z 'B492B66FBE98F273' ) tUInt64 , PARAMETER :: K2 = ToInt64 ( Z '9AE16A3B2F90404F' ) tUInt64 , PARAMETER :: K_MUL = ToInt64 ( Z '9DDFEA08EB382D69' ) tIndex , PARAMETER :: BlockLen = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *FarmNaHasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *FarmNa* hash algorithm by Google Inc. TYPE , EXTENDS ( Hasher64 ) :: FarmNaHasher64 PRIVATE !% seeds tUInt64 :: Seed ( 2 ) = 0_kInt64 !% state tUInt64 :: State ( 7 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => FarmNa_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => FarmNa_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => FarmNa_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => FarmNa_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher with one seed. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => FarmNa_Initialize !> **Type-Bound Subroutine**: InitializeWSeeds <br> !  **Purpose**:  To initialize the hasher with two seeds. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2)          ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSeeds(Seed1, Seed2, .TRUE.)  ! remove sign from hash value <br> PROCEDURE :: InitializeWSeeds => FarmNa_Initialize_WithSeeds !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => FarmNa_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                without seed or with one seed. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => FarmNa_HashDirect !> **Type-Bound Function**: HashDirectWSeeds <br> !  **Purpose**:  To compute the hash value directly (non-incrementally) !                with two seeds. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2) <br> !   --->    HashCode = Hasher%HashDirectWSeeds(Input, InpSize, Seed1, Seed2, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSeeds => FarmNa_HashDirect_WithSeeds END TYPE FarmNaHasher64 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION FarmNa_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'FarmNa_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION FarmNa_GetName !****************************************************************************** FUNCTION FarmNa_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION FarmNa_BlockLength !****************************************************************************** SUBROUTINE FarmNa_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE FarmNa_SetBufPtr !****************************************************************************** SUBROUTINE FarmNa_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Tmp tUInt64 :: A1 , B1 , C1 , Z1 tUInt64 :: A2 , B2 , C2 , Z2 !** FLOW ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V1 => HS % State ( 4 ), V2 => HS % State ( 5 ), & W1 => HS % State ( 6 ), W2 => HS % State ( 7 )) IF ( HS % GetBlockCount () == 0_kIndex ) X = X * K2 + PackLong ( BytesIn , 0_kIndex ) X = RotateRight ( X + Y + V1 + PackLong ( BytesIn , 8_kIndex ), 37 ) * K1 Y = RotateRight ( Y + V2 + PackLong ( BytesIn , 48_kIndex ), 42 ) * K1 X = IEOR ( X , W2 ) Y = Y + V1 + PackLong ( BytesIn , 40_kIndex ) Z = RotateRight ( Z + W1 , 33 ) * K1 ! WeakHashLen32WithSeeds A1 = V2 * K1 B1 = X + W1 Z1 = PackLong ( BytesIn , 24_kIndex ) A1 = A1 + PackLong ( BytesIn , 0_kIndex ) B1 = RotateRight ( B1 + A1 + Z1 , 21 ) C1 = A1 A1 = A1 + PackLong ( BytesIn , 8_kIndex ) A1 = A1 + PackLong ( BytesIn , 16_kIndex ) B1 = B1 + RotateRight ( A1 , 44 ) V1 = A1 + Z1 V2 = B1 + C1 ! WeakHashLen32WithSeeds A2 = Z + W2 B2 = Y + PackLong ( BytesIn , 16_kIndex ) Z2 = PackLong ( BytesIn , 56_kIndex ) A2 = A2 + PackLong ( BytesIn , 32_kIndex ) B2 = RotateRight ( B2 + A2 + Z2 , 21 ) C2 = A2 A2 = A2 + PackLong ( BytesIn , 40_kIndex ) A2 = A2 + PackLong ( BytesIn , 48_kIndex ) B2 = B2 + RotateRight ( A2 , 44 ) W1 = A2 + Z2 W2 = B2 + C2 ! swap Z and X Tmp = Z Z = X X = Tmp END ASSOCIATE RETURN END SUBROUTINE FarmNa_ProcessBlock !****************************************************************************** SUBROUTINE FarmNa_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL HS % InitializeWSeeds ( Seed , K2 , RemoveSign ) RETURN END SUBROUTINE FarmNa_Initialize !****************************************************************************** SUBROUTINE FarmNa_Initialize_WithSeeds ( HS , Seed1 , Seed2 , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher with two seeds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed1 !! seed1 tUInt64 , INTENT ( IN ) :: Seed2 !! seed2 tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % Seed ( 1 ) = Seed1 HS % Seed ( 2 ) = Seed2 ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V1 => HS % State ( 4 ), V2 => HS % State ( 5 ), & W1 => HS % State ( 6 ), W2 => HS % State ( 7 )) X = 81_kInt64 Y = 81_kInt64 * K1 + 113_kInt64 Z = ShiftMix ( Y * K2 + 113_kInt64 ) * K2 V1 = 0_kInt64 V2 = 0_kInt64 W1 = 0_kInt64 W2 = 0_kInt64 END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE FarmNa_Initialize_WithSeeds !****************************************************************************** FUNCTION FarmNa_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length !** FLOW IF ( HS % GetBlockCount () > 0_kIndex ) THEN ! compute length Length = HS % GetBlockCount () * HS % GetBlockLength () + HS % GetBufLen () BLOCK ! block variables tUInt8 :: LastBuf ( 0 : BlockLen - 1 ) tIndex :: I , J tUInt64 :: Tmp , M tUInt64 :: A1 , B1 , C1 , Z1 tUInt64 :: A2 , B2 , C2 , Z2 ! copy buffer data for last round J = HS % GetBufLen () + 1_kIndex DO I = 0_kIndex , BlockLen - 1_kIndex LastBuf ( I ) = HS % BufArr ( J ) J = J + 1_kIndex IF ( J >= BlockLen ) J = 0_kIndex END DO ASSOCIATE ( X => HS % State ( 1 ), Y => HS % State ( 2 ), Z => HS % State ( 3 ), & V1 => HS % State ( 4 ), V2 => HS % State ( 5 ), & W1 => HS % State ( 6 ), W2 => HS % State ( 7 )) M = K1 + SHIFTL ( IAND ( Z , ToInt64 ( Z '00000000000000FF' )), 1 ) W1 = W1 + ToInt64 ( IAND (( Length - 1 ), 63_kIndex )) V1 = V1 + W1 W1 = W1 + V1 X = RotateRight ( X + Y + V1 + PackLong ( LastBuf , 8_kIndex ), 37 ) * M Y = RotateRight ( Y + V2 + PackLong ( LastBuf , 48_kIndex ), 42 ) * M X = IEOR ( X , W2 * 9_kInt64 ) Y = Y + V1 * 9_kInt64 + PackLong ( LastBuf , 40_kIndex ) Z = RotateRight ( Z + W1 , 33 ) * M ! WeakHashLen32WithSeeds A1 = V2 * M B1 = X + W1 Z1 = PackLong ( LastBuf , 24_kIndex ) A1 = A1 + PackLong ( LastBuf , 0_kIndex ) B1 = RotateRight ( B1 + A1 + Z1 , 21 ) C1 = A1 A1 = A1 + PackLong ( LastBuf , 8_kIndex ) A1 = A1 + PackLong ( LastBuf , 16_kIndex ) B1 = B1 + RotateRight ( A1 , 44 ) V1 = A1 + Z1 V2 = B1 + C1 ! WeakHashLen32WithSeeds A2 = Z + W2 B2 = Y + PackLong ( LastBuf , 16_kIndex ) Z2 = PackLong ( LastBuf , 56_kIndex ) A2 = A2 + PackLong ( LastBuf , 32_kIndex ) B2 = RotateRight ( B2 + A2 + Z2 , 21 ) C2 = A2 A2 = A2 + PackLong ( LastBuf , 40_kIndex ) A2 = A2 + PackLong ( LastBuf , 48_kIndex ) B2 = B2 + RotateRight ( A2 , 44 ) W1 = A2 + Z2 W2 = B2 + C2 ! swap Z and X Tmp = Z Z = X X = Tmp HashCode = HashLen16_3 ( HashLen16_3 ( V1 , W1 , M ) + ShiftMix ( Y ) * K0 + Z , \\ HashLen16_3 ( V2 , W2 , M ) + X , M ) END ASSOCIATE END BLOCK ELSE Length = HS % GetBufLen () ASSOCIATE ( Input => HS % BufArr ) IF ( Length <= 16 ) THEN ! FarmNaHash_Len0To16 IF ( Length >= 8 ) THEN BLOCK tUInt64 :: M , A , C , D tUInt64 :: First8Bytes , Last8Bytes First8Bytes = PackLong ( Input , 0_kIndex ) Last8Bytes = PackLong ( Input , Length - 8 ) ! Hash 8 To 16 Bytes M = Mul ( Length ) A = First8Bytes + K2 C = RotateRight ( Last8Bytes , 37 ) * M + A D = ( RotateRight ( A , 25 ) + Last8Bytes ) * M HashCode = HashLen16_3 ( C , D , M ) END BLOCK ELSEIF ( Length >= 4 ) THEN BLOCK tUInt64 :: M , First4Bytes , Last4Bytes First4Bytes = Pack_U32 ( Input , 0_kIndex ) Last4Bytes = Pack_U32 ( Input , Length - 4 ) ! Hash 4 To 7 Bytes M = Mul ( Length ) HashCode = HashLen16_3 ( ToInt64 ( Length ) + SHIFTL ( First4Bytes , 3 ), Last4Bytes , M ) END BLOCK ELSEIF ( Length > 0 ) THEN BLOCK tUInt32 :: FirstByte , MidOrLastByte , LastByte tUInt32 :: Y , Z FirstByte = MaskI8 ( Input ( 0 )) MidOrLastByte = MaskI8 ( Input ( SHIFTA ( Length , 1 ))) LastByte = MaskI8 ( Input ( Length - 1 )) ! Hash 1 To 3 Bytes Y = FirstByte + SHIFTL ( MidOrLastByte , 8 ) Z = ToInt32 ( Length ) + SHIFTL ( LastByte , 2 ) HashCode = ShiftMix ( IEOR ( ToInt64 ( Y ) * K2 , ToInt64 ( Z ) * K0 )) * K2 END BLOCK ELSE HashCode = K2 END IF ELSEIF ( Length <= 32 ) THEN ! FarmNaHash_Len17To32 BLOCK tUInt64 :: M , A , B , C , D ! perform hashing M = Mul ( Length ) A = PackLong ( Input , 0_kIndex ) * K1 B = PackLong ( Input , 8_kIndex ) C = PackLong ( Input , Length - 8 ) * M D = PackLong ( Input , Length - 16 ) * K2 HashCode = HashLen16_3 ( RotateRight ( A + B , 43 ) + RotateRight ( C , 30 ) + D , \\ A + RotateRight ( B + K2 , 18 ) + C , M ) END BLOCK ELSE ! FarmNaHash_Len33To64 BLOCK tUInt64 :: M , A , B , C , D , E , F , G , H tUInt64 :: Y , Z ! perform hashing M = Mul ( Length ) A = PackLong ( Input , 0_kIndex ) * K2 B = PackLong ( Input , 8_kIndex ) C = PackLong ( Input , Length - 8 ) * M D = PackLong ( Input , Length - 16 ) * K2 Y = RotateRight ( A + B , 43 ) + RotateRight ( C , 30 ) + D Z = HashLen16_3 ( Y , A + RotateRight ( B + K2 , 18 ) + C , M ) E = PackLong ( Input , 16_kIndex ) * M F = PackLong ( Input , 24_kIndex ) G = ( Y + PackLong ( Input , Length - 32 )) * M H = ( Z + PackLong ( Input , Length - 24 )) * M HashCode = HashLen16_3 ( RotateRight ( E + F , 43 ) + RotateRight ( G , 30 ) + H , \\ E + RotateRight ( F + A , 18 ) + G , M ) END BLOCK END IF END ASSOCIATE END IF ! finalize with seed(s) HashCode = HashLen16_2 ( HashCode - HS % Seed ( 2 ), HS % Seed ( 1 )) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % Seed = 0_kInt64 HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS PURE FUNCTION PackInteger ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 32-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define MaskInt32(X)  IAND(ToInt32(X), Z'000000FF') ! implementation algorithm #1 Res = IOR ( IOR ( IOR ( MaskInt32 ( Buf ( Off )), & SHIFTL ( MaskInt32 ( Buf ( Off + 1 )), 8 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 )), & SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #undef MaskInt32 RETURN END FUNCTION PackInteger !************************************************************************** END FUNCTION FarmNa_Finalize !****************************************************************************** FUNCTION FarmNa_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION FarmNa_HashDirect !****************************************************************************** FUNCTION FarmNa_HashDirect_WithSeeds ( HS , Input , InpSize , Seed1 , Seed2 , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) with two seeds. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FarmNaHasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , INTENT ( IN ) :: Seed1 !! seed1 tUInt64 , INTENT ( IN ) :: Seed2 !! seed2 tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following code illustrates simple use of the hasher. CALL HS % InitializeWSeeds ( Seed1 , Seed2 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION FarmNa_HashDirect_WithSeeds !****************************************************************************** PURE FUNCTION PackLong ( Buf , Off ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack the array 'Buf' at Offset 'Off' into the 64-bit word 'Res', ! in little-endian convention (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! Offset tUInt64 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Input ( 0 : 7 ) tUInt64 :: Output EQUIVALENCE ( Input , Output ) ! FLOW ! implementation algorithm #7 Input ( 0 : 7 ) = Buf ( Off : Off + 7 ) Res = Output RETURN END FUNCTION PackLong !************************************************************************** END MODULE MClass_FarmNaHasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_farmnahasher64.f90.html"},{"title":"MClass_XXHasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_XXHasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *XXHasher32* type and its related routines. !   The *XXHasher32* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> type. !   It provides all deferred procedures required by a *Hasher32* class and !   outputs the hash value as a 32-bit integer. <br> !   The *XXHasher32* type employs the *XX* hash algorithm for 32-bit integer !   output by Yann Collet [1].  As a hasher, it can be used to compute the !   hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/Cyan4973/xxHash\">xxHash: Extremely fast hash algorithm. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher32 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: XXHasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define Pack_U8(Inp,Off)    IAND(ToInt32(Inp(Off)), Z'000000FF') #define MaskInt32(X)        IAND(ToInt32(X), Z'000000FF') #define Pack_I32(Buf,Off)   (MaskInt32(Buf(Off)) + SHIFTL(MaskInt32(Buf(Off+1)),  8) + \\ SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 ) + SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 )) #define XXH32_Round(Acc, Inp) \\ Acc = Acc + Inp * XXH_PRIME32_2 ; \\ Acc = RotateLeft ( Acc , 13 ); \\ Acc = Acc * XXH_PRIME32_1 ; !** MODULE PARAMETERS: tUInt32 , PARAMETER :: XXH_PRIME32_1 = ToInt32 ( Z '9E3779B1' ) tUInt32 , PARAMETER :: XXH_PRIME32_2 = ToInt32 ( Z '85EBCA77' ) tUInt32 , PARAMETER :: XXH_PRIME32_3 = ToInt32 ( Z 'C2B2AE3D' ) tUInt32 , PARAMETER :: XXH_PRIME32_4 = ToInt32 ( Z '27D4EB2F' ) tUInt32 , PARAMETER :: XXH_PRIME32_5 = ToInt32 ( Z '165667B1' ) !** DERIVED TYPE DEFINITIONS !> *XXHasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *XX* hash algorithm by Yann Collet. TYPE , EXTENDS ( Hasher32 ) :: XXHasher32 PRIVATE !% state tUInt32 :: State ( 4 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 15 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX_HashDirect END TYPE XXHasher32 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION XX_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'XX_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX_GetName !****************************************************************************** FUNCTION XX_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = 16_kIndex ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX_BlockLength !****************************************************************************** SUBROUTINE XX_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE XX_SetBufPtr !****************************************************************************** SUBROUTINE XX_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ASSOCIATE ( V1 => HS % State ( 1 ), V2 => HS % State ( 2 ), & V3 => HS % State ( 3 ), V4 => HS % State ( 4 )) IF ( HS % GetBlockCount () == 0_kIndex ) THEN V1 = V1 + XXH_PRIME32_1 + XXH_PRIME32_2 V2 = V2 + XXH_PRIME32_2 V4 = V4 - XXH_PRIME32_1 END IF XXH32_Round ( V1 , Pack_I32 ( BytesIn , 0_kIndex )) XXH32_Round ( V2 , Pack_I32 ( BytesIn , 4_kIndex )) XXH32_Round ( V3 , Pack_I32 ( BytesIn , 8_kIndex )) XXH32_Round ( V4 , Pack_I32 ( BytesIn , 12_kIndex )) END ASSOCIATE RETURN END SUBROUTINE XX_ProcessBlock !****************************************************************************** SUBROUTINE XX_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % State = Seed SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE XX_Initialize !****************************************************************************** FUNCTION XX_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining , Offset !** FLOW ! initialize Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining HashCode = RotateLeft ( HS % State ( 1 ), 1 ) + RotateLeft ( HS % State ( 2 ), 7 ) + & RotateLeft ( HS % State ( 3 ), 12 ) + RotateLeft ( HS % State ( 4 ), 18 ) ELSE Length = Remaining HashCode = HS % State ( 3 ) + XXH_PRIME32_5 END IF HashCode = HashCode + ToInt32 ( Length ) ! XXH32_finalize Offset = 0_kIndex DO WHILE ( Remaining >= 4_kIndex ) HashCode = HashCode + Pack_I32 ( HS % BufArr , Offset ) * XXH_PRIME32_3 HashCode = RotateLeft ( HashCode , 17 ) * XXH_PRIME32_4 Offset = Offset + 4_kIndex Remaining = Remaining - 4_kIndex END DO DO WHILE ( Remaining /= 0_kIndex ) HashCode = HashCode + Pack_U8 ( HS % BufArr , Offset ) * XXH_PRIME32_5 HashCode = RotateLeft ( HashCode , 11 ) * XXH_PRIME32_1 Offset = Offset + 1_kIndex Remaining = Remaining - 1_kIndex END DO ! XXH32_avalanche HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 15 )) HashCode = HashCode * XXH_PRIME32_2 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 13 )) HashCode = HashCode * XXH_PRIME32_3 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 16 )) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % State = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN END FUNCTION XX_Finalize !****************************************************************************** FUNCTION XX_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XXHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt32 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION XX_HashDirect !****************************************************************************** END MODULE MClass_XXHasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_xxhasher32.f90.html"},{"title":"MClass_MD5.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MD5 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MD5* type and its related routines. !   The *MD5* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *MD5* type implements an incremental cryptographic hash !   function by employing the *MD5 message-digest* algorithm where !   the algorithm is described in RFC 1321 [1].  The implementation !   here is mainly based on the *SPHLIB* implementation [2].  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://datatracker.ietf.org/doc/html/rfc1321\">RFC1321: !       The MD5 Message-Digest Algorithm. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MD5 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DigestLen = 16_kIndex tInteger , PARAMETER :: IV ( 0 : 3 ) = [ & ToInt32 ( Z '67452301' ), ToInt32 ( Z 'EFCDAB89' ), & ToInt32 ( Z '98BADCFE' ), ToInt32 ( Z '10325476' )] !** DERIVED TYPE DEFINITIONS !> *MD5* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing !  the *MD5 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: MD5 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 3 ) = IV ( 0 : 3 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => MD5_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => MD5_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => MD5_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => MD5_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => MD5_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => MD5_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => MD5_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => MD5_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => MD5_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => MD5_AddBitsNPad END TYPE MD5 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE MD5_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: MD !! 'MD5' object !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = TrueVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperInit ( LittleEndian , 8_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE MD5_Initialize !****************************************************************************** SUBROUTINE MD5_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: MD !! 'MD5' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % State = IV CALL MD % HelperReset () RETURN END SUBROUTINE MD5_Reset !****************************************************************************** SUBROUTINE MD5_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( MD5 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( MD5 ) CALL Dst % Create () Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE MD5_GetClone !****************************************************************************** FUNCTION MD5_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( IN ) :: MD !! 'MD5' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'MD5' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD5_GetName !****************************************************************************** FUNCTION MD5_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( IN ) :: MD !! 'MD5' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = DigestLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD5_GetDigestLen !****************************************************************************** FUNCTION MD5_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( IN ) :: MD !! 'MD5' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION MD5_GetBlockLen !****************************************************************************** SUBROUTINE MD5_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), TARGET , INTENT ( INOUT ) :: MD !! 'MD5' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE MD5_SetBufPtr !****************************************************************************** SUBROUTINE MD5_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: MD !! 'MD5' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D tInteger :: X ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define FRound(X, Y, Z)     IOR(IAND(Y, X), IAND(Z, NOT(X))) #define GRound(X, Y, Z)     IOR(IAND(X, Z), IAND(Y, NOT(Z))) #define HRound(X, Y, Z)     IEOR(IEOR(X, Y), Z) #define IRound(X, Y, Z)     IEOR(Y, IOR(X, NOT(Z))) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) CALL BytePackLE ( BytesIn , 0_kIndex , X ) A = B + RotateLeft ( A + FRound ( B , C , D ) + X ( 0 ) + ToInt32 ( Z 'D76AA478' ), 7 ) D = A + RotateLeft ( D + FRound ( A , B , C ) + X ( 1 ) + ToInt32 ( Z 'E8C7B756' ), 12 ) C = D + RotateLeft ( C + FRound ( D , A , B ) + X ( 2 ) + ToInt32 ( Z '242070DB' ), 17 ) B = C + RotateLeft ( B + FRound ( C , D , A ) + X ( 3 ) + ToInt32 ( Z 'C1BDCEEE' ), 22 ) A = B + RotateLeft ( A + FRound ( B , C , D ) + X ( 4 ) + ToInt32 ( Z 'F57C0FAF' ), 7 ) D = A + RotateLeft ( D + FRound ( A , B , C ) + X ( 5 ) + ToInt32 ( Z '4787C62A' ), 12 ) C = D + RotateLeft ( C + FRound ( D , A , B ) + X ( 6 ) + ToInt32 ( Z 'A8304613' ), 17 ) B = C + RotateLeft ( B + FRound ( C , D , A ) + X ( 7 ) + ToInt32 ( Z 'FD469501' ), 22 ) A = B + RotateLeft ( A + FRound ( B , C , D ) + X ( 8 ) + ToInt32 ( Z '698098D8' ), 7 ) D = A + RotateLeft ( D + FRound ( A , B , C ) + X ( 9 ) + ToInt32 ( Z '8B44F7AF' ), 12 ) C = D + RotateLeft ( C + FRound ( D , A , B ) + X ( 10 ) + ToInt32 ( Z 'FFFF5BB1' ), 17 ) B = C + RotateLeft ( B + FRound ( C , D , A ) + X ( 11 ) + ToInt32 ( Z '895CD7BE' ), 22 ) A = B + RotateLeft ( A + FRound ( B , C , D ) + X ( 12 ) + ToInt32 ( Z '6B901122' ), 7 ) D = A + RotateLeft ( D + FRound ( A , B , C ) + X ( 13 ) + ToInt32 ( Z 'FD987193' ), 12 ) C = D + RotateLeft ( C + FRound ( D , A , B ) + X ( 14 ) + ToInt32 ( Z 'A679438E' ), 17 ) B = C + RotateLeft ( B + FRound ( C , D , A ) + X ( 15 ) + ToInt32 ( Z '49B40821' ), 22 ) A = B + RotateLeft ( A + GRound ( B , C , D ) + X ( 1 ) + ToInt32 ( Z 'F61E2562' ), 5 ) D = A + RotateLeft ( D + GRound ( A , B , C ) + X ( 6 ) + ToInt32 ( Z 'C040B340' ), 9 ) C = D + RotateLeft ( C + GRound ( D , A , B ) + X ( 11 ) + ToInt32 ( Z '265E5A51' ), 14 ) B = C + RotateLeft ( B + GRound ( C , D , A ) + X ( 0 ) + ToInt32 ( Z 'E9B6C7AA' ), 20 ) A = B + RotateLeft ( A + GRound ( B , C , D ) + X ( 5 ) + ToInt32 ( Z 'D62F105D' ), 5 ) D = A + RotateLeft ( D + GRound ( A , B , C ) + X ( 10 ) + ToInt32 ( Z '02441453' ), 9 ) C = D + RotateLeft ( C + GRound ( D , A , B ) + X ( 15 ) + ToInt32 ( Z 'D8A1E681' ), 14 ) B = C + RotateLeft ( B + GRound ( C , D , A ) + X ( 4 ) + ToInt32 ( Z 'E7D3FBC8' ), 20 ) A = B + RotateLeft ( A + GRound ( B , C , D ) + X ( 9 ) + ToInt32 ( Z '21E1CDE6' ), 5 ) D = A + RotateLeft ( D + GRound ( A , B , C ) + X ( 14 ) + ToInt32 ( Z 'C33707D6' ), 9 ) C = D + RotateLeft ( C + GRound ( D , A , B ) + X ( 3 ) + ToInt32 ( Z 'F4D50D87' ), 14 ) B = C + RotateLeft ( B + GRound ( C , D , A ) + X ( 8 ) + ToInt32 ( Z '455A14ED' ), 20 ) A = B + RotateLeft ( A + GRound ( B , C , D ) + X ( 13 ) + ToInt32 ( Z 'A9E3E905' ), 5 ) D = A + RotateLeft ( D + GRound ( A , B , C ) + X ( 2 ) + ToInt32 ( Z 'FCEFA3F8' ), 9 ) C = D + RotateLeft ( C + GRound ( D , A , B ) + X ( 7 ) + ToInt32 ( Z '676F02D9' ), 14 ) B = C + RotateLeft ( B + GRound ( C , D , A ) + X ( 12 ) + ToInt32 ( Z '8D2A4C8A' ), 20 ) A = B + RotateLeft ( A + HRound ( B , C , D ) + X ( 5 ) + ToInt32 ( Z 'FFFA3942' ), 4 ) D = A + RotateLeft ( D + HRound ( A , B , C ) + X ( 8 ) + ToInt32 ( Z '8771F681' ), 11 ) C = D + RotateLeft ( C + HRound ( D , A , B ) + X ( 11 ) + ToInt32 ( Z '6D9D6122' ), 16 ) B = C + RotateLeft ( B + HRound ( C , D , A ) + X ( 14 ) + ToInt32 ( Z 'FDE5380C' ), 23 ) A = B + RotateLeft ( A + HRound ( B , C , D ) + X ( 1 ) + ToInt32 ( Z 'A4BEEA44' ), 4 ) D = A + RotateLeft ( D + HRound ( A , B , C ) + X ( 4 ) + ToInt32 ( Z '4BDECFA9' ), 11 ) C = D + RotateLeft ( C + HRound ( D , A , B ) + X ( 7 ) + ToInt32 ( Z 'F6BB4B60' ), 16 ) B = C + RotateLeft ( B + HRound ( C , D , A ) + X ( 10 ) + ToInt32 ( Z 'BEBFBC70' ), 23 ) A = B + RotateLeft ( A + HRound ( B , C , D ) + X ( 13 ) + ToInt32 ( Z '289B7EC6' ), 4 ) D = A + RotateLeft ( D + HRound ( A , B , C ) + X ( 0 ) + ToInt32 ( Z 'EAA127FA' ), 11 ) C = D + RotateLeft ( C + HRound ( D , A , B ) + X ( 3 ) + ToInt32 ( Z 'D4EF3085' ), 16 ) B = C + RotateLeft ( B + HRound ( C , D , A ) + X ( 6 ) + ToInt32 ( Z '04881D05' ), 23 ) A = B + RotateLeft ( A + HRound ( B , C , D ) + X ( 9 ) + ToInt32 ( Z 'D9D4D039' ), 4 ) D = A + RotateLeft ( D + HRound ( A , B , C ) + X ( 12 ) + ToInt32 ( Z 'E6DB99E5' ), 11 ) C = D + RotateLeft ( C + HRound ( D , A , B ) + X ( 15 ) + ToInt32 ( Z '1FA27CF8' ), 16 ) B = C + RotateLeft ( B + HRound ( C , D , A ) + X ( 2 ) + ToInt32 ( Z 'C4AC5665' ), 23 ) A = B + RotateLeft ( A + IRound ( B , C , D ) + X ( 0 ) + ToInt32 ( Z 'F4292244' ), 6 ) D = A + RotateLeft ( D + IRound ( A , B , C ) + X ( 7 ) + ToInt32 ( Z '432AFF97' ), 10 ) C = D + RotateLeft ( C + IRound ( D , A , B ) + X ( 14 ) + ToInt32 ( Z 'AB9423A7' ), 15 ) B = C + RotateLeft ( B + IRound ( C , D , A ) + X ( 5 ) + ToInt32 ( Z 'FC93A039' ), 21 ) A = B + RotateLeft ( A + IRound ( B , C , D ) + X ( 12 ) + ToInt32 ( Z '655B59C3' ), 6 ) D = A + RotateLeft ( D + IRound ( A , B , C ) + X ( 3 ) + ToInt32 ( Z '8F0CCC92' ), 10 ) C = D + RotateLeft ( C + IRound ( D , A , B ) + X ( 10 ) + ToInt32 ( Z 'FFEFF47D' ), 15 ) B = C + RotateLeft ( B + IRound ( C , D , A ) + X ( 1 ) + ToInt32 ( Z '85845DD1' ), 21 ) A = B + RotateLeft ( A + IRound ( B , C , D ) + X ( 8 ) + ToInt32 ( Z '6FA87E4F' ), 6 ) D = A + RotateLeft ( D + IRound ( A , B , C ) + X ( 15 ) + ToInt32 ( Z 'FE2CE6E0' ), 10 ) C = D + RotateLeft ( C + IRound ( D , A , B ) + X ( 6 ) + ToInt32 ( Z 'A3014314' ), 15 ) B = C + RotateLeft ( B + IRound ( C , D , A ) + X ( 13 ) + ToInt32 ( Z '4E0811A1' ), 21 ) A = B + RotateLeft ( A + IRound ( B , C , D ) + X ( 4 ) + ToInt32 ( Z 'F7537E82' ), 6 ) D = A + RotateLeft ( D + IRound ( A , B , C ) + X ( 11 ) + ToInt32 ( Z 'BD3AF235' ), 10 ) C = D + RotateLeft ( C + IRound ( D , A , B ) + X ( 2 ) + ToInt32 ( Z '2AD7D2BB' ), 15 ) B = C + RotateLeft ( B + IRound ( C , D , A ) + X ( 9 ) + ToInt32 ( Z 'EB86D391' ), 21 ) MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D RETURN #undef FRound #undef GRound #undef HRound #undef IRound END SUBROUTINE MD5_ProcessBlock !****************************************************************************** SUBROUTINE MD5_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: MD !! 'MD5' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperPadding () CALL ByteUnpackLE ( MD % State , BytesOut , Offset ) RETURN END SUBROUTINE MD5_DoPadding !****************************************************************************** SUBROUTINE MD5_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MD5 ), INTENT ( INOUT ) :: MD !! 'MD5' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! MD5 algorithm does not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE MD5_AddBitsNPad !****************************************************************************** END MODULE MClass_MD5 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_md5.f90.html"},{"title":"MClass_KP1600Sponge.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_KP1600Sponge !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *KP1600Sponge* type and its related routines. !   The *KP1600Sponge* type is a derived type representing a sponge instance !   for use with the so-called *Keccak Sponge* function.  It provides basic !   operations of the *Keccak-p[1600, nRound]* message-digest algorithm, which !   has the internal state size of 1600 bits.  The *Keccak Sponge* function, !   the *Sponge* construction and other related information are described in !   FIPS 202 [1].  The implementation here is mainly based on the *eXtended !   Keccak Code Package* (XKCP) [2].  The *KP1600Sponge* type is provided !   to help the development and implementation of the *Keccak-based* digest !   types.  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE , INTRINSIC :: ISO_C_BINDING USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MBase_UIntUtil , ONLY : OPERATOR (. UGE .) IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: KP1600Sponge PUBLIC :: SUCCESS , FAILURE PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! parameters for the first padding byte tByte , PARAMETER :: FByte00 = ToInt8 ( Z '00' ) tByte , PARAMETER :: FByte01 = ToInt8 ( Z '01' ) tByte , PARAMETER :: FByte80 = ToInt8 ( Z '80' ) tByte , PARAMETER :: FByteFF = ToInt8 ( Z 'FF' ) ! size parameters tInteger , PARAMETER :: KP1600SizeInBits = 1600 tInteger , PARAMETER :: KP1600SizeInBytes = ( KP1600SizeInBits / 8 ) ! 200 tInteger , PARAMETER :: KP1600SizeInWords = ( KP1600SizeInBits / 64 ) ! 25 ! maximum number of rounds of permutation tInteger , PARAMETER :: MaxNrRounds = 24 ! return flags tByte , PARAMETER :: SUCCESS = 0_kInt8 tByte , PARAMETER :: FAILURE = 1_kInt8 !** DERIVED TYPE DEFINITIONS !> *KP1600Sponge* is a derived type representing a sponge instance for !  use with the *Keccak Sponge* functions.  It gathers the state processed !  by the permutation as well as the rate. TYPE KP1600Sponge PRIVATE !% The state in bytes processed by the permutation tByte :: State ( 0 : KP1600SizeInBytes - 1 ) = 0_kInt8 !% The state in words; an alias of the state tLong , POINTER :: StateAsWords (:) => NULL () !% The number of permutation rounds tInteger :: NRounds = 24 !% The value of the rate in bits tInteger :: Rate !% The position in the state of the next byte to be input/output tInteger :: ByteIOIndex = 0 !% The flag for squeezing tLogical :: Squeezing = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AddByte => KP1600Sponge_AddByte PROCEDURE , PRIVATE :: AddBytes => KP1600Sponge_AddBytes PROCEDURE , PRIVATE :: ExtractBytes => KP1600Sponge_ExtractBytes ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%Initialize(Capacity, nRounds) PROCEDURE :: Initialize => KP1600Sponge_Initialize !> **Type-Bound Function**: Absorb <br> !  **Purpose**:  To insert input data in bytes to be absorbed by *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%Absorb(Input, InpSize) <br> !   --->    IF (.NOT.Instance%Absorb(Input, InpSize)) DoSomething <br> !  **Note**: Must call this method before calling either the *AbsorbLastFewBits* !            method or the *Squeeze* method. <br> PROCEDURE :: Absorb => KP1600Sponge_Absorb !> **Type-Bound Function**: AbsorbLastFewBits <br> !  **Purpose**:  To insert input data in bits to be absorbed by *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%AbsorbLastFewBits(LastByte) <br> !   --->    IF (.NOT.Instance%AbsorbLastFewBits(LastByte)) DoSomething <br> !  **Note**: Must call this method only once and before calling the *Squeeze* method. <br> PROCEDURE :: AbsorbLastFewBits => KP1600Sponge_AbsorbLastFewBits !> **Type-Bound Subroutine**: Permute <br> !  **Purpose**:  To perform a permutation of the state of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%Permute() PROCEDURE :: Permute => KP1600Sponge_Permute !> **Type-Bound Function**: Squeeze <br> !  **Purpose**:  To retrieve output data from *Sponge* instance. <br> !  **Usage**: <br> !   --->    Flag = Instance%Squeeze(Output, OutSize) <br> !   --->    IF (.NOT.Instance%Squeeze(Output, OutSize)) DoSomething <br> PROCEDURE :: Squeeze => KP1600Sponge_Squeeze !> **Type-Bound Function**: GetByteIOIndex <br> !  **Purpose**:  To get value of the *ByteIOIndex* component of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    Index = Instance%GetByteIOIndex() PROCEDURE :: GetByteIOIndex => KP1600Sponge_GetByteIOIndex !> **Type-Bound Subroutine**: SetByteIOIndex <br> !  **Purpose**:  To set value of the *ByteIOIndex* component of the *Sponge* instance. <br> !  **Usage**: <br> !   --->    CALL Instance%SetByteIOIndex(Index) PROCEDURE :: SetByteIOIndex => KP1600Sponge_SetByteIOIndex !> **Type-Bound Subroutine**: CopyState <br> !  **Purpose**:  To copy the current state of the source instance. <br> !  **Usage**: <br> !   --->    CALL Src%CopyState(Dst) PROCEDURE :: CopyState => KP1600Sponge_CopyState ! --------------------------------------------------------------------- FINAL :: KP1600Sponge_Finalize ! --------------------------------------------------------------------- END TYPE KP1600Sponge !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS !------------------------------------------------------------------------------ !               KP1600Sponge Procedures (i.e. Sponge Functions) !------------------------------------------------------------------------------ SUBROUTINE KP1600Sponge_Initialize ( Instance , Capacity , NRounds ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the state of the Keccak-p[1600, nRounds] sponge function. !  The phase of the sponge function is set to absorbing. <br> !  Note: the capacity 'c' is a double of the security strength of a particular !        cryptographic hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), TARGET , INTENT ( INOUT ) :: Instance !! 'Sponge' instance tInteger , INTENT ( IN ) :: Capacity !! value of the capacity c tInteger , INTENT ( IN ) :: NRounds !! the number of rounds to be permuted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( C_PTR ) :: StateLoc ! FLOW Instance % State = 0_kInt8 ! map the StateAsWords to the State StateLoc = C_LOC ( Instance % State ) CALL C_F_POINTER ( StateLoc , Instance % StateAsWords , SHAPE = [ KP1600SizeInWords ]) Instance % Rate = KP1600SizeInBits - Capacity Instance % ByteIOIndex = 0 Instance % Squeezing = FalseVal Instance % NRounds = NRounds RETURN END SUBROUTINE KP1600Sponge_Initialize !****************************************************************************** FUNCTION KP1600Sponge_Absorb ( Instance , InpDat , InpByteLen ) RESULT ( RetFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in bytes to be absorbed by the sponge function. <br> !  The sponge function must be in the absorbing phase, which means that !  the *Squeezing* flag is currently set to false.  Otherwise, the routine !  return a *FAILURE* value. <br> !  This also indicates that this function (i.e. the *Absorb* method) must be !  called before the *AbsorbLastFewBits* method or the *Squeeze* method is !  called. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( IN ) :: InpDat ( 0 :) !! input data as an array of 8-bit integers tIndex , INTENT ( IN ) :: InpByteLen !! size of input data in bytes tByte :: RetFlag !&#94; Returned flag indicating whether the operation is successful or not. <br> !  - Return the *FAILURE* value if the *Squeezing* flag is true. <br> !  - Otherwise, return the *SUCCESS* value. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J tInteger :: PartialBlock , RateInBytes tIndex :: CurIndx ! FLOW IF ( Instance % Squeezing ) THEN ! Too late for additional input RetFlag = FAILURE RETURN END IF ! initialize RateInBytes = Instance % Rate / 8 I = 0 CurIndx = 0_kIndex DO WHILE ( I < InpByteLen ) IF (( Instance % ByteIOIndex == 0 ). AND .( InpByteLen >= ( I + RateInBytes ))) THEN J = InpByteLen - I DO WHILE ( J >= RateInBytes ) CALL Instance % AddBytes ( InpDat ( CurIndx :), 0 , RateInBytes ) CALL Instance % Permute () CurIndx = CurIndx + RateInBytes J = J - RateInBytes END DO I = InpByteLen - J ELSE ! normal lane: using the message queue PartialBlock = ToInt32 ( InpByteLen - I ) IF ( PartialBlock + Instance % ByteIOIndex > RateInBytes ) THEN PartialBlock = RateInBytes - Instance % ByteIOIndex END IF I = I + PartialBlock CALL Instance % AddBytes ( InpDat ( CurIndx :), Instance % ByteIOIndex , PartialBlock ) CurIndx = CurIndx + PartialBlock Instance % ByteIOIndex = Instance % ByteIOIndex + PartialBlock IF ( Instance % ByteIOIndex == RateInBytes ) THEN CALL Instance % Permute () Instance % ByteIOIndex = 0 END IF END IF END DO RetFlag = SUCCESS RETURN END FUNCTION KP1600Sponge_Absorb !****************************************************************************** FUNCTION KP1600Sponge_AbsorbLastFewBits ( Instance , DelimitedData ) RESULT ( RetFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in bits to be absorbed by the sponge function and !  then switch to the squeezing phase. <br> !  The sponge function must be in the absorbing phase, which means that !  the *Squeezing* flag is currently set to false.  Otherwise, the routine !  return a *FAILURE* value. <br> !  This also indicates that this function (i.e. the *AbsorbLastFewBits* method) !  must be called only once and before the *Squeeze* method is called. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( IN ) :: DelimitedData !&#94; A single byte containing from 0 to 7 trailing bits that must be absorbed. !  These *n* bits must be in the least significant bit positions. These bits !  must be delimited with a bit 1 at position *n* (counting from 0=LSB to 7=MSB) !  and followed by bits 0 from position *n*+1 to position 7. <br> !  Some examples: <br> !   - If no bits are to be absorbed, then *DelimitedData* must be Z'01'. <br> !   - If the 2-bit sequence 0,0 is to be absorbed, *DelimitedData* must be Z'04'. <br> !   - If the 5-bit sequence 0,1,0,0,1 is to be absorbed, *DelimitedData* must be Z'32'. <br> !   - If the 7-bit sequence 1,1,0,1,0,0,0 is to be absorbed, *DelimitedData* must be Z'8B'. <br> !  *DelimitedData* must NOT be zero. tByte :: RetFlag !&#94; Returned flag indicating whether the operation is successful or not. <br> !  - Return the *FAILURE* value if the *Squeezing* flag is true or *DelimitedData* is zero. <br> !  - Otherwise, return the *SUCCESS* value. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: RateInBytes ! FLOW IF ( DelimitedData == 0_kInt8 ) THEN ! no data to be added RetFlag = FAILURE RETURN END IF IF ( Instance % Squeezing ) THEN ! Too late for additional input RetFlag = FAILURE RETURN END IF ! initialize RateInBytes = Instance % Rate / 8 ! Last few bits, whose delimiter coincides with first bit of padding CALL Instance % AddByte ( DelimitedData , Instance % ByteIOIndex ) ! If the first bit of padding is at position rate-1, ! we need a whole new block for the second bit of padding IF (( DelimitedData . UGE . FByte80 ). AND .( Instance % ByteIOIndex == ( RateInBytes - 1 ))) THEN CALL Instance % Permute () END IF ! Second bit of padding CALL Instance % AddByte ( FByte80 , RateInBytes - 1 ) CALL Instance % Permute () Instance % ByteIOIndex = 0 Instance % Squeezing = TrueVal RetFlag = SUCCESS RETURN END FUNCTION KP1600Sponge_AbsorbLastFewBits !****************************************************************************** SUBROUTINE KP1600Sponge_Permute ( Instance ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform a permutation of the state of the instance. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance !** SUBROUTINE PARAMETER DECLARATIONS: tInteger , PARAMETER :: NrLanes = 25 tLong , PARAMETER :: KeccakRoundConstants ( 0 : MaxNrRounds - 1 ) = [ & ToInt64 ( Z '0000000000000001' ), ToInt64 ( Z '0000000000008082' ), & ToInt64 ( Z '800000000000808A' ), ToInt64 ( Z '8000000080008000' ), & ToInt64 ( Z '000000000000808B' ), ToInt64 ( Z '0000000080000001' ), & ToInt64 ( Z '8000000080008081' ), ToInt64 ( Z '8000000000008009' ), & ToInt64 ( Z '000000000000008A' ), ToInt64 ( Z '0000000000000088' ), & ToInt64 ( Z '0000000080008009' ), ToInt64 ( Z '000000008000000A' ), & ToInt64 ( Z '000000008000808B' ), ToInt64 ( Z '800000000000008B' ), & ToInt64 ( Z '8000000000008089' ), ToInt64 ( Z '8000000000008003' ), & ToInt64 ( Z '8000000000008002' ), ToInt64 ( Z '8000000000000080' ), & ToInt64 ( Z '000000000000800A' ), ToInt64 ( Z '800000008000000A' ), & ToInt64 ( Z '8000000080008081' ), ToInt64 ( Z '8000000000008080' ), & ToInt64 ( Z '0000000080000001' ), ToInt64 ( Z '8000000080008008' )] tInteger , PARAMETER :: KeccakRhoOffsets ( 0 : NrLanes - 1 ) = [ & 0 , 1 , 62 , 28 , 27 , 36 , 44 , 6 , 55 , 20 , 3 , 10 , 43 , & 25 , 39 , 41 , 45 , 15 , 21 , 8 , 18 , 2 , 61 , 56 , 14 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: A0 , A1 , A2 , A3 , A4 tLong :: A5 , A6 , A7 , A8 , A9 tLong :: A10 , A11 , A12 , A13 , A14 tLong :: A15 , A16 , A17 , A18 , A19 tLong :: A20 , A21 , A22 , A23 , A24 tLong :: C0 , C1 , C2 , C3 , C4 tLong :: D0 , D1 , D2 , D3 , D4 tInteger :: IRound !** SUBROUTINE MACRO DEFINITIONS: #define IEOR_5(A, B, C, D, E)   IEOR(IEOR(IEOR(IEOR(A, B), C), D), E) #define Lane(A, B)              IEOR(RotateLeft(A, 1), B) #define IEOR_N_NOT(A, B, C)     IEOR(A, IAND(NOT(B), C)) ! FLOW ASSOCIATE ( State => Instance % StateAsWords , NRounds => Instance % NRounds ) ! get input A0 = State ( 1 ) A1 = State ( 2 ) A2 = State ( 3 ) A3 = State ( 4 ) A4 = State ( 5 ) A5 = State ( 6 ) A6 = State ( 7 ) A7 = State ( 8 ) A8 = State ( 9 ) A9 = State ( 10 ) A10 = State ( 11 ) A11 = State ( 12 ) A12 = State ( 13 ) A13 = State ( 14 ) A14 = State ( 15 ) A15 = State ( 16 ) A16 = State ( 17 ) A17 = State ( 18 ) A18 = State ( 19 ) A19 = State ( 20 ) A20 = State ( 21 ) A21 = State ( 22 ) A22 = State ( 23 ) A23 = State ( 24 ) A24 = State ( 25 ) ! permute state DO IRound = MaxNrRounds - NRounds , MaxNrRounds - 1 ! theta step C0 = IEOR_5 ( A0 , A5 , A10 , A15 , A20 ) C1 = IEOR_5 ( A1 , A6 , A11 , A16 , A21 ) C2 = IEOR_5 ( A2 , A7 , A12 , A17 , A22 ) C3 = IEOR_5 ( A3 , A8 , A13 , A18 , A23 ) C4 = IEOR_5 ( A4 , A9 , A14 , A19 , A24 ) D1 = Lane ( C1 , C4 ) D2 = Lane ( C2 , C0 ) D3 = Lane ( C3 , C1 ) D4 = Lane ( C4 , C2 ) D0 = Lane ( C0 , C3 ) A0 = IEOR ( A0 , D1 ) A5 = IEOR ( A5 , D1 ) A10 = IEOR ( A10 , D1 ) A15 = IEOR ( A15 , D1 ) A20 = IEOR ( A20 , D1 ) A1 = IEOR ( A1 , D2 ) A6 = IEOR ( A6 , D2 ) A11 = IEOR ( A11 , D2 ) A16 = IEOR ( A16 , D2 ) A21 = IEOR ( A21 , D2 ) A2 = IEOR ( A2 , D3 ) A7 = IEOR ( A7 , D3 ) A12 = IEOR ( A12 , D3 ) A17 = IEOR ( A17 , D3 ) A22 = IEOR ( A22 , D3 ) A3 = IEOR ( A3 , D4 ) A8 = IEOR ( A8 , D4 ) A13 = IEOR ( A13 , D4 ) A18 = IEOR ( A18 , D4 ) A23 = IEOR ( A23 , D4 ) A4 = IEOR ( A4 , D0 ) A9 = IEOR ( A9 , D0 ) A14 = IEOR ( A14 , D0 ) A19 = IEOR ( A19 , D0 ) A24 = IEOR ( A24 , D0 ) ! rho and pi steps C0 = RotateLeft ( A1 , 1 ) A1 = RotateLeft ( A6 , 44 ) A6 = RotateLeft ( A9 , 20 ) A9 = RotateLeft ( A22 , 61 ) A22 = RotateLeft ( A14 , 39 ) A14 = RotateLeft ( A20 , 18 ) A20 = RotateLeft ( A2 , 62 ) A2 = RotateLeft ( A12 , 43 ) A12 = RotateLeft ( A13 , 25 ) A13 = RotateLeft ( A19 , 8 ) A19 = RotateLeft ( A23 , 56 ) A23 = RotateLeft ( A15 , 41 ) A15 = RotateLeft ( A4 , 27 ) A4 = RotateLeft ( A24 , 14 ) A24 = RotateLeft ( A21 , 2 ) A21 = RotateLeft ( A8 , 55 ) A8 = RotateLeft ( A16 , 45 ) A16 = RotateLeft ( A5 , 36 ) A5 = RotateLeft ( A3 , 28 ) A3 = RotateLeft ( A18 , 21 ) A18 = RotateLeft ( A17 , 15 ) A17 = RotateLeft ( A11 , 10 ) A11 = RotateLeft ( A7 , 6 ) A7 = RotateLeft ( A10 , 3 ) A10 = C0 ! chi step C0 = IEOR_N_NOT ( A0 , A1 , A2 ) C1 = IEOR_N_NOT ( A1 , A2 , A3 ) A2 = IEOR_N_NOT ( A2 , A3 , A4 ) A3 = IEOR_N_NOT ( A3 , A4 , A0 ) A4 = IEOR_N_NOT ( A4 , A0 , A1 ) A0 = C0 A1 = C1 C0 = IEOR_N_NOT ( A5 , A6 , A7 ) C1 = IEOR_N_NOT ( A6 , A7 , A8 ) A7 = IEOR_N_NOT ( A7 , A8 , A9 ) A8 = IEOR_N_NOT ( A8 , A9 , A5 ) A9 = IEOR_N_NOT ( A9 , A5 , A6 ) A5 = C0 A6 = C1 C0 = IEOR_N_NOT ( A10 , A11 , A12 ) C1 = IEOR_N_NOT ( A11 , A12 , A13 ) A12 = IEOR_N_NOT ( A12 , A13 , A14 ) A13 = IEOR_N_NOT ( A13 , A14 , A10 ) A14 = IEOR_N_NOT ( A14 , A10 , A11 ) A10 = C0 A11 = C1 C0 = IEOR_N_NOT ( A15 , A16 , A17 ) C1 = IEOR_N_NOT ( A16 , A17 , A18 ) A17 = IEOR_N_NOT ( A17 , A18 , A19 ) A18 = IEOR_N_NOT ( A18 , A19 , A15 ) A19 = IEOR_N_NOT ( A19 , A15 , A16 ) A15 = C0 A16 = C1 C0 = IEOR_N_NOT ( A20 , A21 , A22 ) C1 = IEOR_N_NOT ( A21 , A22 , A23 ) A22 = IEOR_N_NOT ( A22 , A23 , A24 ) A23 = IEOR_N_NOT ( A23 , A24 , A20 ) A24 = IEOR_N_NOT ( A24 , A20 , A21 ) A20 = C0 A21 = C1 ! iota step A0 = IEOR ( A0 , KeccakRoundConstants ( IRound )) END DO ! return output State ( 1 ) = A0 State ( 2 ) = A1 State ( 3 ) = A2 State ( 4 ) = A3 State ( 5 ) = A4 State ( 6 ) = A5 State ( 7 ) = A6 State ( 8 ) = A7 State ( 9 ) = A8 State ( 10 ) = A9 State ( 11 ) = A10 State ( 12 ) = A11 State ( 13 ) = A12 State ( 14 ) = A13 State ( 15 ) = A14 State ( 16 ) = A15 State ( 17 ) = A16 State ( 18 ) = A17 State ( 19 ) = A18 State ( 20 ) = A19 State ( 21 ) = A20 State ( 22 ) = A21 State ( 23 ) = A22 State ( 24 ) = A23 State ( 25 ) = A24 END ASSOCIATE RETURN #undef IEOR_N_NOT #undef IEOR_5 #undef Lane END SUBROUTINE KP1600Sponge_Permute !****************************************************************************** FUNCTION KP1600Sponge_Squeeze ( Instance , OutDat , OutByteLen ) RESULT ( RetFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To squeeze output data from the sponge function.  If the sponge function !  was in the absorbing phase, this function switches it to the squeezing !  phase as if the *AbsorbLastFewBits* method was called. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( OUT ) :: OutDat ( 0 :) !! a byte array to store the output data tIndex , INTENT ( IN ) :: OutByteLen !! the number of output bytes desired tByte :: RetFlag !&#94; Returned flag indicating whether the operation is successful or not. <br> !  - Return the *FAILURE* value if the operation is NOT successful. <br> !  - Otherwise, return the *SUCCESS* value. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J tInteger :: PartialBlock , RateInBytes tIndex :: CurIndx ! FLOW IF (. NOT . Instance % Squeezing ) THEN RetFlag = Instance % AbsorbLastFewBits ( FByte01 ) IF ( RetFlag == FAILURE ) RETURN END IF ! initialize RateInBytes = Instance % Rate / 8 I = 0_kIndex CurIndx = 0_kIndex DO WHILE ( I < OutByteLen ) IF (( Instance % ByteIOIndex == RateInBytes ). AND .( OutByteLen >= ( I + RateInBytes ))) THEN J = OutByteLen - I DO WHILE ( J >= RateInBytes ) CALL Instance % Permute () CALL Instance % ExtractBytes ( OutDat ( CurIndx :), 0_kInt32 , RateInBytes ) CurIndx = CurIndx + RateInBytes J = J - RateInBytes END DO I = OutByteLen - J ELSE ! normal lane: using the message queue IF ( Instance % ByteIOIndex == RateInBytes ) THEN CALL Instance % Permute () Instance % ByteIOIndex = 0 END IF PartialBlock = ToInt32 ( OutByteLen - I ) IF ( PartialBlock + Instance % ByteIOIndex > RateInBytes ) THEN PartialBlock = RateInBytes - Instance % ByteIOIndex END IF I = I + PartialBlock CALL Instance % ExtractBytes ( OutDat ( CurIndx :), Instance % ByteIOIndex , PartialBlock ) CurIndx = CurIndx + PartialBlock Instance % ByteIOIndex = Instance % ByteIOIndex + PartialBlock END IF END DO RetFlag = SUCCESS RETURN END FUNCTION KP1600Sponge_Squeeze !****************************************************************************** FUNCTION KP1600Sponge_GetByteIOIndex ( Instance ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *ByteIOIndex* variable. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Indx = Instance % ByteIOIndex RETURN END FUNCTION KP1600Sponge_GetByteIOIndex !****************************************************************************** SUBROUTINE KP1600Sponge_SetByteIOIndex ( Instance , Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the *ByteIOIndex* variable. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance tIndex , INTENT ( IN ) :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Instance % ByteIOIndex = Indx RETURN END SUBROUTINE KP1600Sponge_SetByteIOIndex !****************************************************************************** SUBROUTINE KP1600Sponge_CopyState ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the current states of the source instance to the destination instance. <br> !  Note: Only those that would be changed during various operations are copied. !        Those that would not be changed are expected to be copied to the !        destination during its construction. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Src !! the source instance CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Dst !! the destination instance !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Dst % State = Src % State Dst % ByteIOIndex = Src % ByteIOIndex Dst % Squeezing = Src % Squeezing RETURN END SUBROUTINE KP1600Sponge_CopyState !------------------------------------------------------------------------------ !           State and Permutation Procedures (i.e. SnP Functions) !------------------------------------------------------------------------------ SUBROUTINE KP1600Sponge_AddByte ( Instance , InpByte , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a given byte into the state of the sponge instance. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( IN ) :: InpByte !! an input byte tInteger , INTENT ( IN ) :: Offset !! offset in bytes within the state !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( IsLittleEndian ) THEN Instance % State ( Offset ) = IEOR ( Instance % State ( Offset ), InpByte ) ELSE BLOCK tLong :: Lane tIndex :: Indx Lane = InpByte Lane = SHIFTL ( Lane , MOD ( Offset , 8 ) * 8 ) Indx = SHIFTR ( Offset , 3 ) Instance % StateAsWords ( Indx ) = IEOR ( Instance % StateAsWords ( Indx ), Lane ) END BLOCK END IF RETURN END SUBROUTINE KP1600Sponge_AddByte !****************************************************************************** SUBROUTINE KP1600Sponge_AddBytes ( Instance , InpBytes , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the given bytes into the state of the sponge instance. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( IN ) :: InpBytes ( 0 :) !! a byte array of input data tInteger , INTENT ( IN ) :: Offset !! offset in bytes within the state tInteger , INTENT ( IN ) :: Length !! length of the input bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( IsLittleEndian ) THEN DO I = 0 , Length - 1 Instance % State ( Offset + I ) = IEOR ( Instance % State ( Offset + I ), InpBytes ( I )) END DO ELSE BLOCK tLong :: Lane tIndex :: Indx I = 0 DO WHILE ( I < ( Length - 8 )) Indx = SHIFTR ( Offset + I , 3 ) CALL BytePackLE ( InpBytes , I , Lane ) Instance % StateAsWords ( Indx ) = IEOR ( Instance % StateAsWords ( Indx ), Lane ) I = I + 8 END DO DO WHILE ( I < Length ) Lane = InpBytes ( I ) Lane = SHIFTL ( Lane , MOD ( Offset + I , 8_kIndex ) * 8 ) Indx = SHIFTR ( Offset + I , 3 ) Instance % StateAsWords ( Indx ) = IEOR ( Instance % StateAsWords ( Indx ), Lane ) END DO END BLOCK END IF RETURN END SUBROUTINE KP1600Sponge_AddBytes !****************************************************************************** SUBROUTINE KP1600Sponge_ExtractBytes ( Instance , OutDat , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve output data from the state of the sponge instance. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance tByte , INTENT ( OUT ) :: OutDat ( 0 :) !! a byte array used to store output data tInteger , INTENT ( IN ) :: Offset !! offset index of the state values tInteger , INTENT ( IN ) :: Length !! a number of bytes extracted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( IsLittleEndian ) THEN OutDat ( 0 : Length - 1 ) = Instance % State ( Offset : Offset + Length - 1 ) ELSE Outer : BLOCK tIndex :: Len8 , I , Indx Len8 = ( Length / 8 ) * 8 IF ( Len8 == Length ) THEN DO I = 0 , Length - 1 , 8 Indx = SHIFTR ( Offset + I , 3 ) CALL ByteUnpackLE ( Instance % StateAsWords ( Indx ), OutDat , I ) END DO ELSE Len8 = Len8 + 8 Inner : BLOCK tByte :: OutBuf ( 0 : Length ) DO I = 0 , Len8 - 1 , 8 Indx = SHIFTR ( Offset + I , 3 ) CALL ByteUnpackLE ( Instance % StateAsWords ( Indx ), OutBuf , I ) END DO OutDat ( 0 : Length - 1 ) = OutBuf ( 0 : Length - 1 ) END BLOCK Inner END IF END BLOCK Outer END IF RETURN END SUBROUTINE KP1600Sponge_ExtractBytes !****************************************************************************** SUBROUTINE KP1600Sponge_Finalize ( Instance ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KP1600Sponge ), INTENT ( INOUT ) :: Instance !! 'Sponge' instance !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Instance % StateAsWords => NULL () RETURN END SUBROUTINE KP1600Sponge_Finalize !****************************************************************************** END MODULE MClass_KP1600Sponge !******************************************************************************","tags":"","loc":"sourcefile\\mclass_kp1600sponge.f90.html"},{"title":"MClass_BmwB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BmwB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BmwB* type and its related routines. !   The *BmwB* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *BmwB* type implements an incremental cryptographic hash function !   by employing a *Blue Midnight Wish (BMW) message-digest* algorithm !   (either the *BMW-384* or the *BMW-512*) [1].  The implementation here !   is based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *BmwB* type employs the *BMW-512 message-digest* !   algorithm.  However, a user can specify the *IsBMW384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *BMW-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"http://people.item.ntnu.no/~danilog/Hash/BMW-SecondRound/\"> !       The Blue Midnight Wish cryptographic hash function package submitted !       to the second round of the NIST's SHA-3 hash competition. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: BmwB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tLong , PARAMETER :: IV384 ( 0 : 15 ) = [ & ToInt64 ( Z '0001020304050607' ), ToInt64 ( Z '08090A0B0C0D0E0F' ), & ToInt64 ( Z '1011121314151617' ), ToInt64 ( Z '18191A1B1C1D1E1F' ), & ToInt64 ( Z '2021222324252627' ), ToInt64 ( Z '28292A2B2C2D2E2F' ), & ToInt64 ( Z '3031323334353637' ), ToInt64 ( Z '38393A3B3C3D3E3F' ), & ToInt64 ( Z '4041424344454647' ), ToInt64 ( Z '48494A4B4C4D4E4F' ), & ToInt64 ( Z '5051525354555657' ), ToInt64 ( Z '58595A5B5C5D5E5F' ), & ToInt64 ( Z '6061626364656667' ), ToInt64 ( Z '68696A6B6C6D6E6F' ), & ToInt64 ( Z '7071727374757677' ), ToInt64 ( Z '78797A7B7C7D7E7F' )] tLong , PARAMETER :: IV512 ( 0 : 15 ) = [ & ToInt64 ( Z '8081828384858687' ), ToInt64 ( Z '88898A8B8C8D8E8F' ), & ToInt64 ( Z '9091929394959697' ), ToInt64 ( Z '98999A9B9C9D9E9F' ), & ToInt64 ( Z 'A0A1A2A3A4A5A6A7' ), ToInt64 ( Z 'A8A9AAABACADAEAF' ), & ToInt64 ( Z 'B0B1B2B3B4B5B6B7' ), ToInt64 ( Z 'B8B9BABBBCBDBEBF' ), & ToInt64 ( Z 'C0C1C2C3C4C5C6C7' ), ToInt64 ( Z 'C8C9CACBCCCDCECF' ), & ToInt64 ( Z 'D0D1D2D3D4D5D6D7' ), ToInt64 ( Z 'D8D9DADBDCDDDEDF' ), & ToInt64 ( Z 'E0E1E2E3E4E5E6E7' ), ToInt64 ( Z 'E8E9EAEBECEDEEEF' ), & ToInt64 ( Z 'F0F1F2F3F4F5F6F7' ), ToInt64 ( Z 'F8F9FAFBFCFDFEFF' )] tLong , PARAMETER :: FINAL_PARAM ( 0 : 15 ) = [ & ToInt64 ( Z 'AAAAAAAAAAAAAAA0' ), ToInt64 ( Z 'AAAAAAAAAAAAAAA1' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAA2' ), ToInt64 ( Z 'AAAAAAAAAAAAAAA3' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAA4' ), ToInt64 ( Z 'AAAAAAAAAAAAAAA5' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAA6' ), ToInt64 ( Z 'AAAAAAAAAAAAAAA7' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAA8' ), ToInt64 ( Z 'AAAAAAAAAAAAAAA9' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAAA' ), ToInt64 ( Z 'AAAAAAAAAAAAAAAB' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAAC' ), ToInt64 ( Z 'AAAAAAAAAAAAAAAD' ), & ToInt64 ( Z 'AAAAAAAAAAAAAAAE' ), ToInt64 ( Z 'AAAAAAAAAAAAAAAF' )] !** DERIVED TYPE DEFINITIONS !> *BmwB* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *BMW-384* or the *BMW-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: BmwB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tLong :: H ( 0 : 15 ) = IV512 ( 0 : 15 ) !% flag indicating whether the BMW-384 algorithm is employed or not. tLogical :: IsBMW384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => BmwB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BMW-512). PROCEDURE :: Initialize => BmwB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => BmwB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => BmwB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => BmwB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => BmwB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => BmwB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => BmwB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => BmwB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => BmwB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => BmwB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BMW-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BMW-384 algorithm <br> !   --->    CALL MD%Create(IsBMW384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE BmwB !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE BmwB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the BMW-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE BmwB_Initialize !****************************************************************************** SUBROUTINE BmwB_Initialize_wFlag ( MD , IsBMW384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object tLogical , INTENT ( IN ) :: IsBMW384 !&#94; flag indicating whether the BMW-384 algorithm is employed or not. <br> !  - If true, use the BMW-384 algorithm. <br> !  - Otherwise, use the BMW-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsBMW384 = IsBMW384 CALL MD % Reset () RETURN END SUBROUTINE BmwB_Initialize_wFlag !****************************************************************************** SUBROUTINE BmwB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsBMW384 ) THEN MD % H = IV384 ELSE MD % H = IV512 END IF CALL MD % EngineReset () RETURN END SUBROUTINE BmwB_Reset !****************************************************************************** SUBROUTINE BmwB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( BmwB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( BmwB ) CALL Dst % Create ( Src % IsBMW384 ) Dst % H = Src % H Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE BmwB_GetClone !****************************************************************************** FUNCTION BmwB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( IN ) :: MD !! 'BmwB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBMW384 ) THEN Name = 'BMW-384' ELSE Name = 'BMW-512' END IF RETURN END FUNCTION BmwB_GetName !****************************************************************************** FUNCTION BmwB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( IN ) :: MD !! 'BmwB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBMW384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION BmwB_GetDigestLen !****************************************************************************** FUNCTION BmwB_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( IN ) :: MD !! 'BmwB' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION BmwB_GetBlockLen !****************************************************************************** SUBROUTINE BmwB_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), TARGET , INTENT ( INOUT ) :: MD !! 'BmwB' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE BmwB_SetBufPtr !****************************************************************************** SUBROUTINE BmwB_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: M ( 0 : 15 ) ! FLOW ! input block CALL BytePackLE ( BytesIn , 0_kIndex , M ) ! perform 16 rounds of mixing CALL Compress ( MD % H , M ) RETURN END SUBROUTINE BmwB_ProcessBlock !****************************************************************************** SUBROUTINE BmwB_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE BmwB_DoPadding !****************************************************************************** SUBROUTINE BmwB_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BmwB ), INTENT ( INOUT ) :: MD !! 'BmwB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: H2 ( 0 : 15 ) tIndex :: Ptr , I , J , DLen tLong :: BitLen tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () BitLen = SHIFTL ( ToInt64 ( MD % GetBlockCount ()), 10 ) + SHIFTL ( ToInt64 ( Ptr ), 3 ) Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1_kIndex IF ( Ptr > 120_kIndex ) THEN TmpBuf ( Ptr : 127 ) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) Ptr = 0_kIndex END IF TmpBuf ( Ptr : 119 ) = FByte00 CALL ByteUnpackLE ( BitLen + NBits , TmpBuf , 120_kIndex ) CALL MD % ProcessBlock ( TmpBuf ) END ASSOCIATE ! finalizing H2 = MD % H MD % H = FINAL_PARAM CALL Compress ( MD % H , H2 ) DLen = SHIFTR ( MD % GetDigestLen (), 3 ) J = 16_kIndex - DLen DO I = 0_kIndex , DLen - 1_kIndex CALL ByteUnpackLE ( MD % H ( J ), BytesOut , Offset + I * 8_kIndex ) J = J + 1_kIndex END DO RETURN END SUBROUTINE BmwB_AddBitsNPad !****************************************************************************** SUBROUTINE Compress ( H , M ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the compression of the given message. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: H ( 0 : 15 ) tLong , INTENT ( IN ) :: M ( 0 : 15 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: Q ( 0 : 31 ) tLong :: Xl , Xh !** SUBROUTINE MACRO DEFINITIONS: #define SB0(x)      IEOR(IEOR(IEOR(SHIFTR(x, 1), SHIFTL(x, 3)), RotateLeft(x,  4)), RotateLeft(x, 37)) #define SB1(x)      IEOR(IEOR(IEOR(SHIFTR(x, 1), SHIFTL(x, 2)), RotateLeft(x,  13)), RotateLeft(x, 43)) #define SB2(x)      IEOR(IEOR(IEOR(SHIFTR(x, 2), SHIFTL(x, 1)), RotateLeft(x,  19)), RotateLeft(x, 53)) #define SB3(x)      IEOR(IEOR(IEOR(SHIFTR(x, 2), SHIFTL(x, 2)), RotateLeft(x,  28)), RotateLeft(x, 59)) #define SB4(x)      IEOR(SHIFTR(x, 1), x) #define SB5(x)      IEOR(SHIFTR(x, 2), x) #define RB1(x)      RotateLeft(x,  5) #define RB2(x)      RotateLeft(x, 11) #define RB3(x)      RotateLeft(x, 27) #define RB4(x)      RotateLeft(x, 32) #define RB5(x)      RotateLeft(x, 37) #define RB6(x)      RotateLeft(x, 43) #define RB7(x)      RotateLeft(x, 53) #define KB(j)       (j * ToInt64(Z'0555555555555555')) #define Add_Elt_B(mf, hf, j0m, j1m, j3m, j4m, j7m, j10m, j11m, j16) \\ IEOR (( RotateLeft ( mf ( j0m ), j1m ) + RotateLeft ( mf ( j3m ), j4m ) - \\ RotateLeft ( mf ( j10m ), j11m ) + KB ( j16 )), hf ( j7m )) #define Expand1B_Inner(qf, mf, hf, i16, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i0m, i1m, i3m, i4m, i7m, i10m, i11m) \\ ( SB1 ( qf ( i0 )) + SB2 ( qf ( i1 )) + SB3 ( qf ( i2 )) + SB0 ( qf ( i3 )) \\ + SB1 ( qf ( i4 )) + SB2 ( qf ( i5 )) + SB3 ( qf ( i6 )) + SB0 ( qf ( i7 )) \\ + SB1 ( qf ( i8 )) + SB2 ( qf ( i9 )) + SB3 ( qf ( i10 )) + SB0 ( qf ( i11 )) \\ + SB1 ( qf ( i12 )) + SB2 ( qf ( i13 )) + SB3 ( qf ( i14 )) + SB0 ( qf ( i15 )) \\ + Add_Elt_B ( mf , hf , i0m , i1m , i3m , i4m , i7m , i10m , i11m , i16 )) #define Expand1B16(qf, mf, hf, i16)     Expand1B_Inner(qf, mf, hf, i16, 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 0,  1,  3,  4,  7, 10, 11) #define Expand1B17(qf, mf, hf, i16)     Expand1B_Inner(qf, mf, hf, i16, 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 1,  2,  4,  5,  8, 11, 12) #define Expand2B_Inner(qf, mf, hf, i16, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, i0m, i1m, i3m, i4m, i7m, i10m, i11m) \\ ( qf ( i0 ) + RB1 ( qf ( i1 )) + qf ( i2 ) + RB2 ( qf ( i3 )) \\ + qf ( i4 ) + RB3 ( qf ( i5 )) + qf ( i6 ) + RB4 ( qf ( i7 )) \\ + qf ( i8 ) + RB5 ( qf ( i9 )) + qf ( i10 ) + RB6 ( qf ( i11 )) \\ + qf ( i12 ) + RB7 ( qf ( i13 )) + SB4 ( qf ( i14 )) + SB5 ( qf ( i15 )) \\ + Add_Elt_B ( mf , hf , i0m , i1m , i3m , i4m , i7m , i10m , i11m , i16 )) #define Expand2B18(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 2,  3,  5,  6,  9, 12, 13) #define Expand2B19(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 3,  4,  6,  7, 10, 13, 14) #define Expand2B20(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 4,  5,  7,  8, 11, 14, 15) #define Expand2B21(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 5,  6,  8,  9, 12, 15, 16) #define Expand2B22(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 6,  7,  9, 10, 13,  0,  1) #define Expand2B23(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 7,  8, 10, 11, 14,  1,  2) #define Expand2B24(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 8,  9, 11, 12, 15,  2,  3) #define Expand2B25(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 9, 10, 12, 13,  0,  3,  4) #define Expand2B26(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 10, 11, 13, 14,  1,  4,  5) #define Expand2B27(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 11, 12, 14, 15,  2,  5,  6) #define Expand2B28(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 12, 13, 15, 16,  3,  6,  7) #define Expand2B29(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 13, 14,  0,  1,  4,  7,  8) #define Expand2B30(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 14, 15,  1,  2,  5,  8,  9) #define Expand2B31(qf, mf, hf, i16)     Expand2B_Inner(qf, mf, hf, i16, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 15, 16,  2,  3,  6,  9, 10) #define MAKE_W(i0, op01, i1, op12, i2, op23, i3, op34, i4) \\ ( IEOR ( M ( i0 ), H ( i0 )) op01 IEOR ( M ( i1 ), H ( i1 )) op12 IEOR ( M ( i2 ), H ( i2 )) op23 IEOR ( M ( i3 ), H ( i3 )) op34 IEOR ( M ( i4 ), H ( i4 ))) #define Wb0             MAKE_W( 5, -,  7, +, 10, +, 13, +, 14) #define Wb1             MAKE_W( 6, -,  8, +, 11, +, 14, -, 15) #define Wb2             MAKE_W( 0, +,  7, +,  9, -, 12, +, 15) #define Wb3             MAKE_W( 0, -,  1, +,  8, -, 10, +, 13) #define Wb4             MAKE_W( 1, +,  2, +,  9, -, 11, -, 14) #define Wb5             MAKE_W( 3, -,  2, +, 10, -, 12, +, 15) #define Wb6             MAKE_W( 4, -,  0, -,  3, -, 11, +, 13) #define Wb7             MAKE_W( 1, -,  4, -,  5, -, 12, -, 14) #define Wb8             MAKE_W( 2, -,  5, -,  6, +, 13, -, 15) #define Wb9             MAKE_W( 0, -,  3, +,  6, -,  7, +, 14) #define Wb10            MAKE_W( 8, -,  1, -,  4, -,  7, +, 15) #define Wb11            MAKE_W( 8, -,  0, -,  2, -,  5, +,  9) #define Wb12            MAKE_W( 1, +,  3, -,  6, -,  9, +, 10) #define Wb13            MAKE_W( 2, +,  4, +,  7, +, 10, +, 11) #define Wb14            MAKE_W( 3, -,  5, +,  8, -, 11, -, 12) #define Wb15            MAKE_W(12, -,  4, -,  6, -,  9, +, 13) #define IEOR3(A, B, C)  IEOR(IEOR(A, B), C) ! FLOW Q ( 0 ) = SB0 ( Wb0 ) + H ( 1 ) Q ( 1 ) = SB1 ( Wb1 ) + H ( 2 ) Q ( 2 ) = SB2 ( Wb2 ) + H ( 3 ) Q ( 3 ) = SB3 ( Wb3 ) + H ( 4 ) Q ( 4 ) = SB4 ( Wb4 ) + H ( 5 ) Q ( 5 ) = SB0 ( Wb5 ) + H ( 6 ) Q ( 6 ) = SB1 ( Wb6 ) + H ( 7 ) Q ( 7 ) = SB2 ( Wb7 ) + H ( 8 ) Q ( 8 ) = SB3 ( Wb8 ) + H ( 9 ) Q ( 9 ) = SB4 ( Wb9 ) + H ( 10 ) Q ( 10 ) = SB0 ( Wb10 ) + H ( 11 ) Q ( 11 ) = SB1 ( Wb11 ) + H ( 12 ) Q ( 12 ) = SB2 ( Wb12 ) + H ( 13 ) Q ( 13 ) = SB3 ( Wb13 ) + H ( 14 ) Q ( 14 ) = SB4 ( Wb14 ) + H ( 15 ) Q ( 15 ) = SB0 ( Wb15 ) + H ( 0 ) Q ( 16 ) = Expand1B16 ( Q , M , H , 16 ) Q ( 17 ) = Expand1B17 ( Q , M , H , 17 ) Q ( 18 ) = Expand2B18 ( Q , M , H , 18 ) Q ( 19 ) = Expand2B19 ( Q , M , H , 19 ) Q ( 20 ) = Expand2B20 ( Q , M , H , 20 ) Q ( 21 ) = Expand2B21 ( Q , M , H , 21 ) Q ( 22 ) = Expand2B22 ( Q , M , H , 22 ) Q ( 23 ) = Expand2B23 ( Q , M , H , 23 ) Q ( 24 ) = Expand2B24 ( Q , M , H , 24 ) Q ( 25 ) = Expand2B25 ( Q , M , H , 25 ) Q ( 26 ) = Expand2B26 ( Q , M , H , 26 ) Q ( 27 ) = Expand2B27 ( Q , M , H , 27 ) Q ( 28 ) = Expand2B28 ( Q , M , H , 28 ) Q ( 29 ) = Expand2B29 ( Q , M , H , 29 ) Q ( 30 ) = Expand2B30 ( Q , M , H , 30 ) Q ( 31 ) = Expand2B31 ( Q , M , H , 31 ) XL = IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( Q ( 16 ), Q ( 17 )), Q ( 18 )), Q ( 19 )), & Q ( 20 )), Q ( 21 )), Q ( 22 )), Q ( 23 )) XH = IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( IEOR ( XL , Q ( 24 )), Q ( 25 )), Q ( 26 )), Q ( 27 )), & Q ( 28 )), Q ( 29 )), Q ( 30 )), Q ( 31 )) H ( 0 ) = IEOR3 ( SHIFTL ( XH , 5 ), SHIFTR ( Q ( 16 ), 5 ), M ( 0 )) + IEOR3 ( XL , Q ( 24 ), Q ( 0 )) H ( 1 ) = IEOR3 ( SHIFTR ( XH , 7 ), SHIFTL ( Q ( 17 ), 8 ), M ( 1 )) + IEOR3 ( XL , Q ( 25 ), Q ( 1 )) H ( 2 ) = IEOR3 ( SHIFTR ( XH , 5 ), SHIFTL ( Q ( 18 ), 5 ), M ( 2 )) + IEOR3 ( XL , Q ( 26 ), Q ( 2 )) H ( 3 ) = IEOR3 ( SHIFTR ( XH , 1 ), SHIFTL ( Q ( 19 ), 5 ), M ( 3 )) + IEOR3 ( XL , Q ( 27 ), Q ( 3 )) H ( 4 ) = IEOR3 ( SHIFTR ( XH , 3 ), SHIFTL ( Q ( 20 ), 0 ), M ( 4 )) + IEOR3 ( XL , Q ( 28 ), Q ( 4 )) H ( 5 ) = IEOR3 ( SHIFTL ( XH , 6 ), SHIFTR ( Q ( 21 ), 6 ), M ( 5 )) + IEOR3 ( XL , Q ( 29 ), Q ( 5 )) H ( 6 ) = IEOR3 ( SHIFTR ( XH , 4 ), SHIFTL ( Q ( 22 ), 6 ), M ( 6 )) + IEOR3 ( XL , Q ( 30 ), Q ( 6 )) H ( 7 ) = IEOR3 ( SHIFTR ( XH , 11 ), SHIFTL ( Q ( 23 ), 2 ), M ( 7 )) + IEOR3 ( XL , Q ( 31 ), Q ( 7 )) H ( 8 ) = RotateLeft ( H ( 4 ), 9 ) + IEOR3 ( XH , Q ( 24 ), M ( 8 )) + IEOR3 ( SHIFTL ( XL , 8 ), Q ( 23 ), Q ( 8 )) H ( 9 ) = RotateLeft ( H ( 5 ), 10 ) + IEOR3 ( XH , Q ( 25 ), M ( 9 )) + IEOR3 ( SHIFTR ( XL , 6 ), Q ( 16 ), Q ( 9 )) H ( 10 ) = RotateLeft ( H ( 6 ), 11 ) + IEOR3 ( XH , Q ( 26 ), M ( 10 )) + IEOR3 ( SHIFTL ( XL , 6 ), Q ( 17 ), Q ( 10 )) H ( 11 ) = RotateLeft ( H ( 7 ), 12 ) + IEOR3 ( XH , Q ( 27 ), M ( 11 )) + IEOR3 ( SHIFTL ( XL , 4 ), Q ( 18 ), Q ( 11 )) H ( 12 ) = RotateLeft ( H ( 0 ), 13 ) + IEOR3 ( XH , Q ( 28 ), M ( 12 )) + IEOR3 ( SHIFTR ( XL , 3 ), Q ( 19 ), Q ( 12 )) H ( 13 ) = RotateLeft ( H ( 1 ), 14 ) + IEOR3 ( XH , Q ( 29 ), M ( 13 )) + IEOR3 ( SHIFTR ( XL , 4 ), Q ( 20 ), Q ( 13 )) H ( 14 ) = RotateLeft ( H ( 2 ), 15 ) + IEOR3 ( XH , Q ( 30 ), M ( 14 )) + IEOR3 ( SHIFTR ( XL , 7 ), Q ( 21 ), Q ( 14 )) H ( 15 ) = RotateLeft ( H ( 3 ), 16 ) + IEOR3 ( XH , Q ( 31 ), M ( 15 )) + IEOR3 ( SHIFTR ( XL , 2 ), Q ( 22 ), Q ( 15 )) RETURN END SUBROUTINE Compress !****************************************************************************** END MODULE MClass_BmwB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_bmwb.f90.html"},{"title":"MBase_OptimalHash32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_OptimalHash32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains an optimal implementation of various non-cryptographic hash !   function routines that output a hash value as a 32-bit integer.  The available !   hash functions are a subset of those reference hash functions implemented in the !   <a href=\"../module/mbase_referencehash32.html\">ModBase_ReferenceHash32</a> module. !   The API of these optimal routines are exactly the same as those reference routines. <br> !   It should be noted that each optimal hash function routine is based on a benchmark !   that compares performances of various possible implementations of the hash function !   as provided in the  <a href=\"../module/mbase_experimentalhash32.html\"> !   ModBase_ExperimentalHash32</a> module.  It should also be noted that these so-called !   optimal hash function routines may not actually be optimal for a particular user so !   the user is highly encouraged to perform (by himself/herself) a benchmark of each !   specific hash function routine in order to know which implementation is the best one !   for a particular system (i.e. a combination of operating system, machine as well as !   compiler used). <br> !   <br> !&#94; **REFERENCES**: <br> !   See the <a href=\"../module/mbase_referencehash32.html\">ModBase_ReferenceHash32</a> !   module for references of the available hash functions in this module. !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_ByteUtil , ONLY : SwapBytes IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! experimental procedures PUBLIC :: City_Hash32_Opt PUBLIC :: FarmMk_Hash32_Opt PUBLIC :: Lookup3_Hash32_Opt PUBLIC :: Murmur3_Hash32_Opt PUBLIC :: NM_Hash32_Opt PUBLIC :: NMx_Hash32_Opt PUBLIC :: Water_Hash32_Opt PUBLIC :: XX_Hash32_Opt PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_OpterimentalHash32' ! The maximum (positive) number of hash code tUInt32 , PARAMETER :: MaxHash = ToInt32 ( Z '7FFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE FUNCTION Pack_I16 ( ByteArr , Offset ) RESULT ( Res ) !&#94; To convert an array of 8-bit integers starting at the offset to !  a 16-bit integer value. IMPORT tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt16 :: Res !! result END FUNCTION Pack_I16 FUNCTION Pack_I32 ( ByteArr , Offset ) RESULT ( Res ) !&#94; To convert an array of 8-bit integers starting at the offset to !  a 32-bit integer value. IMPORT tUInt8 , TARGET , INTENT ( IN ) :: ByteArr ( 0 :) !! byte array tIndex , INTENT ( IN ) :: Offset !! offset tUInt32 :: Res !! result END FUNCTION Pack_I32 END INTERFACE INTERFACE !---------------------------------------------------------------------- MODULE FUNCTION Lookup3_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Murmur3_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the MurmurHash3 hash algorithm by Austin !  Appleby [1]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION City_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the City hash algorithm by Google Inc [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmMk_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION NM_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMHASH hash algorithm !  by James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION NMx_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMxHASH hash algorithm by !  James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Water_Hash32_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using a new version of the WaterHash hash !  algorithm by Tommy Ettinger [11]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** FUNCTION PackPartial ( Buf , Off , Length , PackFull ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack three or fewer bytes of the array 'Buf' at offset 'Off' ! into the 32-bit word 'Res'. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) !! buffer tIndex , INTENT ( IN ) :: Off !! offset tIndex , INTENT ( IN ) :: Length !! the number of bytes to pack (between 1 to 3) PROCEDURE ( Pack_I32 ) :: PackFull !! procedure to convert a byte array to 32-bit integer tUInt32 :: Res !! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 3 ) ! FLOW ! initialize Wrk = 0_kInt8 ! gather available bytes in little-endian order Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) ! gather available bytes in big-endian order !    Wrk(Length-1:0:-1) = Buf(Off:Off+Length-1) ! pack bytes into word Res = PackFull ( Wrk , 0_kIndex ) RETURN END FUNCTION PackPartial !****************************************************************************** END MODULE MBase_OptimalHash32 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_optimalhash32.f90.html"},{"title":"MClass_Blake1S.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake1S !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake1S* type and its related routines. !   The *Blake1S* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *Blake1S* type implements an incremental cryptographic hash !   function by employing either the *BLAKE-224* or the *BLAKE-256 !   message-digest* algorithm where both algorithms are described in !   the *Hash Function BLAKE* book [1].  The implementation here is !   based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *Blake1S* type employs the *BLAKE-256 message-digest* !   algorithm.  However, a user can specify the *IsBLAKE224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *BLAKE-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.aumasson.jp/blake/book/\">J.P. Aumasson, W. Meier, !       R.C.W. Phan, and L. Henzen. 2015. The Hash Function BLAKE. Springer. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Blake1S PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: IV224 ( 0 : 7 ) = [ & ToInt32 ( Z 'C1059ED8' ), ToInt32 ( Z '367CD507' ), & ToInt32 ( Z '3070DD17' ), ToInt32 ( Z 'F70E5939' ), & ToInt32 ( Z 'FFC00B31' ), ToInt32 ( Z '68581511' ), & ToInt32 ( Z '64F98FA7' ), ToInt32 ( Z 'BEFA4FA4' )] tInteger , PARAMETER :: IV256 ( 0 : 7 ) = [ & ToInt32 ( Z '6A09E667' ), ToInt32 ( Z 'BB67AE85' ), & ToInt32 ( Z '3C6EF372' ), ToInt32 ( Z 'A54FF53A' ), & ToInt32 ( Z '510E527F' ), ToInt32 ( Z '9B05688C' ), & ToInt32 ( Z '1F83D9AB' ), ToInt32 ( Z '5BE0CD19' )] tIndex , PARAMETER :: SIGMA ( 0 : 223 ) = [ & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 , & 9 , 0 , 5 , 7 , 2 , 4 , 10 , 15 , 14 , 1 , 11 , 12 , 6 , 8 , 3 , 13 , & 2 , 12 , 6 , 10 , 0 , 11 , 8 , 3 , 4 , 13 , 7 , 5 , 15 , 14 , 1 , 9 , & 12 , 5 , 1 , 15 , 14 , 13 , 4 , 10 , 0 , 7 , 6 , 3 , 9 , 2 , 8 , 11 , & 13 , 11 , 7 , 14 , 12 , 1 , 3 , 9 , 5 , 0 , 15 , 4 , 8 , 6 , 2 , 10 , & 6 , 15 , 14 , 9 , 11 , 3 , 0 , 8 , 12 , 2 , 13 , 7 , 1 , 4 , 10 , 5 , & 10 , 2 , 8 , 4 , 7 , 6 , 1 , 5 , 15 , 11 , 9 , 14 , 3 , 12 , 13 , 0 , & 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , & 14 , 10 , 4 , 8 , 9 , 15 , 13 , 6 , 1 , 12 , 0 , 2 , 11 , 7 , 5 , 3 , & 11 , 8 , 12 , 0 , 5 , 2 , 15 , 13 , 10 , 14 , 3 , 6 , 7 , 1 , 9 , 4 , & 7 , 9 , 3 , 1 , 13 , 12 , 11 , 14 , 2 , 6 , 5 , 10 , 4 , 0 , 15 , 8 ] tInteger , PARAMETER :: CS ( 0 : 15 ) = [ & ToInt32 ( Z '243F6A88' ), ToInt32 ( Z '85A308D3' ), & ToInt32 ( Z '13198A2E' ), ToInt32 ( Z '03707344' ), & ToInt32 ( Z 'A4093822' ), ToInt32 ( Z '299F31D0' ), & ToInt32 ( Z '082EFA98' ), ToInt32 ( Z 'EC4E6C89' ), & ToInt32 ( Z '452821E6' ), ToInt32 ( Z '38D01377' ), & ToInt32 ( Z 'BE5466CF' ), ToInt32 ( Z '34E90C6C' ), & ToInt32 ( Z 'C0AC29B7' ), ToInt32 ( Z 'C97C50DD' ), & ToInt32 ( Z '3F84D5B5' ), ToInt32 ( Z 'B5470917' )] !** DERIVED TYPE DEFINITIONS !> *Blake1S* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *BLAKE-224* or the *BLAKE-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: Blake1S PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: H ( 0 : 7 ) = IV256 ( 0 : 7 ) tInteger :: S ( 0 : 3 ) = 0 tInteger :: T ( 0 : 1 ) = 0 !% flag indicating whether the BLAKE-224 algorithm is employed or not. tLogical :: IsBLAKE224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => Blake1S_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (BLAKE-256). PROCEDURE :: Initialize => Blake1S_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake1S_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake1S_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake1S_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Blake1S_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => Blake1S_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Blake1S_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Blake1S_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => Blake1S_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => Blake1S_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (BLAKE-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the BLAKE-224 algorithm <br> !   --->    CALL MD%Create(IsBLAKE224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE Blake1S !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake1S_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the BLAKE-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE Blake1S_Initialize !****************************************************************************** SUBROUTINE Blake1S_Initialize_wFlag ( MD , IsBLAKE224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object tLogical , INTENT ( IN ) :: IsBLAKE224 !&#94; flag indicating whether the BLAKE-224 algorithm is employed or not. <br> !  - If true, use the BLAKE-224 algorithm. <br> !  - Otherwise, use the BLAKE-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsBLAKE224 = IsBLAKE224 CALL MD % Reset () RETURN END SUBROUTINE Blake1S_Initialize_wFlag !****************************************************************************** SUBROUTINE Blake1S_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % S = 0 MD % T = 0 IF ( MD % IsBLAKE224 ) THEN MD % H = IV224 ELSE MD % H = IV256 END IF CALL MD % EngineReset () RETURN END SUBROUTINE Blake1S_Reset !****************************************************************************** SUBROUTINE Blake1S_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Blake1S :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Blake1S ) CALL Dst % Create ( Src % IsBLAKE224 ) Dst % H = Src % H Dst % S = Src % S Dst % T = Src % T Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE Blake1S_GetClone !****************************************************************************** FUNCTION Blake1S_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( IN ) :: MD !! 'Blake1S' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBLAKE224 ) THEN Name = 'BLAKE-224' ELSE Name = 'BLAKE-256' END IF RETURN END FUNCTION Blake1S_GetName !****************************************************************************** FUNCTION Blake1S_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( IN ) :: MD !! 'Blake1S' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsBLAKE224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION Blake1S_GetDigestLen !****************************************************************************** FUNCTION Blake1S_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( IN ) :: MD !! 'Blake1S' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION Blake1S_GetBlockLen !****************************************************************************** SUBROUTINE Blake1S_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), TARGET , INTENT ( INOUT ) :: MD !! 'Blake1S' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE Blake1S_SetBufPtr !****************************************************************************** SUBROUTINE Blake1S_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: M ( 0 : 15 ) tInteger :: V ( 0 : 15 ) tIndex :: I , J , R tIndex :: K ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define IEOR2(X, Y, Z)      IEOR(IEOR(X, Y), Z) #define LShift4(X)          SHIFTL(X, 4) #define GS(K0, K1, A, B, C, D) \\ A = A + B + ( IEOR ( M ( K0 ), CS ( K1 ))); \\ D = RotateRight ( IEOR ( D , A ), 16 ); \\ C = C + D ; \\ B = RotateRight ( IEOR ( B , C ), 12 ); \\ A = A + B + ( IEOR ( M ( K1 ), CS ( K0 ))); \\ D = RotateRight ( IEOR ( D , A ), 8 ); \\ C = C + D ; \\ B = RotateRight ( IEOR ( B , C ), 7 ); ! FLOW ! initialize MD % T ( 0 ) = MD % T ( 0 ) + 512_kInt32 IF ( IAND ( MD % T ( 0 ), NOT ( ToInt32 ( Z '1FF' ))) == 0_kInt32 ) MD % T ( 1 ) = MD % T ( 1 ) + 1 V ( 0 : 3 ) = MD % S ( 0 : 3 ) V ( 4 : 5 ) = MD % T ( 0 ) V ( 6 : 7 ) = MD % T ( 1 ) DO I = 0 , 7 V ( I + 8 ) = IEOR ( V ( I ), CS ( I )) END DO V ( 0 : 7 ) = MD % H ( 0 : 7 ) ! input block CALL BytePackBE ( BytesIn , 0_kIndex , M ) ! perform block transformation DO R = 0 , 13 ! compute indices DO I = 0 , 15 K ( I ) = SIGMA ( LShift4 ( R ) + I ) END DO ! perform core operations GS ( K ( 0 ), K ( 1 ), V ( 0 ), V ( 4 ), V ( 8 ), V ( 12 )) GS ( K ( 2 ), K ( 3 ), V ( 1 ), V ( 5 ), V ( 9 ), V ( 13 )) GS ( K ( 4 ), K ( 5 ), V ( 2 ), V ( 6 ), V ( 10 ), V ( 14 )) GS ( K ( 6 ), K ( 7 ), V ( 3 ), V ( 7 ), V ( 11 ), V ( 15 )) GS ( K ( 8 ), K ( 9 ), V ( 0 ), V ( 5 ), V ( 10 ), V ( 15 )) GS ( K ( 10 ), K ( 11 ), V ( 1 ), V ( 6 ), V ( 11 ), V ( 12 )) GS ( K ( 12 ), K ( 13 ), V ( 2 ), V ( 7 ), V ( 8 ), V ( 13 )) GS ( K ( 14 ), K ( 15 ), V ( 3 ), V ( 4 ), V ( 9 ), V ( 14 )) END DO ! update H DO I = 0 , 7 J = I IF ( J > 3 ) J = J - 4 MD % H ( I ) = IEOR ( MD % H ( I ), IEOR2 ( MD % S ( J ), V ( I ), V ( I + 8 ))) END DO RETURN #undef IEOR2 #undef LShift4 #undef GS END SUBROUTINE Blake1S_ProcessBlock !****************************************************************************** SUBROUTINE Blake1S_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE Blake1S_DoPadding !****************************************************************************** SUBROUTINE Blake1S_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake1S ), INTENT ( INOUT ) :: MD !! 'Blake1S' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , BitLen , I tInteger :: TH , TL tByte :: Z ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) TmpBuf = 0_kInt8 Ptr = MD % GetBufLen () BitLen = SHIFTL ( Ptr , 3 ) + NBits Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) TL = MD % T ( 0 ) + BitLen TH = MD % T ( 1 ) IF (( Ptr == 0_kIndex ). AND .( NBits == 0_kIndex )) THEN MD % T ( 0 ) = ToInt32 ( Z 'FFFFFE00' ) MD % T ( 1 ) = ToInt32 ( Z 'FFFFFFFF' ) ELSEIF ( MD % T ( 0 ) == 0 ) THEN MD % T ( 0 ) = ToInt32 ( Z 'FFFFFE00' ) + BitLen MD % T ( 1 ) = MD % T ( 1 ) - 1_kInt32 ELSE MD % T ( 0 ) = MD % T ( 0 ) - ( 512_kInt32 - BitLen ) END IF IF ( BitLen <= 446_kIndex ) THEN TmpBuf ( Ptr + 1 : 55 ) = 0_kInt8 IF ( MD % GetDigestLen () == 32_kIndex ) TmpBuf ( 55 ) = IOR ( TmpBuf ( 55 ), 1_kInt8 ) CALL ByteUnpackBE ( TH , TmpBuf , 56_kIndex ) CALL ByteUnpackBE ( TL , TmpBuf , 60_kIndex ) CALL MD % Update ( TmpBuf , Ptr , 64_kIndex - Ptr ) ELSE TmpBuf ( Ptr + 1 : 63 ) = 0_kInt8 CALL MD % Update ( TmpBuf , Ptr , 64_kIndex - Ptr ) MD % T ( 0 ) = ToInt32 ( Z 'FFFFFE00' ) MD % T ( 1 ) = ToInt32 ( Z 'FFFFFFFF' ) TmpBuf ( 0 : 55 ) = 0_kInt8 IF ( MD % GetDigestLen () == 32_kIndex ) TmpBuf ( 55 ) = 1_kInt8 CALL ByteUnpackBE ( TH , TmpBuf , 56_kIndex ) CALL ByteUnpackBE ( TL , TmpBuf , 60_kIndex ) CALL MD % Update ( TmpBuf , 0_kIndex , 64_kIndex ) END IF END ASSOCIATE DO I = 0_kIndex , ( MD % GetDigestLen () / 4_kIndex - 1_kIndex ) CALL ByteUnpackBE ( MD % H ( I ), BytesOut , Offset + 4_kIndex * I ) END DO RETURN END SUBROUTINE Blake1S_AddBitsNPad !****************************************************************************** END MODULE MClass_Blake1S !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake1s.f90.html"},{"title":"MClass_MDEngine.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MDEngine !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MDEngine* type and its related routines. !   The *MDEngine* type is an abstract *digest* type extending directly !   from the <a href=\"../module/mclass_basedigest.html#type-basedigest\"> !   BaseDigest</a> type.  It defines additional methods (most of which !   is intended to be used internally) to provide an extended API for !   an incremental cryptographic hash function. <br> !   By design, the *MDEngine* type is intended to be used as a template !   (a parent type) to implement a cryptographic hash function.  It takes !   care some of the deferred procedures required by a *digest* object. !   If practical, all other *digest* types that implement specific hash !   functions should extend from this template type. !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MDEngine PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: ! parameters for the first padding byte tUInt8 , PARAMETER , PUBLIC :: FByte00 = ToInt8 ( Z '00' ) tUInt8 , PARAMETER , PUBLIC :: FByte01 = ToInt8 ( Z '01' ) tUInt8 , PARAMETER , PUBLIC :: FByte80 = ToInt8 ( Z '80' ) tUInt8 , PARAMETER , PUBLIC :: FByteFF = ToInt8 ( Z 'FF' ) !** DERIVED TYPE DEFINITIONS !> *MDEngine* is an abstract *digest* type provided to be a template !  (a parent class) for other *digest* types to implement incremental !  cryptographic hash functions. TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: MDEngine PRIVATE !% the number of blocks of input processed tIndex :: BlockCount = 0_kIndex !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                 Additional Deferred Procedures            ----- ! --------------------------------------------------------------------- !> *GetDigestLen* is a binding name of the *DEDigestLen* deferred procedure. <br> !  **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE ( DEDigestLen ), DEFERRED :: GetDigestLen !> *GetBlockLen* is a binding name of the *DEBlockLen* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEBlockLen ), DEFERRED :: GetBlockLen !> *SetBufPtr* is a binding name of the *DESetPtr* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DESetPtr ), DEFERRED :: SetBufPtr !> *ProcessBlock* is a binding name of the *DEProcess* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEProcess ), DEFERRED :: ProcessBlock !> *DoPadding* is a binding name of the *DEPadding* deferred procedure. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE ( DEPadding ), DEFERRED :: DoPadding !> *AddBitsNPad* is a binding name of the *DEAddBitsNPad* deferred procedure. <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. PROCEDURE ( DEAddBitsNPad ), DEFERRED :: AddBitsNPad ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => MDEngine_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => MDEngine_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => MDEngine_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => MDEngine_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *EngineReset* is a procedure to reset components of the digest to their initial values. <br> !  This procedure is NOT intended to be used by a user but the *Reset* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: EngineReset => MDEngine_Reset !> *EngineClone* is a procedure to copy components of the source object to the destination one. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method implemented !  by a *concrete* digest type should call this method. PROCEDURE :: EngineClone => MDEngine_Clone !> *GetBlockCount* is a procedure to get the number of blocks of input processed. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockCount => MDEngine_BlockCount !> *GetBufLen* is a procedure to get the number of bytes of input currently !  stored in the buffer. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBufLen => MDEngine_BufLen ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: MDEngine_ByteDigest_AddBits PROCEDURE , PRIVATE :: MDEngine_HexDigest_AddBits ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => MDEngine_ByteDigest_AddBits , & MDEngine_HexDigest_AddBits END TYPE MDEngine !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> DEDigestLen is a deferred procedure to return the natural hash !  function output length (in bytes). FUNCTION DEDigestLen ( MD ) RESULT ( Length ) IMPORT CLASS ( MDEngine ), INTENT ( IN ) :: MD !! 'MDEngine' object tIndex :: Length !! the digest length END FUNCTION !> DEBlockLen is a deferred procedure to return the *block length* !  for the hash function. <br> FUNCTION DEBlockLen ( MD ) RESULT ( Length ) IMPORT CLASS ( MDEngine ), INTENT ( IN ) :: MD !! *MDEngine* object tIndex :: Length !! the block length END FUNCTION !> DESetPtr is a deferred procedure to set the pointer *BufPtr* to !  the actual buffer array with starting index of zero. <br> SUBROUTINE DESetPtr ( MD , BufPtr ) IMPORT CLASS ( MDEngine ), TARGET , INTENT ( INOUT ) :: MD !! *MDEngine* object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer END SUBROUTINE !> DEProcess is a deferred procedure to process one block of data. <br> SUBROUTINE DEProcess ( MD , BytesIn ) IMPORT CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! *MDEngine* object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block END SUBROUTINE !> DEPadding is a deferred procedure to perform the final padding and store !  the result in the provided buffer.  This method shall call the *Flush* !  method and then the *Update* method with the appropriate padding data !  in order to get the full input data. SUBROUTINE DEPadding ( MD , BytesOut , Offset ) IMPORT CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset END SUBROUTINE !> DEAddBitsNPad is a deferred procedure to add the last byte and then perform !  the final padding and store the result in the provided buffer.  This method !  shall call the *Flush* and then the *Update* method with the appropriate !  padding data in order to get the full input data. SUBROUTINE DEAddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) IMPORT CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , INTENT ( IN ) :: LastByte !! the last byte tUInt8 , INTENT ( IN ) :: NBits !! number of bits in the last byte tUInt8 , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE MDEngine_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW MD % BufLen = 0_kIndex MD % BlockCount = 0_kIndex RETURN END SUBROUTINE MDEngine_Reset !****************************************************************************** SUBROUTINE MDEngine_Clone ( SrcMD , DstMD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy components of the source digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( IN ) :: SrcMD !! source object CLASS ( MDEngine ), INTENT ( INOUT ) :: DstMD !! destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW DstMD % BufLen = SrcMD % BufLen DstMD % BlockCount = SrcMD % BlockCount RETURN END SUBROUTINE MDEngine_Clone !****************************************************************************** FUNCTION MDEngine_BlockCount ( MD ) RESULT ( BlockCount ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of blocks of input processed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( IN ) :: MD !! 'MDEngine' object tIndex :: BlockCount !! number of blocks !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BlockCount = MD % BlockCount RETURN END FUNCTION MDEngine_BlockCount !****************************************************************************** FUNCTION MDEngine_BufLen ( MD ) RESULT ( BufLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of bytes of input currently stored in the buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( IN ) :: MD !! 'MDEngine' object tIndex :: BufLen !! number of bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufLen = MD % BufLen RETURN END FUNCTION MDEngine_BufLen !****************************************************************************** SUBROUTINE MDEngine_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , POINTER :: BufPtr (:) tIndex :: CurrLen , CopyLen , CurrOff ! FLOW ! set pointer to the buffer array CALL MD % SetBufPtr ( BufPtr ) CurrLen = Length CurrOff = Offset DO WHILE ( CurrLen > 0_kIndex ) CopyLen = MD % GetBlockLen () - MD % BufLen IF ( CopyLen > CurrLen ) CopyLen = CurrLen ! store input in the buffer array BufPtr ( MD % BufLen : MD % BufLen + CopyLen - 1_kIndex ) = ByteArr ( CurrOff : CurrOff + CopyLen - 1_kIndex ) CurrOff = CurrOff + CopyLen MD % BufLen = MD % BufLen + CopyLen CurrLen = CurrLen - CopyLen ! process the input if the buffer is full IF ( MD % BufLen == MD % GetBlockLen ()) THEN CALL MD % ProcessBlock ( BufPtr ) MD % BlockCount = MD % BlockCount + 1_kIndex MD % BufLen = 0_kIndex END IF END DO NULLIFY ( BufPtr ) RETURN END SUBROUTINE MDEngine_InsertBytes !****************************************************************************** SUBROUTINE MDEngine_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % Update ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE MDEngine_InsertGen !****************************************************************************** SUBROUTINE MDEngine_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MemAlloc ( ByteArr , MD % GetDigestLen (), StartID = 0_kIndex ) CALL MD % DoPadding ( ByteArr , 0_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE MDEngine_ByteDigest !****************************************************************************** SUBROUTINE MDEngine_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE MDEngine_ByteDigest_wInput !****************************************************************************** SUBROUTINE MDEngine_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , INTENT ( IN ) :: LastByte !! the last byte tUInt8 , INTENT ( IN ) :: NBits !! number of bits in the last byte tUInt8 , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MemAlloc ( ByteArr , MD % GetDigestLen (), StartID = 0_kIndex ) CALL MD % AddBitsNPad ( LastByte , NBits , ByteArr , 0_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE MDEngine_ByteDigest_AddBits !****************************************************************************** SUBROUTINE MDEngine_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MDEngine ), INTENT ( INOUT ) :: MD !! 'MDEngine' object tUInt8 , INTENT ( IN ) :: LastByte !! the last byte tUInt8 , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE MDEngine_HexDigest_AddBits !****************************************************************************** END MODULE MClass_MDEngine !******************************************************************************","tags":"","loc":"sourcefile\\mclass_mdengine.f90.html"},{"title":"MClass_NMHasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_NMHasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *NMHasher32* and *NMxHasher32* types and their related !   routines.  The *NMHasher32* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> type.  It !   provides all deferred procedures required by a *Hasher32* class and outputs the !   hash value as a 32-bit integer.  The *NMxHasher32* type is a hasher type that !   extends from the *NMHasher32* type and overrides a couple of methods that require !   different implementation from those of the *NMHasher32* type. <br> !   The *NMHasher32* type employs the *NM* hash algorithm for 32-bit integer !   output by James Z. M. Gao. [1] whereas the *NMxHasher32* type employs the *NMx* !   hash algorithm, which is a variant of the *NM* hash algorithm.  As hashers, both !   can be used to compute the hash value incrementally.  They also provide a method !   to compute the hash value directly (i.e. non-incrementally).  The following code !   snippet illustrates a typical usage of both hashers. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the *HashDirect* !   method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/gzm55/hash-garage\">NMHash32 Hash Functions. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher32 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: NMHasher32 PUBLIC :: NMxHasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskInt32(X)                    IAND(ToInt32(X), Z'000000FF') #define NMHASH32_9to32(P, Len, Seed)    NMHASH32_9to255(P, Len, Seed, FalseVal) #define NMHASH32_33to255(P, Len, Seed)  NMHASH32_9to255(P, Len, Seed, TrueVal) #define PackFull(Buf, Off)              MaskInt32(Buf(Off)) + SHIFTL(MaskInt32(Buf(Off+1)),  8) + \\ SHIFTL ( MaskInt32 ( Buf ( Off + 2 )), 16 ) + SHIFTL ( MaskInt32 ( Buf ( Off + 3 )), 24 ) #define MaskU32(X)                      IAND(ToInt32(X), Z'0000FFFF') #define PackInteger(X)                  IOR(MaskU32(X(0)), SHIFTL(MaskU32(X(1)), 16)) #define UnPackInteger(X, Y)             Y(0) = ToInt16(X); Y(1) = ToInt16(SHIFTR(X, 16)) !** MODULE PARAMETERS: ! primes from xxh! tUInt32 , PARAMETER :: NMH_PRIME32_1 = ToInt32 ( Z '9E3779B1' ) tUInt32 , PARAMETER :: NMH_PRIME32_2 = ToInt32 ( Z '85EBCA77' ) tUInt32 , PARAMETER :: NMH_PRIME32_3 = ToInt32 ( Z 'C2B2AE3D' ) tUInt32 , PARAMETER :: NMH_PRIME32_4 = ToInt32 ( Z '27D4EB2F' ) ! Pseudorandom secret taken directly from FARSH tUInt32 , PARAMETER :: NMH_ACC_INIT ( 0 : 31 ) = [ & ToInt32 ( Z 'B8FE6C39' ), ToInt32 ( Z '23A44BBE' ), & ToInt32 ( Z '7C01812C' ), ToInt32 ( Z 'F721AD1C' ), & ToInt32 ( Z 'DED46DE9' ), ToInt32 ( Z '839097DB' ), & ToInt32 ( Z '7240A4A4' ), ToInt32 ( Z 'B7B3671F' ), & ToInt32 ( Z 'CB79E64E' ), ToInt32 ( Z 'CCC0E578' ), & ToInt32 ( Z '825AD07D' ), ToInt32 ( Z 'CCFF7221' ), & ToInt32 ( Z 'B8084674' ), ToInt32 ( Z 'F743248E' ), & ToInt32 ( Z 'E03590E6' ), ToInt32 ( Z '813A264C' ), & ToInt32 ( Z '3C2852BB' ), ToInt32 ( Z '91C300CB' ), & ToInt32 ( Z '88D0658B' ), ToInt32 ( Z '1B532EA3' ), & ToInt32 ( Z '71644897' ), ToInt32 ( Z 'A20DF94E' ), & ToInt32 ( Z '3819EF46' ), ToInt32 ( Z 'A9DEACD8' ), & ToInt32 ( Z 'A8FA763F' ), ToInt32 ( Z 'E39C343F' ), & ToInt32 ( Z 'F9DCBBC7' ), ToInt32 ( Z 'C70B4F1D' ), & ToInt32 ( Z '8A51E04B' ), ToInt32 ( Z 'CDB45931' ), & ToInt32 ( Z 'C89F7EC9' ), ToInt32 ( Z 'D9787364' )] tUInt16 , PARAMETER :: NMH_M1_16 ( 0 : 1 ) = [ ToInt16 ( Z 'F0D9649B' ), & ToInt16 ( SHIFTR ( ToInt32 ( Z 'F0D9649B' ), 16 ))] tUInt16 , PARAMETER :: NMH_M2_16 ( 0 : 1 ) = [ ToInt16 ( Z '29A7935D' ), & ToInt16 ( SHIFTR ( ToInt32 ( Z '29A7935D' ), 16 ))] tUInt16 , PARAMETER :: NMH_M3_16 ( 0 : 1 ) = [ ToInt16 ( Z '55D35831' ), & ToInt16 ( SHIFTR ( ToInt32 ( Z '55D35831' ), 16 ))] tIndex , PARAMETER :: ACC_SIZE = SIZE ( NMH_ACC_INIT ) tIndex , PARAMETER :: BlockLen = 2_kIndex * ( ACC_SIZE * 4_kIndex ) !** DERIVED TYPE DEFINITIONS !> *NMHasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *NM* hash algorithm by James Z. M. Gao. TYPE , EXTENDS ( Hasher32 ) :: NMHasher32 PRIVATE !% states tUInt32 :: AccX ( 0 : ACC_SIZE - 1 ) = 0_kInt32 tUInt32 :: AccY ( 0 : ACC_SIZE - 1 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => NM_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => NM_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => NM_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => NM_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => NM_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => NM_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => NM_HashDirect END TYPE NMHasher32 !&#94; *NMHasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *NMx* hash algorithm, which is a variant of the  *NM* hash algorithm. TYPE , EXTENDS ( NMHasher32 ) :: NMxHasher32 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => NMx_GetName !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => NMx_Finalize END TYPE NMxHasher32 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION NM_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'NM_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION NM_GetName !****************************************************************************** FUNCTION NMx_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMxHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'NMx_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION NMx_GetName !****************************************************************************** FUNCTION NM_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION NM_BlockLength !****************************************************************************** SUBROUTINE NM_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE NM_SetBufPtr !****************************************************************************** SUBROUTINE NM_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL NMHASH32_LongRound ( HS % AccX , HS % AccY , BytesIn ) RETURN END SUBROUTINE NM_ProcessBlock !****************************************************************************** SUBROUTINE NM_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % AccX = NMH_ACC_INIT HS % AccY = Seed SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE NM_Initialize !****************************************************************************** FUNCTION NM_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length !** FLOW IF ( HS % GetBlockCount () > 0_kIndex ) THEN ! compute length Length = HS % GetBlockCount () * HS % GetBlockLength () + HS % GetBufLen () BLOCK ! block variables tUInt32 :: Sum tUInt8 :: LastBuf ( 0 : BlockLen - 1 ) tIndex :: I , J ! initialize Sum = 0 ! copy buffer data for last round J = HS % GetBufLen () + 1_kIndex DO I = 0_kIndex , BlockLen - 1_kIndex LastBuf ( I ) = HS % BufArr ( J ) J = J + 1_kIndex IF ( J >= BlockLen ) J = 0_kIndex END DO ! perform last round CALL NMHASH32_LongRound ( HS % AccX , HS % AccY , LastBuf ) ! merge acc DO I = 0 , ACC_SIZE - 1 HS % AccX ( I ) = IEOR ( HS % AccX ( I ), NMH_ACC_INIT ( I )) Sum = Sum + HS % AccX ( I ) END DO ! get hash Sum = Sum + ToInt32 ( SHIFTA ( Length , 32 )) HashCode = NMHASH32_Avalanche32 ( IEOR ( Sum , ToInt32 ( Length ))) END BLOCK ELSE Length = HS % GetBufLen () ASSOCIATE ( Input => HS % BufArr , Seed => HS % AccY ( 0 )) IF ( Length <= 32 ) THEN IF ( Length > 8 ) THEN HashCode = NMHASH32_9to32 ( Input , Length , Seed ) ELSEIF ( Length > 4 ) THEN BLOCK tUInt32 :: X , Y X = PackFull ( Input , 0 ) Y = IEOR ( PackFull ( Input , Length - 4 ), NMH_PRIME32_4 + 2 + Seed ) X = X + Y X = IEOR ( X , SHIFTL ( X , Length + 7 )) HashCode = NMHASH32_0to8 ( X , RotateLeft ( Y , 5 )) END BLOCK ELSE BLOCK tUInt32 :: X , NewSeed SELECT CASE ( Length ) CASE ( 0 ) NewSeed = Seed + NMH_PRIME32_2 X = 0 CASE ( 1 : 3 ) NewSeed = Seed + NMH_PRIME32_2 + SHIFTL ( Length , 24 ) + SHIFTL ( Length , 1 ) X = Pack_Partial ( Input , 0_kIndex , Length ) CASE ( 4 ) NewSeed = Seed + NMH_PRIME32_3 X = PackFull ( Input , 0_kIndex ) END SELECT HashCode = NMHASH32_0to8 ( X + NewSeed , RotateLeft ( NewSeed , 5 )) END BLOCK END IF ELSE HashCode = NMHASH32_33to255 ( Input , Length , Seed ) END IF END ASSOCIATE END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % AccX = 0_kInt32 HS % AccY = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS FUNCTION NMHASH32_0to8 ( X , Seed ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: X tUInt32 , INTENT ( IN ) :: Seed tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt16 , PARAMETER :: M1_16 ( 0 : 1 ) = [ ToInt16 ( Z '776BF593' ), ToInt16 ( SHIFTR ( ToInt32 ( Z '776BF593' ), 16 ))] tUInt16 , PARAMETER :: M2_16 ( 0 : 1 ) = [ ToInt16 ( Z '3FB39C65' ), ToInt16 ( SHIFTR ( ToInt32 ( Z '3FB39C65' ), 16 ))] tUInt16 , PARAMETER :: M3_16 ( 0 : 1 ) = [ ToInt16 ( Z 'E9139917' ), ToInt16 ( SHIFTR ( ToInt32 ( Z 'E9139917' ), 16 ))] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: VxU32 tUInt16 :: VxU16 ( 0 : 1 ) !** FLOW ! initialize VxU32 = X ! avalanche VxU32 = IEOR ( VxU32 , IEOR ( SHIFTR ( VxU32 , 12 ), SHIFTR ( VxU32 , 6 ))) UnPackInteger ( VxU32 , VxU16 ) VxU16 = VxU16 * M1_16 VxU32 = PackInteger ( VxU16 ) VxU32 = IEOR ( VxU32 , IEOR ( SHIFTL ( VxU32 , 11 ), SHIFTR ( VxU32 , 19 ))) UnPackInteger ( VxU32 , VxU16 ) VxU16 = VxU16 * M2_16 VxU32 = PackInteger ( VxU16 ) VxU32 = IEOR ( VxU32 , Seed ) VxU32 = IEOR ( VxU32 , IEOR ( SHIFTR ( VxU32 , 15 ), SHIFTR ( VxU32 , 9 ))) UnPackInteger ( VxU32 , VxU16 ) VxU16 = VxU16 * M3_16 VxU32 = PackInteger ( VxU16 ) HashCode = IEOR ( VxU32 , IEOR ( SHIFTL ( VxU32 , 16 ), SHIFTR ( VxU32 , 11 ))) RETURN END FUNCTION NMHASH32_0to8 !************************************************************************** FUNCTION NMHASH32_9to255 ( P , Length , Seed , FullAvalanche ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: P ( 0 :) tIndex , INTENT ( IN ) :: Length tUInt32 , INTENT ( IN ) :: Seed tLogical , INTENT ( IN ) :: FullAvalanche tUInt32 :: HashCode !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , K , R , ShiftLen tUInt32 :: XU32 ( 0 : 3 ), YU32 ( 0 : 3 ), SL tUInt16 :: XU16 ( 0 : 1 ) !** FLOW ! initialize SL = Seed + ToInt32 ( Length ) XU32 ( 0 ) = NMH_PRIME32_1 XU32 ( 1 ) = NMH_PRIME32_2 XU32 ( 2 ) = NMH_PRIME32_3 XU32 ( 3 ) = NMH_PRIME32_4 YU32 = SL IF ( FullAvalanche ) THEN ! 33 to 255 bytes R = ( Length - 1 ) / 32 DO I = 0 , R - 1 DO J = 0 , 3 K = I * 32 + J * 4 XU32 ( J ) = IEOR ( XU32 ( J ), PackFull ( P , K )) YU32 ( J ) = IEOR ( YU32 ( J ), PackFull ( P , K + 16 )) XU32 ( J ) = XU32 ( J ) + YU32 ( J ) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M1_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTL ( XU32 ( J ), 5 ), SHIFTR ( XU32 ( J ), 13 ))) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M2_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), YU32 ( J )) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTL ( XU32 ( J ), 11 ), SHIFTR ( XU32 ( J ), 9 ))) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M3_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTR ( XU32 ( J ), 10 ), SHIFTR ( XU32 ( J ), 20 ))) END DO END DO K = 0 DO J = 0 , 3 XU32 ( J ) = IEOR ( XU32 ( J ), PackFull ( P , Length - 32 + K )) YU32 ( J ) = IEOR ( YU32 ( J ), PackFull ( P , Length - 16 + K )) K = K + 4 END DO ELSE ! 9 to 32 bytes ShiftLen = SHIFTL ( SHIFTA ( Length , 4 ), 3 ) XU32 ( 0 ) = IEOR ( XU32 ( 0 ), PackFull ( P , 0 )) XU32 ( 1 ) = IEOR ( XU32 ( 1 ), PackFull ( P , ShiftLen )) XU32 ( 2 ) = IEOR ( XU32 ( 2 ), PackFull ( P , Length - 8 )) XU32 ( 3 ) = IEOR ( XU32 ( 3 ), PackFull ( P , Length - 8 - ShiftLen )) YU32 ( 0 ) = IEOR ( YU32 ( 0 ), PackFull ( P , 4 )) YU32 ( 1 ) = IEOR ( YU32 ( 1 ), PackFull ( P , ShiftLen + 4 )) YU32 ( 2 ) = IEOR ( YU32 ( 2 ), PackFull ( P , Length - 4 )) YU32 ( 3 ) = IEOR ( YU32 ( 3 ), PackFull ( P , Length - 4 - ShiftLen )) END IF DO J = 0 , 3 XU32 ( J ) = XU32 ( J ) + YU32 ( J ) YU32 ( J ) = IEOR ( YU32 ( J ), IEOR ( SHIFTL ( YU32 ( J ), 17 ), SHIFTR ( YU32 ( J ), 6 ))) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M1_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTL ( XU32 ( J ), 5 ), SHIFTR ( XU32 ( J ), 13 ))) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M2_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), YU32 ( J )) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTL ( XU32 ( J ), 11 ), SHIFTR ( XU32 ( J ), 9 ))) UnPackInteger ( XU32 ( J ), XU16 ) XU16 = XU16 * NMH_M3_16 XU32 ( J ) = PackInteger ( XU16 ) XU32 ( J ) = IEOR ( XU32 ( J ), IEOR ( SHIFTR ( XU32 ( J ), 10 ), SHIFTR ( XU32 ( J ), 20 ))) END DO XU32 ( 0 ) = IEOR ( XU32 ( 0 ), NMH_PRIME32_1 ) XU32 ( 1 ) = IEOR ( XU32 ( 1 ), NMH_PRIME32_2 ) XU32 ( 2 ) = IEOR ( XU32 ( 2 ), NMH_PRIME32_3 ) XU32 ( 3 ) = IEOR ( XU32 ( 3 ), NMH_PRIME32_4 ) XU32 ( 0 ) = XU32 ( 0 ) + XU32 ( 1 ) + XU32 ( 2 ) + XU32 ( 3 ) XU32 ( 0 ) = IEOR ( XU32 ( 0 ), SL + SHIFTR ( SL , 5 )) UnPackInteger ( XU32 ( 0 ), XU16 ) XU16 = XU16 * NMH_M3_16 XU32 ( 0 ) = PackInteger ( XU16 ) XU32 ( 0 ) = IEOR ( XU32 ( 0 ), IEOR ( SHIFTR ( XU32 ( 0 ), 10 ), SHIFTR ( XU32 ( 0 ), 20 ))) HashCode = XU32 ( 0 ) RETURN END FUNCTION NMHASH32_9to255 !************************************************************************** FUNCTION NMHASH32_Avalanche32 ( X ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: X tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt16 , PARAMETER :: M1_16 ( 0 : 1 ) = [ ToInt16 ( Z 'CCE5196D' ), ToInt16 ( SHIFTR ( ToInt32 ( Z 'CCE5196D' ), 16 ))] tUInt16 , PARAMETER :: M2_16 ( 0 : 1 ) = [ ToInt16 ( Z '464BE229' ), ToInt16 ( SHIFTR ( ToInt32 ( Z '464BE229' ), 16 ))] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: VxU32 tUInt16 :: VxU16 ( 0 : 1 ) !** FLOW ! initialize VxU32 = X ! avalanche VxU32 = IEOR ( VxU32 , IEOR ( SHIFTR ( VxU32 , 8 ), SHIFTR ( VxU32 , 21 ))) UnPackInteger ( VxU32 , VxU16 ) VxU16 = VxU16 * M1_16 VxU32 = PackInteger ( VxU16 ) VxU32 = IEOR ( VxU32 , IEOR ( SHIFTL ( VxU32 , 12 ), SHIFTR ( VxU32 , 7 ))) UnPackInteger ( VxU32 , VxU16 ) VxU16 = VxU16 * M2_16 VxU32 = PackInteger ( VxU16 ) HashCode = IEOR ( IEOR ( VxU32 , SHIFTR ( VxU32 , 8 )), SHIFTR ( VxU32 , 21 )) RETURN END FUNCTION NMHASH32_Avalanche32 !************************************************************************** END FUNCTION NM_Finalize !****************************************************************************** FUNCTION NMx_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMxHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length !** FLOW ! initialize IF ( HS % GetBlockCount () > 0_kIndex ) THEN ! compute length Length = HS % GetBlockCount () * HS % GetBlockLength () + HS % GetBufLen () BLOCK ! block variables tUInt32 :: Sum tUInt8 :: LastBuf ( 0 : BlockLen - 1 ) tIndex :: I , J ! initialize Sum = 0 ! copy buffer data for last round J = HS % GetBufLen () + 1_kIndex DO I = 0_kIndex , BlockLen - 1_kIndex LastBuf ( I ) = HS % BufArr ( J ) J = J + 1_kIndex IF ( J >= BlockLen ) J = 0_kIndex END DO ! perform last round CALL NMHASH32_LongRound ( HS % AccX , HS % AccY , LastBuf ) ! merge acc DO I = 0 , ACC_SIZE - 1 HS % AccX ( I ) = IEOR ( HS % AccX ( I ), NMH_ACC_INIT ( I )) Sum = Sum + HS % AccX ( I ) END DO ! get hash Sum = Sum + ToInt32 ( SHIFTA ( Length , 32 )) HashCode = NMxHASH32_Avalanche32 ( IEOR ( Sum , ToInt32 ( Length ))) END BLOCK ELSE Length = HS % GetBufLen () ASSOCIATE ( Input => HS % BufArr , Seed => HS % AccY ( 0 )) IF ( Length <= 8 ) THEN IF ( Length > 4 ) THEN HashCode = NMxHASH32_5to8 ( Input , Length , Seed ) ELSE BLOCK tUInt32 :: X , NewSeed SELECT CASE ( Length ) CASE ( 0 ) NewSeed = Seed + NMH_PRIME32_2 X = 0 CASE ( 1 : 3 ) NewSeed = Seed + NMH_PRIME32_2 + SHIFTL ( Length , 24 ) + SHIFTL ( Length , 1 ) X = Pack_Partial ( Input , 0_kIndex , Length ) CASE ( 4 ) NewSeed = Seed + NMH_PRIME32_1 X = PackFull ( Input , 0_kIndex ) END SELECT HashCode = NMxHASH32_0to4 ( X , NewSeed ) END BLOCK END IF ELSE HashCode = NMxHASH32_9to255 ( Input , Length , Seed ) END IF END ASSOCIATE END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % AccX = 0_kInt32 HS % AccY = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS FUNCTION NMxHASH32_0to4 ( X , Seed ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: X tUInt32 , INTENT ( IN ) :: Seed tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: M1 = ToInt32 ( Z 'BDAB1EA9' ) tUInt32 , PARAMETER :: M2 = ToInt32 ( Z 'A7896A1B' ) tUInt32 , PARAMETER :: M3 = ToInt32 ( Z '83796A2D' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! initialize HashCode = X ! mix HashCode = IEOR ( HashCode , Seed ) HashCode = HashCode * M1 HashCode = HashCode + RotateLeft ( Seed , 31 ) HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 18 )) HashCode = HashCode * M2 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 12 )) HashCode = HashCode * M3 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 16 )) RETURN END FUNCTION NMxHASH32_0to4 !************************************************************************** FUNCTION NMxHASH32_5to8 ( P , Length , Seed ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: P ( 0 :) tIndex , INTENT ( IN ) :: Length tUInt32 , INTENT ( IN ) :: Seed tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: M1 = ToInt32 ( Z '11049A7D' ) tUInt32 , PARAMETER :: M2 = ToInt32 ( Z 'BCCCDC7B' ) tUInt32 , PARAMETER :: M3 = ToInt32 ( Z '065E9DAD' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: X , Y !** FLOW ! initialize X = IEOR ( PackFull ( P , 0 ), NMH_PRIME32_3 ) Y = IEOR ( PackFull ( P , Length - 4 ), Seed ) ! mix X = X + Y X = IEOR ( X , SHIFTR ( X , Length )) X = X * M1 X = IEOR ( X , SHIFTR ( X , 23 )) X = X * M2 X = IEOR ( X , RotateLeft ( Y , 3 )) X = IEOR ( X , SHIFTR ( X , 12 )) X = X * M3 X = IEOR ( X , SHIFTR ( X , 12 )) HashCode = X RETURN END FUNCTION NMxHASH32_5to8 !************************************************************************** FUNCTION NMxHASH32_9to255 ( P , Length , Seed ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: P ( 0 :) tIndex , INTENT ( IN ) :: Length tUInt32 , INTENT ( IN ) :: Seed tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: M1 = ToInt32 ( Z '11049A7D' ) tUInt32 , PARAMETER :: M2 = ToInt32 ( Z 'BCCCDC7B' ) tUInt32 , PARAMETER :: M3 = ToInt32 ( Z '065E9DAD' ) tUInt32 , PARAMETER :: M4 = ToInt32 ( Z 'A52FB2CD' ) tUInt32 , PARAMETER :: M5 = ToInt32 ( Z '551E4D49' ) tUInt32 , PARAMETER :: M6 = ToInt32 ( Z '141CC535' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: X , Y , A , B tIndex :: I , R , Offset !** FLOW X = NMH_PRIME32_3 Y = Seed A = NMH_PRIME32_4 B = Seed R = ( Length - 1 ) / 16 Offset = 0 DO I = 0 , R - 1 X = IEOR ( X , PackFull ( P , Offset + 0 )) Y = IEOR ( Y , PackFull ( P , Offset + 4 )) X = IEOR ( X , Y ) X = X * M1 X = IEOR ( X , SHIFTR ( X , 23 )) X = X * M2 Y = RotateLeft ( Y , 4 ) X = IEOR ( X , Y ) X = IEOR ( X , SHIFTR ( X , 12 )) X = X * M3 X = IEOR ( X , SHIFTR ( X , 12 )) A = IEOR ( A , PackFull ( P , Offset + 8 )) B = IEOR ( B , PackFull ( P , Offset + 12 )) A = IEOR ( A , B ) A = A * M1 A = IEOR ( A , SHIFTR ( A , 23 )) A = A * M2 B = RotateLeft ( B , 3 ) A = IEOR ( A , B ) A = IEOR ( A , SHIFTR ( A , 12 )) A = A * M3 A = IEOR ( A , SHIFTR ( A , 12 )) Offset = Offset + 16 END DO IF ( IAND ( ToInt32 ( Length ) - 1 , 8 ) /= 0 ) THEN IF ( IAND ( ToInt32 ( Length ) - 1 , 4 ) /= 0 ) THEN A = IEOR ( A , PackFull ( P , Offset )) B = IEOR ( B , PackFull ( P , Offset + 4 )) A = IEOR ( A , B ) A = A * M1 A = IEOR ( A , SHIFTR ( A , 23 )) A = A * M2 A = IEOR ( A , RotateLeft ( B , 4 )) A = IEOR ( A , SHIFTR ( A , 12 )) A = A * M3 ELSE A = IEOR ( A , PackFull ( P , Offset ) + B ) A = IEOR ( A , SHIFTR ( A , 16 )) A = A * M4 A = IEOR ( A , SHIFTR ( A , 15 )) A = A * M5 END IF X = IEOR ( X , PackFull ( P , Length - 8 )) Y = IEOR ( Y , PackFull ( P , Length - 4 )) X = IEOR ( X , Y ) X = X * M1 X = IEOR ( X , SHIFTR ( X , 23 )) X = X * M2 X = IEOR ( X , RotateLeft ( Y , 3 )) X = IEOR ( X , SHIFTR ( X , 12 )) X = X * M3 ELSE IF ( IAND ( ToInt32 ( Length ) - 1 , 4 ) /= 0 ) THEN A = IEOR ( A , PackFull ( P , Offset ) + B ) A = IEOR ( A , SHIFTR ( A , 16 )) A = A * M4 A = IEOR ( A , SHIFTR ( A , 15 )) A = A * M5 END IF X = IEOR ( X , PackFull ( P , Length - 4 ) + Y ) X = IEOR ( X , SHIFTR ( X , 16 )) X = X * M4 X = IEOR ( X , SHIFTR ( X , 15 )) X = X * M5 END IF X = IEOR ( X , ToInt32 ( Length )) ! rotate one lane to pass diff test X = IEOR ( X , RotateLeft ( A , 27 )) X = IEOR ( X , SHIFTR ( X , 14 )) X = X * M6 HashCode = X RETURN END FUNCTION NMxHASH32_9to255 !************************************************************************** FUNCTION NMxHASH32_Avalanche32 ( X ) RESULT ( HashCode ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( IN ) :: X tUInt32 :: HashCode !** SUBROUTINE PARAMETER DECLARATIONS: tUInt32 , PARAMETER :: M1 = ToInt32 ( Z 'D168AAAD' ) tUInt32 , PARAMETER :: M2 = ToInt32 ( Z 'AF723597' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! initialize HashCode = X HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 15 )) HashCode = HashCode * M1 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 15 )) HashCode = HashCode * M2 HashCode = IEOR ( HashCode , SHIFTR ( HashCode , 15 )) RETURN END FUNCTION NMxHASH32_Avalanche32 !************************************************************************** END FUNCTION NMx_Finalize !****************************************************************************** FUNCTION NM_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NMHasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt32 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION NM_HashDirect !****************************************************************************** SUBROUTINE NMHASH32_LongRound ( AccX , AccY , P ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt32 , INTENT ( INOUT ) :: AccX ( 0 :) tUInt32 , INTENT ( INOUT ) :: AccY ( 0 :) tUInt8 , INTENT ( IN ) :: P ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Offset , SizeOfACC tUInt16 :: Acc_16 ( 0 : 1 ) !** FLOW ! initialize Offset = 0_kIndex SizeOfACC = ACC_SIZE * 4 DO I = 0_kIndex , ACC_SIZE - 1_kIndex AccX ( I ) = IEOR ( AccX ( I ), PackFull ( P , Offset )) AccY ( I ) = IEOR ( AccY ( I ), PackFull ( P , Offset + SizeOfACC )) AccX ( I ) = AccX ( I ) + AccY ( I ) AccY ( I ) = IEOR ( AccY ( I ), SHIFTR ( AccX ( I ), 1 )) UnPackInteger ( AccX ( I ), Acc_16 ) Acc_16 = Acc_16 * NMH_M1_16 AccX ( I ) = PackInteger ( Acc_16 ) AccX ( I ) = IEOR ( AccX ( I ), IEOR ( SHIFTL ( AccX ( I ), 5 ), SHIFTR ( AccX ( I ), 13 ))) UnPackInteger ( AccX ( I ), Acc_16 ) Acc_16 = Acc_16 * NMH_M2_16 AccX ( I ) = PackInteger ( Acc_16 ) AccX ( I ) = IEOR ( AccX ( I ), AccY ( I )) AccX ( I ) = IEOR ( AccX ( I ), IEOR ( SHIFTL ( AccX ( I ), 11 ), SHIFTR ( AccX ( I ), 9 ))) UnPackInteger ( AccX ( I ), Acc_16 ) Acc_16 = Acc_16 * NMH_M3_16 AccX ( I ) = PackInteger ( Acc_16 ) AccX ( I ) = IEOR ( AccX ( I ), IEOR ( SHIFTR ( AccX ( I ), 10 ), SHIFTR ( AccX ( I ), 20 ))) ! update index Offset = Offset + 4_kIndex END DO RETURN END SUBROUTINE NMHASH32_LongRound !****************************************************************************** FUNCTION Pack_Partial ( Buf , Off , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack seven or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res', in little-endian convention ! (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tIndex , INTENT ( IN ) :: Length ! the number of bytes to pack (between 1 to 3) tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 3 ) ! FLOW Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) Wrk ( Length : 3 ) = 0_kInt8 Res = MaskInt32 ( Wrk ( 0 )) + SHIFTL ( MaskInt32 ( Wrk ( 1 )), 8 ) + & SHIFTL ( MaskInt32 ( Wrk ( 2 )), 16 ) + SHIFTL ( MaskInt32 ( Wrk ( 3 )), 24 ) RETURN END FUNCTION Pack_Partial !****************************************************************************** END MODULE MClass_NMHasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_nmhasher32.f90.html"},{"title":"MClass_Murmur3Hasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Murmur3Hasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Murmur3Hasher32* type and its related routines. !   The *Murmur3Hasher32* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> type. !   It provides all deferred procedures required by a *Hasher32* class and !   outputs the hash value as a 32-bit integer. <br> !   The *Murmur3Hasher32* type employs the *Murmur3* hash algorithm for 32-bit !   integer output by Austin Appleby [1].  As a hasher, it can be used to compute !   the hash value incrementally.  It also provides a method to compute the hash !   value directly (i.e. non-incrementally).  The following code snippet shows !   a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/aappleby/smhasher\">SMHasher: a test suite designed to !       test the distribution, collision, and performance properties of non-cryptographic !       hash functions. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher32 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Murmur3Hasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define FinalMixing(H) \\ H = IEOR ( H , SHIFTR ( H , 16 )); \\ H = H * ToInt32 ( Z '85EBCA6B' ); \\ H = IEOR ( H , SHIFTR ( H , 13 )); \\ H = H * ToInt32 ( Z 'C2B2AE35' ); \\ H = IEOR ( H , SHIFTR ( H , 16 )); #define MaskInt32(X)          IAND(ToInt32(X), Z'000000FF') #define UnsignedShort(Val, Off) IOR(MaskInt32(Val(Off)), SHIFTL(MaskInt32(Val(Off+1)), 8)) #define PackFull(Buf, Off)      IOR(UnsignedShort(Buf, Off), SHIFTL(UnsignedShort(Buf, Off+2), 16)) !** MODULE PARAMETERS: tUInt32 , PARAMETER :: C1 = ToInt32 ( Z 'CC9E2D51' ) tUInt32 , PARAMETER :: C2 = ToInt32 ( Z '1B873593' ) !** DERIVED TYPE DEFINITIONS !> *Murmur3Hasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *Murmur3* hash algorithm by Austin Appleby. TYPE , EXTENDS ( Hasher32 ) :: Murmur3Hasher32 PRIVATE !% state tUInt32 :: State = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 3 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => Murmur3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => Murmur3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => Murmur3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => Murmur3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => Murmur3_Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => Murmur3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => Murmur3_HashDirect END TYPE Murmur3Hasher32 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION Murmur3_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'Murmur3_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Murmur3_GetName !****************************************************************************** FUNCTION Murmur3_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = 4_kIndex ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION Murmur3_BlockLength !****************************************************************************** SUBROUTINE Murmur3_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE Murmur3_SetBufPtr !****************************************************************************** SUBROUTINE Murmur3_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: K1 !** FLOW ASSOCIATE ( H1 => HS % State ) ! get input K1 = PackFull ( BytesIn , 0_kIndex ) ! mixing input with constants K1 = K1 * C1 K1 = RotateLeft ( K1 , 15 ) K1 = K1 * C2 H1 = IEOR ( H1 , K1 ) H1 = RotateLeft ( H1 , 13 ) H1 = H1 * 5 + ToInt32 ( Z 'E6546B64' ) END ASSOCIATE RETURN END SUBROUTINE Murmur3_ProcessBlock !****************************************************************************** SUBROUTINE Murmur3_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % State = Seed SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE Murmur3_Initialize !****************************************************************************** FUNCTION Murmur3_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining tUInt32 :: K1 !** FLOW ! initialize Remaining = HS % GetBufLen () Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining HashCode = HS % State ! process remaining bytes IF ( Remaining > 0 ) THEN K1 = Pack_Partial ( HS % BufArr , 0_kIndex , Remaining ) K1 = K1 * C1 K1 = RotateLeft ( K1 , 15 ) K1 = K1 * C2 HashCode = IEOR ( HashCode , K1 ) END IF ! finalize the hash value HashCode = ToInt32 ( IEOR ( ToIndex ( HashCode ), Length )) FinalMixing ( HashCode ) ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % State = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS FUNCTION Pack_Partial ( Buf , Off , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack seven or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res', in little-endian convention ! (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Off ! offset tIndex , INTENT ( IN ) :: Length ! the number of bytes to pack (between 1 to 3) tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 :: Wrk ( 0 : 3 ) ! FLOW Wrk ( 0 : Length - 1 ) = Buf ( Off : Off + Length - 1 ) Wrk ( Length : 3 ) = 0_kInt8 Res = PackFull ( Wrk , 0 ) RETURN END FUNCTION Pack_Partial !************************************************************************** END FUNCTION Murmur3_Finalize !****************************************************************************** FUNCTION Murmur3_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Murmur3Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt32 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION Murmur3_HashDirect !****************************************************************************** END MODULE MClass_Murmur3Hasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_murmur3hasher32.f90.html"},{"title":"MClass_SIMDS.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SIMDS !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SIMDS* type and its related routines. !   The *SIMDS* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SIMDS* type implements an incremental cryptographic hash function !   by employing either the *SIMD-224* or the *SIMD-256 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *SIMDS* type employs the *SIMD-256 message-digest* !   algorithm.  However, a user can specify the *IsSIMD224* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SIMD-224 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://who.rocq.inria.fr/Gaetan.Leurent/simd.html\"> !       The SIMD Hash Function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SIMDS PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tInteger , PARAMETER :: IV224 ( 0 : 15 ) = [ & ToInt32 ( Z '33586E9F' ), ToInt32 ( Z '12FFF033' ), & ToInt32 ( Z 'B2D9F64D' ), ToInt32 ( Z '6F8FEA53' ), & ToInt32 ( Z 'DE943106' ), ToInt32 ( Z '2742E439' ), & ToInt32 ( Z '4FBAB5AC' ), ToInt32 ( Z '62B9FF96' ), & ToInt32 ( Z '22E7B0AF' ), ToInt32 ( Z 'C862B3A8' ), & ToInt32 ( Z '33E00CDC' ), ToInt32 ( Z '236B86A6' ), & ToInt32 ( Z 'F64AE77C' ), ToInt32 ( Z 'FA373B76' ), & ToInt32 ( Z '7DC1EE5B' ), ToInt32 ( Z '7FB29CE8' )] tInteger , PARAMETER :: IV256 ( 0 : 15 ) = [ & ToInt32 ( Z '4D567983' ), ToInt32 ( Z '07190BA9' ), & ToInt32 ( Z '8474577B' ), ToInt32 ( Z '39D726E9' ), & ToInt32 ( Z 'AAF3D925' ), ToInt32 ( Z '3EE20B03' ), & ToInt32 ( Z 'AFD5E751' ), ToInt32 ( Z 'C96006D3' ), & ToInt32 ( Z 'C2C2BA14' ), ToInt32 ( Z '49B3BCB4' ), & ToInt32 ( Z 'F67CAF46' ), ToInt32 ( Z '668626C9' ), & ToInt32 ( Z 'E2EAA8D2' ), ToInt32 ( Z '1FF47833' ), & ToInt32 ( Z 'D0C661A5' ), ToInt32 ( Z '55693DE1' )] tInteger , PARAMETER , PUBLIC :: MaskI8 = ToInt32 ( Z '000000FF' ) tInteger , PARAMETER , PUBLIC :: MaskI16 = ToInt32 ( Z '0000FFFF' ) tInteger , PARAMETER , PUBLIC :: AlphaTab ( 0 : 255 ) = [ & 1 , 41 , 139 , 45 , 46 , 87 , 226 , 14 , 60 , 147 , 116 , 130 , & 190 , 80 , 196 , 69 , 2 , 82 , 21 , 90 , 92 , 174 , 195 , 28 , & 120 , 37 , 232 , 3 , 123 , 160 , 135 , 138 , 4 , 164 , 42 , 180 , & 184 , 91 , 133 , 56 , 240 , 74 , 207 , 6 , 246 , 63 , 13 , 19 , & 8 , 71 , 84 , 103 , 111 , 182 , 9 , 112 , 223 , 148 , 157 , 12 , & 235 , 126 , 26 , 38 , 16 , 142 , 168 , 206 , 222 , 107 , 18 , 224 , & 189 , 39 , 57 , 24 , 213 , 252 , 52 , 76 , 32 , 27 , 79 , 155 , & 187 , 214 , 36 , 191 , 121 , 78 , 114 , 48 , 169 , 247 , 104 , 152 , & 64 , 54 , 158 , 53 , 117 , 171 , 72 , 125 , 242 , 156 , 228 , 96 , & 81 , 237 , 208 , 47 , 128 , 108 , 59 , 106 , 234 , 85 , 144 , 250 , & 227 , 55 , 199 , 192 , 162 , 217 , 159 , 94 , 256 , 216 , 118 , 212 , & 211 , 170 , 31 , 243 , 197 , 110 , 141 , 127 , 67 , 177 , 61 , 188 , & 255 , 175 , 236 , 167 , 165 , 83 , 62 , 229 , 137 , 220 , 25 , 254 , & 134 , 97 , 122 , 119 , 253 , 93 , 215 , 77 , 73 , 166 , 124 , 201 , & 17 , 183 , 50 , 251 , 11 , 194 , 244 , 238 , 249 , 186 , 173 , 154 , & 146 , 75 , 248 , 145 , 34 , 109 , 100 , 245 , 22 , 131 , 231 , 219 , & 241 , 115 , 89 , 51 , 35 , 150 , 239 , 33 , 68 , 218 , 200 , 233 , & 44 , 5 , 205 , 181 , 225 , 230 , 178 , 102 , 70 , 43 , 221 , 66 , & 136 , 179 , 143 , 209 , 88 , 10 , 153 , 105 , 193 , 203 , 99 , 204 , & 140 , 86 , 185 , 132 , 15 , 101 , 29 , 161 , 176 , 20 , 49 , 210 , & 129 , 149 , 198 , 151 , 23 , 172 , 113 , 7 , 30 , 202 , 58 , 65 , & 95 , 40 , 98 , 163 ] !** DERIVED TYPE DEFINITIONS !> *SIMDS* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *SIMD-224* or the *SIMD-256 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: SIMDS PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: State ( 0 : 15 ) = IV256 ( 0 : 15 ) !% flag indicating whether the SIMD-224 algorithm is employed or not. tLogical :: IsSIMD224 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SIMDS_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SIMD-256). PROCEDURE :: Initialize => SIMDS_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SIMDS_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SIMDS_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SIMDS_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SIMDS_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SIMDS_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SIMDS_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SIMDS_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SIMDS_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SIMDS_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SIMD-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SIMD-224 algorithm <br> !   --->    CALL MD%Create(IsSIMD224=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE SIMDS !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SIMDS_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SIMD-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SIMDS_Initialize !****************************************************************************** SUBROUTINE SIMDS_Initialize_wFlag ( MD , IsSIMD224 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object tLogical , INTENT ( IN ) :: IsSIMD224 !&#94; flag indicating whether the SIMD-224 algorithm is employed or not. <br> !  - If true, use the SIMD-224 algorithm. <br> !  - Otherwise, use the SIMD-256 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSIMD224 = IsSIMD224 CALL MD % Reset () RETURN END SUBROUTINE SIMDS_Initialize_wFlag !****************************************************************************** SUBROUTINE SIMDS_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsSIMD224 ) THEN MD % State = IV224 ELSE MD % State = IV256 END IF CALL MD % EngineReset () RETURN END SUBROUTINE SIMDS_Reset !****************************************************************************** SUBROUTINE SIMDS_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SIMDS :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SIMDS ) CALL Dst % Create ( Src % IsSIMD224 ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE SIMDS_GetClone !****************************************************************************** FUNCTION SIMDS_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( IN ) :: MD !! 'SIMDS' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSIMD224 ) THEN Name = 'SIMD-224' ELSE Name = 'SIMD-256' END IF RETURN END FUNCTION SIMDS_GetName !****************************************************************************** FUNCTION SIMDS_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( IN ) :: MD !! 'SIMDS' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSIMD224 ) THEN Length = DLen224 ELSE Length = DLen256 END IF RETURN END FUNCTION SIMDS_GetDigestLen !****************************************************************************** FUNCTION SIMDS_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( IN ) :: MD !! 'SIMDS' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SIMDS_GetBlockLen !****************************************************************************** SUBROUTINE SIMDS_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), TARGET , INTENT ( INOUT ) :: MD !! 'SIMDS' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SIMDS_SetBufPtr !****************************************************************************** SUBROUTINE SIMDS_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL SIMDCore_Compress_Small ( MD , BytesIn , FalseVal ) RETURN END SUBROUTINE SIMDS_ProcessBlock !****************************************************************************** SUBROUTINE SIMDS_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE SIMDS_DoPadding !****************************************************************************** SUBROUTINE SIMDS_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD !! 'SIMDS' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , I , DLen tLong :: BlockCount ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () IF (( Ptr > 0_kIndex ). OR .( NBits > 0_kInt8 )) THEN TmpBuf ( Ptr ) = IAND ( LastByte , SHIFTL ( FByteFF , 8 - NBits )) TmpBuf ( Ptr + 1 :) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) END IF ! encode counter and compress buffer BlockCount = SHIFTL ( MD % GetBlockCount (), 9 ) + ToInt64 ( SHIFTL ( Ptr , 3 )) + ToInt64 ( NBits ) CALL ByteUnpackLE ( ToInt32 ( BlockCount ), TmpBuf , 0_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTA ( BlockCount , 32 )), TmpBuf , 4_kIndex ) TmpBuf ( 8 :) = FByte00 CALL SIMDCore_Compress_Small ( MD , TmpBuf , TrueVal ) END ASSOCIATE DLen = MD % GetDigestLen () DO I = 0 , SHIFTR ( DLen , 2 ) - 1 CALL ByteUnpackLE ( MD % State ( I ), BytesOut , Offset + SHIFTL ( I , 2 )) END DO RETURN END SUBROUTINE SIMDS_AddBitsNPad !****************************************************************************** SUBROUTINE SIMDCore_Compress_Small ( MD , X , Last ) !** PURPOSE OF THIS SUBROUTINE: ! To perform compression based on a Feistel-like cipher in Davies-Meyer mode. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDS ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: X ( 0 :) tLogical , INTENT ( IN ) :: Last !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , PARAMETER :: Wsp ( 0 : 31 ) = [ & SHIFTL ( 4_kIndex , 3 ), SHIFTL ( 6_kIndex , 3 ), SHIFTL ( 0_kIndex , 3 ), SHIFTL ( 2_kIndex , 3 ), & SHIFTL ( 7_kIndex , 3 ), SHIFTL ( 5_kIndex , 3 ), SHIFTL ( 3_kIndex , 3 ), SHIFTL ( 1_kIndex , 3 ), & SHIFTL ( 15_kIndex , 3 ), SHIFTL ( 11_kIndex , 3 ), SHIFTL ( 12_kIndex , 3 ), SHIFTL ( 8_kIndex , 3 ), & SHIFTL ( 9_kIndex , 3 ), SHIFTL ( 13_kIndex , 3 ), SHIFTL ( 10_kIndex , 3 ), SHIFTL ( 14_kIndex , 3 ), & SHIFTL ( 17_kIndex , 3 ), SHIFTL ( 18_kIndex , 3 ), SHIFTL ( 23_kIndex , 3 ), SHIFTL ( 20_kIndex , 3 ), & SHIFTL ( 22_kIndex , 3 ), SHIFTL ( 21_kIndex , 3 ), SHIFTL ( 16_kIndex , 3 ), SHIFTL ( 19_kIndex , 3 ), & SHIFTL ( 30_kIndex , 3 ), SHIFTL ( 24_kIndex , 3 ), SHIFTL ( 25_kIndex , 3 ), SHIFTL ( 31_kIndex , 3 ), & SHIFTL ( 27_kIndex , 3 ), SHIFTL ( 29_kIndex , 3 ), SHIFTL ( 28_kIndex , 3 ), SHIFTL ( 26_kIndex , 3 )] tInteger , PARAMETER :: YOff_S_N ( 0 : 127 ) = [ & 1 , 98 , 95 , 58 , 30 , 113 , 23 , 198 , 129 , 49 , 176 , 29 , & 15 , 185 , 140 , 99 , 193 , 153 , 88 , 143 , 136 , 221 , 70 , 178 , & 225 , 205 , 44 , 200 , 68 , 239 , 35 , 89 , 241 , 231 , 22 , 100 , & 34 , 248 , 146 , 173 , 249 , 244 , 11 , 50 , 17 , 124 , 73 , 215 , & 253 , 122 , 134 , 25 , 137 , 62 , 165 , 236 , 255 , 61 , 67 , 141 , & 197 , 31 , 211 , 118 , 256 , 159 , 162 , 199 , 227 , 144 , 234 , 59 , & 128 , 208 , 81 , 228 , 242 , 72 , 117 , 158 , 64 , 104 , 169 , 114 , & 121 , 36 , 187 , 79 , 32 , 52 , 213 , 57 , 189 , 18 , 222 , 168 , & 16 , 26 , 235 , 157 , 223 , 9 , 111 , 84 , 8 , 13 , 246 , 207 , & 240 , 133 , 184 , 42 , 4 , 135 , 123 , 232 , 120 , 195 , 92 , 21 , & 2 , 196 , 190 , 116 , 60 , 226 , 46 , 139 ] tInteger , PARAMETER :: YOff_S_F ( 0 : 127 ) = [ & 2 , 156 , 118 , 107 , 45 , 212 , 111 , 162 , 97 , 249 , 211 , 3 , & 49 , 101 , 151 , 223 , 189 , 178 , 253 , 204 , 76 , 82 , 232 , 65 , & 96 , 176 , 161 , 47 , 189 , 61 , 248 , 107 , 0 , 131 , 133 , 113 , & 17 , 33 , 12 , 111 , 251 , 103 , 57 , 148 , 47 , 65 , 249 , 143 , & 189 , 8 , 204 , 230 , 205 , 151 , 187 , 227 , 247 , 111 , 140 , 6 , & 77 , 10 , 21 , 149 , 255 , 101 , 139 , 150 , 212 , 45 , 146 , 95 , & 160 , 8 , 46 , 254 , 208 , 156 , 106 , 34 , 68 , 79 , 4 , 53 , & 181 , 175 , 25 , 192 , 161 , 81 , 96 , 210 , 68 , 196 , 9 , 150 , & 0 , 126 , 124 , 144 , 240 , 224 , 245 , 146 , 6 , 154 , 200 , 109 , & 210 , 192 , 8 , 114 , 68 , 249 , 53 , 27 , 52 , 106 , 70 , 30 , & 10 , 146 , 117 , 251 , 180 , 247 , 236 , 108 ] tInteger , PARAMETER :: PP4_0 ( 0 : 3 ) = [ 1 , 0 , 3 , 2 ] tInteger , PARAMETER :: PP4_1 ( 0 : 3 ) = [ 2 , 3 , 0 , 1 ] tInteger , PARAMETER :: PP4_2 ( 0 : 3 ) = [ 3 , 2 , 1 , 0 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger , TARGET :: State ( 0 : 15 ) tInteger , POINTER :: A (:), B (:), C (:), D (:) tInteger :: Q ( 0 : 127 ) tInteger :: W ( 0 : 31 ) tInteger :: tA ( 0 : 3 ) tInteger :: TQ , MWord , Tmp tIndex :: II , JJ , KK !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/SIMD_Def Macro.f90\" ! FLOW ! set pointers A ( 0 : 3 ) => State ( 0 :) B ( 0 : 3 ) => State ( 4 :) C ( 0 : 3 ) => State ( 8 :) D ( 0 : 3 ) => State ( 12 :) ! ++++++++ FFT_128(0, 1, 0) +++++++++ CALL FFT_32 ( X ( 0 :), SHIFTL ( 1_kIndex , 2 ), Q ( 0 :)) CALL FFT_32 ( X ( 2 :), SHIFTL ( 1_kIndex , 2 ), Q ( 32 :)) FFT_LOOP ( 0 , 32 , 4 ) CALL FFT_32 ( X ( 1 :), SHIFTL ( 1_kIndex , 2 ), Q ( 64 :)) CALL FFT_32 ( X ( 3 :), SHIFTL ( 1_kIndex , 2 ), Q ( 96 :)) FFT_LOOP ( 64 , 32 , 4 ) FFT_LOOP ( 0 , 64 , 2 ) ! +++++++++++++++++++++++++++++++++++ IF ( Last ) THEN DO II = 0 , 127 TQ = Q ( II ) + YOff_S_F ( II ) TQ = REDS2 ( TQ ) TQ = REDS1 ( TQ ) TQ = REDS1 ( TQ ) IF ( TQ <= 128 ) THEN Q ( II ) = TQ ELSE Q ( II ) = TQ - 257 END IF END DO ELSE DO II = 0 , 127 TQ = Q ( II ) + YOff_S_N ( II ) TQ = REDS2 ( TQ ) TQ = REDS1 ( TQ ) TQ = REDS1 ( TQ ) IF ( TQ <= 128 ) THEN Q ( II ) = TQ ELSE Q ( II ) = TQ - 257 END IF END DO END IF State = MD % State DO II = 0 , 15 , 4 DO JJ = II , II + 3 KK = 4 * JJ CALL BytePackLE ( X , KK , MWord ) State ( JJ ) = IEOR ( State ( JJ ), MWord ) END DO END DO WSREAD ( 0 , 0 , 1 , 185 ) CALL OneRound_Small ( State , W , 0 , 3 , 23 , 17 , 27 ) WSREAD ( 8 , 0 , 1 , 185 ) CALL OneRound_Small ( State , W , 2 , 28 , 19 , 22 , 7 ) WSREAD ( 16 , ( - 128 ), ( - 64 ), 233 ) CALL OneRound_Small ( State , W , 1 , 29 , 9 , 15 , 5 ) WSREAD ( 24 , ( - 191 ), ( - 127 ), 233 ) CALL OneRound_Small ( State , W , 0 , 4 , 13 , 10 , 25 ) STEP_SMALL_II ( MD % State ( 0 ), MD % State ( 1 ), MD % State ( 2 ), MD % State ( 3 ), IFF , 4 , 13 , PP4_2 ) STEP_SMALL_II ( MD % State ( 4 ), MD % State ( 5 ), MD % State ( 6 ), MD % State ( 7 ), IFF , 13 , 10 , PP4_0 ) STEP_SMALL_II ( MD % State ( 8 ), MD % State ( 9 ), MD % State ( 10 ), MD % State ( 11 ), IFF , 10 , 25 , PP4_1 ) STEP_SMALL_II ( MD % State ( 12 ), MD % State ( 13 ), MD % State ( 14 ), MD % State ( 15 ), IFF , 25 , 4 , PP4_2 ) ! return state values MD % State = State NULLIFY ( A , B , C , D ) RETURN CONTAINS SUBROUTINE FFT_32 ( X , XS , Q ) !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: X ( 0 :) tIndex , INTENT ( IN ) :: XS tInteger , INTENT ( INOUT ) :: Q ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: XD ! FLOW XD = SHIFTL ( XS , 1 ) FFT16 ( 0 , XD , 0 ) FFT16 ( XS , XD , 16 ) FFT_LOOP ( 0 , 16 , 8 ) RETURN END SUBROUTINE FFT_32 !****************************************************************************** SUBROUTINE OneRound_Small ( State , W , ISP , P0 , P1 , P2 , P3 ) !** PURPOSE OF THIS SUBROUTINE: ! To perform one round of mixing. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , TARGET , INTENT ( INOUT ) :: State ( 0 : 15 ) tInteger , INTENT ( INOUT ) :: W ( 0 : 31 ) tInteger , INTENT ( IN ) :: ISP , P0 , P1 , P2 , P3 !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , PARAMETER :: PP4K ( 0 : 10 ) = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger , POINTER :: A (:), B (:), C (:), D (:) tInteger :: tA ( 0 : 3 ), Tmp ! FLOW A ( 0 : 3 ) => State ( 0 :) B ( 0 : 3 ) => State ( 4 :) C ( 0 : 3 ) => State ( 8 :) D ( 0 : 3 ) => State ( 12 :) STEP_SMALL ( W ( 0 ), W ( 1 ), W ( 2 ), W ( 3 ), IFF , P0 , P1 , PP4K ( ISP + 0 )) STEP_SMALL ( W ( 4 ), W ( 5 ), W ( 6 ), W ( 7 ), IFF , P1 , P2 , PP4K ( ISP + 1 )) STEP_SMALL ( W ( 8 ), W ( 9 ), W ( 10 ), W ( 11 ), IFF , P2 , P3 , PP4K ( ISP + 2 )) STEP_SMALL ( W ( 12 ), W ( 13 ), W ( 14 ), W ( 15 ), IFF , P3 , P0 , PP4K ( ISP + 3 )) STEP_SMALL ( W ( 16 ), W ( 17 ), W ( 18 ), W ( 19 ), MAJ , P0 , P1 , PP4K ( ISP + 4 )) STEP_SMALL ( W ( 20 ), W ( 21 ), W ( 22 ), W ( 23 ), MAJ , P1 , P2 , PP4K ( ISP + 5 )) STEP_SMALL ( W ( 24 ), W ( 25 ), W ( 26 ), W ( 27 ), MAJ , P2 , P3 , PP4K ( ISP + 6 )) STEP_SMALL ( W ( 28 ), W ( 29 ), W ( 30 ), W ( 31 ), MAJ , P3 , P0 , PP4K ( ISP + 7 )) NULLIFY ( A , B , C , D ) RETURN END SUBROUTINE OneRound_Small !****************************************************************************** #include    \"Includes/SIMD_Undef Macro.f90\" END SUBROUTINE SIMDCore_Compress_Small !****************************************************************************** END MODULE MClass_SIMDS !******************************************************************************","tags":"","loc":"sourcefile\\mclass_simds.f90.html"},{"title":"MClass_Blake3.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Blake3 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Blake3* type and its related routines. !   The *Blake3* type is a *digest* type extending directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   The *Blake3* type implements an incremental cryptographic hash function !   by employing the *BLAKE3 message-digest* algorithm [1].  The implementation !   here is based mainly on the official implementation in C [2]. <br> !   Similar to the *Blake2-based* digest types, the *Blake3* type can perform !   keyed hashing providing that a user specifies the key during an initialization !   of the digest object by calling the *CreateHMAC* method in place of the *Create* !   method.  In addition, the *Blake3* type can be used as a key derivative function !   (KDF) by specifying the context string during an initialization of the digest !   object with the *CreateKDF* method.  Furthermore, the *Blake3* type can be used !   as an extendable-output function (XOF) by specifying the hash output length !   during a finalization of the digest object where the *DigestWOutLen* method !   is called. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/BLAKE3-team/BLAKE3-specs\">The BLAKE3 paper: !       specifications, analysis, and design rationale. </a> <br> !   [2] <a href=\"https://github.com/BLAKE3-team/BLAKE3\">Blake3: The official Rust !       and C implementations of BLAKE3 cryptographic hash function. </a> <br> !** USE STATEMENTS: USE , INTRINSIC :: ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , & ByteArr_2_HexStr => ToHexStr_BE USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Blake3 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tCharParam :: ModName = 'MClass_Blake3' tIndex , PARAMETER :: BLAKE3_KEY_LEN = 8_kIndex tIndex , PARAMETER :: BLAKE3_OUT_LEN = 32_kIndex tIndex , PARAMETER :: BLAKE3_BLOCK_LEN = 64_kIndex tIndex , PARAMETER :: BLAKE3_CHUNK_LEN = 1024_kIndex tIndex , PARAMETER :: BLAKE3_MAX_DEPTH = 54_kIndex !--------------------------------------------------------------------- tByte , PARAMETER :: CHUNK_START = SHIFTL ( 1_kInt8 , 0 ) tByte , PARAMETER :: CHUNK_END = SHIFTL ( 1_kInt8 , 1 ) tByte , PARAMETER :: PARENT = SHIFTL ( 1_kInt8 , 2 ) tByte , PARAMETER :: ROOT = SHIFTL ( 1_kInt8 , 3 ) tByte , PARAMETER :: KEYED_HASH = SHIFTL ( 1_kInt8 , 4 ) tByte , PARAMETER :: DERIVE_KEY_CONTEXT = SHIFTL ( 1_kInt8 , 5 ) tByte , PARAMETER :: DERIVE_KEY_MATERIAL = SHIFTL ( 1_kInt8 , 6 ) !--------------------------------------------------------------------- tInteger , PARAMETER :: IV ( 0 : 7 ) = [ & ToInt32 ( Z '6A09E667' ), ToInt32 ( Z 'BB67AE85' ), & ToInt32 ( Z '3C6EF372' ), ToInt32 ( Z 'A54FF53A' ), & ToInt32 ( Z '510E527F' ), ToInt32 ( Z '9B05688C' ), & ToInt32 ( Z '1F83D9AB' ), ToInt32 ( Z '5BE0CD19' )] !--------------------------------------------------------------------- !** DERIVED TYPE DEFINITIONS !> *ChunkState* is a helper object and a private type. TYPE ChunkState !% chaining value tInteger :: CV ( 0 : BLAKE3_KEY_LEN - 1 ) !% buffer tByte :: Buf ( 0 : BLAKE3_BLOCK_LEN - 1 ) !% number of bytes used in the buffer tByte :: BufLen !% counter tLong :: Counter !% flags tByte :: Flags !% the number of block compressed tByte :: BlocksCompressed END TYPE ChunkState !> *Blake3* is a concrete *digest* type that implements an incremental cryptographic !  hash function by employing the *BLAKE3 message-digest* algorithm.  It can also be !  utilized as a hash-based message authentication code (HMAC).  It can be used as !  a key derivation function (KDF) as well.  In addition, it can be employed as an !  extendable-output function (XOF) to output the hash value with a desired length. TYPE , EXTENDS ( BaseDigest ) :: Blake3 PRIVATE !% stored key tInteger :: Key ( 0 : BLAKE3_KEY_LEN - 1 ) !% chunk state variable TYPE ( ChunkState ) :: Chunk !% chaining value stack tByte :: CVStack ( 0 :( BLAKE3_MAX_DEPTH + 1 ) * BLAKE3_OUT_LEN - 1 ) !% the number of chaining values occupying the stack tByte :: CVStackLen CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: DoInit => Blake3_InitBase PROCEDURE , PRIVATE :: DoUpdate => Blake3_Update PROCEDURE , PRIVATE :: Blake3_Finalize PROCEDURE , PRIVATE :: Blake3_Finalize_Seek GENERIC , PRIVATE :: DoFinal => Blake3_Finalize , Blake3_Finalize_Seek PROCEDURE , PRIVATE :: MergeCVStack => Blake3_Merge_CVStack PROCEDURE , PRIVATE :: PushCV => Blake3_Push_CV PROCEDURE , PRIVATE :: Blake3_ByteDigest_wOutLen PROCEDURE , PRIVATE :: Blake3_ByteDigest_wInputNOutLen PROCEDURE , PRIVATE :: Blake3_HexDigest_wOutLen PROCEDURE , PRIVATE :: Blake3_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to perform !  default initialization of the *digest* object. PROCEDURE :: Initialize => Blake3_Initialize !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Blake3_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Blake3_GetName !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Blake3_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Blake3_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Blake3_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Blake3_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Blake3_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateHMAC <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *HMAC* object (for keyed hashing). <br> !  **Usage**: <br> !   --->    CALL MD%CreateHMAC(Key) <br> PROCEDURE :: CreateHMAC => Blake3_InitHMAC !> **Type-Bound Subroutine**: CreateKDF <br> !  **Purpose**:  To perform any essential initialization of the *digest* object !                as a *KDF* object (for key derivation). <br> !  **Usage**: <br> !   --->    CALL MD%CreateKDF(ContextString) <br> PROCEDURE :: CreateKDF => Blake3_InitKDF ! --------------------------------------------------------------------- ! -----                     Generic Interface                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: DigestWOutLen <br> !  **Purpose**:  To finalize the current hash computation and return the hash output !                with specified length.  The object is reset.  Some final input data !                can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(ByteArr, OutLen) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, ByteArr, OutLen) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(HexStr, OutLen) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%DigestWOutLen(Input, InpSize, HexStr, OutLen) <br> GENERIC :: DigestWOutLen => Blake3_ByteDigest_wOutLen , & Blake3_ByteDigest_wInputNOutLen , & Blake3_HexDigest_wOutLen , & Blake3_HexDigest_wInputNOutLen ! --------------------------------------------------------------------- END TYPE Blake3 !** INTERFACE DEFINITIONS: INTERFACE !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_InitBase ( MD , Key , Flags ) CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tInteger , INTENT ( IN ) :: Key ( 0 : BLAKE3_KEY_LEN - 1 ) tByte , INTENT ( IN ) :: Flags END SUBROUTINE Blake3_InitBase !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_Merge_CVStack ( MD , TotalLen ) CLASS ( Blake3 ), TARGET , INTENT ( INOUT ) :: MD tLong , INTENT ( IN ) :: TotalLen END SUBROUTINE Blake3_Merge_CVStack !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_Push_CV ( MD , NewCV , ChunkCounter ) CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: NewCV ( 0 : BLAKE3_OUT_LEN - 1 ) tLong , INTENT ( IN ) :: ChunkCounter END SUBROUTINE Blake3_Push_CV !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_Update ( MD , BytesIn , Offset , Length ) CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: BytesIn ( 0 :) tIndex , INTENT ( IN ) :: Offset tIndex , INTENT ( IN ) :: Length END SUBROUTINE Blake3_Update !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_Finalize_Seek ( MD , Seek , Output , OutLen ) CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tLong , INTENT ( IN ) :: Seek tByte , INTENT ( INOUT ) :: Output ( 0 :) tIndex , INTENT ( IN ) :: OutLen END SUBROUTINE Blake3_Finalize_Seek !---------------------------------------------------------------------- MODULE SUBROUTINE Blake3_Finalize ( MD , Output , OutLen ) CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tByte , INTENT ( OUT ) :: Output ( 0 :) tIndex , INTENT ( IN ) :: OutLen END SUBROUTINE Blake3_Finalize !---------------------------------------------------------------------- MODULE SUBROUTINE ChunkState_Reset ( Chunk , Key , Counter ) TYPE ( ChunkState ), INTENT ( INOUT ) :: Chunk tInteger , INTENT ( IN ) :: Key ( 0 : 7 ) tLong , INTENT ( IN ) :: Counter END SUBROUTINE ChunkState_Reset !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Blake3_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with !  default algorithm and default hash output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % DoInit ( IV , 0_kInt8 ) RETURN END SUBROUTINE Blake3_Initialize !****************************************************************************** SUBROUTINE Blake3_InitHMAC ( MD , Key ) !** PURPOSE OF THIS SUBROUTINE: ! To construct Blake3 hasher with key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: Key ( 0 : BLAKE3_KEY_LEN * 4 - 1 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: KeyWords ( 0 : 7 ) ! FLOW CALL BytePackLE ( Key , 0_kIndex , KeyWords ) CALL MD % DoInit ( KeyWords , KEYED_HASH ) RETURN END SUBROUTINE Blake3_InitHMAC !****************************************************************************** SUBROUTINE Blake3_InitKDF ( BaseMD , ContextStr ) !** PURPOSE OF THIS SUBROUTINE: ! To construct Blake3 hasher with context string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: BaseMD tCharStar , INTENT ( IN ) :: ContextStr !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( Blake3 ) :: ContextMD tByte :: HashKey ( 0 : BLAKE3_OUT_LEN - 1 ) tInteger :: HashWords ( 0 : BLAKE3_KEY_LEN - 1 ) ! FLOW ! hash the context string CALL ContextMD % DoInit ( IV , DERIVE_KEY_CONTEXT ) CALL ContextMD % Update ( ContextStr , LEN ( ContextStr , KIND = kIndex )) CALL ContextMD % DoFinal ( HashKey , BLAKE3_KEY_LEN * 4 ) ! initialize with the context hash CALL BytePackLE ( HashKey , 0_kIndex , HashWords ) CALL BaseMD % DoInit ( HashWords , DERIVE_KEY_MATERIAL ) RETURN END SUBROUTINE Blake3_InitKDF !****************************************************************************** SUBROUTINE Blake3_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL ChunkState_Reset ( MD % Chunk , MD % Key , 0_kInt64 ) MD % CVStackLen = 0_kInt8 RETURN END SUBROUTINE Blake3_Reset !****************************************************************************** SUBROUTINE Blake3_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Blake3 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Blake3 ) Dst % Key = Src % Key Dst % Chunk = Src % Chunk Dst % CVStackLen = Src % CVStackLen Dst % CVStack = Src % CVStack END SELECT RETURN END SUBROUTINE Blake3_GetClone !****************************************************************************** FUNCTION Blake3_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( IN ) :: MD !! 'Blake3' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'Blake3' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION Blake3_GetName !****************************************************************************** SUBROUTINE Blake3_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % DoUpdate ( ByteArr , Offset , Length ) RETURN END SUBROUTINE Blake3_InsertBytes !****************************************************************************** SUBROUTINE Blake3_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % DoUpdate ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE Blake3_InsertGen !****************************************************************************** SUBROUTINE Blake3_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: HashLen ! FLOW HashLen = BLAKE3_OUT_LEN CALL MemAlloc ( ByteArr , HashLen , StartID = 0_kIndex ) CALL MD % DoFinal ( 0_kInt64 , ByteArr , HashLen ) CALL MD % Reset () RETURN END SUBROUTINE Blake3_ByteDigest !****************************************************************************** SUBROUTINE Blake3_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE Blake3_ByteDigest_wInput !****************************************************************************** SUBROUTINE Blake3_ByteDigest_wOutLen ( MD , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes. The digest object is reset. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( OutputLen > 0_kIndex ) THEN CALL MD % DoFinal ( 0_kInt64 , ByteArr , OutputLen ) CALL MD % Reset () END IF RETURN END SUBROUTINE Blake3_ByteDigest_wOutLen !****************************************************************************** SUBROUTINE Blake3_ByteDigest_wInputNOutLen ( MD , Input , InpSize , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'Blake3' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % DigestWOutLen ( ByteArr , OutputLen ) RETURN END SUBROUTINE Blake3_ByteDigest_wInputNOutLen !****************************************************************************** SUBROUTINE Blake3_HexDigest_wOutLen ( MD , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as a hexadecimal string in a newly-allocated character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Blake3_HexDigest_wOutLen !****************************************************************************** SUBROUTINE Blake3_HexDigest_wInputNOutLen ( MD , Input , InpSize , HexStr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash computation !  and return the hash value as a hexadecimal string in a newly-allocated character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Blake3 ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output as a hexadecimal string tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: ByteArr ( OutputLen ) ! FLOW CALL MD % DigestWOutLen ( Input , InpSize , ByteArr , OutputLen ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Blake3_HexDigest_wInputNOutLen !****************************************************************************** END MODULE MClass_Blake3 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_blake3.f90.html"},{"title":"MClass_XX3Hasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_XX3Hasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *XX3Hasher64* and *XX3Hasher128* types and their !   related routines.  The *XX3Hasher64* type is a hasher type that extends directly !   from the <a href=\"../module/mclass_hasher64.html#type-hasher64\">Hasher64</a> type. !   It provides all deferred procedures required by a *Hasher64* class and outputs the !   hash value as a 64-bit integer.  The *XX3Hasher128* type is a hasher type that !   extends from the *XX3Hasher64* type and provides additional methods to output !   the hash value as a 128-bit integer. <br> !   Both hashers employ the *XX3* hash algorithm by Yann Collet [1, 2].  As hashers, !   they can be used to compute the hash value incrementally.  They also provide a !   method to compute the hash value directly (i.e. non-incrementally).  The following !   code snippet shows a typical usage of the hashers. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the *HashDirect* !   method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !   To compute the hash value as a 128-bit integer, simply replace the *Finalize* and !   *HashDirect* methods by the *Finalize128* and *HashDirect128* methods, respectively. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/Cyan4973/xxHash\">xxHash: Extremely fast hash algorithm. </a> <br> !   [2] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : LongReverseBytes => ReverseBytes , & IntegerReverseBytes => ReverseBytes USE MBase_UIntUtil , ONLY : UnsignedLongMultiplyHigh => UMul128_Upper64 USE MBase_SInt128 USE MClass_Hasher64 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: XX3Hasher64 PUBLIC :: XX3Hasher128 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define     tSInt128        TYPE(SInt128) #define     MaskI8(X)           IAND(ToInt64(X), ToInt64(Z'00000000000000FF')) #define     MaskI32(X)          IAND(ToInt64(X), ToInt64(Z'00000000FFFFFFFF')) #define     UnsignedInt(I)      IAND(ToInt64(I), ToInt64(Z'00000000FFFFFFFF')) #define     XXH3_Mix16B(Seed,Input,OffIn,Secret,OffSec) \\ UnsignedLongMultiplyorFold ( IEOR ( Input ( OffIn ), Secret ( OffSec ) + Seed ), \\ IEOR ( Input ( OffIn + 1 ), Secret ( OffSec + 1 ) - Seed )) #define     XXH3_Mix2Accs(Acc_LH,Acc_RH,Secret,OffSec) \\ UnsignedLongMultiplyorFold ( IEOR ( Acc_LH , Secret ( OffSec )), IEOR ( Acc_RH , Secret ( OffSec + 1 ))) #define     XXH128_Mix32B_Once(Seed,Secret,OffSec,Acc,Input0,Input1,Input2,Input3) \\ IEOR ( Acc + UnsignedLongMultiplyorFold ( IEOR ( Input0 , ( Secret ( OffSec ) + Seed )), \\ IEOR ( Input1 , ( Secret ( OffSec + 1 ) - Seed ))), \\ ( Input2 + Input3 )) !** MODULE PARAMETERS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) ! ***************************************************************** ! *****     Pseudo-random secret taken directly from FARSH    ***** ! ***************************************************************** ! base secret parameters in bytes for non-optimized versions tUInt8 , PARAMETER :: XXH3_Secret_Bytes ( 192 ) = & [ ToInt8 ( Z 'B8' ), ToInt8 ( Z 'FE' ), ToInt8 ( Z '6C' ), ToInt8 ( Z '39' ), & ToInt8 ( Z '23' ), ToInt8 ( Z 'A4' ), ToInt8 ( Z '4B' ), ToInt8 ( Z 'BE' ), & ToInt8 ( Z '7C' ), ToInt8 ( Z '01' ), ToInt8 ( Z '81' ), ToInt8 ( Z '2C' ), & ToInt8 ( Z 'F7' ), ToInt8 ( Z '21' ), ToInt8 ( Z 'AD' ), ToInt8 ( Z '1C' ), & ToInt8 ( Z 'DE' ), ToInt8 ( Z 'D4' ), ToInt8 ( Z '6D' ), ToInt8 ( Z 'E9' ), & ToInt8 ( Z '83' ), ToInt8 ( Z '90' ), ToInt8 ( Z '97' ), ToInt8 ( Z 'DB' ), & ToInt8 ( Z '72' ), ToInt8 ( Z '40' ), ToInt8 ( Z 'A4' ), ToInt8 ( Z 'A4' ), & ToInt8 ( Z 'B7' ), ToInt8 ( Z 'B3' ), ToInt8 ( Z '67' ), ToInt8 ( Z '1F' ), & ToInt8 ( Z 'CB' ), ToInt8 ( Z '79' ), ToInt8 ( Z 'E6' ), ToInt8 ( Z '4E' ), & ToInt8 ( Z 'CC' ), ToInt8 ( Z 'C0' ), ToInt8 ( Z 'E5' ), ToInt8 ( Z '78' ), & ToInt8 ( Z '82' ), ToInt8 ( Z '5A' ), ToInt8 ( Z 'D0' ), ToInt8 ( Z '7D' ), & ToInt8 ( Z 'CC' ), ToInt8 ( Z 'FF' ), ToInt8 ( Z '72' ), ToInt8 ( Z '21' ), & ToInt8 ( Z 'B8' ), ToInt8 ( Z '08' ), ToInt8 ( Z '46' ), ToInt8 ( Z '74' ), & ToInt8 ( Z 'F7' ), ToInt8 ( Z '43' ), ToInt8 ( Z '24' ), ToInt8 ( Z '8E' ), & ToInt8 ( Z 'E0' ), ToInt8 ( Z '35' ), ToInt8 ( Z '90' ), ToInt8 ( Z 'E6' ), & ToInt8 ( Z '81' ), ToInt8 ( Z '3A' ), ToInt8 ( Z '26' ), ToInt8 ( Z '4C' ), & ToInt8 ( Z '3C' ), ToInt8 ( Z '28' ), ToInt8 ( Z '52' ), ToInt8 ( Z 'BB' ), & ToInt8 ( Z '91' ), ToInt8 ( Z 'C3' ), ToInt8 ( Z '00' ), ToInt8 ( Z 'CB' ), & ToInt8 ( Z '88' ), ToInt8 ( Z 'D0' ), ToInt8 ( Z '65' ), ToInt8 ( Z '8B' ), & ToInt8 ( Z '1B' ), ToInt8 ( Z '53' ), ToInt8 ( Z '2E' ), ToInt8 ( Z 'A3' ), & ToInt8 ( Z '71' ), ToInt8 ( Z '64' ), ToInt8 ( Z '48' ), ToInt8 ( Z '97' ), & ToInt8 ( Z 'A2' ), ToInt8 ( Z '0D' ), ToInt8 ( Z 'F9' ), ToInt8 ( Z '4E' ), & ToInt8 ( Z '38' ), ToInt8 ( Z '19' ), ToInt8 ( Z 'EF' ), ToInt8 ( Z '46' ), & ToInt8 ( Z 'A9' ), ToInt8 ( Z 'DE' ), ToInt8 ( Z 'AC' ), ToInt8 ( Z 'D8' ), & ToInt8 ( Z 'A8' ), ToInt8 ( Z 'FA' ), ToInt8 ( Z '76' ), ToInt8 ( Z '3F' ), & ToInt8 ( Z 'E3' ), ToInt8 ( Z '9C' ), ToInt8 ( Z '34' ), ToInt8 ( Z '3F' ), & ToInt8 ( Z 'F9' ), ToInt8 ( Z 'DC' ), ToInt8 ( Z 'BB' ), ToInt8 ( Z 'C7' ), & ToInt8 ( Z 'C7' ), ToInt8 ( Z '0B' ), ToInt8 ( Z '4F' ), ToInt8 ( Z '1D' ), & ToInt8 ( Z '8A' ), ToInt8 ( Z '51' ), ToInt8 ( Z 'E0' ), ToInt8 ( Z '4B' ), & ToInt8 ( Z 'CD' ), ToInt8 ( Z 'B4' ), ToInt8 ( Z '59' ), ToInt8 ( Z '31' ), & ToInt8 ( Z 'C8' ), ToInt8 ( Z '9F' ), ToInt8 ( Z '7E' ), ToInt8 ( Z 'C9' ), & ToInt8 ( Z 'D9' ), ToInt8 ( Z '78' ), ToInt8 ( Z '73' ), ToInt8 ( Z '64' ), & ToInt8 ( Z 'EA' ), ToInt8 ( Z 'C5' ), ToInt8 ( Z 'AC' ), ToInt8 ( Z '83' ), & ToInt8 ( Z '34' ), ToInt8 ( Z 'D3' ), ToInt8 ( Z 'EB' ), ToInt8 ( Z 'C3' ), & ToInt8 ( Z 'C5' ), ToInt8 ( Z '81' ), ToInt8 ( Z 'A0' ), ToInt8 ( Z 'FF' ), & ToInt8 ( Z 'FA' ), ToInt8 ( Z '13' ), ToInt8 ( Z '63' ), ToInt8 ( Z 'EB' ), & ToInt8 ( Z '17' ), ToInt8 ( Z '0D' ), ToInt8 ( Z 'DD' ), ToInt8 ( Z '51' ), & ToInt8 ( Z 'B7' ), ToInt8 ( Z 'F0' ), ToInt8 ( Z 'DA' ), ToInt8 ( Z '49' ), & ToInt8 ( Z 'D3' ), ToInt8 ( Z '16' ), ToInt8 ( Z '55' ), ToInt8 ( Z '26' ), & ToInt8 ( Z '29' ), ToInt8 ( Z 'D4' ), ToInt8 ( Z '68' ), ToInt8 ( Z '9E' ), & ToInt8 ( Z '2B' ), ToInt8 ( Z '16' ), ToInt8 ( Z 'BE' ), ToInt8 ( Z '58' ), & ToInt8 ( Z '7D' ), ToInt8 ( Z '47' ), ToInt8 ( Z 'A1' ), ToInt8 ( Z 'FC' ), & ToInt8 ( Z '8F' ), ToInt8 ( Z 'F8' ), ToInt8 ( Z 'B8' ), ToInt8 ( Z 'D1' ), & ToInt8 ( Z '7A' ), ToInt8 ( Z 'D0' ), ToInt8 ( Z '31' ), ToInt8 ( Z 'CE' ), & ToInt8 ( Z '45' ), ToInt8 ( Z 'CB' ), ToInt8 ( Z '3A' ), ToInt8 ( Z '8F' ), & ToInt8 ( Z '95' ), ToInt8 ( Z '16' ), ToInt8 ( Z '04' ), ToInt8 ( Z '28' ), & ToInt8 ( Z 'AF' ), ToInt8 ( Z 'D7' ), ToInt8 ( Z 'FB' ), ToInt8 ( Z 'CA' ), & ToInt8 ( Z 'BB' ), ToInt8 ( Z '4B' ), ToInt8 ( Z '40' ), ToInt8 ( Z '7E' )] ! base secret parameters in longs used for general optimization tUInt64 , PARAMETER :: XXH3_Secret_Long1 ( 0 : 23 ) = & [ ToInt64 ( Z 'BE4BA423396CFEB8' ), ToInt64 ( Z '1CAD21F72C81017C' ), & ToInt64 ( Z 'DB979083E96DD4DE' ), ToInt64 ( Z '1F67B3B7A4A44072' ), & ToInt64 ( Z '78E5C0CC4EE679CB' ), ToInt64 ( Z '2172FFCC7DD05A82' ), & ToInt64 ( Z '8E2443F7744608B8' ), ToInt64 ( Z '4C263A81E69035E0' ), & ToInt64 ( Z 'CB00C391BB52283C' ), ToInt64 ( Z 'A32E531B8B65D088' ), & ToInt64 ( Z '4EF90DA297486471' ), ToInt64 ( Z 'D8ACDEA946EF1938' ), & ToInt64 ( Z '3F349CE33F76FAA8' ), ToInt64 ( Z '1D4F0BC7C7BBDCF9' ), & ToInt64 ( Z '3159B4CD4BE0518A' ), ToInt64 ( Z '647378D9C97E9FC8' ), & ToInt64 ( Z 'C3EBD33483ACC5EA' ), ToInt64 ( Z 'EB6313FAFFA081C5' ), & ToInt64 ( Z '49DAF0B751DD0D17' ), ToInt64 ( Z '9E68D429265516D3' ), & ToInt64 ( Z 'FCA1477D58BE162B' ), ToInt64 ( Z 'CE31D07AD1B8F88F' ), & ToInt64 ( Z '280416958F3ACB45' ), ToInt64 ( Z '7E404BBBCAFBD7AF' )] ! base secret parameters in longs used for medium-message (129-240) optimization tUInt64 , PARAMETER :: XXH3_Secret_Long2 ( 0 : 13 ) = & [ ToInt64 ( Z '81017CBE4BA42339' ), ToInt64 ( Z '6DD4DE1CAD21F72C' ), & ToInt64 ( Z 'A44072DB979083E9' ), ToInt64 ( Z 'E679CB1F67B3B7A4' ), & ToInt64 ( Z 'D05A8278E5C0CC4E' ), ToInt64 ( Z '4608B82172FFCC7D' ), & ToInt64 ( Z '9035E08E2443F774' ), ToInt64 ( Z '52283C4C263A81E6' ), & ToInt64 ( Z '65D088CB00C391BB' ), ToInt64 ( Z '486471A32E531B8B' ), & ToInt64 ( Z 'EF19384EF90DA297' ), ToInt64 ( Z '76FAA8D8ACDEA946' ), & ToInt64 ( Z 'BBDCF93F349CE33F' ), ToInt64 ( Z 'E0518A1D4F0BC7C7' )] tUInt64 , PARAMETER :: XXH3_Secret_Long3 ( 0 : 3 ) = & [ ToInt64 ( Z '4F0BC7C7BBDCF93F' ), ToInt64 ( Z '59B4CD4BE0518A1D' ), & ToInt64 ( Z '7378D9C97E9FC831' ), ToInt64 ( Z 'EBD33483ACC5EA64' )] ! base secret parameters in longs used for long-message (240 up) optimization tUInt64 , PARAMETER :: XXH3_Secret_Long4 ( 0 : 7 ) = & [ ToInt64 ( Z 'EA647378D9C97E9F' ), ToInt64 ( Z 'C5C3EBD33483ACC5' ), & ToInt64 ( Z '17EB6313FAFFA081' ), ToInt64 ( Z 'D349DAF0B751DD0D' ), & ToInt64 ( Z '2B9E68D429265516' ), ToInt64 ( Z '8FFCA1477D58BE16' ), & ToInt64 ( Z '45CE31D07AD1B8F8' ), ToInt64 ( Z 'AF280416958F3ACB' )] tUInt64 , PARAMETER :: XXH3_Secret_Long5 ( 0 : 7 ) = & [ ToInt64 ( Z '6DD4DE1CAD21F72C' ), ToInt64 ( Z 'A44072DB979083E9' ), & ToInt64 ( Z 'E679CB1F67B3B7A4' ), ToInt64 ( Z 'D05A8278E5C0CC4E' ), & ToInt64 ( Z '4608B82172FFCC7D' ), ToInt64 ( Z '9035E08E2443F774' ), & ToInt64 ( Z '52283C4C263A81E6' ), ToInt64 ( Z '65D088CB00C391BB' )] tUInt64 , PARAMETER :: XXH3_Secret_Long6 ( 0 : 7 ) = & [ ToInt64 ( Z 'D9C97E9FC83159B4' ), ToInt64 ( Z '3483ACC5EA647378' ), & ToInt64 ( Z 'FAFFA081C5C3EBD3' ), ToInt64 ( Z 'B751DD0D17EB6313' ), & ToInt64 ( Z '29265516D349DAF0' ), ToInt64 ( Z '7D58BE162B9E68D4' ), & ToInt64 ( Z '7AD1B8F88FFCA147' ), ToInt64 ( Z '958F3ACB45CE31D0' )] ! base secret parameters in integers used for short-message (1-16) optimization tUInt32 , PARAMETER :: XXH3_Secret_Integer ( 0 : 3 ) = & [ ToInt32 ( Z '396CFEB8' ), ToInt32 ( Z 'BE4BA423' ), & ToInt32 ( Z '2C81017C' ), ToInt32 ( Z '1CAD21F7' )] ! Primes for 32 bits tUInt64 , PARAMETER :: XXH_PRIME32_1 = ToInt64 ( Z '000000009E3779B1' ) ! < 0b10011110001101110111100110110001 > tUInt64 , PARAMETER :: XXH_PRIME32_2 = ToInt64 ( Z '0000000085EBCA77' ) ! < 0b10000101111010111100101001110111 > tUInt64 , PARAMETER :: XXH_PRIME32_3 = ToInt64 ( Z '00000000C2B2AE3D' ) ! < 0b11000010101100101010111000111101 > ! Primes for 64 bits tUInt64 , PARAMETER :: XXH_PRIME64_1 = ToInt64 ( Z '9E3779B185EBCA87' ) ! < 0b1001111000110111011110011011000110000101111010111100101010000111 > tUInt64 , PARAMETER :: XXH_PRIME64_2 = ToInt64 ( Z 'C2B2AE3D27D4EB4F' ) ! < 0b1100001010110010101011100011110100100111110101001110101101001111 > tUInt64 , PARAMETER :: XXH_PRIME64_3 = ToInt64 ( Z '165667B19E3779F9' ) ! < 0b0001011001010110011001111011000110011110001101110111100111111001 > tUInt64 , PARAMETER :: XXH_PRIME64_4 = ToInt64 ( Z '85EBCA77C2B2AE63' ) ! < 0b1000010111101011110010100111011111000010101100101010111001100011 > tUInt64 , PARAMETER :: XXH_PRIME64_5 = ToInt64 ( Z '27D4EB2F165667C5' ) ! < 0b0010011111010100111010110010111100010110010101100110011111000101 > tIndex , PARAMETER :: BlockLen = 256_kIndex !** DERIVED TYPE DEFINITIONS !> *XX3Hasher64* is a hasher type that outputs the hash value as a 64-bit integer. !  It employs the *XX3* hash algorithm by Yann Collet. TYPE , EXTENDS ( Hasher64 ) :: XX3Hasher64 PRIVATE !% seed tUInt64 :: Seed = 0_kInt64 !% state tUInt64 :: State ( 0 : 7 ) = 0_kInt64 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% pointer to custom secret tUInt8 , POINTER :: Secret (:) => NULL () !% number of stripes processed tIndex :: nStripe = 0_kIndex !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX3_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => XX3_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => XX3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => XX3_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => XX3_Initialize !> **Type-Bound Subroutine**: InitializeWSecret <br> !  **Purpose**:  To initialize the hasher with specified secret. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWSecret(Seed, Secret)         ! hash value with sign <br> !   --->    CALL Hasher%InitializeWSecret(Seed, Secret, .TRUE.) ! remove sign from hash value <br> PROCEDURE :: InitializeWSecret => XX3_Initialize_wSecret !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX3_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => XX3_HashDirect !> **Type-Bound Function**: HashDirectWSecret <br> !  **Purpose**:  To compute the hash value directly with specified seed and secret. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret) <br> !   --->    HashCode = Hasher%HashDirectWSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirectWSecret => XX3_HashDirect_wSecret END TYPE XX3Hasher64 !> *XX3Hasher128* is a hasher type that outputs the hash value as a 128-bit integer. !  It is a subtype of the *XX3Hasher64* type. TYPE , EXTENDS ( XX3Hasher64 ) :: XX3Hasher128 CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => XX3_GetName128 !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => XX3_Finalize64 !> **Type-Bound Function**: Finalize128 <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 128-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize128() PROCEDURE :: Finalize128 => XX3_Finalize128 !> **Type-Bound Function**: HashDirect128 <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect128(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128 => XX3_HashDirect128 !> **Type-Bound Function**: HashDirect128WSecret <br> !  **Purpose**:  To compute the hash value directly with specified seed and secret. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret) <br> !   --->    HashCode = Hasher%HashDirect128WSecret(Input, InpSize, Seed, Secret, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect128WSecret => XX3_HashDirect128_wSecret END TYPE XX3Hasher128 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tUInt8 , TARGET :: CustomSecret ( 0 : 191 ) CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION XX3_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'XX3_Hahser64' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX3_GetName !****************************************************************************** FUNCTION XX3_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = BlockLen ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX3_BlockLength !****************************************************************************** SUBROUTINE XX3_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE XX3_SetBufPtr !****************************************************************************** SUBROUTINE XX3_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: DataVal0 , DataVal1 tUInt64 :: DataKey0 , DataKey1 tIndex :: I , J , OffStripe , Offsec tUInt8 :: InpBytes ( 0 : 63 ) tUInt64 :: InpLongs ( 1 : 8 ) EQUIVALENCE ( InpBytes , InpLongs ) tUInt8 :: SecBytes ( 0 : 63 ) tUInt64 :: SecLongs ( 1 : 8 ) EQUIVALENCE ( SecBytes , SecLongs ) !** FLOW IF ( ASSOCIATED ( HS % Secret )) THEN ASSOCIATE ( nStripe => HS % nStripe , Acc => HS % State ) ! XXH3_accumulate_256 OffStripe = 0_kIndex OffSec = nStripe * 8_kIndex ! process 4 stripes at a time DO I = 1 , 4 InpBytes ( 0 : 63 ) = BytesIn ( OffStripe : OffStripe + 63 ) SecBytes ( 0 : 63 ) = HS % Secret ( OffSec : OffSec + 63 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , SecLongs ( J + 1 )) DataKey1 = IEOR ( DataVal1 , SecLongs ( J + 2 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO nStripe = nStripe + 1_kIndex OffStripe = OffStripe + 64_kIndex END DO IF ( nStripe == 16_kIndex ) THEN ! XXH3_scrambleAcc_scalar OffSec = 128 ! 192 - 64 SecBytes ( 0 : 63 ) = HS % Secret ( 128 : 191 ) DO J = 0 , 7 Acc ( J ) = ( IEOR ( IEOR ( Acc ( J ), SHIFTR ( Acc ( J ), 47 )), SecLongs ( J + 1 ))) * XXH_PRIME32_1 END DO ! reset nStripe = 0_kIndex END IF END ASSOCIATE ELSE ASSOCIATE ( Secret1 => XXH3_Secret_Long1 , nStripe => HS % nStripe , Acc => HS % State ) ! XXH3_accumulate_256 OffStripe = 0_kIndex ! process 4 stripes at a time DO I = 1 , 4 InpBytes ( 0 : 63 ) = BytesIn ( OffStripe : OffStripe + 63 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , Secret1 ( nStripe + J )) DataKey1 = IEOR ( DataVal1 , Secret1 ( nStripe + J + 1 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO nStripe = nStripe + 1_kIndex OffStripe = OffStripe + 64_kIndex END DO IF ( nStripe == 16_kIndex ) THEN ! XXH3_scrambleAcc_scalar DO J = 0 , 7 Acc ( J ) = ( IEOR ( IEOR ( Acc ( J ), SHIFTR ( Acc ( J ), 47 )), & Secret1 ( nStripe + J ))) * XXH_PRIME32_1 END DO ! reset nStripe = 0_kIndex END IF END ASSOCIATE END IF RETURN END SUBROUTINE XX3_ProcessBlock !****************************************************************************** SUBROUTINE XX3_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % Seed = Seed HS % State ( 0 ) = XXH_PRIME32_3 HS % State ( 1 ) = XXH_PRIME64_1 HS % State ( 2 ) = XXH_PRIME64_2 HS % State ( 3 ) = XXH_PRIME64_3 HS % State ( 4 ) = XXH_PRIME64_4 HS % State ( 5 ) = XXH_PRIME32_2 HS % State ( 6 ) = XXH_PRIME64_5 HS % State ( 7 ) = XXH_PRIME32_1 HS % Secret => NULL () HS % nStripe = 0_kIndex SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE XX3_Initialize !****************************************************************************** SUBROUTINE XX3_Initialize_wSecret ( HS , Seed , Secret , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tUInt8 , TARGET , INTENT ( IN ) :: Secret ( 0 :) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW HS % Seed = Seed HS % State ( 0 ) = XXH_PRIME32_3 HS % State ( 1 ) = XXH_PRIME64_1 HS % State ( 2 ) = XXH_PRIME64_2 HS % State ( 3 ) = XXH_PRIME64_3 HS % State ( 4 ) = XXH_PRIME64_4 HS % State ( 5 ) = XXH_PRIME32_2 HS % State ( 6 ) = XXH_PRIME64_5 HS % State ( 7 ) = XXH_PRIME32_1 IF ( SIZE ( Secret ) >= 192 ) THEN HS % Secret => Secret ELSE BLOCK tUInt32 :: InSize InSize = SIZE ( Secret ) CustomSecret ( 1 : InSize ) = Secret ( 1 : InSize ) CustomSecret ( InSize + 1 :) = XXH3_Secret_Bytes ( 1 :) HS % Secret => CustomSecret END BLOCK END IF HS % nStripe = 0_kIndex SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE XX3_Initialize_wSecret !****************************************************************************** FUNCTION XX3_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF IF ( Length > 240 ) THEN ASSOCIATE ( Input => HS % BufArr , Acc => HS % State , Secret => HS % Secret ) IF ( ASSOCIATED ( HS % Secret )) THEN CALL XX3Hash_Len241Up_Custom ( Acc , Input , Remaining , Length , Secret , HashCode ) ELSE CALL XX3Hash_Len241Up_Base ( Acc , Input , Remaining , Length , & XXH3_Secret_Long1 , XXH3_Secret_Long4 , & XXH3_Secret_Long5 , XXH3_Secret_Long6 , HashCode ) END IF END ASSOCIATE ELSE ASSOCIATE ( Input => HS % BufArr , Seed => HS % Seed ) IF ( Length <= 16 ) THEN HashCode = XX3Hash64_Len1To16 ( Input , Seed , Length , XXH3_Secret_Integer , & XXH3_Secret_Long1 ) ELSEIF ( Length <= 128 ) THEN HashCode = XX3Hash64_Len17To128 ( Input , Seed , Length , XXH3_Secret_Long1 ) ELSEIF ( Length <= 240 ) THEN HashCode = XX3Hash64_Len129To240 ( Input , Seed , Length , XXH3_Secret_Long1 , & XXH3_Secret_Long2 , XXH3_Secret_Long3 ) END IF END ASSOCIATE END IF ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % Seed = 0_kInt64 HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % nStripe = 0_kIndex HS % RemoveSign = FalseVal CALL HS % Reset () NULLIFY ( HS % Secret ) RETURN CONTAINS FUNCTION XX3Hash64_Len1To16 ( Input , Seed , Length , IntSecret , & LongSecret ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash64 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt32 , INTENT ( IN ) :: IntSecret ( 0 : 3 ) ! base secret in integers tUInt64 , INTENT ( IN ) :: LongSecret ( 0 : 23 ) ! base secret in longs tUInt64 :: HashCode ! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: BitFlip1 , BitFlip2 , Input_Lo , Input_Hi , Acc tUInt64 :: S , Input1 , Input2 , BitFlip , Keyed tUInt32 :: C1 , C2 , C3 tUInt64 :: Combined ! variables used to quickly access input and secret bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) tUInt8 :: Bytes ( 0 : 7 ) tUInt32 :: I32Val ( 2 ) EQUIVALENCE ( Bytes , I32Val ) !** FLOW ! XXH3_Len_0to16_64b IF ( Length > 8 ) THEN ! XXH3_Len_9to16_64b BitFlip1 = IEOR ( LongSecret ( 3 ), LongSecret ( 4 )) + Seed BitFlip2 = IEOR ( LongSecret ( 5 ), LongSecret ( 6 )) - Seed InpBytes ( 0 : 7 ) = Input ( 0 : 7 ) InpBytes ( 8 : 15 ) = Input ( Length - 8 : Length - 1 ) Input_Lo = IEOR ( InpLongs ( 1 ), BitFlip1 ) Input_Hi = IEOR ( InpLongs ( 2 ), BitFlip2 ) Acc = ToInt64 ( Length ) + LongReverseBytes ( Input_Lo ) + Input_Hi + & UnsignedLongMultiplyorFold ( Input_Lo , Input_Hi ) HashCode = XXH3_Avalanche ( Acc ) RETURN END IF IF ( Length >= 4 ) THEN ! XXH3_Len_4to8_64b S = IEOR ( Seed , LongReverseBytes ( IAND ( Seed , MaxU32 ))) Bytes ( 0 : 3 ) = Input ( 0 : 3 ) Bytes ( 4 : 7 ) = Input ( Length - 4 : Length - 1 ) Input1 = ToInt64 ( I32Val ( 1 )) ! high int will be shifted Input2 = MaskI32 ( I32Val ( 2 )) BitFlip = IEOR ( LongSecret ( 1 ), LongSecret ( 2 )) - S Keyed = IEOR (( Input2 + SHIFTL ( Input1 , 32 )), BitFlip ) HashCode = XXH3_RRMxMx ( Keyed , Length ) RETURN END IF IF ( Length /= 0 ) THEN ! XXH3_Len_1to3_64b C1 = MaskI8 ( Input ( 0 )) C2 = ToInt32 ( Input ( SHIFTA ( Length , 1 ))) ! high 3 bytes will be shifted C3 = MaskI8 ( Input ( Length - 1 )) Combined = UnsignedInt ( ToInt32 ( IOR ( ToIndex ( IOR ( IOR ( SHIFTL ( C1 , 16 ), SHIFTL ( C2 , 24 )), C3 )), \\ SHIFTL ( Length , 8 )))) BitFlip = UnsignedInt ( IEOR ( IntSecret ( 0 ), IntSecret ( 1 ))) + Seed HashCode = IEOR ( Combined , BitFlip ) HashCode = XXH64_Avalanche ( HashCode ) RETURN END IF HashCode = IEOR ( IEOR ( Seed , LongSecret ( 7 )), LongSecret ( 8 )) HashCode = XXH64_Avalanche ( HashCode ) RETURN END FUNCTION XX3Hash64_Len1To16 !*************************************************************************** FUNCTION XX3Hash64_Len17To128 ( Input , Seed , Length , LongSecret ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash64 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt64 , INTENT ( IN ) :: LongSecret ( 0 : 23 ) ! base secret tUInt64 :: HashCode ! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Acc ! variables used to quickly access input and secret bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) !** FLOW ! XXH3_Len_17to128_64b Acc = ToInt64 ( Length ) * XXH_PRIME64_1 IF ( Length > 32 ) THEN IF ( Length > 64 ) THEN IF ( Length > 96 ) THEN InpBytes ( 0 : 63 ) = Input ( 0 : 63 ) InpBytes ( 64 : 127 ) = Input ( Length - 64 : Length - 1 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 7 , LongSecret , 12 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 9 , LongSecret , 14 ) ELSE InpBytes ( 0 : 47 ) = Input ( 0 : 47 ) InpBytes ( 80 : 127 ) = Input ( Length - 48 : Length - 1 ) END IF Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 5 , LongSecret , 8 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 11 , LongSecret , 10 ) ELSE InpBytes ( 0 : 31 ) = Input ( 0 : 31 ) InpBytes ( 96 : 127 ) = Input ( Length - 32 : Length - 1 ) END IF Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 3 , LongSecret , 4 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 13 , LongSecret , 6 ) ELSE InpBytes ( 0 : 15 ) = Input ( 0 : 15 ) InpBytes ( 112 : 127 ) = Input ( Length - 16 : Length - 1 ) END IF Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 1 , LongSecret , 0 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 15 , LongSecret , 2 ) HashCode = XXH3_Avalanche ( Acc ) RETURN END FUNCTION XX3Hash64_Len17To128 !*************************************************************************** FUNCTION XX3Hash64_Len129To240 ( Input , Seed , Length , LongSecret1 , & LongSecret2 , LongSecret3 ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash64 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt64 , INTENT ( IN ) :: LongSecret1 ( 0 : 23 ) ! base secret tUInt64 , INTENT ( IN ) :: LongSecret2 ( 0 : 13 ) ! base secret tUInt64 , INTENT ( IN ) :: LongSecret3 ( 0 : 3 ) ! base secret tUInt64 :: HashCode ! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Acc tIndex :: NbRounds , I ! variables used to quickly access input and secret bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) !** FLOW ! XXH3_Len_129to240_64b Acc = ToInt64 ( Length ) * XXH_PRIME64_1 NbRounds = Length / 16 I = 0 InpBytes ( 0 : 127 ) = Input ( 0 : 127 ) DO WHILE ( I < 8 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 2 * I + 1 , LongSecret1 , 2 * I ) I = I + 1 END DO Acc = XXH3_Avalanche ( Acc ) InpBytes ( 0 :( NbRounds * 2 - 16 ) * 8 - 1 ) = Input ( 128 : 128 + ( NbRounds * 2 - 16 ) * 8 - 1 ) DO WHILE ( I < NbRounds ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 2 * ( I - 8 ) + 1 , LongSecret2 , 2 * ( I - 8 )) I = I + 1 END DO ! last bytes InpBytes ( 0 : 15 ) = Input ( Length - 16 : Length - 1 ) Acc = Acc + XXH3_Mix16B ( Seed , InpLongs , 1 , LongSecret3 , 2 ) HashCode = XXH3_Avalanche ( Acc ) RETURN END FUNCTION XX3Hash64_Len129To240 !****************************************************************************** END FUNCTION XX3_Finalize !****************************************************************************** FUNCTION XX3_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION XX3_HashDirect !****************************************************************************** FUNCTION XX3_HashDirect_wSecret ( HS , Input , InpSize , Seed , Secret , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , INTENT ( IN ) :: Seed !! seed tUInt8 , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following code illustrates simple use of the hasher. CALL HS % InitializeWSecret ( Seed , Secret , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION XX3_HashDirect_wSecret !****************************************************************************** FUNCTION XX3_GetName128 ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'XX3_Hahser128' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION XX3_GetName128 !****************************************************************************** FUNCTION XX3_Finalize64 ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 64-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL XX3_Finalize_Hash128 ( HS , HashCode ) RETURN END FUNCTION XX3_Finalize64 !****************************************************************************** FUNCTION XX3_Finalize128 ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 128-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL XX3_Finalize_Hash128 ( HS , HashCode % Low , HashCode % High ) RETURN END FUNCTION XX3_Finalize128 !****************************************************************************** SUBROUTINE XX3_Finalize_Hash128 ( HS , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 128-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( OUT ) :: HashLo !! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi !! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , Remaining !** FLOW Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF IF ( Length > 240 ) THEN ASSOCIATE ( Input => HS % BufArr , Acc => HS % State , Secret => HS % Secret ) IF ( ASSOCIATED ( HS % Secret )) THEN CALL XX3Hash_Len241Up_Custom ( Acc , Input , Remaining , Length , Secret , HashLo , HashHi ) ELSE CALL XX3Hash_Len241Up_Base ( Acc , Input , Remaining , Length , & XXH3_Secret_Long1 , XXH3_Secret_Long4 , & XXH3_Secret_Long5 , XXH3_Secret_Long6 , & HashLo , HashHi ) END IF END ASSOCIATE ELSE ASSOCIATE ( Input => HS % BufArr , Seed => HS % Seed ) IF ( Length <= 16 ) THEN CALL XX3Hash128_Len1To16 ( Input , Seed , Length , XXH3_Secret_Integer , & XXH3_Secret_Long1 , HashLo , HashHi ) ELSEIF ( Length <= 128 ) THEN CALL XX3Hash128_Len17To128 ( Input , Seed , Length , XXH3_Secret_Long1 , & HashLo , HashHi ) ELSEIF ( Length <= 240 ) THEN CALL XX3Hash128_Len129To240 ( Input , Seed , Length , XXH3_Secret_Long1 , & XXH3_Secret_Long2 , XXH3_Secret_Long3 , & HashLo , HashHi ) END IF END ASSOCIATE END IF ! remove sign if needed IF ( HS % RemoveSign ) HashHi = IAND ( HashHi , ToInt64 ( Z '7FFFFFFFFFFFFFFF' )) ! reset the hasher HS % Seed = 0_kInt64 HS % State = 0_kInt64 HS % BufArr = 0_kInt8 HS % nStripe = 0_kIndex HS % RemoveSign = FalseVal CALL HS % Reset () NULLIFY ( HS % Secret ) RETURN CONTAINS SUBROUTINE XX3Hash128_Len1To16 ( Input , Seed , Length , IntSecret , LongSecret , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash128 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt32 , INTENT ( IN ) :: IntSecret ( 0 : 3 ) ! base secret in integers tUInt64 , INTENT ( IN ) :: LongSecret ( 0 : 23 ) ! base secret in longs tUInt64 , INTENT ( OUT ) :: HashLo ! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi ! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: BitFlipL , BitFlipH , Input_Lo , Input_Hi tUInt64 :: S , PL , Bitflip , Keyed , M128_Lo , M128_Hi tUInt32 :: C1 , C2 , C3 , CombinedL , CombinedH ! variables used to quickly access input bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) tUInt8 :: Bytes ( 0 : 7 ) tUInt32 :: I32Val ( 1 : 2 ) EQUIVALENCE ( Bytes , I32Val ) !** FLOW ! perform hashing ! XXH3_len_0to16_128b IF ( Length > 8 ) THEN ! XXH3_len_9to16_128b BitflipL = IEOR ( LongSecret ( 4 ), LongSecret ( 5 )) - Seed BitflipH = IEOR ( LongSecret ( 6 ), LongSecret ( 7 )) + Seed InpBytes ( 0 : 7 ) = Input ( Length - 8 : Length - 1 ) InpBytes ( 8 : 15 ) = Input ( 0 : 7 ) Input_Hi = InpLongs ( 1 ) Input_Lo = IEOR ( IEOR ( InpLongs ( 2 ), Input_Hi ), BitflipL ) M128_Lo = Input_Lo * XXH_PRIME64_1 M128_Hi = UnsignedLongMultiplyHigh ( Input_Lo , XXH_PRIME64_1 ) M128_Lo = M128_Lo + SHIFTL ( ToInt64 ( Length - 1 ), 54 ) Input_Hi = IEOR ( Input_Hi , BitflipH ) M128_Hi = M128_Hi + Input_Hi + & UnsignedInt ( ToInt32 ( Input_Hi )) * ( XXH_PRIME32_2 - 1_kInt64 ) M128_Lo = IEOR ( M128_Lo , LongReverseBytes ( M128_Hi )) HashLo = XXH3_Avalanche ( M128_Lo * XXH_PRIME64_2 ) IF ( PRESENT ( HashHi )) THEN HashHi = XXH3_Avalanche ( UnsignedLongMultiplyHigh ( M128_Lo , XXH_PRIME64_2 ) & + M128_Hi * XXH_PRIME64_2 ) END IF RETURN END IF IF ( Length >= 4 ) THEN ! XXH3_len_4to8_128b S = IEOR ( Seed , LongReverseBytes ( IAND ( Seed , MaxU32 ))) ! high int will be shifted Bytes ( 0 : 3 ) = Input ( 0 : 3 ) Bytes ( 4 : 7 ) = Input ( Length - 4 : Length - 1 ) Input_Lo = MaskI32 ( I32Val ( 1 )) Input_Hi = ToInt64 ( I32Val ( 2 )) Bitflip = IEOR ( LongSecret ( 2 ), LongSecret ( 3 )) + S Keyed = IEOR ( Input_Lo + SHIFTL ( Input_Hi , 32 ), Bitflip ) ! Shift len to the left to ensure it is even, this avoids even multiplies. PL = XXH_PRIME64_1 + ToInt64 ( SHIFTL ( Length , 2 )) M128_Lo = Keyed * PL M128_Hi = UnsignedLongMultiplyHigh ( Keyed , PL ) M128_Hi = M128_Hi + SHIFTL ( M128_Lo , 1 ) M128_Lo = IEOR ( M128_Lo , SHIFTR ( M128_Hi , 3 )) M128_Lo = IEOR ( M128_Lo , SHIFTR ( M128_Lo , 35 )) M128_Lo = M128_Lo * ToInt64 ( Z '9FB21C651E98DF25' ) M128_Lo = IEOR ( M128_Lo , SHIFTR ( M128_Lo , 28 )) HashLo = M128_Lo IF ( PRESENT ( HashHi )) HashHi = XXH3_Avalanche ( M128_Hi ) RETURN END IF IF ( Length /= 0 ) THEN ! XXH3_len_1to3_128b C1 = MaskI8 ( Input ( 0 )) ! high 3 bytes will be shifted C2 = ToInt32 ( Input ( 0 + SHIFTA ( Length , 1 ))) C3 = MaskI8 ( Input ( 0 + Length - 1 )) CombinedL = ToInt32 ( IOR ( ToIndex ( IOR ( IOR ( SHIFTL ( C1 , 16 ), SHIFTL ( C2 , 24 )), C3 )), SHIFTL ( Length , 8 ))) CombinedH = RotateLeft ( IntegerReverseBytes ( CombinedL ), 13 ) BitFlipL = UnsignedInt ( IEOR ( IntSecret ( 0 ), IntSecret ( 1 ))) + Seed BitFlipH = UnsignedInt ( IEOR ( IntSecret ( 2 ), IntSecret ( 3 ))) - Seed HashLo = IEOR ( UnsignedInt ( CombinedL ), BitFlipL ) HashLo = XXH64_Avalanche ( HashLo ) IF ( PRESENT ( HashHi )) THEN HashHi = IEOR ( UnsignedInt ( CombinedH ), BitFlipH ) HashHi = XXH64_Avalanche ( HashHi ) END IF RETURN END IF HashLo = XXH64_Avalanche ( IEOR ( IEOR ( Seed , LongSecret ( 8 )), LongSecret ( 9 ))) IF ( PRESENT ( HashHi )) THEN HashHi = XXH64_Avalanche ( IEOR ( IEOR ( Seed , LongSecret ( 10 )), LongSecret ( 11 ))) END IF RETURN END SUBROUTINE XX3Hash128_Len1To16 !************************************************************************** SUBROUTINE XX3Hash128_Len17To128 ( Input , Seed , Length , LongSecret , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash128 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt64 , INTENT ( IN ) :: LongSecret ( 0 : 23 ) ! base secret in longs tUInt64 , INTENT ( OUT ) :: HashLo ! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi ! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Acc0 , Acc1 , Input0 , Input1 , Input2 , Input3 ! variables used to quickly access input and secret bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) !** FLOW ! perform hashing ! XXH3_len_17to128_128b Acc0 = ToInt64 ( Length ) * XXH_PRIME64_1 Acc1 = 0 IF ( Length > 32 ) THEN IF ( Length > 64 ) THEN IF ( Length > 96 ) THEN InpBytes ( 0 : 63 ) = Input ( 0 : 63 ) InpBytes ( 64 : 127 ) = Input ( Length - 64 : Length - 1 ) Input0 = InpLongs ( 7 ) Input1 = InpLongs ( 8 ) Input2 = InpLongs ( 9 ) Input3 = InpLongs ( 10 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret , 12 , Acc0 , \\ Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret , 14 , Acc1 , \\ Input2 , Input3 , Input0 , Input1 ) ELSE InpBytes ( 0 : 47 ) = Input ( 0 : 47 ) InpBytes ( 80 : 127 ) = Input ( Length - 48 : Length - 1 ) END IF Input0 = InpLongs ( 5 ) Input1 = InpLongs ( 6 ) Input2 = InpLongs ( 11 ) Input3 = InpLongs ( 12 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret , 8 , Acc0 , \\ Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret , 10 , Acc1 , \\ Input2 , Input3 , Input0 , Input1 ) ELSE InpBytes ( 0 : 31 ) = Input ( 0 : 31 ) InpBytes ( 96 : 127 ) = Input ( Length - 32 : Length - 1 ) END IF Input0 = InpLongs ( 3 ) Input1 = InpLongs ( 4 ) Input2 = InpLongs ( 13 ) Input3 = InpLongs ( 14 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret , 4 , Acc0 , Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret , 6 , Acc1 , Input2 , Input3 , Input0 , Input1 ) ELSE InpBytes ( 0 : 15 ) = Input ( 0 : 15 ) InpBytes ( 112 : 127 ) = Input ( Length - 16 : Length - 1 ) END IF Input0 = InpLongs ( 1 ) Input1 = InpLongs ( 2 ) Input2 = InpLongs ( 15 ) Input3 = InpLongs ( 16 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret , 0 , Acc0 , Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret , 2 , Acc1 , Input2 , Input3 , Input0 , Input1 ) HashLo = XXH3_Avalanche ( Acc0 + Acc1 ) IF ( PRESENT ( HashHi )) THEN HashHi = - XXH3_Avalanche ( Acc0 * XXH_PRIME64_1 + Acc1 * XXH_PRIME64_4 & + ( ToInt64 ( Length ) - Seed ) * XXH_PRIME64_2 ) END IF RETURN END SUBROUTINE XX3Hash128_Len17To128 !************************************************************************** SUBROUTINE XX3Hash128_Len129To240 ( Input , Seed , Length , LongSecret1 , LongSecret2 , & LongSecret3 , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash128 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tUInt64 , INTENT ( IN ) :: Seed ! seed tIndex , INTENT ( IN ) :: Length ! length of input bytes tUInt64 , INTENT ( IN ) :: LongSecret1 ( 0 : 23 ) ! base secret tUInt64 , INTENT ( IN ) :: LongSecret2 ( 0 : 13 ) ! base secret tUInt64 , INTENT ( IN ) :: LongSecret3 ( 0 : 3 ) ! base secret tUInt64 , INTENT ( OUT ) :: HashLo ! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi ! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Offset tUInt64 :: Acc0 , Acc1 , Input0 , Input1 , Input2 , Input3 tIndex :: I tUInt32 :: NbRounds ! variables used to quickly access input and secret bytes tUInt8 :: InpBytes ( 0 : 127 ) tUInt64 :: InpLongs ( 1 : 16 ) EQUIVALENCE ( InpBytes , InpLongs ) !** FLOW ! initialize Offset = 0 ! XXH3_len_129to240_128b NbRounds = Length / 32 Acc0 = ToInt64 ( Length ) * XXH_PRIME64_1 Acc1 = 0_kInt64 I = 0 InpBytes ( 0 : 127 ) = Input ( Offset : Offset + 127 ) DO WHILE ( I < 4 ) Input0 = InpLongs ( 4 * I + 1 ) Input1 = InpLongs ( 4 * I + 2 ) Input2 = InpLongs ( 4 * I + 3 ) Input3 = InpLongs ( 4 * I + 4 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret1 , 4 * I , Acc0 , \\ Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret1 , 4 * I + 2 , Acc1 , \\ Input2 , Input3 , Input0 , Input1 ) I = I + 1 END DO Acc0 = XXH3_Avalanche ( Acc0 ) Acc1 = XXH3_Avalanche ( Acc1 ) Offset = Offset + 128 InpBytes ( 0 :( NbRounds * 4 - 16 ) * 8 - 1 ) = Input ( Offset : Offset + ( NbRounds * 4 - 16 ) * 8 - 1 ) DO WHILE ( I < NbRounds ) Input0 = InpLongs ( 4 * ( I - 4 ) + 1 ) Input1 = InpLongs ( 4 * ( I - 4 ) + 2 ) Input2 = InpLongs ( 4 * ( I - 4 ) + 3 ) Input3 = InpLongs ( 4 * ( I - 4 ) + 4 ) Acc0 = XXH128_Mix32B_Once ( Seed , LongSecret2 , 4 * ( I - 4 ), Acc0 , \\ Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once ( Seed , LongSecret2 , 4 * ( I - 4 ) + 2 , Acc1 , \\ Input2 , Input3 , Input0 , Input1 ) I = I + 1 END DO ! last bytes Offset = Offset - 128 InpBytes ( 0 : 31 ) = Input ( Offset + Length - 32 : Length - 1 ) Input0 = InpLongs ( 3 ) Input1 = InpLongs ( 4 ) Input2 = InpLongs ( 1 ) Input3 = InpLongs ( 2 ) Acc0 = XXH128_Mix32B_Once (( - Seed ), LongSecret3 , 0 , Acc0 , Input0 , Input1 , Input2 , Input3 ) Acc1 = XXH128_Mix32B_Once (( - Seed ), LongSecret3 , 2 , Acc1 , Input2 , Input3 , Input0 , Input1 ) HashLo = XXH3_Avalanche ( Acc0 + Acc1 ) IF ( PRESENT ( HashHi )) THEN HashHi = - XXH3_Avalanche ( Acc0 * XXH_PRIME64_1 + Acc1 * XXH_PRIME64_4 & + ( ToInt64 ( Length ) - Seed ) * XXH_PRIME64_2 ) END IF RETURN END SUBROUTINE XX3Hash128_Len129To240 !************************************************************************** END SUBROUTINE XX3_Finalize_Hash128 !****************************************************************************** FUNCTION XX3_HashDirect128 ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) without seed or with one seed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt64 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize128 () RETURN END FUNCTION XX3_HashDirect128 !****************************************************************************** FUNCTION XX3_HashDirect128_wSecret ( HS , Input , InpSize , Seed , Secret , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental) with seed and secret. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( XX3Hasher128 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , INTENT ( IN ) :: Seed !! seed tUInt8 , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tSInt128 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The following code illustrates simple use of the hasher. CALL HS % InitializeWSecret ( Seed , Secret , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize128 () RETURN END FUNCTION XX3_HashDirect128_wSecret !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                                                                             + !                   SUPPORTING ROUTINES FOR XXHASH ALGORITHMS                 + !                                                                             + !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION XXH64_Avalanche ( H64 ) RESULT ( Res ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: H64 tUInt64 :: Res !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Res = IEOR ( H64 , SHIFTR ( H64 , 33 )) * XXH_PRIME64_2 Res = IEOR ( Res , SHIFTR ( Res , 29 )) * XXH_PRIME64_3 Res = IEOR ( Res , SHIFTR ( Res , 32 )) RETURN END FUNCTION XXH64_Avalanche !****************************************************************************** FUNCTION XXH3_Avalanche ( H64 ) RESULT ( Res ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: H64 tUInt64 :: Res !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Res = IEOR ( H64 , SHIFTR ( H64 , 37 )) * ToInt64 ( Z '165667919E3779F9' ) Res = IEOR ( Res , SHIFTR ( Res , 32 )) RETURN END FUNCTION XXH3_Avalanche !****************************************************************************** FUNCTION XXH3_RRMxMx ( H64 , Length ) RESULT ( Res ) !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: H64 tIndex , INTENT ( IN ) :: Length tUInt64 :: Res !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Res = IEOR ( H64 , IEOR ( RotateLeft ( H64 , 49 ), RotateLeft ( H64 , 24 ))) * ToInt64 ( Z '9FB21C651E98DF25' ) Res = IEOR ( Res , SHIFTR ( Res , 35 ) + ToInt64 ( Length )) * ToInt64 ( Z '9FB21C651E98DF25' ) Res = IEOR ( Res , SHIFTR ( Res , 28 )) RETURN END FUNCTION XXH3_RRMxMx !****************************************************************************** FUNCTION UnsignedLongMultiplyorFold ( LHS , RHS ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply or fold. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 :: Res !** SUBROUTINE PARAMETER DECLARATIONS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = IAND ( LHS , MaxU32 ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = IAND ( RHS , MaxU32 ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaxU32 ) + LHS_Lo * RHS_Hi Res = IEOR ( IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaxU32 )), & SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi ) RETURN END FUNCTION UnsignedLongMultiplyorFold !****************************************************************************** SUBROUTINE XX3Hash_Len241Up_Base ( Acc , Input , Remaining , Length , Secret1 , Secret2 , & Secret3 , Secret4 , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash64 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( INOUT ) :: Acc ( 0 : 7 ) ! state tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tIndex , INTENT ( IN ) :: Remaining ! remaining length of input bytes tIndex , INTENT ( IN ) :: Length ! total length of input bytes tUInt64 , INTENT ( IN ) :: Secret1 ( 0 : 23 ) ! base secret tUInt64 , INTENT ( IN ) :: Secret2 ( 0 : 7 ) ! base secret tUInt64 , INTENT ( IN ) :: Secret3 ( 0 : 7 ) ! base secret tUInt64 , INTENT ( IN ) :: Secret4 ( 0 : 7 ) ! base secret tUInt64 , INTENT ( OUT ) :: HashLo ! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi ! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: OffStripe , OffSec , NbStripes tIndex :: J tUInt64 :: DataVal0 , DataVal1 , DataKey0 , DataKey1 tUInt8 :: InpBytes ( 0 : 63 ) tUInt64 :: InpLongs ( 1 : 8 ) EQUIVALENCE ( InpBytes , InpLongs ) !** FLOW ! last partial block NbStripes = ( Remaining - 1 ) / 64_kIndex OffStripe = 0_kIndex DO OffSec = 0 , NbStripes - 1 ! XXH3_accumulate_512 InpBytes ( 0 : 63 ) = Input ( OffStripe : OffStripe + 63 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , Secret1 ( Offsec + J )) DataKey1 = IEOR ( DataVal1 , Secret1 ( Offsec + J + 1 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO OffStripe = OffStripe + 64_kIndex END DO ! last stripe ! XXH3_accumulate_512 OffStripe = Remaining - 64 InpBytes ( 0 : 63 ) = Input ( OffStripe : OffStripe + 63 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , Secret2 ( J )) DataKey1 = IEOR ( DataVal1 , Secret2 ( J + 1 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO ! XXH3_mergeAccs HashLo = ToInt64 ( Length ) * XXH_PRIME64_1 & + XXH3_Mix2Accs ( Acc ( 0 ), Acc ( 1 ), Secret3 , 0 ) & + XXH3_Mix2Accs ( Acc ( 2 ), Acc ( 3 ), Secret3 , 2 ) & + XXH3_Mix2Accs ( Acc ( 4 ), Acc ( 5 ), Secret3 , 4 ) & + XXH3_Mix2Accs ( Acc ( 6 ), Acc ( 7 ), Secret3 , 6 ) HashLo = XXH3_Avalanche ( HashLo ) IF ( PRESENT ( HashHi )) THEN HashHi = NOT ( ToInt64 ( Length ) * XXH_PRIME64_2 ) & + XXH3_Mix2Accs ( Acc ( 0 ), Acc ( 1 ), Secret4 , 0 ) & + XXH3_Mix2Accs ( Acc ( 2 ), Acc ( 3 ), Secret4 , 2 ) & + XXH3_Mix2Accs ( Acc ( 4 ), Acc ( 5 ), Secret4 , 4 ) & + XXH3_Mix2Accs ( Acc ( 6 ), Acc ( 7 ), Secret4 , 6 ) HashHi = XXH3_Avalanche ( HashHi ) END IF RETURN END SUBROUTINE XX3Hash_Len241Up_Base !****************************************************************************** SUBROUTINE XX3Hash_Len241Up_Custom ( Acc , Input , Remaining , Length , Secret , HashLo , HashHi ) !** PURPOSE OF THIS SUBROUTINE: ! To compute hash code using the XX3Hash64 hash algorithm by Yann Collet. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( INOUT ) :: Acc ( 0 : 7 ) ! state tUInt8 , INTENT ( IN ) :: Input ( 0 :) ! input bytes tIndex , INTENT ( IN ) :: Remaining ! remaining length of input bytes tIndex , INTENT ( IN ) :: Length ! total length of input bytes tUInt8 , INTENT ( IN ) :: Secret ( 0 : 191 ) ! custom secret tUInt64 , INTENT ( OUT ) :: HashLo ! lower 64-bit hash code tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashHi ! upper 64-bit hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: OffStripe , OffSec , NbStripes tIndex :: S , J tUInt64 :: DataVal0 , DataVal1 , DataKey0 , DataKey1 tUInt8 :: InpBytes ( 0 : 63 ) tUInt64 :: InpLongs ( 1 : 8 ) EQUIVALENCE ( InpBytes , InpLongs ) tUInt8 :: SecBytes ( 0 : 127 ) tUInt64 :: SecLongs ( 1 : 16 ) EQUIVALENCE ( SecBytes , SecLongs ) !** FLOW ! last partial block NbStripes = ( Remaining - 1 ) / 64_kIndex OffStripe = 0_kIndex OffSec = 0_kIndex DO S = 0 , NbStripes - 1 ! XXH3_accumulate_512 InpBytes ( 0 : 63 ) = Input ( OffStripe : OffStripe + 63 ) SecBytes ( 0 : 63 ) = Secret ( OffSec : OffSec + 63 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , SecLongs ( J + 1 )) DataKey1 = IEOR ( DataVal1 , SecLongs ( J + 2 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO OffStripe = OffStripe + 64_kIndex OffSec = OffSec + 8_kIndex END DO ! last stripe ! XXH3_accumulate_512 OffStripe = Remaining - 64 OffSec = 121 ! 192 - 64 - 7 InpBytes ( 0 : 63 ) = Input ( OffStripe : OffStripe + 63 ) SecBytes ( 0 : 63 ) = Secret ( 121 : 184 ) DO J = 0 , 7 , 2 DataVal0 = InpLongs ( J + 1 ) DataVal1 = InpLongs ( J + 2 ) DataKey0 = IEOR ( DataVal0 , SecLongs ( J + 1 )) DataKey1 = IEOR ( DataVal1 , SecLongs ( J + 2 )) ! swap adjacent lanes Acc ( J ) = Acc ( J ) + DataVal1 + IAND ( MaxU32 , DataKey0 ) * SHIFTR ( DataKey0 , 32 ) Acc ( J + 1 ) = Acc ( J + 1 ) + DataVal0 + IAND ( MaxU32 , DataKey1 ) * SHIFTR ( DataKey1 , 32 ) END DO ! XXH3_mergeAccs SecBytes ( 0 : 63 ) = Secret ( 11 : 74 ) HashLo = ToInt64 ( Length ) * XXH_PRIME64_1 & + XXH3_Mix2Accs ( Acc ( 0 ), Acc ( 1 ), SecLongs , 1 ) & + XXH3_Mix2Accs ( Acc ( 2 ), Acc ( 3 ), SecLongs , 3 ) & + XXH3_Mix2Accs ( Acc ( 4 ), Acc ( 5 ), SecLongs , 5 ) & + XXH3_Mix2Accs ( Acc ( 6 ), Acc ( 7 ), SecLongs , 7 ) HashLo = XXH3_Avalanche ( HashLo ) IF ( PRESENT ( HashHi )) THEN SecBytes ( 0 : 63 ) = Secret ( 117 : 180 ) HashHi = NOT ( ToInt64 ( Length ) * XXH_PRIME64_2 ) & + XXH3_Mix2Accs ( Acc ( 0 ), Acc ( 1 ), SecLongs , 1 ) & + XXH3_Mix2Accs ( Acc ( 2 ), Acc ( 3 ), SecLongs , 3 ) & + XXH3_Mix2Accs ( Acc ( 4 ), Acc ( 5 ), SecLongs , 5 ) & + XXH3_Mix2Accs ( Acc ( 6 ), Acc ( 7 ), SecLongs , 7 ) HashHi = XXH3_Avalanche ( HashHi ) END IF RETURN END SUBROUTINE XX3Hash_Len241Up_Custom !****************************************************************************** END MODULE MClass_XX3Hasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_xx3hasher64.f90.html"},{"title":"MBase_ReferenceHash32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_ReferenceHash32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains a reference implementation of various non-cryptographic !   hash function routines that output a hash value as a 32-bit integer.  The API !   of these hash function routines are mostly similar to that of routines in the !   <a href=\"../../xpfbase/module/mbase_simplehash32.html\">ModBase_SimpleHash32</a> !   module.  The main difference between routines in these two modules is that routines !   in the *ModBase_SimpleHash32* module process input data one byte at a time whereas !   routines in this module commonly process input data several/many bytes at a time. !   Also, routines in this module are somewhat more complicated than those in the !   *ModBase_SimpleHash32* module. <br> !   Similar to those routines in the *ModBase_SimpleHash32* module, all routines can !   be used for an input (i.e. a key) of any type and rank providing that the size of !   the input (in bytes) is known at compile time.  All routines can be used for a !   continued hashing by providing the previously computed hash value as an (optional) !   input argument (i.e. the *StartHash* argument).  Optionally, a user can specify !   whether to return only positive value of the hash code.  This is particularly !   useful when used in conjunction with a hash table. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/aappleby/smhasher\">SMHasher: a test suite designed to !       test the distribution, collision, and performance properties of non-cryptographic !       hash functions. </a> <br> !   [2] <a href=\"https://burtleburtle.net/bob/c/lookup3.c\">Lookup 3 Hash Function: C Code. </a> <br> !   [3] <a href=\"https://github.com/google/cityhash\">CityHash: a family of hash functions !       for strings. </a> <br> !   [4] <a href=\"https://github.com/google/farmhash\">FarmHash: a family of hash functions. </a> <br> !   [5] <a href=\"http://www.azillionmonkeys.com/qed/hash.html\">Hash functions by Paul Hsieh. </a> <br> !   [6] <a href=\"https://github.com/fortran-lang/stdlib\">Fortran Standard Library. </a> <br> !   [7] <a href=\"https://github.com/gzm55/hash-garage\">NMHash32 Hash Functions. </a> <br> !   [8] <a href=\"https://github.com/Cyan4973/xxHash\">xxHash: Extremely fast hash algorithm. </a> <br> !   [9] <a href=\"https://github.com/tildeleb/hashland\">HashLand: a collection of hash !       functions in Go. </a> <br> !   [10] <a href=\"https://github.com/rurban/fast-hash/tree/master\">FastHash by Zilong Tan. </a> <br> !   [11] <a href=\"https://github.com/tommyettinger/waterhash\">WaterHash: A variant of WyHash. </a> <br> !   [12] <a href=\"https://github.com/veorq/SipHash\">SipHash: high-speed secure pseudorandom !       function for short messages. </a> <br> !** USE STATEMENTS: USE MBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: CityHash_I32 PUBLIC :: CrapWowHash_I32 PUBLIC :: FarmMkHash_I32 PUBLIC :: FarmMkHash_I32_Recur PUBLIC :: FastHash_I32 PUBLIC :: HalfSipHash24_I32 PUBLIC :: HalfSipHash_I32 PUBLIC :: Lookup3Hash_I32 PUBLIC :: Murmur3Hash_I32 PUBLIC :: NMHash_V1_I32 PUBLIC :: NMxHash_V1_I32 PUBLIC :: NMHash_V2_I32 PUBLIC :: NMxHash_V2_I32 PUBLIC :: SuperFastHash_I32 PUBLIC :: WaterHash_I32 PUBLIC :: WaterHash_I32_New PUBLIC :: XXHash_I32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_ReferenceHash32' ! The maximum (positive) number of hash code tUInt32 , PARAMETER :: MaxHash = ToInt32 ( Z '7FFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: INTERFACE !---------------------------------------------------------------------- MODULE FUNCTION Lookup3Hash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the Lookup3 hash algorithm by Bob Jenkins [2]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION Lookup3Hash_I32 !---------------------------------------------------------------------- MODULE FUNCTION Murmur3Hash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the Murmur3 hash algorithm by Austin Appleby [1]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION Murmur3Hash_I32 !---------------------------------------------------------------------- MODULE FUNCTION CityHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the City hash algorithm by Google Inc [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION CityHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION FarmMkHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. <br> !  *Note*: The working routine of this procedure is a non-recursive one. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION FarmMkHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION FarmMkHash_I32_Recur ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the FarmMk hash algorithm by Google Inc [4]. <br> !  *Note*: The working routine of this procedure is a recursive one. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION FarmMkHash_I32_Recur !---------------------------------------------------------------------- MODULE FUNCTION SuperFastHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the SuperFast hash algorithm by Paul !  Hsieh [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION SuperFastHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION NMHash_V1_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 1 of the NMHASH hash algorithm !  by James Z. M. Gao [6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION NMHash_V1_I32 !---------------------------------------------------------------------- MODULE FUNCTION NMxHash_V1_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 1 of the NMxHASH hash algorithm by !  James Z. M. Gao [6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION NMxHash_V1_I32 !---------------------------------------------------------------------- MODULE FUNCTION NMHash_V2_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMHASH hash algorithm !  by James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION NMHash_V2_I32 !---------------------------------------------------------------------- MODULE FUNCTION NMxHash_V2_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using version 2 of the NMxHASH hash algorithm by !  James Z. M. Gao [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION NMxHash_V2_I32 !---------------------------------------------------------------------- MODULE FUNCTION XXHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the XXHash hash algorithm by Yann Collet [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION XXHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION CrapWowHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the CrapWow hash algorithm [9]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION CrapWowHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION FastHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the Fast hash algorithm by !  Zilong Tan [10]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION FastHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION WaterHash_I32 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the WaterHash hash algorithm by Tommy !  Ettinger [6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION WaterHash_I32 !---------------------------------------------------------------------- MODULE FUNCTION WaterHash_I32_New ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using a new version of the WaterHash hash !  algorithm by Tommy Ettinger [11]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION WaterHash_I32_New !---------------------------------------------------------------------- MODULE FUNCTION HalfSipHash24_I32 ( Input , InpSize , Key , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute the hash value using the HalfSipHash24 hash algorithm by !  Jean-Philippe Aumasson [12]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , INTENT ( IN ) :: Key (:) !! key (at least 8 bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code END FUNCTION HalfSipHash24_I32 !---------------------------------------------------------------------- MODULE FUNCTION HalfSipHash_I32 ( Input , InpSize , Key , cRound , dRound , & StartHash , RemoveSign , HashLong ) RESULT ( HashCode ) !&#94; To compute the hash value using the HalfSipHash hash algorithm by !  Jean-Philippe Aumasson [12] where the numbers of rounds are specified. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , INTENT ( IN ) :: Key (:) !! key (at least 8 bytes) tIndex , INTENT ( IN ) :: cRound !! number of C rounds tIndex , INTENT ( IN ) :: dRound !! number of D rounds tUInt32 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashLong !! long integer hash code tUInt32 :: HashCode !! hash code END FUNCTION HalfSipHash_I32 !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** END MODULE MBase_ReferenceHash32 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_referencehash32.f90.html"},{"title":"MClass_SIMDB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SIMDB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SIMDB* type and its related routines. !   The *SIMDB* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SIMDB* type implements an incremental cryptographic hash function !   by employing either the *SIMD-384* or the *SIMD-512 message-digest* !   algorithm [1].  The implementation here is based mainly on the *SPHLIB* !   implementation [2].  <br> !   By default, the *SIMDB* type employs the *SIMD-512 message-digest* !   algorithm.  However, a user can specify the *IsSIMD384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SIMD-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://who.rocq.inria.fr/Gaetan.Leurent/simd.html\"> !       The SIMD Hash Function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine USE MClass_SIMDS , ONLY : MaskI8 , MaskI16 , AlphaTab IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SIMDB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: IV384 ( 0 : 31 ) = [ & ToInt32 ( Z '8A36EEBC' ), ToInt32 ( Z '94A3BD90' ), & ToInt32 ( Z 'D1537B83' ), ToInt32 ( Z 'B25B070B' ), & ToInt32 ( Z 'F463F1B5' ), ToInt32 ( Z 'B6F81E20' ), & ToInt32 ( Z '0055C339' ), ToInt32 ( Z 'B4D144D1' ), & ToInt32 ( Z '7360CA61' ), ToInt32 ( Z '18361A03' ), & ToInt32 ( Z '17DCB4B9' ), ToInt32 ( Z '3414C45A' ), & ToInt32 ( Z 'A699A9D2' ), ToInt32 ( Z 'E39E9664' ), & ToInt32 ( Z '468BFE77' ), ToInt32 ( Z '51D062F8' ), & ToInt32 ( Z 'B9E3BFE8' ), ToInt32 ( Z '63BECE2A' ), & ToInt32 ( Z '8FE506B9' ), ToInt32 ( Z 'F8CC4AC2' ), & ToInt32 ( Z '7AE11542' ), ToInt32 ( Z 'B1AADDA1' ), & ToInt32 ( Z '64B06794' ), ToInt32 ( Z '28D2F462' ), & ToInt32 ( Z 'E64071EC' ), ToInt32 ( Z '1DEB91A8' ), & ToInt32 ( Z '8AC8DB23' ), ToInt32 ( Z '3F782AB5' ), & ToInt32 ( Z '039B5CB8' ), ToInt32 ( Z '71DDD962' ), & ToInt32 ( Z 'FADE2CEA' ), ToInt32 ( Z '1416DF71' )] tInteger , PARAMETER :: IV512 ( 0 : 31 ) = [ & ToInt32 ( Z '0BA16B95' ), ToInt32 ( Z '72F999AD' ), & ToInt32 ( Z '9FECC2AE' ), ToInt32 ( Z 'BA3264FC' ), & ToInt32 ( Z '5E894929' ), ToInt32 ( Z '8E9F30E5' ), & ToInt32 ( Z '2F1DAA37' ), ToInt32 ( Z 'F0F2C558' ), & ToInt32 ( Z 'AC506643' ), ToInt32 ( Z 'A90635A5' ), & ToInt32 ( Z 'E25B878B' ), ToInt32 ( Z 'AAB7878F' ), & ToInt32 ( Z '88817F7A' ), ToInt32 ( Z '0A02892B' ), & ToInt32 ( Z '559A7550' ), ToInt32 ( Z '598F657E' ), & ToInt32 ( Z '7EEF60A1' ), ToInt32 ( Z '6B70E3E8' ), & ToInt32 ( Z '9C1714D1' ), ToInt32 ( Z 'B958E2A8' ), & ToInt32 ( Z 'AB02675E' ), ToInt32 ( Z 'ED1C014F' ), & ToInt32 ( Z 'CD8D65BB' ), ToInt32 ( Z 'FDB7A257' ), & ToInt32 ( Z '09254899' ), ToInt32 ( Z 'D699C7BC' ), & ToInt32 ( Z '9019B6DC' ), ToInt32 ( Z '2B9022E4' ), & ToInt32 ( Z '8FA14956' ), ToInt32 ( Z '21BF9BD3' ), & ToInt32 ( Z 'B94D0943' ), ToInt32 ( Z '6FFDDC22' )] !** DERIVED TYPE DEFINITIONS !> *SIMDB* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *SIMD-384* or the *SIMD-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: SIMDB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variable tInteger :: State ( 0 : 31 ) = IV512 ( 0 : 31 ) !% flag indicating whether the SIMD-384 algorithm is employed or not. tLogical :: IsSIMD384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SIMDB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SIMD-512). PROCEDURE :: Initialize => SIMDB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SIMDB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SIMDB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SIMDB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SIMDB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SIMDB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SIMDB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SIMDB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SIMDB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SIMDB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SIMD-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SIMD-384 algorithm <br> !   --->    CALL MD%Create(IsSIMD384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE SIMDB !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SIMDB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SIMD-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SIMDB_Initialize !****************************************************************************** SUBROUTINE SIMDB_Initialize_wFlag ( MD , IsSIMD384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object tLogical , INTENT ( IN ) :: IsSIMD384 !&#94; flag indicating whether the SIMD-384 algorithm is employed or not. <br> !  - If true, use the SIMD-384 algorithm. <br> !  - Otherwise, use the SIMD-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSIMD384 = IsSIMD384 CALL MD % Reset () RETURN END SUBROUTINE SIMDB_Initialize_wFlag !****************************************************************************** SUBROUTINE SIMDB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsSIMD384 ) THEN MD % State = IV384 ELSE MD % State = IV512 END IF CALL MD % EngineReset () RETURN END SUBROUTINE SIMDB_Reset !****************************************************************************** SUBROUTINE SIMDB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SIMDB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SIMDB ) CALL Dst % Create ( Src % IsSIMD384 ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE SIMDB_GetClone !****************************************************************************** FUNCTION SIMDB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( IN ) :: MD !! 'SIMDB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSIMD384 ) THEN Name = 'SIMD-384' ELSE Name = 'SIMD-512' END IF RETURN END FUNCTION SIMDB_GetName !****************************************************************************** FUNCTION SIMDB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( IN ) :: MD !! 'SIMDB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSIMD384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION SIMDB_GetDigestLen !****************************************************************************** FUNCTION SIMDB_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( IN ) :: MD !! 'SIMDB' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SIMDB_GetBlockLen !****************************************************************************** SUBROUTINE SIMDB_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), TARGET , INTENT ( INOUT ) :: MD !! 'SIMDB' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SIMDB_SetBufPtr !****************************************************************************** SUBROUTINE SIMDB_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL SIMDCore_Compress_Big ( MD , BytesIn , FalseVal ) RETURN END SUBROUTINE SIMDB_ProcessBlock !****************************************************************************** SUBROUTINE SIMDB_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE SIMDB_DoPadding !****************************************************************************** SUBROUTINE SIMDB_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD !! 'SIMDB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , I , DLen tLong :: BlockCount ! FLOW ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () IF (( Ptr > 0_kIndex ). OR .( NBits > 0_kInt8 )) THEN TmpBuf ( Ptr ) = IAND ( LastByte , SHIFTL ( FByteFF , 8 - NBits )) TmpBuf ( Ptr + 1 :) = FByte00 CALL MD % ProcessBlock ( TmpBuf ) END IF ! encode counter and compress buffer BlockCount = SHIFTL ( MD % GetBlockCount (), 10 ) + ToInt64 ( SHIFTL ( Ptr , 3 )) + ToInt64 ( NBits ) CALL ByteUnpackLE ( ToInt32 ( BlockCount ), TmpBuf , 0_kIndex ) CALL ByteUnpackLE ( ToInt32 ( SHIFTA ( BlockCount , 32 )), TmpBuf , 4_kIndex ) TmpBuf ( 8 :) = FByte00 CALL SIMDCore_Compress_Big ( MD , TmpBuf , TrueVal ) END ASSOCIATE DLen = MD % GetDigestLen () DO I = 0 , SHIFTR ( DLen , 2 ) - 1 CALL ByteUnpackLE ( MD % State ( I ), BytesOut , Offset + SHIFTL ( I , 2 )) END DO RETURN END SUBROUTINE SIMDB_AddBitsNPad !****************************************************************************** SUBROUTINE SIMDCore_Compress_Big ( MD , X , Last ) !** PURPOSE OF THIS SUBROUTINE: ! To perform compression based on a Feistel-like cipher in Davies-Meyer mode. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SIMDB ), INTENT ( INOUT ) :: MD tByte , INTENT ( IN ) :: X ( 0 :) tLogical , INTENT ( IN ) :: Last !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , PARAMETER :: Wbp ( 0 : 31 ) = [ & SHIFTL ( 4_kIndex , 4 ), SHIFTL ( 6_kIndex , 4 ), SHIFTL ( 0_kIndex , 4 ), SHIFTL ( 2_kIndex , 4 ), & SHIFTL ( 7_kIndex , 4 ), SHIFTL ( 5_kIndex , 4 ), SHIFTL ( 3_kIndex , 4 ), SHIFTL ( 1_kIndex , 4 ), & SHIFTL ( 15_kIndex , 4 ), SHIFTL ( 11_kIndex , 4 ), SHIFTL ( 12_kIndex , 4 ), SHIFTL ( 8_kIndex , 4 ), & SHIFTL ( 9_kIndex , 4 ), SHIFTL ( 13_kIndex , 4 ), SHIFTL ( 10_kIndex , 4 ), SHIFTL ( 14_kIndex , 4 ), & SHIFTL ( 17_kIndex , 4 ), SHIFTL ( 18_kIndex , 4 ), SHIFTL ( 23_kIndex , 4 ), SHIFTL ( 20_kIndex , 4 ), & SHIFTL ( 22_kIndex , 4 ), SHIFTL ( 21_kIndex , 4 ), SHIFTL ( 16_kIndex , 4 ), SHIFTL ( 19_kIndex , 4 ), & SHIFTL ( 30_kIndex , 4 ), SHIFTL ( 24_kIndex , 4 ), SHIFTL ( 25_kIndex , 4 ), SHIFTL ( 31_kIndex , 4 ), & SHIFTL ( 27_kIndex , 4 ), SHIFTL ( 29_kIndex , 4 ), SHIFTL ( 28_kIndex , 4 ), SHIFTL ( 26_kIndex , 4 )] tInteger , PARAMETER :: YOff_B_N ( 0 : 255 ) = [ & 1 , 163 , 98 , 40 , 95 , 65 , 58 , 202 , 30 , 7 , 113 , 172 , & 23 , 151 , 198 , 149 , 129 , 210 , 49 , 20 , 176 , 161 , 29 , 101 , & 15 , 132 , 185 , 86 , 140 , 204 , 99 , 203 , 193 , 105 , 153 , 10 , & 88 , 209 , 143 , 179 , 136 , 66 , 221 , 43 , 70 , 102 , 178 , 230 , & 225 , 181 , 205 , 5 , 44 , 233 , 200 , 218 , 68 , 33 , 239 , 150 , & 35 , 51 , 89 , 115 , 241 , 219 , 231 , 131 , 22 , 245 , 100 , 109 , & 34 , 145 , 248 , 75 , 146 , 154 , 173 , 186 , 249 , 238 , 244 , 194 , & 11 , 251 , 50 , 183 , 17 , 201 , 124 , 166 , 73 , 77 , 215 , 93 , & 253 , 119 , 122 , 97 , 134 , 254 , 25 , 220 , 137 , 229 , 62 , 83 , & 165 , 167 , 236 , 175 , 255 , 188 , 61 , 177 , 67 , 127 , 141 , 110 , & 197 , 243 , 31 , 170 , 211 , 212 , 118 , 216 , 256 , 94 , 159 , 217 , & 162 , 192 , 199 , 55 , 227 , 250 , 144 , 85 , 234 , 106 , 59 , 108 , & 128 , 47 , 208 , 237 , 81 , 96 , 228 , 156 , 242 , 125 , 72 , 171 , & 117 , 53 , 158 , 54 , 64 , 152 , 104 , 247 , 169 , 48 , 114 , 78 , & 121 , 191 , 36 , 214 , 187 , 155 , 79 , 27 , 32 , 76 , 52 , 252 , & 213 , 24 , 57 , 39 , 189 , 224 , 18 , 107 , 222 , 206 , 168 , 142 , & 16 , 38 , 26 , 126 , 235 , 12 , 157 , 148 , 223 , 112 , 9 , 182 , & 111 , 103 , 84 , 71 , 8 , 19 , 13 , 63 , 246 , 6 , 207 , 74 , & 240 , 56 , 133 , 91 , 184 , 180 , 42 , 164 , 4 , 138 , 135 , 160 , & 123 , 3 , 232 , 37 , 120 , 28 , 195 , 174 , 92 , 90 , 21 , 82 , & 2 , 69 , 196 , 80 , 190 , 130 , 116 , 147 , 60 , 14 , 226 , 87 , & 46 , 45 , 139 , 41 ] tInteger , PARAMETER :: YOff_B_F ( 0 : 255 ) = [ & 2 , 203 , 156 , 47 , 118 , 214 , 107 , 106 , 45 , 93 , 212 , 20 , & 111 , 73 , 162 , 251 , 97 , 215 , 249 , 53 , 211 , 19 , 3 , 89 , & 49 , 207 , 101 , 67 , 151 , 130 , 223 , 23 , 189 , 202 , 178 , 239 , & 253 , 127 , 204 , 49 , 76 , 236 , 82 , 137 , 232 , 157 , 65 , 79 , & 96 , 161 , 176 , 130 , 161 , 30 , 47 , 9 , 189 , 247 , 61 , 226 , & 248 , 90 , 107 , 64 , 0 , 88 , 131 , 243 , 133 , 59 , 113 , 115 , & 17 , 236 , 33 , 213 , 12 , 191 , 111 , 19 , 251 , 61 , 103 , 208 , & 57 , 35 , 148 , 248 , 47 , 116 , 65 , 119 , 249 , 178 , 143 , 40 , & 189 , 129 , 8 , 163 , 204 , 227 , 230 , 196 , 205 , 122 , 151 , 45 , & 187 , 19 , 227 , 72 , 247 , 125 , 111 , 121 , 140 , 220 , 6 , 107 , & 77 , 69 , 10 , 101 , 21 , 65 , 149 , 171 , 255 , 54 , 101 , 210 , & 139 , 43 , 150 , 151 , 212 , 164 , 45 , 237 , 146 , 184 , 95 , 6 , & 160 , 42 , 8 , 204 , 46 , 238 , 254 , 168 , 208 , 50 , 156 , 190 , & 106 , 127 , 34 , 234 , 68 , 55 , 79 , 18 , 4 , 130 , 53 , 208 , & 181 , 21 , 175 , 120 , 25 , 100 , 192 , 178 , 161 , 96 , 81 , 127 , & 96 , 227 , 210 , 248 , 68 , 10 , 196 , 31 , 9 , 167 , 150 , 193 , & 0 , 169 , 126 , 14 , 124 , 198 , 144 , 142 , 240 , 21 , 224 , 44 , & 245 , 66 , 146 , 238 , 6 , 196 , 154 , 49 , 200 , 222 , 109 , 9 , & 210 , 141 , 192 , 138 , 8 , 79 , 114 , 217 , 68 , 128 , 249 , 94 , & 53 , 30 , 27 , 61 , 52 , 135 , 106 , 212 , 70 , 238 , 30 , 185 , & 10 , 132 , 146 , 136 , 117 , 37 , 251 , 150 , 180 , 188 , 247 , 156 , & 236 , 192 , 108 , 86 ] tInteger , PARAMETER :: PP8_0 ( 0 : 7 ) = [ 1 , 0 , 3 , 2 , 5 , 4 , 7 , 6 ] tInteger , PARAMETER :: PP8_4 ( 0 : 7 ) = [ 5 , 4 , 7 , 6 , 1 , 0 , 3 , 2 ] tInteger , PARAMETER :: PP8_5 ( 0 : 7 ) = [ 7 , 6 , 5 , 4 , 3 , 2 , 1 , 0 ] tInteger , PARAMETER :: PP8_6 ( 0 : 7 ) = [ 4 , 5 , 6 , 7 , 0 , 1 , 2 , 3 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger , TARGET :: State ( 0 : 31 ) tInteger , POINTER :: A (:), B (:), C (:), D (:) tInteger :: Q ( 0 : 255 ) tInteger :: W ( 0 : 63 ) tInteger :: tA ( 0 : 7 ) tInteger :: TQ , MWord , Tmp tIndex :: II , JJ , KK !** SUBROUTINE MACRO DEFINITIONS: #include    \"Includes/SIMD_Def Macro.f90\" ! FLOW ! set pointers A ( 0 : 7 ) => State ( 0 :) B ( 0 : 7 ) => State ( 8 :) C ( 0 : 7 ) => State ( 16 :) D ( 0 : 7 ) => State ( 24 :) ! ++++++++ FFT_256(0, 1, 0) +++++++++ CALL FFT_64 ( X ( 0 :), SHIFTL ( 1_kIndex , 2 ), Q ( 0 :)) CALL FFT_64 ( X ( 2 :), SHIFTL ( 1_kIndex , 2 ), Q ( 64 :)) FFT_LOOP ( 0 , 64 , 2 ) CALL FFT_64 ( X ( 1 :), SHIFTL ( 1_kIndex , 2 ), Q ( 128 :)) CALL FFT_64 ( X ( 3 :), SHIFTL ( 1_kIndex , 2 ), Q ( 192 :)) FFT_LOOP ( 128 , 64 , 2 ) FFT_LOOP ( 0 , 128 , 1 ) ! +++++++++++++++++++++++++++++++++++ IF ( Last ) THEN DO II = 0 , 255 TQ = Q ( II ) + YOff_B_F ( II ) TQ = REDS2 ( TQ ) TQ = REDS1 ( TQ ) TQ = REDS1 ( TQ ) IF ( TQ <= 128 ) THEN Q ( II ) = TQ ELSE Q ( II ) = TQ - 257 END IF END DO ELSE DO II = 0 , 255 TQ = Q ( II ) + YOff_B_N ( II ) TQ = REDS2 ( TQ ) TQ = REDS1 ( TQ ) TQ = REDS1 ( TQ ) IF ( TQ <= 128 ) THEN Q ( II ) = TQ ELSE Q ( II ) = TQ - 257 END IF END DO END IF State = MD % State DO II = 0 , 31 , 8 DO JJ = II , II + 7 KK = 4 * JJ CALL BytePackLE ( X , KK , MWord ) State ( JJ ) = IEOR ( State ( JJ ), MWord ) END DO END DO WBREAD ( 0 , 0 , 1 , 185 ) CALL OneRound_Big ( State , W , 0 , 3 , 23 , 17 , 27 ) WBREAD ( 8 , 0 , 1 , 185 ) CALL OneRound_Big ( State , W , 1 , 28 , 19 , 22 , 7 ) WBREAD ( 16 , ( - 256 ), ( - 128 ), 233 ) CALL OneRound_Big ( State , W , 2 , 29 , 9 , 15 , 5 ) WBREAD ( 24 , ( - 383 ), ( - 255 ), 233 ) CALL OneRound_Big ( State , W , 3 , 4 , 13 , 10 , 25 ) STEP_BIG_II ( MD % State ( 0 ), MD % State ( 1 ), MD % State ( 2 ), MD % State ( 3 ), \\ MD % State ( 4 ), MD % State ( 5 ), MD % State ( 6 ), MD % State ( 7 ), \\ IFF , 4 , 13 , PP8_4 ) STEP_BIG_II ( MD % State ( 8 ), MD % State ( 9 ), MD % State ( 10 ), MD % State ( 11 ), \\ MD % State ( 12 ), MD % State ( 13 ), MD % State ( 14 ), MD % State ( 15 ), \\ IFF , 13 , 10 , PP8_5 ) STEP_BIG_II ( MD % State ( 16 ), MD % State ( 17 ), MD % State ( 18 ), MD % State ( 19 ), \\ MD % State ( 20 ), MD % State ( 21 ), MD % State ( 22 ), MD % State ( 23 ), \\ IFF , 10 , 25 , PP8_6 ) STEP_BIG_II ( MD % State ( 24 ), MD % State ( 25 ), MD % State ( 26 ), MD % State ( 27 ), \\ MD % State ( 28 ), MD % State ( 29 ), MD % State ( 30 ), MD % State ( 31 ), \\ IFF , 25 , 4 , PP8_0 ) ! return state values MD % State = State NULLIFY ( A , B , C , D ) RETURN CONTAINS SUBROUTINE FFT_32 ( X , XB , XS , RB , Q ) !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: X ( 0 :) tIndex , INTENT ( IN ) :: XB tIndex , INTENT ( IN ) :: XS tIndex , INTENT ( IN ) :: RB tInteger , INTENT ( INOUT ) :: Q ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW FFT16 ( XB , SHIFTL ( XS , 1 ), RB ) FFT16 (( XB + XS ), SHIFTL ( XS , 1 ), ( RB + 16 )) FFT_LOOP ( RB , 16 , 8 ) RETURN END SUBROUTINE FFT_32 !****************************************************************************** SUBROUTINE FFT_64 ( X , XS , Q ) !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , INTENT ( IN ) :: X ( 0 :) tIndex , INTENT ( IN ) :: XS tInteger , INTENT ( INOUT ) :: Q ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: XD ! FLOW XD = SHIFTL ( XS , 1 ) CALL FFT_32 ( X , 0_kIndex , XD , 0_kIndex , Q ) CALL FFT_32 ( X , XS , XD , 32_kIndex , Q ) FFT_LOOP ( 0 , 32 , 4 ) RETURN END SUBROUTINE FFT_64 !****************************************************************************** SUBROUTINE OneRound_Big ( State , W , ISP , P0 , P1 , P2 , P3 ) !** PURPOSE OF THIS SUBROUTINE: ! To perform one round of mixing. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , TARGET , INTENT ( INOUT ) :: State ( 0 : 31 ) tInteger , INTENT ( INOUT ) :: W ( 0 : 63 ) tInteger , INTENT ( IN ) :: ISP , P0 , P1 , P2 , P3 !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , PARAMETER :: PP8K ( 0 : 10 ) = [ 1 , 6 , 2 , 3 , 5 , 7 , 4 , 1 , 6 , 2 , 3 ] !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger , POINTER :: A (:), B (:), C (:), D (:) tInteger :: tA ( 0 : 7 ), Tmp ! FLOW A ( 0 : 7 ) => State ( 0 :) B ( 0 : 7 ) => State ( 8 :) C ( 0 : 7 ) => State ( 16 :) D ( 0 : 7 ) => State ( 24 :) STEP_BIG ( W ( 0 ), W ( 1 ), W ( 2 ), W ( 3 ), W ( 4 ), W ( 5 ), W ( 6 ), W ( 7 ), IFF , P0 , P1 , PP8K ( ISP + 0 )) STEP_BIG ( W ( 8 ), W ( 9 ), W ( 10 ), W ( 11 ), W ( 12 ), W ( 13 ), W ( 14 ), W ( 15 ), IFF , P1 , P2 , PP8K ( ISP + 1 )) STEP_BIG ( W ( 16 ), W ( 17 ), W ( 18 ), W ( 19 ), W ( 20 ), W ( 21 ), W ( 22 ), W ( 23 ), IFF , P2 , P3 , PP8K ( ISP + 2 )) STEP_BIG ( W ( 24 ), W ( 25 ), W ( 26 ), W ( 27 ), W ( 28 ), W ( 29 ), W ( 30 ), W ( 31 ), IFF , P3 , P0 , PP8K ( ISP + 3 )) STEP_BIG ( W ( 32 ), W ( 33 ), W ( 34 ), W ( 35 ), W ( 36 ), W ( 37 ), W ( 38 ), W ( 39 ), MAJ , P0 , P1 , PP8K ( ISP + 4 )) STEP_BIG ( W ( 40 ), W ( 41 ), W ( 42 ), W ( 43 ), W ( 44 ), W ( 45 ), W ( 46 ), W ( 47 ), MAJ , P1 , P2 , PP8K ( ISP + 5 )) STEP_BIG ( W ( 48 ), W ( 49 ), W ( 50 ), W ( 51 ), W ( 52 ), W ( 53 ), W ( 54 ), W ( 55 ), MAJ , P2 , P3 , PP8K ( ISP + 6 )) STEP_BIG ( W ( 56 ), W ( 57 ), W ( 58 ), W ( 59 ), W ( 60 ), W ( 61 ), W ( 62 ), W ( 63 ), MAJ , P3 , P0 , PP8K ( ISP + 7 )) NULLIFY ( A , B , C , D ) RETURN END SUBROUTINE OneRound_Big !****************************************************************************** #include    \"Includes/SIMD_Undef Macro.f90\" END SUBROUTINE SIMDCore_Compress_Big !****************************************************************************** END MODULE MClass_SIMDB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_simdb.f90.html"},{"title":"MClass_Hasher64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Hasher64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Hasher64* type and its related routines. !   The *Hasher64* type is an abstract type that extends from the !   <a href=\"../module/mclass_basehasher.html#type-basehasher\">BaseHasher</a> !   type.  It represents a 64-bit integer hasher where additional methods, !   specific for 64-bit integer hash functions, are defined to complete !   the API for an incremental non-cryptographic hash function.  All !   hashers that output a hash value as a 64-bit integer should extends !   from this abstract type. <br> !   <br> !  **USAGE**: <br> !   Although there are a number of methods provided, several of them are !   intended for internal use (by developers).  Only five methods are !   intentionally provided for users including: <br> !   - the *Initialize* method that initializes the hasher, <br> !   - the *Update* method that inputs data into the hasher, <br> !   - the *Finalize* method that returns the hash value, <br> !   - the *GetName* method that returns the hasher name, and <br> !   - the *HashDirect* method that compute the hash value directly. <br> !   The first three methods mentioned are provided for the incremental !   hash computations where the *Initialize* method is first called !   (once), the *Update* method is then called (many times), and the !   *Finalize* method is finally called (once). <br> !   If the *Update* method is to be called only one time, then the !   *HashDirect* method (for non-incremental hash computations) should !   be employed in place of those three methods. !** USE STATEMENTS: USE MBase_Common USE MClass_BaseHasher IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: Hasher64 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *Hasher64* is an abstract type representing a hasher that outputs the hash value !  as a 64-bit integer for an incremental non-cryptographic hash function. TYPE , ABSTRACT , EXTENDS ( BaseHasher ) :: Hasher64 CONTAINS !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE ( HS64Init ), DEFERRED :: Initialize !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 64-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE ( HS64Final ), DEFERRED :: Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE ( HS64Hash ), DEFERRED :: HashDirect END TYPE Hasher64 !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> HS64Init is a deferred procedure to initialize the hasher. <br> SUBROUTINE HS64Init ( HS , Seed , RemoveSign ) IMPORT CLASS ( Hasher64 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign END SUBROUTINE !> HS64Final is a deferred procedure to finalize the current hash computation !  and return the hash value in a 64-bit integer.  The object is reset. <br> FUNCTION HS64Final ( HS ) RESULT ( HashCode ) IMPORT CLASS ( Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt64 :: HashCode !! hash code END FUNCTION HS64Final !> HS64Hash is a deferred procedure to compute the hash value directly !  (non-incrementally). <br> FUNCTION HS64Hash ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) IMPORT CLASS ( Hasher64 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** END MODULE MClass_Hasher64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hasher64.f90.html"},{"title":"MBase_OptimalHash64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_OptimalHash64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains an optimal implementation of various non-cryptographic hash !   function routines that output a hash value as a 64-bit integer.  The available !   hash functions are a subset of those reference hash functions implemented in the !   <a href=\"../module/mbase_referencehash64.html\">ModBase_ReferenceHash64</a> module. !   The API of these optimal routines are exactly the same as those reference routines. <br> !   It should be noted that each optimal hash function routine is based on a benchmark !   that compares performances of various possible implementations of the hash function !   as provided in the  <a href=\"../module/mbase_experimentalhash64.html\"> !   ModBase_ExperimentalHash64</a> module.  It should also be noted that these so-called !   optimal hash function routines may not actually be optimal for a particular user so !   the user is highly encouraged to perform (by himself/herself) a benchmark of each !   specific hash function routine in order to know which implementation is the best one !   for a particular system (i.e. a combination of operating system, machine as well as !   compiler used). <br> !   <br> !&#94; **REFERENCES**: <br> !   See the <a href=\"../module/mbase_referencehash64.html\">ModBase_ReferenceHash64</a> !   module for references of the available hash functions in this module. !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_ByteUtil , ONLY : SwapBytes , SwapByteArray IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: City_Hash64_Opt PUBLIC :: FarmNa_Hash64_Opt PUBLIC :: FarmUo_Hash64_Opt PUBLIC :: Komi_Hash64_Opt PUBLIC :: Metro_Hash64_Opt PUBLIC :: Murmur3_Hash128_Opt PUBLIC :: PengyV02_Hash64_Opt PUBLIC :: PengyV03_Hash64_Opt PUBLIC :: Spooky_Hash128_Opt PUBLIC :: Wy_Hash64_Opt PUBLIC :: WyF3_Hash64_Opt PUBLIC :: XX_Hash64_Opt PUBLIC :: XX3_Hash64_Opt PUBLIC :: XX3_Hash128_Opt PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_OptimalHash64' ! The maximum (positive) number of hash code tUInt64 , PARAMETER :: MaxHash = ToInt64 ( Z '7FFFFFFFFFFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: INTERFACE MODULE FUNCTION Metro_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the MetroHash64 hash algorithm by J. Andrew !  Rogers [2]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Murmur3_Hash128_Opt ( Input , InpSize , StartHash , RemoveSign , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the MurmurHash3 hash algorithm by Austin !  Appleby [1]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Wy_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using version 3 (?) of the WyHash hash algorithm by !  Wang Yi [3, 4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION WyF3_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the final version 3 of the WyHash hash algorithm !  by Wang Yi [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the XXHash hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX3_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign , & Secret ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION XX3_Hash128_Opt ( Input , InpSize , StartHash , RemoveSign , & Secret , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION City_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the CityHash hash algorithm by Google Inc [6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmNa_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmNaHash hash algorithm by Google Inc [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION FarmUo_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmUoHash hash algorithm by Google Inc [7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Spooky_Hash128_Opt ( Input , InpSize , StartHash , RemoveSign , & Seed , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using version 2 of the SpookyHash hash algorithm !  by Bob Jenkins [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION PengyV03_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.3) by !  Alberto Fajardo [15]. <br> TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION PengyV02_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.2) by !  Alberto Fajardo [9, 10]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- MODULE FUNCTION Komi_Hash64_Opt ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** FUNCTION UnsignedLongMultiplyorFold ( LHS , RHS ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply or fold. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 :: Res !** SUBROUTINE PARAMETER DECLARATIONS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = IAND ( LHS , MaxU32 ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = IAND ( RHS , MaxU32 ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaxU32 ) + LHS_Lo * RHS_Hi Res = IEOR ( IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaxU32 )), & SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi ) RETURN END FUNCTION UnsignedLongMultiplyorFold !****************************************************************************** END MODULE MBase_OptimalHash64 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_optimalhash64.f90.html"},{"title":"MClass_KP1600Core.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_KP1600Core !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *KP1600Core* type and its related routines. !   The *KP1600Core* type is an abstract *digest* type extending directly !   from the <a href=\"../module/mclass_basedigest.html#type-basedigest\"> !   BaseDigest</a> type.  It implements additional methods to provide an !   extended API for an incremental cryptographic hash function.  Several !   of these additional methods are the same as those methods defined by the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> type. <br> !   By design, the *KP1600Core* type is intended to be used as a parent !   type for all *Keccak-based* digest types.  The *KP1600Core* type !   provides an implementation of an incremental cryptographic hash function !   by employing the *Keccak message-digest* algorithm with the internal !   state size of 1600 bits (i.e. Keccak-p[1600, nRound]) [1].  It takes care !   core operations (i.e. some of the deferred procedures and additional methods !   provided) required by a *Keccak-based digest* object where its subtypes must !   take care the remaining operations (i.e the rest of the deferred procedures). !   The *KP1600Core* type utilizes the <a href=\"../module/mclass_kp1600sponge.html#type-kp1600sponge\"> !   KP1600Sponge</a> type, which provides all basic operations of the !   *Keccak-p[1600, nRound]* algorithm.  The implementation of the *KP1600Sponge* !   type is mainly based on the *eXtended Keccak Code Package* (XKCP) [2].<br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [2] <a href=\"https://github.com/XKCP/XKCP\">The eXtended Keccak Code Package. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr USE MClass_BaseDigest USE MClass_KP1600Sponge IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: KP1600Core PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: ! maximum number of rounds of permutation tInteger , PARAMETER :: MaxNrRounds = 24 !** DERIVED TYPE DEFINITIONS !> *KP1600Core* is an abstract *digest* type provided to be a parent !  type for other *Keccak-based digest* types to implement incremental !  cryptographic hash functions. TYPE , ABSTRACT , EXTENDS ( BaseDigest ) :: KP1600Core PRIVATE !% The sponge instance TYPE ( KP1600Sponge ) :: Sponge !% The value of the capacity in bits tInteger :: Capacity = 512 !% The number of permutation rounds tInteger :: NRounds = 24 !% The length of output in bytes tIndex :: DigestLen = 32_kIndex !% The initial bits appended to the end of input tByte :: InitSuffix = ToInt8 ( Z '80' ) !% The current bits appended to the end of input tByte :: CurrSuffix = ToInt8 ( Z '80' ) CONTAINS ! --------------------------------------------------------------------- ! -----                 Deferred Procedures Implemented           ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => KP1600Core_Reset !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => KP1600Core_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => KP1600Core_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => KP1600Core_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => KP1600Core_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> *CoreInit* is a procedure to initialize components of the 'KP1600Core' object. <br> !  This procedure is NOT intended to be used by a user but the *Initialize* !  method(s) implemented by a *concrete* digest type should call this method. PROCEDURE :: CoreInit => KP1600Core_Initialize !> *CopyState* is a procedure to copy components of the source to the destination. <br> !  This procedure is NOT intended to be used by a user but the *GetClone* method !  implemented by a *concrete* digest type should call this method. PROCEDURE :: CopyState => KP1600Core_CopyState !> *DoFinalWOutLen* is a procedure to finalize the digest object with a specified !  hash output length. <br> !  This procedure is NOT intended to be used by a user.  It is provided to aid the !  development and implementation of the *Keccak-based digest* types that can be !  used as an extendable-output function (XOF). PROCEDURE :: DoFinalWOutLen => KP1600Core_ByteDigest_wOutLen !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => KP1600Core_GetDigestLen !> **Type-Bound Function**: GetSponge <br> !  **Purpose**:  To return a pointer to the sponge component of the digest object. <br> !  **Usage**: <br> !   --->    Instance => MD%GetSponge() PROCEDURE :: GetSponge => KP1600Core_GetSponge ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AddBitsNPad => KP1600Core_AddBitsNPad PROCEDURE , PRIVATE :: KP1600Core_ByteDigest_AddBits PROCEDURE , PRIVATE :: KP1600Core_HexDigest_AddBits ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => KP1600Core_ByteDigest_AddBits , & KP1600Core_HexDigest_AddBits END TYPE KP1600Core !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE KP1600Core_Initialize ( MD , Capacity , Suffix , DigestLen , NRounds ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize components of the 'KP1600Core' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tInteger , INTENT ( IN ) :: Capacity !! the value of the capacity C tByte , INTENT ( IN ) :: Suffix !! suffix for padding tIndex , INTENT ( IN ) :: DigestLen !! the desired length of output in bytes tInteger , OPTIONAL , INTENT ( IN ) :: NRounds !! number of permutation rounds !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set values related to optional input MD % NRounds = MaxNrRounds IF ( PRESENT ( NRounds )) MD % NRounds = NRounds ! set values related to required input MD % Capacity = Capacity MD % DigestLen = DigestLen MD % InitSuffix = Suffix ! initialize the sponge CALL MD % Reset () RETURN END SUBROUTINE KP1600Core_Initialize !****************************************************************************** SUBROUTINE KP1600Core_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset components of the digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL MD % Sponge % Initialize ( MD % Capacity , MD % NRounds ) MD % CurrSuffix = MD % InitSuffix RETURN END SUBROUTINE KP1600Core_Reset !****************************************************************************** SUBROUTINE KP1600Core_CopyState ( SrcMD , DstMD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy essential components of the source digest. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: SrcMD !! source object CLASS ( KP1600Core ), INTENT ( INOUT ) :: DstMD !! destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL SrcMD % Sponge % CopyState ( DstMD % Sponge ) DstMD % Capacity = SrcMD % Capacity DstMD % NRounds = SrcMD % NRounds DstMD % DigestLen = SrcMD % DigestLen DstMD % InitSuffix = SrcMD % InitSuffix DstMD % CurrSuffix = SrcMD % CurrSuffix RETURN END SUBROUTINE KP1600Core_CopyState !****************************************************************************** FUNCTION KP1600Core_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the output length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( IN ) :: MD !! 'KP1600_Core' object tIndex :: Length !! digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION KP1600Core_GetDigestLen !****************************************************************************** FUNCTION KP1600Core_GetSponge ( MD ) RESULT ( Sponge ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the sponge component of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), TARGET , INTENT ( IN ) :: MD !! 'KP1600_Core' object TYPE ( KP1600Sponge ), POINTER :: Sponge !! sponge object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Sponge => MD % Sponge RETURN END FUNCTION KP1600Core_GetSponge !****************************************************************************** SUBROUTINE KP1600Core_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: Flag ! FLOW Flag = MD % Sponge % Absorb ( ByteArr ( Offset :), Length ) RETURN END SUBROUTINE KP1600Core_InsertBytes !****************************************************************************** SUBROUTINE KP1600Core_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) tByte :: Flag ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array Flag = MD % Sponge % Absorb ( InpPtr , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE KP1600Core_InsertGen !****************************************************************************** SUBROUTINE KP1600Core_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: Flag ! FLOW IF ( MD % DigestLen > 0_kIndex ) THEN CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) IF ( MD % Sponge % AbsorbLastFewBits ( MD % CurrSuffix ) == SUCCESS ) THEN Flag = MD % Sponge % Squeeze ( ByteArr , MD % DigestLen ) END IF CALL MD % Reset () END IF RETURN END SUBROUTINE KP1600Core_ByteDigest !****************************************************************************** SUBROUTINE KP1600Core_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE KP1600Core_ByteDigest_wInput !****************************************************************************** SUBROUTINE KP1600Core_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % DigestLen > 0_kIndex ) THEN CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) CALL MD % AddBitsNPad ( LastByte , NBits , ByteArr , 0_kIndex ) CALL MD % Reset () END IF RETURN END SUBROUTINE KP1600Core_ByteDigest_AddBits !****************************************************************************** SUBROUTINE KP1600Core_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE KP1600Core_HexDigest_AddBits !****************************************************************************** SUBROUTINE KP1600Core_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the offset of the output buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: Flag tInteger :: DelimitedLastBytes tByte :: OneByte ( 0 : 0 ) ! FLOW IF ( NBits > 0_kInt8 ) THEN ! Concatenate the last few bits provided here with those of the suffix DelimitedLastBytes = IEOR ( ToInt32 ( SHIFTR ( LastByte , ( 8_kIndex - NBits ))), & SHIFTL ( ToInt32 ( MD % CurrSuffix ), NBits )) IF ( IAND ( DelimitedLastBytes , ToInt32 ( Z '0000FF00' )) == 0_kInt32 ) THEN MD % CurrSuffix = ToInt8 ( DelimitedLastBytes ) ELSE OneByte ( 0 ) = ToInt8 ( DelimitedLastBytes ) Flag = MD % Sponge % Absorb ( OneByte , 1_kIndex ) MD % CurrSuffix = ToInt8 ( SHIFTR ( DelimitedLastBytes , 8 )) END IF END IF IF ( MD % Sponge % AbsorbLastFewBits ( MD % CurrSuffix ) == SUCCESS ) THEN Flag = MD % Sponge % Squeeze ( BytesOut ( Offset :), MD % DigestLen ) END IF RETURN END SUBROUTINE KP1600Core_AddBitsNPad !****************************************************************************** SUBROUTINE KP1600Core_ByteDigest_wOutLen ( MD , ByteArr , OutputLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes. The digest object is reset. <br> !  Note: The routine will ignore the output length specified during !  initialization if the given *OutputLen* is valid (>= 1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( KP1600Core ), INTENT ( INOUT ) :: MD !! 'KP1600Core' object tIndex , INTENT ( IN ) :: OutputLen !! the desired output length in bytes tByte , INTENT ( OUT ) :: ByteArr ( OutputLen ) !! an array containing the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: Flag ! FLOW IF ( OutputLen > 0_kIndex ) THEN IF ( MD % Sponge % AbsorbLastFewBits ( MD % CurrSuffix ) == SUCCESS ) THEN Flag = MD % Sponge % Squeeze ( ByteArr , OutputLen ) END IF CALL MD % Reset () END IF RETURN END SUBROUTINE KP1600Core_ByteDigest_wOutLen !****************************************************************************** END MODULE MClass_KP1600Core !******************************************************************************","tags":"","loc":"sourcefile\\mclass_kp1600core.f90.html"},{"title":"MClass_BaseDigest.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BaseDigest !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BaseDigest* type and its related routines. !   The *BaseDigest* type is an abstract type representing a base type for !   a *(message) digest* object, which is an incremental cryptographic hash function. !   The *BaseDigest* type defines an application programming interface (API) !   for various common operations shared by most cryptographic hash functions. !   Therefore, all (message) digest types should extend from this base type. <br> !   Typically, a *digest* object maintains a running state for a hash computation. !   Therefore, it must first be initialized via the *Create* method.  Then, input !   data can be inserted (a number of times) into the digest object (which normally !   stored in a buffer and/or processed if a buffer is fulled) by using the *Update* !   method.  Finally, the result can be obtained from the *Digest* method (where !   some final data can be inserted as well). <br> !   When a digest output has been produced, the *digest* object is automatically reset !   to its initialized state, and can thus be used immediately for another digest !   operation.  The state of a hash computation can be copied by using the *GetClone* !   method; this can be used to get a partial hash result without interrupting the !   complete computation.  The new (clone) object evolves independently of the source !   object. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ByteUtil , ONLY : ByteArr_2_HexStr => ToHexStr_BE IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseDigest PUBLIC :: ByteArr_2_HexStr PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! na !** DERIVED TYPE DEFINITIONS !> *BaseDigest* is an abstract type representing a base type for a !  *(Message) Digest* object.  It defines an API for common operations !  of an incremental cryptographic hash function. TYPE , ABSTRACT :: BaseDigest CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *Initialize* is a binding name of the *MDCreate* deferred procedure. <br> !  Use the *Create* method in place of the *Initialize* method to perform !  any essential initialization of a *digest* object. PROCEDURE ( MDCreate ), DEFERRED :: Initialize !> *Reset* is a binding name of the *MDReset* deferred procedure. <br> !  **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE ( MDReset ), DEFERRED :: Reset !> *GetClone* is a binding name of the *MDClone* deferred procedure. <br> !  **Type-Bound Function**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE ( MDClone ), DEFERRED :: GetClone !> *GetName* is a binding name of the *MDName* deferred procedure. <br> !  **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE ( MDName ), DEFERRED :: GetName !> *InsertBytes* is a binding name of the *MDInsertBytes* deferred procedure. <br> !  Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE ( MDInsertBytes ), DEFERRED :: InsertBytes !> *InsertGen* is a binding name of the *MDInsertGen* deferred procedure. <br> !  Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE ( MDInsertGen ), DEFERRED :: InsertGen !> *ByteDigest* is a binding name of the *MDByteDigest* deferred procedure. <br> !  Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE ( MDByteDigest ), DEFERRED :: ByteDigest !> *ByteDigest_wInput* is a binding name of the *MDByteDigestII* deferred procedure. <br> !  Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE ( MDByteDigestII ), DEFERRED :: ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> HexDigest is a private procedure to finalize the current hash computation and !  return the hash value as a hexadecimal string in a newly-allocated character string. <br> !  Use the *Digest* method in place of the *HexDigest* method. PROCEDURE , PRIVATE :: HexDigest => HexStr_Digest !> HexDigest_wInput is a private procedure to insert final input in a generic !  way and then finalize the current hash computation and return the hash value as !  a hexadecimal string in a newly-allocated character string. <br> !  Use the *Digest* method in place of the *HexDigest_wInput* method. PROCEDURE , PRIVATE :: HexDigest_wInput => HexStr_Digest_wInput ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   --->    CALL MD%Create() GENERIC :: Create => Initialize !> **Type-Bound Subroutine**: Update <br> !  **Purpose**:  To insert input data into the *digest* object (commonly stored in a !                buffer array) and process block(s) of data if necessary. <br> !  **Usage**: <br> !   ! insert input data in a generic way <br> !   --->    CALL MD%Update(Input, InpSize) <br> !   ! insert input data as an array of bytes (8-bit integers) <br> !   --->    CALL MD%Update(ByteArr, Offset, Length) <br> GENERIC :: Update => InsertBytes , InsertGen !> **Type-Bound Subroutine**: Digest <br> !  **Purpose**:  To finalize the current hash computation and return the hash output. !                The object is reset.  Some final input data can be inserted. <br> !  **Usage**: <br> !   ! finalize hash computation and return hash output as a byte array <br> !   --->    CALL MD%Digest(ByteArr) <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%Digest(Input, InpSize, ByteArr) <br> !   ! finalize hash computation and return hash output as a hexadecimal string <br> !   --->    CALL MD%Digest(HexStr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%Digest(Input, InpSize, HexStr) <br> GENERIC :: Digest => ByteDigest , ByteDigest_wInput , & HexDigest , HexDigest_wInput END TYPE BaseDigest !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> MDCreate is a deferred procedure to perform any essential initialization !  of a *digest* object. SUBROUTINE MDCreate ( MD ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object END SUBROUTINE !> MDReset is a deferred procedure to reset the hash algorithm state. SUBROUTINE MDReset ( MD ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object END SUBROUTINE !> MDClone is a deferred procedure to clone the current state. The returned !  object evolves independently of this object. SUBROUTINE MDClone ( Src , Dst ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: Src !! a source digest object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination (clone) digest object END SUBROUTINE !> MDName is a deferred procedure to get the display name for this hash !  function (e.g. \"SHA-1\" for SHA-1). FUNCTION MDName ( MD ) RESULT ( Name ) IMPORT CLASS ( BaseDigest ), INTENT ( IN ) :: MD !! 'BaseDigest' object tCharAlloc :: Name !! name of the hash function END FUNCTION !> MDInsertBytes is a deferred procedure to insert input data as a byte !  (8-bit integer) array where offset (zero-based) and length are specified. SUBROUTINE MDInsertBytes ( MD , ByteArr , Offset , Length ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tUInt8 , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes END SUBROUTINE !> MDInsertGen is a deferred procedure to insert input data in a generic way !  where the *Input* argument can be any type and any rank and the *InpSize* !  argument specifies the size of the input data in a number of bytes. SUBROUTINE MDInsertGen ( MD , Input , InpSize ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) END SUBROUTINE !> MDByteDigest is a deferred procedure to finalize the current hash computation !  and return the hash value as an array of (8-bit integer) bytes in a newly- !  allocated array.  The digest object is reset. SUBROUTINE MDByteDigest ( MD , ByteArr ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tUInt8 , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output END SUBROUTINE !> MDByteDigestII is a deferred procedure to insert final input in a generic way !  and then finalize the current hash computation and return the hash value as !  an array of (8-bit integer) bytes in a newly-allocated array.  The digest !  object is reset. SUBROUTINE MDByteDigestII ( MD , Input , InpSize , ByteArr ) IMPORT CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE HexStr_Digest ( MD , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as a hexadecimal string in a newly-allocated character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % Digest ( ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE HexStr_Digest !****************************************************************************** SUBROUTINE HexStr_Digest_wInput ( MD , Input , InpSize , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash computation !  and return the hash value as a hexadecimal string in a newly-allocated character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDigest ), INTENT ( INOUT ) :: MD !! 'BaseDigest' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt8 , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % Digest ( Input , InpSize , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE HexStr_Digest_wInput !****************************************************************************** END MODULE MClass_BaseDigest !******************************************************************************","tags":"","loc":"sourcefile\\mclass_basedigest.f90.html"},{"title":"MClass_Fugue.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Fugue !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Fugue* type and its related routines. !   The *Fugue* type is a *digest* type that extends directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   The *Fugue* type implements an incremental cryptographic hash !   function by employing the *Fugue message-digest* algorithm [1]. !   The implementation here is mainly based on the references [2]. <br> !   The *Fugue* type represents four cryptographic hash functions: the !   *Fugue-224*, *Fugue-256*, *Fugue-384*, and *Fugue-512* hash functions. !   By default, the *Fugue* type represents the *Fugue-256* hash function. !   However, a user can specify the *Security* argument (to one of the !   four applicable values: 224, 256, 384 and 512) when initializing the !   digest object in order to use a different hash function and get a !   different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20170604091329/http://csrc.nist.gov/groups/ST/hash/sha-3/Round2/documents/Fugue_Round2_Update.zip\"> !       The Hash Function \"Fugue\". </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Fugue PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/Fugue_Def Macro.f90\" !** MODULE PARAMETERS: #include    \"Includes/Fugue_Constants.f90\" tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tInteger , PARAMETER :: IV224 ( 0 : 6 ) = [ & ToInt32 ( Z 'F4C9120D' ), ToInt32 ( Z '6286F757' ), & ToInt32 ( Z 'EE39E01C' ), ToInt32 ( Z 'E074E3CB' ), & ToInt32 ( Z 'A1127C62' ), ToInt32 ( Z '9A43D215' ), & ToInt32 ( Z 'BD8D679A' )] tInteger , PARAMETER :: IV256 ( 0 : 7 ) = [ & ToInt32 ( Z 'E952BDDE' ), ToInt32 ( Z '6671135F' ), & ToInt32 ( Z 'E0D4F668' ), ToInt32 ( Z 'D2B0B594' ), & ToInt32 ( Z 'F96C621D' ), ToInt32 ( Z 'FBF929DE' ), & ToInt32 ( Z '9149E899' ), ToInt32 ( Z '34F8C248' )] tInteger , PARAMETER :: IV384 ( 0 : 11 ) = [ & ToInt32 ( Z 'AA61EC0D' ), ToInt32 ( Z '31252E1F' ), & ToInt32 ( Z 'A01DB4C7' ), ToInt32 ( Z '00600985' ), & ToInt32 ( Z '215EF44A' ), ToInt32 ( Z '741B5E9C' ), & ToInt32 ( Z 'FA693E9A' ), ToInt32 ( Z '473EB040' ), & ToInt32 ( Z 'E502AE8A' ), ToInt32 ( Z 'A99C25E0' ), & ToInt32 ( Z 'BC95517C' ), ToInt32 ( Z '5C1095A1' )] tInteger , PARAMETER :: IV512 ( 0 : 15 ) = [ & ToInt32 ( Z '8807A57E' ), ToInt32 ( Z 'E616AF75' ), & ToInt32 ( Z 'C5D3E4DB' ), ToInt32 ( Z 'AC9AB027' ), & ToInt32 ( Z 'D915F117' ), ToInt32 ( Z 'B6EECC54' ), & ToInt32 ( Z '06E8020B' ), ToInt32 ( Z '4A92EFD1' ), & ToInt32 ( Z 'AAC6E2C9' ), ToInt32 ( Z 'DDB21398' ), & ToInt32 ( Z 'CAE65838' ), ToInt32 ( Z '437F203F' ), & ToInt32 ( Z '25EA78E7' ), ToInt32 ( Z '951FDDD6' ), & ToInt32 ( Z 'DA6ED11D' ), ToInt32 ( Z 'E13E3567' )] !** DERIVED TYPE DEFINITIONS !> *Fugue* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Fugue hash algorithms. TYPE , EXTENDS ( BaseDigest ) :: Fugue PRIVATE !% state (pointer) and its storage tInteger :: Store ( 0 : 35 ) = 0 tInteger , POINTER :: State (:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 !% other working variables tLong :: BitCount tInteger :: Partial tInteger :: PartialLen tInteger :: RoundShift !% pointer to a procedure that processes input data PROCEDURE ( FugueCore ), POINTER :: DoUpdate => NULL () !% pointer to a procedure that finalize the hash process PROCEDURE ( FugueClose ), POINTER :: DoFinal => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Fugue_ByteDigest_AddBits PROCEDURE , PRIVATE :: Fugue_HexDigest_AddBits PROCEDURE , PRIVATE :: InitializeWSecurity => Fugue_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Fugue-256). PROCEDURE :: Initialize => Fugue_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Fugue_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Fugue_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Fugue_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Fugue_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Fugue_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Fugue_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Fugue_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Fugue_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Fugue-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Fugue-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => Fugue_ByteDigest_AddBits , & Fugue_HexDigest_AddBits ! --------------------------------------------------------------------- FINAL :: Fugue_Finalize ! --------------------------------------------------------------------- END TYPE Fugue !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> FugueCore is a procedure to process input data. <br> SUBROUTINE FugueCore ( MD , BytesIn ) IMPORT CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! *Fugue* object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block END SUBROUTINE !> FugueClose is a procedure to add the last byte and then perform !  the final padding and store the result in the provided buffer. SUBROUTINE FugueClose ( MD , LastByte , NBits , BytesOut ) IMPORT CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Fugue_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Create ( 256 ) RETURN END SUBROUTINE Fugue_Initialize !****************************************************************************** SUBROUTINE Fugue_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), TARGET , INTENT ( INOUT ) :: MD !! 'Fugue' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set security SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT ! set digest length SELECT CASE ( MD % Security ) CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT ! set pointers SELECT CASE ( MD % DigestLen ) CASE ( 28 , 32 ) MD % State ( 0 : 29 ) => MD % Store ( 0 : 29 ) MD % DoUpdate => Fugue2_Core MD % DoFinal => Fugue2_Close CASE ( 48 ) MD % State ( 0 : 35 ) => MD % Store ( 0 : 35 ) MD % DoUpdate => Fugue3_Core MD % DoFinal => Fugue3_Close CASE ( 64 ) MD % State ( 0 : 35 ) => MD % Store ( 0 : 35 ) MD % DoUpdate => Fugue4_Core MD % DoFinal => Fugue4_Close END SELECT ! reset CALL MD % Reset () RETURN END SUBROUTINE Fugue_Initialize_wSecurity !****************************************************************************** SUBROUTINE Fugue_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( MD % DigestLen ) CASE ( 28 ) MD % Store ( 0 : 22 ) = 0 MD % Store ( 23 : 29 ) = IV224 ( 0 : 6 ) CASE ( 32 ) MD % Store ( 0 : 21 ) = 0 MD % Store ( 22 : 29 ) = IV256 ( 0 : 7 ) CASE ( 48 ) MD % Store ( 0 : 23 ) = 0 MD % Store ( 24 : 35 ) = IV384 ( 0 : 11 ) CASE ( 64 ) MD % Store ( 0 : 19 ) = 0 MD % Store ( 20 : 35 ) = IV512 ( 0 : 15 ) END SELECT MD % BitCount = 0_kInt64 MD % Partial = 0 MD % PartialLen = 0 MD % RoundShift = 0 RETURN END SUBROUTINE Fugue_Reset !****************************************************************************** SUBROUTINE Fugue_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Fugue :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Fugue ) CALL Dst % Create ( Src % Security ) Dst % State = Src % State Dst % BitCount = Src % BitCount Dst % Partial = Src % Partial Dst % PartialLen = Src % PartialLen Dst % RoundShift = Src % RoundShift END SELECT RETURN END SUBROUTINE Fugue_GetClone !****************************************************************************** FUNCTION Fugue_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( IN ) :: MD !! 'Fugue' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'Fugue-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION Fugue_GetName !****************************************************************************** FUNCTION Fugue_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( IN ) :: MD !! 'Fugue' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Fugue_GetDigestLen !****************************************************************************** SUBROUTINE Fugue_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % DoUpdate ( ByteArr ( Offset : Offset + Length - 1 )) RETURN END SUBROUTINE Fugue_InsertBytes !****************************************************************************** SUBROUTINE Fugue_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % DoUpdate ( InpPtr ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE Fugue_InsertGen !****************************************************************************** SUBROUTINE Fugue_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % AddBitsNDigest ( 0_kInt8 , 0_kInt8 , ByteArr ) RETURN END SUBROUTINE Fugue_ByteDigest !****************************************************************************** SUBROUTINE Fugue_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE Fugue_ByteDigest_wInput !****************************************************************************** SUBROUTINE Fugue_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) CALL MD % DoFinal ( LastByte , NBits , ByteArr ) CALL MD % Reset () RETURN END SUBROUTINE Fugue_ByteDigest_AddBits !****************************************************************************** SUBROUTINE Fugue_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Fugue_HexDigest_AddBits !****************************************************************************** SUBROUTINE Fugue_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Fugue ), INTENT ( INOUT ) :: MD !! 'Fugue' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % State ) NULLIFY ( MD % DoUpdate ) NULLIFY ( MD % DoFinal ) RETURN END SUBROUTINE Fugue_Finalize !****************************************************************************** SUBROUTINE Fugue2_Core ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , CurID tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: P , PLen , RShift , Count , Tmp , Q ! FLOW Length = SIZE ( BytesIn , KIND = kIndex ) CORE_ENTRY ( BytesIn , Length ) RShift = MD % RoundShift DO IF ( RShift == 0 ) THEN Q = P TIX2 ( Q , S00 , S01 , S08 , S10 , S24 ) CMIX30 ( S27 , S28 , S29 , S01 , S02 , S03 , S12 , S13 , S14 ) SMIX ( S27 , S28 , S29 , S00 ) CMIX30 ( S24 , S25 , S26 , S28 , S29 , S00 , S09 , S10 , S11 ) SMIX ( S24 , S25 , S26 , S27 ) NEXT ( 1 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 1 ) THEN Q = P TIX2 ( Q , S24 , S25 , S02 , S04 , S18 ) CMIX30 ( S21 , S22 , S23 , S25 , S26 , S27 , S06 , S07 , S08 ) SMIX ( S21 , S22 , S23 , S24 ) CMIX30 ( S18 , S19 , S20 , S22 , S23 , S24 , S03 , S04 , S05 ) SMIX ( S18 , S19 , S20 , S21 ) NEXT ( 2 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 2 ) THEN Q = P TIX2 ( Q , S18 , S19 , S26 , S28 , S12 ) CMIX30 ( S15 , S16 , S17 , S19 , S20 , S21 , S00 , S01 , S02 ) SMIX ( S15 , S16 , S17 , S18 ) CMIX30 ( S12 , S13 , S14 , S16 , S17 , S18 , S27 , S28 , S29 ) SMIX ( S12 , S13 , S14 , S15 ) NEXT ( 3 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 3 ) THEN Q = P TIX2 ( Q , S12 , S13 , S20 , S22 , S06 ) CMIX30 ( S09 , S10 , S11 , S13 , S14 , S15 , S24 , S25 , S26 ) SMIX ( S09 , S10 , S11 , S12 ) CMIX30 ( S06 , S07 , S08 , S10 , S11 , S12 , S21 , S22 , S23 ) SMIX ( S06 , S07 , S08 , S09 ) NEXT ( 4 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 4 ) THEN Q = P TIX2 ( Q , S06 , S07 , S14 , S16 , S00 ) CMIX30 ( S03 , S04 , S05 , S07 , S08 , S09 , S18 , S19 , S20 ) SMIX ( S03 , S04 , S05 , S06 ) CMIX30 ( S00 , S01 , S02 , S04 , S05 , S06 , S15 , S16 , S17 ) SMIX ( S00 , S01 , S02 , S03 ) NEXT ( 0 , BytesIn , Length ) ! fall through END IF ! reset RShift in order to loop over through all IFs ! until all input data are processed RShift = 0 END DO CORE_EXIT ( BytesIn , Length ) RETURN END SUBROUTINE Fugue2_Core !****************************************************************************** SUBROUTINE Fugue3_Core ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , CurID tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: P , PLen , RShift , Count , Tmp , Q ! FLOW Length = SIZE ( BytesIn , KIND = kIndex ) CORE_ENTRY ( BytesIn , Length ) RShift = MD % RoundShift DO IF ( RShift == 0 ) THEN Q = P TIX3 ( Q , S00 , S01 , S04 , S08 , S16 , S27 , S30 ) CMIX36 ( S33 , S34 , S35 , S01 , S02 , S03 , S15 , S16 , S17 ) SMIX ( S33 , S34 , S35 , S00 ) CMIX36 ( S30 , S31 , S32 , S34 , S35 , S00 , S12 , S13 , S14 ) SMIX ( S30 , S31 , S32 , S33 ) CMIX36 ( S27 , S28 , S29 , S31 , S32 , S33 , S09 , S10 , S11 ) SMIX ( S27 , S28 , S29 , S30 ) NEXT ( 1 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 1 ) THEN Q = P TIX3 ( Q , S27 , S28 , S31 , S35 , S07 , S18 , S21 ) CMIX36 ( S24 , S25 , S26 , S28 , S29 , S30 , S06 , S07 , S08 ) SMIX ( S24 , S25 , S26 , S27 ) CMIX36 ( S21 , S22 , S23 , S25 , S26 , S27 , S03 , S04 , S05 ) SMIX ( S21 , S22 , S23 , S24 ) CMIX36 ( S18 , S19 , S20 , S22 , S23 , S24 , S00 , S01 , S02 ) SMIX ( S18 , S19 , S20 , S21 ) NEXT ( 2 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 2 ) THEN Q = P TIX3 ( Q , S18 , S19 , S22 , S26 , S34 , S09 , S12 ) CMIX36 ( S15 , S16 , S17 , S19 , S20 , S21 , S33 , S34 , S35 ) SMIX ( S15 , S16 , S17 , S18 ) CMIX36 ( S12 , S13 , S14 , S16 , S17 , S18 , S30 , S31 , S32 ) SMIX ( S12 , S13 , S14 , S15 ) CMIX36 ( S09 , S10 , S11 , S13 , S14 , S15 , S27 , S28 , S29 ) SMIX ( S09 , S10 , S11 , S12 ) NEXT ( 3 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 3 ) THEN Q = P TIX3 ( Q , S09 , S10 , S13 , S17 , S25 , S00 , S03 ) CMIX36 ( S06 , S07 , S08 , S10 , S11 , S12 , S24 , S25 , S26 ) SMIX ( S06 , S07 , S08 , S09 ) CMIX36 ( S03 , S04 , S05 , S07 , S08 , S09 , S21 , S22 , S23 ) SMIX ( S03 , S04 , S05 , S06 ) CMIX36 ( S00 , S01 , S02 , S04 , S05 , S06 , S18 , S19 , S20 ) SMIX ( S00 , S01 , S02 , S03 ) NEXT ( 0 , BytesIn , Length ) END IF ! reset RShift in order to loop over through all IFs ! until all input data are processed RShift = 0 END DO CORE_EXIT ( BytesIn , Length ) RETURN END SUBROUTINE Fugue3_Core !****************************************************************************** SUBROUTINE Fugue4_Core ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: ! To process input data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length , CurID tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: P , PLen , RShift , Count , Tmp , Q ! FLOW Length = SIZE ( BytesIn , KIND = kIndex ) CORE_ENTRY ( BytesIn , Length ) RShift = MD % RoundShift DO IF ( RShift == 0 ) THEN Q = P TIX4 ( Q , S00 , S01 , S04 , S07 , S08 , S22 , S24 , S27 , S30 ) CMIX36 ( S33 , S34 , S35 , S01 , S02 , S03 , S15 , S16 , S17 ) SMIX ( S33 , S34 , S35 , S00 ) CMIX36 ( S30 , S31 , S32 , S34 , S35 , S00 , S12 , S13 , S14 ) SMIX ( S30 , S31 , S32 , S33 ) CMIX36 ( S27 , S28 , S29 , S31 , S32 , S33 , S09 , S10 , S11 ) SMIX ( S27 , S28 , S29 , S30 ) CMIX36 ( S24 , S25 , S26 , S28 , S29 , S30 , S06 , S07 , S08 ) SMIX ( S24 , S25 , S26 , S27 ) NEXT ( 1 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 1 ) THEN Q = P TIX4 ( Q , S24 , S25 , S28 , S31 , S32 , S10 , S12 , S15 , S18 ) CMIX36 ( S21 , S22 , S23 , S25 , S26 , S27 , S03 , S04 , S05 ) SMIX ( S21 , S22 , S23 , S24 ) CMIX36 ( S18 , S19 , S20 , S22 , S23 , S24 , S00 , S01 , S02 ) SMIX ( S18 , S19 , S20 , S21 ) CMIX36 ( S15 , S16 , S17 , S19 , S20 , S21 , S33 , S34 , S35 ) SMIX ( S15 , S16 , S17 , S18 ) CMIX36 ( S12 , S13 , S14 , S16 , S17 , S18 , S30 , S31 , S32 ) SMIX ( S12 , S13 , S14 , S15 ) NEXT ( 2 , BytesIn , Length ) ! fall through END IF IF ( RShift <= 2 ) THEN Q = P TIX4 ( Q , S12 , S13 , S16 , S19 , S20 , S34 , S00 , S03 , S06 ) CMIX36 ( S09 , S10 , S11 , S13 , S14 , S15 , S27 , S28 , S29 ) SMIX ( S09 , S10 , S11 , S12 ) CMIX36 ( S06 , S07 , S08 , S10 , S11 , S12 , S24 , S25 , S26 ) SMIX ( S06 , S07 , S08 , S09 ) CMIX36 ( S03 , S04 , S05 , S07 , S08 , S09 , S21 , S22 , S23 ) SMIX ( S03 , S04 , S05 , S06 ) CMIX36 ( S00 , S01 , S02 , S04 , S05 , S06 , S18 , S19 , S20 ) SMIX ( S00 , S01 , S02 , S03 ) NEXT ( 0 , BytesIn , Length ) END IF ! reset RShift in order to loop over through all IFs ! until all input data are processed RShift = 0 END DO CORE_EXIT ( BytesIn , Length ) RETURN END SUBROUTINE Fugue4_Core !****************************************************************************** SUBROUTINE Fugue2_Close ( MD , LastByte , NBits , BytesOut ) !** PURPOSE OF THIS SUBROUTINE: ! To add the last byte, perform final padding and ! return the output in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: LastByte ! the last byte tByte , INTENT ( IN ) :: NBits ! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) ! the output buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: TmpS ( 0 : 29 ) tInteger :: S ( 0 : 29 ) tByte :: TmpBuf ( 0 : 15 ) tInteger :: PLen , Rms , Tmp , I ! FLOW CLOSE_ENTRY ( 30 , 6 , Fugue2_Core ) DO I = 0 , 9 ROR ( 3 , 30 ) CMIX30 ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 4 ), S ( 5 ), S ( 6 ), S ( 15 ), S ( 16 ), S ( 17 )) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO DO I = 0 , 12 S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 15 ) = IEOR ( S ( 15 ), S ( 0 )) ROR ( 15 , 30 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 16 ) = IEOR ( S ( 16 ), S ( 0 )) ROR ( 14 , 30 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 15 ) = IEOR ( S ( 15 ), S ( 0 )) CALL ByteUnpackBE ( S ( 1 ), BytesOut , 0_kIndex ) CALL ByteUnpackBE ( S ( 2 ), BytesOut , 4_kIndex ) CALL ByteUnpackBE ( S ( 3 ), BytesOut , 8_kIndex ) CALL ByteUnpackBE ( S ( 4 ), BytesOut , 12_kIndex ) CALL ByteUnpackBE ( S ( 15 ), BytesOut , 16_kIndex ) CALL ByteUnpackBE ( S ( 16 ), BytesOut , 20_kIndex ) CALL ByteUnpackBE ( S ( 17 ), BytesOut , 24_kIndex ) IF ( MD % DigestLen >= 32 ) THEN CALL ByteUnpackBE ( S ( 18 ), BytesOut , 28_kIndex ) END IF RETURN END SUBROUTINE Fugue2_Close !****************************************************************************** SUBROUTINE Fugue3_Close ( MD , LastByte , NBits , BytesOut ) !** PURPOSE OF THIS SUBROUTINE: ! To add the last byte, perform final padding and ! return the output in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: LastByte ! the last byte tByte , INTENT ( IN ) :: NBits ! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) ! the output buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: TmpS ( 0 : 35 ) tInteger :: S ( 0 : 35 ) tByte :: TmpBuf ( 0 : 15 ) tInteger :: PLen , Rms , Tmp , I ! FLOW CLOSE_ENTRY ( 36 , 9 , Fugue3_Core ) DO I = 0 , 17 ROR ( 3 , 36 ) CMIX30 ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 4 ), S ( 5 ), S ( 6 ), S ( 18 ), S ( 19 ), S ( 20 )) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO DO I = 0 , 12 S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 12 ) = IEOR ( S ( 12 ), S ( 0 )) S ( 24 ) = IEOR ( S ( 24 ), S ( 0 )) ROR ( 12 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 13 ) = IEOR ( S ( 13 ), S ( 0 )) S ( 24 ) = IEOR ( S ( 24 ), S ( 0 )) ROR ( 12 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 13 ) = IEOR ( S ( 13 ), S ( 0 )) S ( 25 ) = IEOR ( S ( 25 ), S ( 0 )) ROR ( 11 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 12 ) = IEOR ( S ( 12 ), S ( 0 )) S ( 24 ) = IEOR ( S ( 24 ), S ( 0 )) CALL ByteUnpackBE ( S ( 1 ), BytesOut , 0_kIndex ) CALL ByteUnpackBE ( S ( 2 ), BytesOut , 4_kIndex ) CALL ByteUnpackBE ( S ( 3 ), BytesOut , 8_kIndex ) CALL ByteUnpackBE ( S ( 4 ), BytesOut , 12_kIndex ) CALL ByteUnpackBE ( S ( 12 ), BytesOut , 16_kIndex ) CALL ByteUnpackBE ( S ( 13 ), BytesOut , 20_kIndex ) CALL ByteUnpackBE ( S ( 14 ), BytesOut , 24_kIndex ) CALL ByteUnpackBE ( S ( 15 ), BytesOut , 28_kIndex ) CALL ByteUnpackBE ( S ( 24 ), BytesOut , 32_kIndex ) CALL ByteUnpackBE ( S ( 25 ), BytesOut , 36_kIndex ) CALL ByteUnpackBE ( S ( 26 ), BytesOut , 40_kIndex ) CALL ByteUnpackBE ( S ( 27 ), BytesOut , 44_kIndex ) RETURN END SUBROUTINE Fugue3_Close !****************************************************************************** SUBROUTINE Fugue4_Close ( MD , LastByte , NBits , BytesOut ) !** PURPOSE OF THIS SUBROUTINE: ! To add the last byte, perform final padding and ! return the output in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Fugue ), INTENT ( INOUT ) :: MD ! 'FugueCore' object tByte , INTENT ( IN ) :: LastByte ! the last byte tByte , INTENT ( IN ) :: NBits ! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) ! the output buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: C0 , C1 , C2 , C3 tInteger :: R0 , R1 , R2 , R3 tInteger :: TmpS ( 0 : 35 ) tInteger :: S ( 0 : 35 ) tByte :: TmpBuf ( 0 : 15 ) tInteger :: PLen , Rms , Tmp , I ! FLOW CLOSE_ENTRY ( 36 , 12 , Fugue4_Core ) DO I = 0 , 31 ROR ( 3 , 36 ) CMIX30 ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 4 ), S ( 5 ), S ( 6 ), S ( 18 ), S ( 19 ), S ( 20 )) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO DO I = 0 , 12 S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 9 ) = IEOR ( S ( 9 ), S ( 0 )) S ( 18 ) = IEOR ( S ( 18 ), S ( 0 )) S ( 27 ) = IEOR ( S ( 27 ), S ( 0 )) ROR ( 9 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 10 ) = IEOR ( S ( 10 ), S ( 0 )) S ( 18 ) = IEOR ( S ( 18 ), S ( 0 )) S ( 27 ) = IEOR ( S ( 27 ), S ( 0 )) ROR ( 9 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 10 ) = IEOR ( S ( 10 ), S ( 0 )) S ( 19 ) = IEOR ( S ( 19 ), S ( 0 )) S ( 27 ) = IEOR ( S ( 27 ), S ( 0 )) ROR ( 9 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 10 ) = IEOR ( S ( 10 ), S ( 0 )) S ( 19 ) = IEOR ( S ( 19 ), S ( 0 )) S ( 28 ) = IEOR ( S ( 28 ), S ( 0 )) ROR ( 8 , 36 ) SMIX ( S ( 0 ), S ( 1 ), S ( 2 ), S ( 3 )) END DO S ( 4 ) = IEOR ( S ( 4 ), S ( 0 )) S ( 9 ) = IEOR ( S ( 9 ), S ( 0 )) S ( 18 ) = IEOR ( S ( 18 ), S ( 0 )) S ( 27 ) = IEOR ( S ( 27 ), S ( 0 )) CALL ByteUnpackBE ( S ( 1 ), BytesOut , 0_kIndex ) CALL ByteUnpackBE ( S ( 2 ), BytesOut , 4_kIndex ) CALL ByteUnpackBE ( S ( 3 ), BytesOut , 8_kIndex ) CALL ByteUnpackBE ( S ( 4 ), BytesOut , 12_kIndex ) CALL ByteUnpackBE ( S ( 9 ), BytesOut , 16_kIndex ) CALL ByteUnpackBE ( S ( 10 ), BytesOut , 20_kIndex ) CALL ByteUnpackBE ( S ( 11 ), BytesOut , 24_kIndex ) CALL ByteUnpackBE ( S ( 12 ), BytesOut , 28_kIndex ) CALL ByteUnpackBE ( S ( 18 ), BytesOut , 32_kIndex ) CALL ByteUnpackBE ( S ( 19 ), BytesOut , 36_kIndex ) CALL ByteUnpackBE ( S ( 20 ), BytesOut , 40_kIndex ) CALL ByteUnpackBE ( S ( 21 ), BytesOut , 44_kIndex ) CALL ByteUnpackBE ( S ( 27 ), BytesOut , 48_kIndex ) CALL ByteUnpackBE ( S ( 28 ), BytesOut , 52_kIndex ) CALL ByteUnpackBE ( S ( 29 ), BytesOut , 56_kIndex ) CALL ByteUnpackBE ( S ( 30 ), BytesOut , 60_kIndex ) RETURN END SUBROUTINE Fugue4_Close !****************************************************************************** #include    \"Includes/Fugue_Undef Macro.f90\" END MODULE MClass_Fugue !******************************************************************************","tags":"","loc":"sourcefile\\mclass_fugue.f90.html"},{"title":"MClass_Skein.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Skein !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Skein* type and its related routines. !   The *Skein* type is a *digest* type that extends directly from the !   <a href=\"../module/mclass_basedigest.html#type-basedigest\">BaseDigest</a> !   type.  It implements all deferred procedures required by a digest type. <br> !   The *Skein* type implements an incremental cryptographic hash !   function by employing the *Skein message-digest* algorithm [1]. !   The implementation here is mainly based on the references [2]. <br> !   The *Skein* type represents four cryptographic hash functions: the !   *Skein-224*, *Skein-256*, *Skein-384*, and *Skein-512* hash functions. !   By default, the *Skein* type represents the *Skein-256* hash function. !   However, a user can specify the *Security* argument (to one of the !   four applicable values: 224, 256, 384 and 512) when initializing the !   digest object in order to use a different hash function and get a !   different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www.schneier.com/academic/skein/\"> !       The Skein Hash Function Family. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers , ONLY : MemAlloc USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MBase_ByteUtil , ONLY : AnyType_2_ByteArrPtr , ByteArr_2_HexStr => ToHexStr_BE USE MClass_BaseDigest IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: Skein PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tByte , PARAMETER :: FByte80 = ToInt8 ( Z '80' ) tByte , PARAMETER :: FByteFF = ToInt8 ( Z 'FF' ) tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tLong , PARAMETER :: IV224 ( 0 : 7 ) = [ & ToInt64 ( Z 'CCD0616248677224' ), ToInt64 ( Z 'CBA65CF3A92339EF' ), & ToInt64 ( Z '8CCD69D652FF4B64' ), ToInt64 ( Z '398AED7B3AB890B4' ), & ToInt64 ( Z '0F59D1B1457D2BD0' ), ToInt64 ( Z '6776FE6575D4EB3D' ), & ToInt64 ( Z '99FBC70E997413E9' ), ToInt64 ( Z '9E2CFCCFE1C41EF7' )] tLong , PARAMETER :: IV256 ( 0 : 7 ) = [ & ToInt64 ( Z 'CCD044A12FDB3E13' ), ToInt64 ( Z 'E83590301A79A9EB' ), & ToInt64 ( Z '55AEA0614F816E6F' ), ToInt64 ( Z '2A2767A4AE9B94DB' ), & ToInt64 ( Z 'EC06025E74DD7683' ), ToInt64 ( Z 'E7A436CDC4746251' ), & ToInt64 ( Z 'C36FBAF9393AD185' ), ToInt64 ( Z '3EEDBA1833EDFC13' )] tLong , PARAMETER :: IV384 ( 0 : 7 ) = [ & ToInt64 ( Z 'A3F6C6BF3A75EF5F' ), ToInt64 ( Z 'B0FEF9CCFD84FAA4' ), & ToInt64 ( Z '9D77DD663D770CFE' ), ToInt64 ( Z 'D798CBF3B468FDDA' ), & ToInt64 ( Z '1BC4A6668A0E4465' ), ToInt64 ( Z '7ED7D434E5807407' ), & ToInt64 ( Z '548FC1ACD4EC44D6' ), ToInt64 ( Z '266E17546AA18FF8' )] tLong , PARAMETER :: IV512 ( 0 : 7 ) = [ & ToInt64 ( Z '4903ADFF749C51CE' ), ToInt64 ( Z '0D95DE399746DF03' ), & ToInt64 ( Z '8FD1934127C79BCE' ), ToInt64 ( Z '9A255629FF352CB1' ), & ToInt64 ( Z '5DB62599DF6CA7B0' ), ToInt64 ( Z 'EABE394CA9D5C3F4' ), & ToInt64 ( Z '991112C71A75B523' ), ToInt64 ( Z 'AE18A40B660FCC33' )] !** DERIVED TYPE DEFINITIONS !> *Skein* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the Skein hash algorithms. TYPE , EXTENDS ( BaseDigest ) :: Skein PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state variables (State will point to the first 8 elements of H) tLong :: H ( 0 : 26 ) = 0_kInt64 tLong , POINTER :: State (:) => NULL () !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 !% the number of blocks of input processed tLong :: BlockCount = 0_kInt64 !% the number of bytes of input currently stored in the buffer tIndex :: BufLen = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Skein_ByteDigest_AddBits PROCEDURE , PRIVATE :: Skein_HexDigest_AddBits PROCEDURE , PRIVATE :: ProcessBlock => Skein_ProcessBlock PROCEDURE , PRIVATE :: InitializeWSecurity => Skein_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (Skein-256). PROCEDURE :: Initialize => Skein_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => Skein_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => Skein_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => Skein_GetName !> Use the *Update* method in place of the *InsertBytes* method to insert input !  data as an array of bytes (8-bit integers) where the offset (zero-based) into !  the array and the length of the input in bytes are specified. PROCEDURE :: InsertBytes => Skein_InsertBytes !> Use the *Update* method in place of the *InsertGen* method to insert !  input data in a generic way where the *Input* argument can be any type and !  any rank and the *InpSize* argument specifies the size of input data in bytes. PROCEDURE :: InsertGen => Skein_InsertGen !> Use the *Digest* method in place of the *ByteDigest* method to finalize the !  current hash computation and return the hash value as an array of bytes !  in a newly-allocated array. PROCEDURE :: ByteDigest => Skein_ByteDigest !> Use the *Digest* method in place of the *ByteDigest_wInput* method to insert final !  input in a generic way and then finalize the current hash computation and return !  the hash value as an array of bytes in a newly-allocated array. PROCEDURE :: ByteDigest_wInput => Skein_ByteDigest_wInput ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => Skein_GetDigestLen ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (Skein-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Skein-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity !> **Type-Bound Subroutine**: AddBitsNDigest <br> !  **Purpose**:  To add the last byte and then finalize the current hash computation !                and return the hash output. The object is reset. <br> !  **Usage**: <br> !   ! insert final input and return hash output as a byte array <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, ByteArr) <br> !   ! insert final input and return hash output as a hexadecimal string <br> !   --->    CALL MD%AddBitsNDigest(Input, InpSize, HexStr) <br> !  **Note**: <br> !  This method is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  The method is intended to be used by a digest type that implements a hash function !  that is an entrant of the SHA-3 competition.  It is mainly used for a test purpose. GENERIC :: AddBitsNDigest => Skein_ByteDigest_AddBits , & Skein_HexDigest_AddBits ! --------------------------------------------------------------------- FINAL :: Skein_Finalize ! --------------------------------------------------------------------- END TYPE Skein !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE Skein_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Create ( 256 ) RETURN END SUBROUTINE Skein_Initialize !****************************************************************************** SUBROUTINE Skein_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), TARGET , INTENT ( INOUT ) :: MD !! 'Skein' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT SELECT CASE ( MD % Security ) CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT MD % State ( 0 : 7 ) => MD % H ( 0 : 7 ) CALL MD % Reset () RETURN END SUBROUTINE Skein_Initialize_wSecurity !****************************************************************************** SUBROUTINE Skein_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % H = 0_kInt64 SELECT CASE ( MD % Security ) CASE ( 224 ) MD % H ( 0 : 7 ) = IV224 CASE ( 256 ) MD % H ( 0 : 7 ) = IV256 CASE ( 384 ) MD % H ( 0 : 7 ) = IV384 CASE ( 512 ) MD % H ( 0 : 7 ) = IV512 END SELECT MD % BufLen = 0_kIndex MD % BlockCount = 0_kInt64 RETURN END SUBROUTINE Skein_Reset !****************************************************************************** SUBROUTINE Skein_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Skein :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( Skein ) CALL Dst % Create ( Src % Security ) Dst % H = Src % H Dst % BufArr = Src % BufArr Dst % BufLen = Src % BufLen Dst % BlockCount = Src % BlockCount END SELECT RETURN END SUBROUTINE Skein_GetClone !****************************************************************************** FUNCTION Skein_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( IN ) :: MD !! 'Skein' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'Skein-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION Skein_GetName !****************************************************************************** FUNCTION Skein_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( IN ) :: MD !! 'Skein' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION Skein_GetDigestLen !****************************************************************************** SUBROUTINE Skein_ProcessBlock ( MD , EType , Extra ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object tInteger , INTENT ( IN ) :: EType tInteger , INTENT ( IN ) :: Extra !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: M ( 0 : 7 ), P ( 0 : 7 ) tLong :: T0 , T1 , T2 , Temp tInteger :: I , S !** SUBROUTINE MACRO DEFINITIONS: #define TFBIG_MIX(X0, X1, RC) \\ X0 = X0 + X1 ; \\ X1 = IEOR ( RotateLeft ( X1 , RC ), X0 ); #define TFBIG_MIX8(W0, W1, W2, W3, W4, W5, W6, W7, RC0, RC1, RC2, RC3) \\ TFBIG_MIX ( W0 , W1 , RC0 ); \\ TFBIG_MIX ( W2 , W3 , RC1 ); \\ TFBIG_MIX ( W4 , W5 , RC2 ); \\ TFBIG_MIX ( W6 , W7 , RC3 ); #define TFBIG_ADDKEY(R, H, SS, TT0, TT1) \\ R ( 0 ) = R ( 0 ) + H ( SS ); \\ R ( 1 ) = R ( 1 ) + H ( SS + 1 ); \\ R ( 2 ) = R ( 2 ) + H ( SS + 2 ); \\ R ( 3 ) = R ( 3 ) + H ( SS + 3 ); \\ R ( 4 ) = R ( 4 ) + H ( SS + 4 ); \\ R ( 5 ) = R ( 5 ) + H ( SS + 5 ) + TT0 ; \\ R ( 6 ) = R ( 6 ) + H ( SS + 6 ) + TT1 ; \\ R ( 7 ) = R ( 7 ) + H ( SS + 7 ) + SS ; #define TFBIG_4E(S) \\ TFBIG_ADDKEY ( P , MD % H , S , T0 , T1 ); \\ TFBIG_MIX8 ( P ( 0 ), P ( 1 ), P ( 2 ), P ( 3 ), P ( 4 ), P ( 5 ), P ( 6 ), P ( 7 ), 46 , 36 , 19 , 37 ); \\ TFBIG_MIX8 ( P ( 2 ), P ( 1 ), P ( 4 ), P ( 7 ), P ( 6 ), P ( 5 ), P ( 0 ), P ( 3 ), 33 , 27 , 14 , 42 ); \\ TFBIG_MIX8 ( P ( 4 ), P ( 1 ), P ( 6 ), P ( 3 ), P ( 0 ), P ( 5 ), P ( 2 ), P ( 7 ), 17 , 49 , 36 , 39 ); \\ TFBIG_MIX8 ( P ( 6 ), P ( 1 ), P ( 0 ), P ( 7 ), P ( 2 ), P ( 5 ), P ( 4 ), P ( 3 ), 44 , 9 , 54 , 56 ); #define TFBIG_4O(S) \\ TFBIG_ADDKEY ( P , MD % H , S , T1 , T2 ); \\ TFBIG_MIX8 ( P ( 0 ), P ( 1 ), P ( 2 ), P ( 3 ), P ( 4 ), P ( 5 ), P ( 6 ), P ( 7 ), 39 , 30 , 34 , 24 ); \\ TFBIG_MIX8 ( P ( 2 ), P ( 1 ), P ( 4 ), P ( 7 ), P ( 6 ), P ( 5 ), P ( 0 ), P ( 3 ), 13 , 50 , 10 , 17 ); \\ TFBIG_MIX8 ( P ( 4 ), P ( 1 ), P ( 6 ), P ( 3 ), P ( 0 ), P ( 5 ), P ( 2 ), P ( 7 ), 25 , 29 , 39 , 43 ); \\ TFBIG_MIX8 ( P ( 6 ), P ( 1 ), P ( 0 ), P ( 7 ), P ( 2 ), P ( 5 ), P ( 4 ), P ( 3 ), 8 , 35 , 56 , 22 ); ! FLOW ! get input CALL BytePackLE ( MD % BufArr , 0_kIndex , M ) ! initialize P ( 0 : 7 ) = M ( 0 : 7 ) MD % H ( 8 ) = IEOR ( IEOR ( IEOR ( IEOR ( MD % State ( 0 ), MD % State ( 1 )), IEOR ( MD % State ( 2 ), MD % State ( 3 ))), & IEOR ( IEOR ( MD % State ( 4 ), MD % State ( 5 )), IEOR ( MD % State ( 6 ), MD % State ( 7 )))), & ToInt64 ( Z '1BD11BDAA9FC1A22' )) T0 = SHIFTL ( MD % BlockCount , 6 ) + ToInt64 ( Extra ) T1 = SHIFTR ( MD % BlockCount , 58 ) + SHIFTL ( ToInt64 ( EType ), 55 ) T2 = IEOR ( T0 , T1 ) DO I = 0 , 15 , 3 MD % H ( I + 9 ) = MD % H ( I ) MD % H ( I + 10 ) = MD % H ( I + 1 ) MD % H ( I + 11 ) = MD % H ( I + 2 ) END DO ! transform DO I = 0 , 8 S = SHIFTL ( I , 1 ) TFBIG_4E ( S ) TFBIG_4O ( S + 1 ) Temp = T2 T2 = T1 T1 = T0 T0 = Temp END DO TFBIG_ADDKEY ( P , MD % H , 18 , T0 , T1 ) ! get output DO I = 0 , 7 MD % State ( I ) = IEOR ( M ( I ), P ( I )) END DO RETURN #undef TFBIG_MIX #undef TFBIG_MIX8 #undef TFBIG_ADDKEY #undef TFBIG_4E #undef TFBIG_4O END SUBROUTINE Skein_ProcessBlock !****************************************************************************** SUBROUTINE Skein_InsertBytes ( MD , ByteArr , Offset , Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data as a byte (8-bit integer) array where offset (zero-based) !  and length are specified. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object tByte , INTENT ( IN ) :: ByteArr ( 0 :) !! a byte array of input data tIndex , INTENT ( IN ) :: Offset !! the offset in input data tIndex , INTENT ( IN ) :: Length !! the length of input data in bytes !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CLen , CurPos , CurLen tInteger :: EType ! FLOW IF ( Length == 0_kIndex ) RETURN CLen = BlockLen - MD % BufLen IF ( Length <= CLen ) THEN MD % BufArr ( MD % BufLen : MD % BufLen + Length - 1 ) = ByteArr ( Offset : Offset + Length - 1 ) MD % BufLen = MD % BufLen + Length RETURN END IF CurPos = Offset CurLen = Length IF ( CLen /= 0_kIndex ) THEN MD % BufArr ( MD % BufLen : MD % BufLen + CLen - 1 ) = ByteArr ( CurPos : CurPos + CLen - 1 ) CurPos = CurPos + CLen CurLen = CurLen - CLen END IF DO IF ( MD % BlockCount == 0_kInt64 ) THEN EType = 224 ELSE EType = 96 END IF MD % BlockCount = MD % BlockCount + 1_kInt64 CALL MD % ProcessBlock ( EType , 0 ) IF ( CurLen <= BlockLen ) EXIT MD % BufArr ( 0 : BlockLen - 1 ) = ByteArr ( CurPos : CurPos + BlockLen - 1 ) CurPos = CurPos + BlockLen CurLen = CurLen - BlockLen END DO MD % BufArr ( 0 : CurLen - 1 ) = ByteArr ( CurPos : CurPos + CurLen - 1 ) MD % BufLen = CurLen RETURN END SUBROUTINE Skein_InsertBytes !****************************************************************************** SUBROUTINE Skein_InsertGen ( MD , Input , InpSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert input data in a generic way where the *Input* argument can be !  any type and any rank and the *InpSize* argument specifies the size of !  the input data in a number of bytes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , POINTER :: InpPtr (:) ! FLOW ! set pointer to the input CALL AnyType_2_ByteArrPtr ( Input , InpSize , InpPtr ) ! insert the input data as a byte array CALL MD % Update ( InpPtr , 0_kIndex , InpSize ) NULLIFY ( InpPtr ) RETURN END SUBROUTINE Skein_InsertGen !****************************************************************************** SUBROUTINE Skein_ByteDigest ( MD , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  as an array of (8-bit integer) bytes in a newly-allocated array. !  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % AddBitsNDigest ( 0_kInt8 , 0_kInt8 , ByteArr ) RETURN END SUBROUTINE Skein_ByteDigest !****************************************************************************** SUBROUTINE Skein_ByteDigest_wInput ( MD , Input , InpSize , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert final input in a generic way and then finalize the current hash !  computation and return the hash value as an array of (8-bit integer) bytes !  in a newly-allocated array.  The digest object is reset. <br> !  **Important Note**: The newly-allocated array has a zero-based index. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % Update ( Input , InpSize ) CALL MD % Digest ( ByteArr ) RETURN END SUBROUTINE Skein_ByteDigest_wInput !****************************************************************************** SUBROUTINE Skein_ByteDigest_AddBits ( MD , LastByte , NBits , ByteArr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a byte array. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , ALLOCATABLE , INTENT ( OUT ) :: ByteArr (:) !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I tInteger :: EType , Add tByte :: TmpOut ( 0 : BlockLen - 1 ) tByte :: X , Z ! FLOW ! Add bit padding if necessary IF ( NBits /= 0_kInt8 ) THEN Z = SHIFTR ( FByte80 , NBits ) X = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) CALL MD % Update ( X , 1_kIndex ) Add = 1 ELSE Add = 0 END IF ! At that point, if BufLen == 0, then the message was empty; ! otherwise, there is between 1 and 64 bytes (inclusive) which ! are yet to be processed. Either way, we complete the buffer ! to a full block with zeros (the Skein specification mandates ! that an empty message is padded so that there is at least ! one block to process). ! ! Once this block has been processed, we do it again, with ! a block full of zeros, for the output (that block contains ! the encoding of \"0\", over 8 bytes, then padded with zeros). ! pad zero to the end of the buffer MD % BufArr ( MD % BufLen : BlockLen - 1 ) = 0_kInt8 ! process the buffer IF ( MD % BlockCount == 0_kInt64 ) THEN EType = 480 + Add ELSE EType = 352 + Add END IF CALL MD % ProcessBlock ( EType , ToInt32 ( MD % BufLen )) ! reset Buffer and BCount MD % BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 MD % BlockCount = 0_kInt64 ! process the buffer CALL MD % ProcessBlock ( 510 , 8 ) ! get output DO I = 0 , 7 CALL ByteUnpackLE ( MD % State ( I ), TmpOut , SHIFTL ( I , 3 )) END DO CALL MemAlloc ( ByteArr , MD % DigestLen , StartID = 0_kIndex ) ByteArr ( 0 : MD % DigestLen - 1 ) = TmpOut ( 0 : MD % DigestLen - 1 ) ! reset the states CALL MD % Reset () RETURN END SUBROUTINE Skein_ByteDigest_AddBits !****************************************************************************** SUBROUTINE Skein_HexDigest_AddBits ( MD , LastByte , NBits , HexStr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then finalize the current hash computation !  and return the hash output as a hexadecimal string. <br> !  This routine is only used for an input message whose bit length is not !  a multiple of eight (i.e. a message with partial bytes). <br> !  This procedure is intended to be used by a digest type that implements !  a hash function that is an entrant of the SHA-3 competition.  It is mainly !  used for a test purpose. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tCharAlloc , INTENT ( OUT ) :: HexStr !! the hash output !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte , ALLOCATABLE :: ByteArr (:) ! FLOW CALL MD % AddBitsNDigest ( LastByte , NBits , ByteArr ) CALL ByteArr_2_HexStr ( ByteArr , HexStr ) RETURN END SUBROUTINE Skein_HexDigest_AddBits !****************************************************************************** SUBROUTINE Skein_Finalize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free a pointer component of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Skein ), INTENT ( INOUT ) :: MD !! 'Skein' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( MD % State ) RETURN END SUBROUTINE Skein_Finalize !****************************************************************************** END MODULE MClass_Skein !******************************************************************************","tags":"","loc":"sourcefile\\mclass_skein.f90.html"},{"title":"MClass_EchoB.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_EChoB !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *EChoB* type and its related routines. !   The *EChoB* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *EChoB* type implements an incremental cryptographic hash function !   by employing either the *ECHO-384* or the *ECHO-512* algorithm [1].  The !   implementation here is based mainly on the *SPHLIB* implementation [2].  <br> !   By default, the *EChoB* type employs the *ECHO-512 message-digest* !   algorithm.  However, a user can specify the *IsECHO384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *ECHO-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://web.archive.org/web/20180315075044/http://crypto.rd.francetelecom.com/ECHO/\"> !       ECHO hash function. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: EChoB PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 #include    \"Includes/AES_LittleEndian.f90\" !** MODULE PARAMETERS: #include    \"Includes/AES_Constants.f90\" tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *EChoB* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either !  the *ECHO-384* or the *ECHO-512 message-digest* algorithm. TYPE , EXTENDS ( MDEngine ) :: EChoB PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state and counter variables tInteger :: V ( 0 : 31 ) = 0 tInteger :: C ( 0 : 3 ) = 0 !% flag indicating whether the ECHO-384 algorithm is employed or not. tLogical :: IsECHO384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                    Private Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => EChoB_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (ECHO-512). PROCEDURE :: Initialize => EChoB_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => EChoB_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => EChoB_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => EChoB_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => EChoB_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => EChoB_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => EChoB_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => EChoB_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => EChoB_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => EChoB_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (ECHO-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the ECHO-384 algorithm <br> !   --->    CALL MD%Create(IsECHO384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag ! --------------------------------------------------------------------- END TYPE EChoB !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE EChoB_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the ECHO-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE EChoB_Initialize !****************************************************************************** SUBROUTINE EChoB_Initialize_wFlag ( MD , IsECHO384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object tLogical , INTENT ( IN ) :: IsECHO384 !&#94; flag indicating whether the ECHO-384 algorithm is employed or not. <br> !  - If true, use the ECHO-384 algorithm. <br> !  - Otherwise, use the ECHO-512 algorithm. <br> !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsECHO384 = IsECHO384 CALL MD % Reset () RETURN END SUBROUTINE EChoB_Initialize_wFlag !****************************************************************************** SUBROUTINE EChoB_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW MD % BufArr = 0_kInt8 MD % C = 0 MD % V = 0 MD % V ( 0 ) = ToInt32 ( SHIFTL ( MD % GetDigestLen (), 3 )) DO I = 1 , 7 MD % V ( I * 4 ) = MD % V ( 0 ) END DO CALL MD % EngineReset () RETURN END SUBROUTINE EChoB_Reset !****************************************************************************** SUBROUTINE EChoB_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( EChoB :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( EChoB ) CALL Dst % Create ( Src % IsECHO384 ) Dst % V = Src % V Dst % C = Src % C Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE EChoB_GetClone !****************************************************************************** FUNCTION EChoB_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( IN ) :: MD !! 'EChoB' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsECHO384 ) THEN Name = 'ECHO-384' ELSE Name = 'ECHO-512' END IF RETURN END FUNCTION EChoB_GetName !****************************************************************************** FUNCTION EChoB_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( IN ) :: MD !! 'EChoB' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsECHO384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION EChoB_GetDigestLen !****************************************************************************** FUNCTION EChoB_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( IN ) :: MD !! 'EChoB' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION EChoB_GetBlockLen !****************************************************************************** SUBROUTINE EChoB_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), TARGET , INTENT ( INOUT ) :: MD !! 'EChoB' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE EChoB_SetBufPtr !****************************************************************************** SUBROUTINE EChoB_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: IncVal ! FLOW ! increment value IncVal = 1024 ! increment counters CALL IncrementCounters ( MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), IncVal ) ! compress CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), BytesIn ) RETURN END SUBROUTINE EChoB_ProcessBlock !****************************************************************************** SUBROUTINE EChoB_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE EChoB_DoPadding !****************************************************************************** SUBROUTINE EChoB_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( EChoB ), INTENT ( INOUT ) :: MD !! 'EChoB' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Ptr , OutLen , I tInteger :: C0 , C1 , C2 , C3 , ELen tByte :: Z ! FLOW ! padding ASSOCIATE ( TmpBuf => MD % BufArr ) Ptr = MD % GetBufLen () ELen = SHIFTL ( Ptr , 3 ) + NBits CALL IncrementCounters ( MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), ELen ) C0 = MD % C ( 0 ) C1 = MD % C ( 1 ) C2 = MD % C ( 2 ) C3 = MD % C ( 3 ) ! If ELen is zero, then this block actually contains no message ! bit, only the first padding bit. IF ( ELen == 0 ) THEN MD % C ( 0 ) = 0 MD % C ( 1 ) = 0 MD % C ( 2 ) = 0 MD % C ( 3 ) = 0 END IF Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( Ptr ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) Ptr = Ptr + 1 IF ( Ptr > 110 ) THEN TmpBuf ( Ptr : 127 ) = FByte00 CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), TmpBuf ) MD % C ( 0 ) = 0 MD % C ( 1 ) = 0 MD % C ( 2 ) = 0 MD % C ( 3 ) = 0 Ptr = 0 END IF TmpBuf ( Ptr : 109 ) = FByte00 OutLen = SHIFTL ( MD % GetDigestLen (), 3 ) TmpBuf ( 110 ) = ToInt8 ( OutLen ) TmpBuf ( 111 ) = ToInt8 ( SHIFTR ( OutLen , 8 )) CALL ByteUnpackLE ( C0 , TmpBuf , 112_kIndex ) CALL ByteUnpackLE ( C1 , TmpBuf , 116_kIndex ) CALL ByteUnpackLE ( C2 , TmpBuf , 120_kIndex ) CALL ByteUnpackLE ( C3 , TmpBuf , 124_kIndex ) CALL Compress ( MD % V , MD % C ( 0 ), MD % C ( 1 ), MD % C ( 2 ), MD % C ( 3 ), TmpBuf ) END ASSOCIATE ! finalizing OutLen = SHIFTR ( OutLen , 5 ) DO I = 0 , OutLen - 1 CALL ByteUnpackLE ( MD % V ( I ), BytesOut , Offset + SHIFTL ( I , 2 )) END DO RETURN END SUBROUTINE EChoB_AddBitsNPad !****************************************************************************** SUBROUTINE IncrementCounters ( C0 , C1 , C2 , C3 , IncVal ) !** PURPOSE OF THIS SUBROUTINE: ! To increment counters. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: C0 , C1 , C2 , C3 tInteger , INTENT ( IN ) :: IncVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW C0 = C0 + IncVal IF (( C0 >= 0 ). AND .( C0 < IncVal )) THEN C1 = C1 + 1 IF ( C1 == 0 ) THEN C2 = C2 + 1 IF ( C2 == 0 ) THEN C3 = C3 + 1 END IF END IF END IF RETURN END SUBROUTINE IncrementCounters !****************************************************************************** SUBROUTINE Compress ( V , C0 , C1 , C2 , C3 , InpDat ) !** PURPOSE OF THIS SUBROUTINE: ! To compress input block. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: V ( 0 :) ! state values tInteger , INTENT ( IN ) :: C0 , C1 , C2 , C3 ! constants tByte , INTENT ( IN ) :: InpDat ( 0 :) ! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: K0 , K1 , K2 , K3 tInteger :: A , Tmp tInteger :: Y0 , Y1 , Y2 , Y3 tInteger , TARGET :: W2D ( 0 : 3 , 0 : 15 ) tInteger , POINTER :: W1D (:) tIndex :: U , I , J !** SUBROUTINE MACRO DEFINITIONS: #define AES_2ROUNDS(W, C)   \\ AES_ROUND_LE ( W ( 0 , C ), W ( 1 , C ), W ( 2 , C ), W ( 3 , C ), K0 , K1 , K2 , K3 , Y0 , Y1 , Y2 , Y3 ); \\ AES_ROUND_NOKEY_LE ( Y0 , Y1 , Y2 , Y3 , W ( 0 , C ), W ( 1 , C ), W ( 2 , C ), W ( 3 , C )); \\ K0 = K0 + 1 ; \\ IF ( K0 == 0 ) THEN ; \\ K1 = K1 + 1 ; \\ IF ( K1 == 0 ) THEN ; \\ K2 = K2 + 1 ; \\ IF ( K2 == 0 ) THEN ; \\ K3 = K3 + 1 ; \\ END IF ; \\ END IF ; \\ END IF ; #define BIG_SUB_WORDS(W) \\ DO I = 0 , 15 ; \\ AES_2ROUNDS ( W , I ); \\ END DO ; #define SHIFT_ROW1(W, A, B, C, D)  \\ Tmp = W ( 0 , A ); \\ W ( 0 , A ) = W ( 0 , B ); \\ W ( 0 , B ) = W ( 0 , C ); \\ W ( 0 , C ) = W ( 0 , D ); \\ W ( 0 , D ) = Tmp ; \\ Tmp = W ( 1 , A ); \\ W ( 1 , A ) = W ( 1 , B ); \\ W ( 1 , B ) = W ( 1 , C ); \\ W ( 1 , C ) = W ( 1 , D ); \\ W ( 1 , D ) = Tmp ; \\ Tmp = W ( 2 , A ); \\ W ( 2 , A ) = W ( 2 , B ); \\ W ( 2 , B ) = W ( 2 , C ); \\ W ( 2 , C ) = W ( 2 , D ); \\ W ( 2 , D ) = Tmp ; \\ Tmp = W ( 3 , A ); \\ W ( 3 , A ) = W ( 3 , B ); \\ W ( 3 , B ) = W ( 3 , C ); \\ W ( 3 , C ) = W ( 3 , D ); \\ W ( 3 , D ) = Tmp ; #define SHIFT_ROW2(W, A, B, C, D)  \\ Tmp = W ( 0 , A ); \\ W ( 0 , A ) = W ( 0 , C ); \\ W ( 0 , C ) = Tmp ; \\ Tmp = W ( 0 , B ); \\ W ( 0 , B ) = W ( 0 , D ); \\ W ( 0 , D ) = Tmp ; \\ Tmp = W ( 1 , A ); \\ W ( 1 , A ) = W ( 1 , C ); \\ W ( 1 , C ) = Tmp ; \\ Tmp = W ( 1 , B ); \\ W ( 1 , B ) = W ( 1 , D ); \\ W ( 1 , D ) = Tmp ; \\ Tmp = W ( 2 , A ); \\ W ( 2 , A ) = W ( 2 , C ); \\ W ( 2 , C ) = Tmp ; \\ Tmp = W ( 2 , B ); \\ W ( 2 , B ) = W ( 2 , D ); \\ W ( 2 , D ) = Tmp ; \\ Tmp = W ( 3 , A ); \\ W ( 3 , A ) = W ( 3 , C ); \\ W ( 3 , C ) = Tmp ; \\ Tmp = W ( 3 , B ); \\ W ( 3 , B ) = W ( 3 , D ); \\ W ( 3 , D ) = Tmp ; #define SHIFT_ROW3(W, A, B, C, D)   SHIFT_ROW1(W, D, C, B, A) #define BIG_SHIFT_ROWS(W)  \\ SHIFT_ROW1 ( W , 1 , 5 , 9 , 13 ); \\ SHIFT_ROW2 ( W , 2 , 6 , 10 , 14 ); \\ SHIFT_ROW3 ( W , 3 , 7 , 11 , 15 ); #define BIG_MIX_COLUMNS(W) \\ CALL MixColumn ( W , 0 , 1 , 2 , 3 ); \\ CALL MixColumn ( W , 4 , 5 , 6 , 7 ); \\ CALL MixColumn ( W , 8 , 9 , 10 , 11 ); \\ CALL MixColumn ( W , 12 , 13 , 14 , 15 ); ! FLOW ! set Ks K0 = C0 K1 = C1 K2 = C2 K3 = C3 ! set pointer W1D ( 0 : 63 ) => W2D ! +++ INPUT_BLOCK_SMALL +++ ! copy state values W1D ( 0 : 31 ) = V ( 0 : 31 ) ! get input block CALL BytePackLE ( InpDat , 0_kIndex , W1D ( 32 : 63 )) DO U = 0 , 9 ! +++ BIG_ROUND +++ BIG_SUB_WORDS ( W2D ) BIG_SHIFT_ROWS ( W2D ) BIG_MIX_COLUMNS ( W2D ) END DO ! +++ FINAL_SMALL +++ ! get output and return state values J = 0_kIndex DO I = 0 , 31 CALL BytePackLE ( InpDat , J , A ) V ( I ) = IEOR ( V ( I ), IEOR ( IEOR ( A , W1D ( I )), W1D ( I + 32 ))) J = J + 4_kIndex END DO NULLIFY ( W1D ) RETURN #undef AES_2ROUNDS #undef BIG_SUB_WORDS #undef SHIFT_ROW1 #undef SHIFT_ROW2 #undef SHIFT_ROW3 #undef BIG_SHIFT_ROWS #undef MIX_COLUMN #undef BIG_MIX_COLUMNS #include \"Includes/AES_Undef Macro.f90\" CONTAINS SUBROUTINE MixColumn ( W , IA , IB , IC , ID ) !** PURPOSE OF THIS SUBROUTINE: ! To perform mixing of columns of W. !** SUBROUTINE ARGUMENT DECLARATIONS: tInteger , INTENT ( INOUT ) :: W ( 0 :, 0 :) tInteger , INTENT ( IN ) :: IA , IB , IC , ID !** SUBROUTINE PARAMETER DECLARATIONS: tInteger , PARAMETER :: C1 = ToInt32 ( Z '80808080' ) tInteger , PARAMETER :: C2 = ToInt32 ( Z '7F7F7F7F' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D tInteger :: AB , BC , CD tInteger :: ABX , BCX , CDX tInteger :: N ! FLOW DO N = 0 , 3 A = W ( N , IA ) B = W ( N , IB ) C = W ( N , IC ) D = W ( N , ID ) AB = IEOR ( A , B ) BC = IEOR ( B , C ) CD = IEOR ( C , D ) ABX = IEOR ( SHIFTR ( IAND ( AB , C1 ), 7 ) * 27 , SHIFTL ( IAND ( AB , C2 ), 1 )) BCX = IEOR ( SHIFTR ( IAND ( BC , C1 ), 7 ) * 27 , SHIFTL ( IAND ( BC , C2 ), 1 )) CDX = IEOR ( SHIFTR ( IAND ( CD , C1 ), 7 ) * 27 , SHIFTL ( IAND ( CD , C2 ), 1 )) W ( N , IA ) = IEOR ( IEOR ( ABX , BC ), D ) W ( N , IB ) = IEOR ( IEOR ( BCX , A ), CD ) W ( N , IC ) = IEOR ( IEOR ( CDX , AB ), D ) W ( N , ID ) = IEOR ( IEOR ( IEOR ( IEOR ( ABX , BCX ), CDX ), AB ), C ) END DO RETURN END SUBROUTINE MixColumn !************************************************************************** END SUBROUTINE Compress !****************************************************************************** END MODULE MClass_EChoB !******************************************************************************","tags":"","loc":"sourcefile\\mclass_echob.f90.html"},{"title":"MClass_HalfSip24Hasher32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HalfSip24Hasher32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HalfSip24Hasher32* type and its related routines. !   The *HalfSip24Hasher32* type is a hasher type that extends directly from the !   <a href=\"../module/mclass_hasher32.html#type-hasher32\">Hasher32</a> type. !   It provides all deferred procedures required by a *Hasher32* class and !   outputs the hash value as a 32-bit integer. <br> !   The *HalfSip24Hasher32* type employs the *HalfSip24* hash algorithm for !   32-bit integer output by Jean-Philippe Aumasson [1].  As a hasher, it can be !   used to compute the hash value incrementally.  It also provides a method to !   compute the hash value directly (i.e. non-incrementally).  The following code !   snippet illustrates a typical usage of the hasher. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! first, initialize the hasher (once) !   CALL Hasher%Initialize(Seed) !   ! then, put data into the hasher (a number of times) !   CALL Hasher%Update(Input, InpSize) !               ... !               ... !               ... !   ! finally, get the hash value from the hasher (once) !   HashCode = Hasher%Finalize() !   </Code></Pre> !   However, if the *Update* method is to be called only one time, then the !   *HashDirect* method should be employed as follows. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! directly compute the hash value !   HashCode = Hasher%HashDirect(Input, InpSize, Seed) !   </Code></Pre> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/veorq/SipHash\">SipHash: high-speed secure pseudorandom !       function for short messages. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Hasher32 IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HalfSip24Hasher32 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../../MacroDef/Macro - Util Definitions.f90\" #define MaskI32(X)      IAND(ToInt64(X), ToInt64(Z'00000000FFFFFFFF')) #define SipRound(V0, V1, V2, V3) \\ V0 = V0 + V1 ; \\ V1 = RotateLeft ( V1 , 5 ); \\ V1 = IEOR ( V1 , V0 ); \\ V0 = RotateLeft ( V0 , 16 ); \\ V2 = V2 + V3 ; \\ V3 = RotateLeft ( V3 , 8 ); \\ V3 = IEOR ( V3 , V2 ); \\ V0 = V0 + V3 ; \\ V3 = RotateLeft ( V3 , 7 ); \\ V3 = IEOR ( V3 , V0 ); \\ V2 = V2 + V1 ; \\ V1 = RotateLeft ( V1 , 13 ); \\ V1 = IEOR ( V1 , V2 ); \\ V2 = RotateLeft ( V2 , 16 ); #define MaskInt32(X)          IAND(ToInt32(X), Z'000000FF') #define UnsignedShort(Val, Off) IOR(MaskInt32(Val(Off)), SHIFTL(MaskInt32(Val(Off+1)), 8)) #define PackFull(Buf, Off)      IOR(UnsignedShort(Buf, Off), SHIFTL(UnsignedShort(Buf, Off+2), 16)) !** MODULE PARAMETERS: tUInt8 , PARAMETER :: DefaultKey ( 8 ) = [ ToInt8 ( Z 'AF' ), ToInt8 ( Z 'D7' ), & ToInt8 ( Z 'FB' ), ToInt8 ( Z 'CA' ), & ToInt8 ( Z 'BB' ), ToInt8 ( Z '4B' ), & ToInt8 ( Z '40' ), ToInt8 ( Z '7E' )] !** DERIVED TYPE DEFINITIONS !> *HalfSip24Hasher32* is a hasher type that outputs the hash value as a 32-bit integer. !  It employs the *HalfSip24* hash algorithm by Jean-Philippe Aumasson. TYPE , EXTENDS ( Hasher32 ) :: HalfSip24Hasher32 PRIVATE !% state tUInt32 :: State ( 4 ) = 0_kInt32 !% buffer array used to store input data tUInt8 :: BufArr ( 0 : 3 ) = 0_kInt8 !% flag indicating whether to remove sign from the final hash value tLogical :: RemoveSign = FalseVal CONTAINS !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the hasher. <br> !  **Usage**: <br> !   --->    Name = Hasher%GetName() PROCEDURE :: GetName => HalfSip24_GetName !> *GetBlockLength* is a procedure to return the block length of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: GetBlockLength => HalfSip24_BlockLength !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => HalfSip24_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this hasher. <br> !  This procedure is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => HalfSip24_ProcessBlock !> **Type-Bound Subroutine**: Initialize <br> !  **Purpose**:  To initialize the hasher. <br> !  **Usage**: <br> !   --->    CALL Hasher%Initialize(Seed)            ! hash value with sign <br> !   --->    CALL Hasher%Initialize(Seed, .TRUE.)    ! remove sign from hash value <br> PROCEDURE :: Initialize => HalfSip24_Initialize !> **Type-Bound Subroutine**: InitializeWKey <br> !  **Purpose**:  To initialize the hasher with a key. <br> !  **Usage**: <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key)           ! hash value with sign <br> !   --->    CALL Hasher%InitializeWKey(Seed, Key, .TRUE.)   ! remove sign from hash value <br> PROCEDURE :: InitializeWKey => HalfSip24_Initialize_wKey !> **Type-Bound Function**: Finalize <br> !  **Purpose**:  To finalize the current hash computation and return the hash value !                in a 32-bit integer.  The object is reset. <br> !  **Usage**: <br> !   --->    HashCode = Hasher%Finalize() PROCEDURE :: Finalize => HalfSip24_Finalize !> **Type-Bound Function**: HashDirect <br> !  **Purpose**:  To compute the hash value directly (non-incrementally). <br> !  **Usage**: <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, Seed) <br> !   --->    HashCode = Hasher%HashDirect(Input, InpSize, RemoveSign=.TRUE.) <br> !  **Note**: The specified input can be any type and any rank where its size is !            the number of bytes of storage used by the input. PROCEDURE :: HashDirect => HalfSip24_HashDirect END TYPE HalfSip24Hasher32 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION HalfSip24_GetName ( HS ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the display name for this hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Name = 'HalfSip24_Hahser32' ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION HalfSip24_GetName !****************************************************************************** FUNCTION HalfSip24_BlockLength ( HS ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the *block length* for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), INTENT ( IN ) :: HS !! a hasher (HS) object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Length = 4_kIndex ASSOCIATE ( Dummy => HS ); END ASSOCIATE RETURN END FUNCTION HalfSip24_BlockLength !****************************************************************************** SUBROUTINE HalfSip24_SetBufPtr ( HS , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => HS % BufArr RETURN END SUBROUTINE HalfSip24_SetBufPtr !****************************************************************************** SUBROUTINE HalfSip24_ProcessBlock ( HS , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt8 , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Mi !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) Mi = PackFull ( BytesIn , 0_kIndex ) V3 = IEOR ( V3 , Mi ) SipRound ( V0 , V1 , V2 , V3 ) SipRound ( V0 , V1 , V2 , V3 ) V0 = IEOR ( V0 , Mi ) END ASSOCIATE RETURN END SUBROUTINE HalfSip24_ProcessBlock !****************************************************************************** SUBROUTINE HalfSip24_Initialize ( HS , Seed , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL HS % InitializeWKey ( Seed , DefaultKey , RemoveSign ) RETURN END SUBROUTINE HalfSip24_Initialize !****************************************************************************** SUBROUTINE HalfSip24_Initialize_wKey ( HS , Seed , Key , RemoveSign ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To initialize the hasher. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), TARGET , INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 , INTENT ( IN ) :: Seed !! seed tUInt8 , INTENT ( IN ) :: Key ( 0 : 7 ) !! key bytes tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: K0 , K1 !** FLOW ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) V0 = 0 V1 = Seed V2 = ToInt32 ( Z '6C796765' ) V3 = ToInt32 ( Z '74656462' ) K0 = PackFull ( Key , 0 ) K1 = PackFull ( Key , 4 ) V3 = IEOR ( V3 , K1 ) V2 = IEOR ( V2 , K0 ) V1 = IEOR ( V1 , K1 ) V0 = IEOR ( V0 , K0 ) END ASSOCIATE SET_OPTION ( HS % RemoveSign , FalseVal , RemoveSign ) CALL HS % Reset () RETURN END SUBROUTINE HalfSip24_Initialize_wKey !****************************************************************************** FUNCTION HalfSip24_Finalize ( HS ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To finalize the current hash computation and return the hash value !  in a 32-bit integer.  The object is reset. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: B tIndex :: Length , Remaining !** FLOW ! initialize Remaining = HS % GetBufLen () IF ( HS % GetBlockCount () > 0_kIndex ) THEN Length = HS % GetBlockCount () * HS % GetBlockLength () + Remaining ELSE Length = Remaining END IF B = SHIFTL ( ToInt32 ( Length ), 24 ) ! process remaining IF ( Remaining > 0_kIndex ) B = B + Pack_Partial ( HS % BufArr , Remaining ) ! finalize ASSOCIATE ( V0 => HS % State ( 1 ), V1 => HS % State ( 2 ), & V2 => HS % State ( 3 ), V3 => HS % State ( 4 )) V3 = IEOR ( V3 , B ) SipRound ( V0 , V1 , V2 , V3 ) SipRound ( V0 , V1 , V2 , V3 ) V0 = IEOR ( V0 , B ) V2 = IEOR ( V2 , Z '000000FF' ) SipRound ( V0 , V1 , V2 , V3 ) SipRound ( V0 , V1 , V2 , V3 ) SipRound ( V0 , V1 , V2 , V3 ) SipRound ( V0 , V1 , V2 , V3 ) HashCode = IEOR ( V1 , V3 ) END ASSOCIATE ! remove sign if needed IF ( HS % RemoveSign ) HashCode = IAND ( HashCode , ToInt32 ( Z '7FFFFFFF' )) ! reset the hasher HS % State = 0_kInt32 HS % BufArr = 0_kInt8 HS % RemoveSign = FalseVal CALL HS % Reset () RETURN CONTAINS FUNCTION Pack_Partial ( Buf , Length ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To pack seven or fewer bytes of the array 'Buf' at offset 'Off' ! into the 64-bit word 'Res', in little-endian convention ! (least significant byte first). !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt8 , INTENT ( INOUT ) :: Buf ( 0 :) ! buffer tIndex , INTENT ( IN ) :: Length ! the number of bytes to pack (between 1 to 3) tUInt32 :: Res ! result !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Buf ( Length : 3 ) = 0_kInt8 Res = PackFull ( Buf , 0_kIndex ) RETURN END FUNCTION Pack_Partial !************************************************************************** END FUNCTION HalfSip24_Finalize !****************************************************************************** FUNCTION HalfSip24_HashDirect ( HS , Input , InpSize , Seed , RemoveSign ) RESULT ( HashCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash value directly (non-incremental). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HalfSip24Hasher32 ), INTENT ( INOUT ) :: HS !! a hasher (HS) object TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input data (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt32 , OPTIONAL , INTENT ( IN ) :: Seed !! seed tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt32 :: HashCode !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt32 :: Seed0 !** FLOW SET_OPTION ( Seed0 , 0_kInt32 , Seed ) ! The following code illustrates simple use of the hasher. CALL HS % Initialize ( Seed0 , RemoveSign ) CALL HS % Update ( Input , InpSize ) HashCode = HS % Finalize () RETURN END FUNCTION HalfSip24_HashDirect !****************************************************************************** END MODULE MClass_HalfSip24Hasher32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_halfsip24hasher32.f90.html"},{"title":"MClass_SHA1.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHA1 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHA1* type and its related routines. !   The *SHA1* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SHA1* type implements an incremental cryptographic hash !   function by employing the *SHA-1 message-digest* algorithm where !   the algorithm is described in FIPS 180-4 [1]. The implementation !   here is mainly based on the *SPHLIB* implementation [2].  <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028%2FNIST.FIPS.180-4\">FIPS PUB 180-4: !       Secure Hash Standard (SHS). </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SHA1 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DigestLen = 20_kIndex tInteger , PARAMETER :: IV ( 0 : 4 ) = [ & ToInt32 ( Z '67452301' ), ToInt32 ( Z 'EFCDAB89' ), & ToInt32 ( Z '98BADCFE' ), ToInt32 ( Z '10325476' ), & ToInt32 ( Z 'C3D2E1F0' )] !** DERIVED TYPE DEFINITIONS !> *SHA1* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing !  the *SHA-1 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: SHA1 PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tInteger :: State ( 0 : 4 ) = IV ( 0 : 4 ) CONTAINS !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object before starting using it. PROCEDURE :: Initialize => SHA1_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA1_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA1_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA1_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA1_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA1_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA1_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA1_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA1_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA1_AddBitsNPad END TYPE SHA1 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHA1_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: MD !! 'SHA1' object !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperInit ( LittleEndian , 8_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE SHA1_Initialize !****************************************************************************** SUBROUTINE SHA1_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: MD !! 'SHA1' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 MD % State = IV CALL MD % HelperReset () RETURN END SUBROUTINE SHA1_Reset !****************************************************************************** SUBROUTINE SHA1_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHA1 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHA1 ) CALL Dst % Create () Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE SHA1_GetClone !****************************************************************************** FUNCTION SHA1_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( IN ) :: MD !! 'SHA1' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'SHA-1' ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA1_GetName !****************************************************************************** FUNCTION SHA1_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( IN ) :: MD !! 'SHA1' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = DigestLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA1_GetDigestLen !****************************************************************************** FUNCTION SHA1_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( IN ) :: MD !! 'SHA1' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA1_GetBlockLen !****************************************************************************** SUBROUTINE SHA1_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), TARGET , INTENT ( INOUT ) :: MD !! 'SHA1' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SHA1_SetBufPtr !****************************************************************************** SUBROUTINE SHA1_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: MD !! 'SHA1' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL PARAMETER DECLARATIONS: tInteger , PARAMETER :: K1 = ToInt32 ( Z '5A827999' ) tInteger , PARAMETER :: K2 = ToInt32 ( Z '6ED9EBA1' ) tInteger , PARAMETER :: K3 = ToInt32 ( Z '8F1BBCDC' ) tInteger , PARAMETER :: K4 = ToInt32 ( Z 'CA62C1D6' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tInteger :: A , B , C , D , E tInteger :: W ( 0 : 15 ) !** SUBROUTINE MACRO DEFINITIONS: #define FRound(X, Y, Z)         IEOR(IAND(IEOR(Y, Z), X), Z) #define GRound(X, Y, Z)         IEOR(IEOR(X, Y), Z) #define HRound(X, Y, Z)         IOR(IAND(Z, Y), IAND(IOR(Z, Y), X)) #define IRound(X, Y, Z)         GRound(X, Y, Z) #define XOR4(A, B, C, D)        IEOR(IEOR(IEOR(A, B), C), D) #define XOR_N_ROT(A, B, C, D)   RotateLeft(XOR4(A, B, C, D), 1) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) E = MD % State ( 4 ) CALL BytePackBE ( BytesIn , 0_kIndex , W ) ! F round E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 0 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 1 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 2 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 3 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 4 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 5 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 6 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 7 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 8 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 9 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 10 ) + K1 B = RotateLeft ( B , 30 ) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 11 ) + K1 A = RotateLeft ( A , 30 ) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 12 ) + K1 E = RotateLeft ( E , 30 ) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 13 ) + K1 D = RotateLeft ( D , 30 ) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 14 ) + K1 C = RotateLeft ( C , 30 ) E = RotateLeft ( A , 5 ) + FRound ( B , C , D ) + E + W ( 15 ) + K1 B = RotateLeft ( B , 30 ) W ( 0 ) = XOR_N_ROT ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) D = RotateLeft ( E , 5 ) + FRound ( A , B , C ) + D + W ( 0 ) + K1 A = RotateLeft ( A , 30 ) W ( 1 ) = XOR_N_ROT ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) C = RotateLeft ( D , 5 ) + FRound ( E , A , B ) + C + W ( 1 ) + K1 E = RotateLeft ( E , 30 ) W ( 2 ) = XOR_N_ROT ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) B = RotateLeft ( C , 5 ) + FRound ( D , E , A ) + B + W ( 2 ) + K1 D = RotateLeft ( D , 30 ) W ( 3 ) = XOR_N_ROT ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) A = RotateLeft ( B , 5 ) + FRound ( C , D , E ) + A + W ( 3 ) + K1 C = RotateLeft ( C , 30 ) ! G round W ( 4 ) = XOR_N_ROT ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 4 ) + K2 B = RotateLeft ( B , 30 ) W ( 5 ) = XOR_N_ROT ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 5 ) + K2 A = RotateLeft ( A , 30 ) W ( 6 ) = XOR_N_ROT ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 6 ) + K2 E = RotateLeft ( E , 30 ) W ( 7 ) = XOR_N_ROT ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 7 ) + K2 D = RotateLeft ( D , 30 ) W ( 8 ) = XOR_N_ROT ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 8 ) + K2 C = RotateLeft ( C , 30 ) W ( 9 ) = XOR_N_ROT ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 9 ) + K2 B = RotateLeft ( B , 30 ) W ( 10 ) = XOR_N_ROT ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 10 ) + K2 A = RotateLeft ( A , 30 ) W ( 11 ) = XOR_N_ROT ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 11 ) + K2 E = RotateLeft ( E , 30 ) W ( 12 ) = XOR_N_ROT ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 12 ) + K2 D = RotateLeft ( D , 30 ) W ( 13 ) = XOR_N_ROT ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 13 ) + K2 C = RotateLeft ( C , 30 ) W ( 14 ) = XOR_N_ROT ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 14 ) + K2 B = RotateLeft ( B , 30 ) W ( 15 ) = XOR_N_ROT ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 15 ) + K2 A = RotateLeft ( A , 30 ) W ( 0 ) = XOR_N_ROT ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 0 ) + K2 E = RotateLeft ( E , 30 ) W ( 1 ) = XOR_N_ROT ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 1 ) + K2 D = RotateLeft ( D , 30 ) W ( 2 ) = XOR_N_ROT ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 2 ) + K2 C = RotateLeft ( C , 30 ) W ( 3 ) = XOR_N_ROT ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) E = RotateLeft ( A , 5 ) + GRound ( B , C , D ) + E + W ( 3 ) + K2 B = RotateLeft ( B , 30 ) W ( 4 ) = XOR_N_ROT ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) D = RotateLeft ( E , 5 ) + GRound ( A , B , C ) + D + W ( 4 ) + K2 A = RotateLeft ( A , 30 ) W ( 5 ) = XOR_N_ROT ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) C = RotateLeft ( D , 5 ) + GRound ( E , A , B ) + C + W ( 5 ) + K2 E = RotateLeft ( E , 30 ) W ( 6 ) = XOR_N_ROT ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) B = RotateLeft ( C , 5 ) + GRound ( D , E , A ) + B + W ( 6 ) + K2 D = RotateLeft ( D , 30 ) W ( 7 ) = XOR_N_ROT ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) A = RotateLeft ( B , 5 ) + GRound ( C , D , E ) + A + W ( 7 ) + K2 C = RotateLeft ( C , 30 ) ! H round W ( 8 ) = XOR_N_ROT ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 8 ) + K3 B = RotateLeft ( B , 30 ) W ( 9 ) = XOR_N_ROT ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 9 ) + K3 A = RotateLeft ( A , 30 ) W ( 10 ) = XOR_N_ROT ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 10 ) + K3 E = RotateLeft ( E , 30 ) W ( 11 ) = XOR_N_ROT ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 11 ) + K3 D = RotateLeft ( D , 30 ) W ( 12 ) = XOR_N_ROT ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 12 ) + K3 C = RotateLeft ( C , 30 ) W ( 13 ) = XOR_N_ROT ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 13 ) + K3 B = RotateLeft ( B , 30 ) W ( 14 ) = XOR_N_ROT ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 14 ) + K3 A = RotateLeft ( A , 30 ) W ( 15 ) = XOR_N_ROT ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 15 ) + K3 E = RotateLeft ( E , 30 ) W ( 0 ) = XOR_N_ROT ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 0 ) + K3 D = RotateLeft ( D , 30 ) W ( 1 ) = XOR_N_ROT ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 1 ) + K3 C = RotateLeft ( C , 30 ) W ( 2 ) = XOR_N_ROT ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 2 ) + K3 B = RotateLeft ( B , 30 ) W ( 3 ) = XOR_N_ROT ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 3 ) + K3 A = RotateLeft ( A , 30 ) W ( 4 ) = XOR_N_ROT ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 4 ) + K3 E = RotateLeft ( E , 30 ) W ( 5 ) = XOR_N_ROT ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 5 ) + K3 D = RotateLeft ( D , 30 ) W ( 6 ) = XOR_N_ROT ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 6 ) + K3 C = RotateLeft ( C , 30 ) W ( 7 ) = XOR_N_ROT ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) E = RotateLeft ( A , 5 ) + HRound ( B , C , D ) + E + W ( 7 ) + K3 B = RotateLeft ( B , 30 ) W ( 8 ) = XOR_N_ROT ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) D = RotateLeft ( E , 5 ) + HRound ( A , B , C ) + D + W ( 8 ) + K3 A = RotateLeft ( A , 30 ) W ( 9 ) = XOR_N_ROT ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) C = RotateLeft ( D , 5 ) + HRound ( E , A , B ) + C + W ( 9 ) + K3 E = RotateLeft ( E , 30 ) W ( 10 ) = XOR_N_ROT ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) B = RotateLeft ( C , 5 ) + HRound ( D , E , A ) + B + W ( 10 ) + K3 D = RotateLeft ( D , 30 ) W ( 11 ) = XOR_N_ROT ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) A = RotateLeft ( B , 5 ) + HRound ( C , D , E ) + A + W ( 11 ) + K3 C = RotateLeft ( C , 30 ) ! I round where IRound = GRound W ( 12 ) = XOR_N_ROT ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 12 ) + K4 B = RotateLeft ( B , 30 ) W ( 13 ) = XOR_N_ROT ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 13 ) + K4 A = RotateLeft ( A , 30 ) W ( 14 ) = XOR_N_ROT ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 14 ) + K4 E = RotateLeft ( E , 30 ) W ( 15 ) = XOR_N_ROT ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 15 ) + K4 D = RotateLeft ( D , 30 ) W ( 0 ) = XOR_N_ROT ( W ( 13 ), W ( 8 ), W ( 2 ), W ( 0 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 0 ) + K4 C = RotateLeft ( C , 30 ) W ( 1 ) = XOR_N_ROT ( W ( 14 ), W ( 9 ), W ( 3 ), W ( 1 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 1 ) + K4 B = RotateLeft ( B , 30 ) W ( 2 ) = XOR_N_ROT ( W ( 15 ), W ( 10 ), W ( 4 ), W ( 2 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 2 ) + K4 A = RotateLeft ( A , 30 ) W ( 3 ) = XOR_N_ROT ( W ( 0 ), W ( 11 ), W ( 5 ), W ( 3 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 3 ) + K4 E = RotateLeft ( E , 30 ) W ( 4 ) = XOR_N_ROT ( W ( 1 ), W ( 12 ), W ( 6 ), W ( 4 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 4 ) + K4 D = RotateLeft ( D , 30 ) W ( 5 ) = XOR_N_ROT ( W ( 2 ), W ( 13 ), W ( 7 ), W ( 5 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 5 ) + K4 C = RotateLeft ( C , 30 ) W ( 6 ) = XOR_N_ROT ( W ( 3 ), W ( 14 ), W ( 8 ), W ( 6 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 6 ) + K4 B = RotateLeft ( B , 30 ) W ( 7 ) = XOR_N_ROT ( W ( 4 ), W ( 15 ), W ( 9 ), W ( 7 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 7 ) + K4 A = RotateLeft ( A , 30 ) W ( 8 ) = XOR_N_ROT ( W ( 5 ), W ( 0 ), W ( 10 ), W ( 8 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 8 ) + K4 E = RotateLeft ( E , 30 ) W ( 9 ) = XOR_N_ROT ( W ( 6 ), W ( 1 ), W ( 11 ), W ( 9 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 9 ) + K4 D = RotateLeft ( D , 30 ) W ( 10 ) = XOR_N_ROT ( W ( 7 ), W ( 2 ), W ( 12 ), W ( 10 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 10 ) + K4 C = RotateLeft ( C , 30 ) W ( 11 ) = XOR_N_ROT ( W ( 8 ), W ( 3 ), W ( 13 ), W ( 11 )) E = RotateLeft ( A , 5 ) + IRound ( B , C , D ) + E + W ( 11 ) + K4 B = RotateLeft ( B , 30 ) W ( 12 ) = XOR_N_ROT ( W ( 9 ), W ( 4 ), W ( 14 ), W ( 12 )) D = RotateLeft ( E , 5 ) + IRound ( A , B , C ) + D + W ( 12 ) + K4 A = RotateLeft ( A , 30 ) W ( 13 ) = XOR_N_ROT ( W ( 10 ), W ( 5 ), W ( 15 ), W ( 13 )) C = RotateLeft ( D , 5 ) + IRound ( E , A , B ) + C + W ( 13 ) + K4 E = RotateLeft ( E , 30 ) W ( 14 ) = XOR_N_ROT ( W ( 11 ), W ( 6 ), W ( 0 ), W ( 14 )) B = RotateLeft ( C , 5 ) + IRound ( D , E , A ) + B + W ( 14 ) + K4 D = RotateLeft ( D , 30 ) W ( 15 ) = XOR_N_ROT ( W ( 12 ), W ( 7 ), W ( 1 ), W ( 15 )) A = RotateLeft ( B , 5 ) + IRound ( C , D , E ) + A + W ( 15 ) + K4 C = RotateLeft ( C , 30 ) MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D MD % State ( 4 ) = MD % State ( 4 ) + E RETURN #undef FRound #undef GRound #undef HRound #undef IRound #undef XOR4 #undef XOR_N_ROT END SUBROUTINE SHA1_ProcessBlock !****************************************************************************** SUBROUTINE SHA1_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: MD !! 'SHA1' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MD % HelperPadding () CALL ByteUnpackBE ( MD % State , BytesOut , Offset ) RETURN END SUBROUTINE SHA1_DoPadding !****************************************************************************** SUBROUTINE SHA1_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA1 ), INTENT ( INOUT ) :: MD !! 'SHA1' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! SHA-1 algorithm does not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE SHA1_AddBitsNPad !****************************************************************************** END MODULE MClass_SHA1 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_sha1.f90.html"},{"title":"MClass_SHA2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHA2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHA2B* type and its related routines. !   The *SHA2B* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdhelper.html#type-mdhelper\">MDHelper</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SHA2B* type implements an incremental cryptographic hash !   function by employing the *SHA-384 or SHA-512 message-digest* !   algorithm where both algorithms are described in FIPS 180-4 [1]. !   The implementation here is mainly based on the references [2, 3].  <br> !   By default, the *SHA2B* type employs the *SHA-512 message-digest* !   algorithm.  However, a user can specify the *IsSHA384* flag to !   true when initializing the digest object (by calling the *Create* !   method) in order to use the *SHA-384 message-digest* algorithm !   instead of the default one. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://doi.org/10.6028%2FNIST.FIPS.180-4\">FIPS PUB 180-4: !       Secure Hash Standard (SHS). </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !   [3] <a href=\"https://github.com/bcgit/bc-java\">The Bouncy Castle Crypto !       Package For Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDHelper IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SHA2B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 128_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tLong , PARAMETER :: IV384 ( 0 : 7 ) = [ & ToInt64 ( Z 'CBBB9D5DC1059ED8' ), ToInt64 ( Z '629A292A367CD507' ), & ToInt64 ( Z '9159015A3070DD17' ), ToInt64 ( Z '152FECD8F70E5939' ), & ToInt64 ( Z '67332667FFC00B31' ), ToInt64 ( Z '8EB44A8768581511' ), & ToInt64 ( Z 'DB0C2E0D64F98FA7' ), ToInt64 ( Z '47B5481DBEFA4FA4' )] tLong , PARAMETER :: IV512 ( 0 : 7 ) = [ & ToInt64 ( Z '6A09E667F3BCC908' ), ToInt64 ( Z 'BB67AE8584CAA73B' ), & ToInt64 ( Z '3C6EF372FE94F82B' ), ToInt64 ( Z 'A54FF53A5F1D36F1' ), & ToInt64 ( Z '510E527FADE682D1' ), ToInt64 ( Z '9B05688C2B3E6C1F' ), & ToInt64 ( Z '1F83D9ABFB41BD6B' ), ToInt64 ( Z '5BE0CD19137E2179' )] tLong , PARAMETER :: K ( 0 : 79 ) = [ & ToInt64 ( Z '428A2F98D728AE22' ), ToInt64 ( Z '7137449123EF65CD' ), ToInt64 ( Z 'B5C0FBCFEC4D3B2F' ), & ToInt64 ( Z 'E9B5DBA58189DBBC' ), ToInt64 ( Z '3956C25BF348B538' ), ToInt64 ( Z '59F111F1B605D019' ), & ToInt64 ( Z '923F82A4AF194F9B' ), ToInt64 ( Z 'AB1C5ED5DA6D8118' ), ToInt64 ( Z 'D807AA98A3030242' ), & ToInt64 ( Z '12835B0145706FBE' ), ToInt64 ( Z '243185BE4EE4B28C' ), ToInt64 ( Z '550C7DC3D5FFB4E2' ), & ToInt64 ( Z '72BE5D74F27B896F' ), ToInt64 ( Z '80DEB1FE3B1696B1' ), ToInt64 ( Z '9BDC06A725C71235' ), & ToInt64 ( Z 'C19BF174CF692694' ), ToInt64 ( Z 'E49B69C19EF14AD2' ), ToInt64 ( Z 'EFBE4786384F25E3' ), & ToInt64 ( Z '0FC19DC68B8CD5B5' ), ToInt64 ( Z '240CA1CC77AC9C65' ), ToInt64 ( Z '2DE92C6F592B0275' ), & ToInt64 ( Z '4A7484AA6EA6E483' ), ToInt64 ( Z '5CB0A9DCBD41FBD4' ), ToInt64 ( Z '76F988DA831153B5' ), & ToInt64 ( Z '983E5152EE66DFAB' ), ToInt64 ( Z 'A831C66D2DB43210' ), ToInt64 ( Z 'B00327C898FB213F' ), & ToInt64 ( Z 'BF597FC7BEEF0EE4' ), ToInt64 ( Z 'C6E00BF33DA88FC2' ), ToInt64 ( Z 'D5A79147930AA725' ), & ToInt64 ( Z '06CA6351E003826F' ), ToInt64 ( Z '142929670A0E6E70' ), ToInt64 ( Z '27B70A8546D22FFC' ), & ToInt64 ( Z '2E1B21385C26C926' ), ToInt64 ( Z '4D2C6DFC5AC42AED' ), ToInt64 ( Z '53380D139D95B3DF' ), & ToInt64 ( Z '650A73548BAF63DE' ), ToInt64 ( Z '766A0ABB3C77B2A8' ), ToInt64 ( Z '81C2C92E47EDAEE6' ), & ToInt64 ( Z '92722C851482353B' ), ToInt64 ( Z 'A2BFE8A14CF10364' ), ToInt64 ( Z 'A81A664BBC423001' ), & ToInt64 ( Z 'C24B8B70D0F89791' ), ToInt64 ( Z 'C76C51A30654BE30' ), ToInt64 ( Z 'D192E819D6EF5218' ), & ToInt64 ( Z 'D69906245565A910' ), ToInt64 ( Z 'F40E35855771202A' ), ToInt64 ( Z '106AA07032BBD1B8' ), & ToInt64 ( Z '19A4C116B8D2D0C8' ), ToInt64 ( Z '1E376C085141AB53' ), ToInt64 ( Z '2748774CDF8EEB99' ), & ToInt64 ( Z '34B0BCB5E19B48A8' ), ToInt64 ( Z '391C0CB3C5C95A63' ), ToInt64 ( Z '4ED8AA4AE3418ACB' ), & ToInt64 ( Z '5B9CCA4F7763E373' ), ToInt64 ( Z '682E6FF3D6B2B8A3' ), ToInt64 ( Z '748F82EE5DEFB2FC' ), & ToInt64 ( Z '78A5636F43172F60' ), ToInt64 ( Z '84C87814A1F0AB72' ), ToInt64 ( Z '8CC702081A6439EC' ), & ToInt64 ( Z '90BEFFFA23631E28' ), ToInt64 ( Z 'A4506CEBDE82BDE9' ), ToInt64 ( Z 'BEF9A3F7B2C67915' ), & ToInt64 ( Z 'C67178F2E372532B' ), ToInt64 ( Z 'CA273ECEEA26619C' ), ToInt64 ( Z 'D186B8C721C0C207' ), & ToInt64 ( Z 'EADA7DD6CDE0EB1E' ), ToInt64 ( Z 'F57D4F7FEE6ED178' ), ToInt64 ( Z '06F067AA72176FBA' ), & ToInt64 ( Z '0A637DC5A2C898A6' ), ToInt64 ( Z '113F9804BEF90DAE' ), ToInt64 ( Z '1B710B35131C471B' ), & ToInt64 ( Z '28DB77F523047D84' ), ToInt64 ( Z '32CAAB7B40C72493' ), ToInt64 ( Z '3C9EBE0A15C9BEBC' ), & ToInt64 ( Z '431D67C49C100D4C' ), ToInt64 ( Z '4CC5D4BECB3E42B6' ), ToInt64 ( Z '597F299CFC657E2A' ), & ToInt64 ( Z '5FCB6FAB3AD6FAEC' ), ToInt64 ( Z '6C44198C4A475817' )] !** DERIVED TYPE DEFINITIONS !> *SHA2B* is a concrete *digest* type that implements an !  incremental cryptographic hash function by employing either the !  *SHA-384* or the *SHA-512 message-digest* algorithm. TYPE , EXTENDS ( MDHelper ) :: SHA2B PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tLong :: State ( 0 : 7 ) = IV512 ( 0 : 7 ) !% flag indicating whether the SHA-384 algorithm is employed or not. tLogical :: IsSHA384 = FalseVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWFlag* method to !  initialize the *digest* object with specified flag. PROCEDURE , PRIVATE :: InitializeWFlag => SHA2B_Initialize_wFlag ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA-512). PROCEDURE :: Initialize => SHA2B_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA2B_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA2B_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA2B_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA2B_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA2B_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA2B_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA2B_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA2B_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA2B_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA-512) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the SHA-384 algorithm <br> !   --->    CALL MD%Create(IsSHA384=.TRUE.) <br> GENERIC :: Create => InitializeWFlag END TYPE SHA2B !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHA2B_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHA-512 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SHA2B_Initialize !****************************************************************************** SUBROUTINE SHA2B_Initialize_wFlag ( MD , IsSHA384 ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object tLogical , INTENT ( IN ) :: IsSHA384 !&#94; flag indicating whether the SHA-384 algorithm is employed or not. <br> !  - If true, use the SHA-384 algorithm. <br> !  - Otherwise, use the SHA-512 algorithm. <br> !** SUBROUTINE PARAMETER DECLARATIONS: tLogical , PARAMETER :: LittleEndian = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % IsSHA384 = IsSHA384 CALL MD % HelperInit ( LittleEndian , 16_kIndex ) CALL MD % Reset () RETURN END SUBROUTINE SHA2B_Initialize_wFlag !****************************************************************************** SUBROUTINE SHA2B_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 IF ( MD % IsSHA384 ) THEN MD % State = IV384 ELSE MD % State = IV512 END IF CALL MD % HelperReset () RETURN END SUBROUTINE SHA2B_Reset !****************************************************************************** SUBROUTINE SHA2B_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHA2B :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHA2B ) CALL Dst % Create ( Src % IsSHA384 ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % HelperClone ( Dst ) END SELECT RETURN END SUBROUTINE SHA2B_GetClone !****************************************************************************** FUNCTION SHA2B_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( IN ) :: MD !! 'SHA2B' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHA384 ) THEN Name = 'SHA-384' ELSE Name = 'SHA-512' END IF RETURN END FUNCTION SHA2B_GetName !****************************************************************************** FUNCTION SHA2B_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( IN ) :: MD !! 'SHA2B' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsSHA384 ) THEN Length = DLen384 ELSE Length = DLen512 END IF RETURN END FUNCTION SHA2B_GetDigestLen !****************************************************************************** FUNCTION SHA2B_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( IN ) :: MD !! 'SHA2B' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION SHA2B_GetBlockLen !****************************************************************************** SUBROUTINE SHA2B_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), TARGET , INTENT ( INOUT ) :: MD !! 'SHA2B' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE SHA2B_SetBufPtr !****************************************************************************** SUBROUTINE SHA2B_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: A , B , C , D , E , F , G , H tLong :: T1 , T2 tLong :: W ( 0 : 79 ) tIndex :: I , J !** SUBROUTINE MACRO DEFINITIONS: #define BSigma0(X)      IEOR(IEOR(RotateLeft(X, 36), RotateLeft(X, 30)), RotateLeft(X, 25)) #define BSigma1(X)      IEOR(IEOR(RotateLeft(X, 50), RotateLeft(X, 46)), RotateLeft(X, 23)) #define SSigma0(X)      IEOR(IEOR(RotateLeft(X, 63), RotateLeft(X, 56)), SHIFTR(X, 7)) #define SSigma1(X)      IEOR(IEOR(RotateLeft(X, 45), RotateLeft(X,  3)), SHIFTR(X, 6)) #define CH(X, Y, Z)     IEOR(IAND(IEOR(Y, Z), X), Z) #define MAJ(X, Y, Z)    IOR(IAND(Y, Z), IAND(IOR(Y, Z), X)) ! FLOW A = MD % State ( 0 ) B = MD % State ( 1 ) C = MD % State ( 2 ) D = MD % State ( 3 ) E = MD % State ( 4 ) F = MD % State ( 5 ) G = MD % State ( 6 ) H = MD % State ( 7 ) CALL BytePackBE ( BytesIn , 0_kIndex , W ( 0 : 15 )) DO J = 16 , 79 W ( J ) = SSigma1 ( W ( J - 2 )) + W ( J - 7 ) + SSigma0 ( W ( J - 15 )) + W ( J - 16 ) END DO DO I = 0 , 79 T1 = H + BSigma1 ( E ) + CH ( E , F , G ) + K ( I ) + W ( I ) T2 = BSigma0 ( A ) + MAJ ( A , B , C ) H = G G = F F = E E = D + T1 D = C C = B B = A A = T1 + T2 END DO MD % State ( 0 ) = MD % State ( 0 ) + A MD % State ( 1 ) = MD % State ( 1 ) + B MD % State ( 2 ) = MD % State ( 2 ) + C MD % State ( 3 ) = MD % State ( 3 ) + D MD % State ( 4 ) = MD % State ( 4 ) + E MD % State ( 5 ) = MD % State ( 5 ) + F MD % State ( 6 ) = MD % State ( 6 ) + G MD % State ( 7 ) = MD % State ( 7 ) + H RETURN #undef BSigma0 #undef BSigma1 #undef SSigma0 #undef SSigma1 #undef CH #undef MAJ END SUBROUTINE SHA2B_ProcessBlock !****************************************************************************** SUBROUTINE SHA2B_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW CALL MD % HelperPadding () DO I = 0_kIndex , ( MD % GetDigestLen () / 8_kIndex - 1_kIndex ) CALL ByteUnpackBE ( MD % State ( I ), BytesOut , Offset + 8_kIndex * I ) END DO RETURN END SUBROUTINE SHA2B_DoPadding !****************************************************************************** SUBROUTINE SHA2B_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA2B ), INTENT ( INOUT ) :: MD !! 'SHA2B' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! SHA-2 algorithms do not handle partial bytes CALL MD % DoPadding ( BytesOut , Offset ) ASSOCIATE ( Dummy => LastByte , Dummy2 => NBits ); END ASSOCIATE RETURN END SUBROUTINE SHA2B_AddBitsNPad !****************************************************************************** END MODULE MClass_SHA2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_sha2b.f90.html"},{"title":"MBase_ReferenceHash64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_ReferenceHash64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains a reference implementation of various non-cryptographic !   hash function routines that output a hash value as a 64-bit integer.  The API !   of these hash function routines are mostly similar to that of routines in the !   <a href=\"../../xpfbase/module/mbase_simplehash64.html\">ModBase_SimpleHash64</a> !   module.  The main difference between routines in these two modules is that routines !   in the *ModBase_SimpleHash64* module process input data one byte at a time whereas !   routines in this module commonly process input data several/many bytes at a time. !   Also, routines in this module are somewhat more complicated than those in the !   *ModBase_SimpleHash64* module. <br> !   Similar to those routines in the *ModBase_SimpleHash64* module, all routines can !   be used for an input (i.e. a key) of any type and rank providing that the size of !   the input (in bytes) is known at compile time.  All routines can be used for a !   continued hashing by providing the previously computed hash value as an (optional) !   input argument (i.e. the *StartHash* argument).  Optionally, a user can specify !   whether to return only positive value of the hash code.  This is particularly !   useful when used in conjunction with a hash table. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/aappleby/smhasher\">SMHasher: a test suite designed to !       test the distribution, collision, and performance properties of non-cryptographic !       hash functions. </a> <br> !   [2] <a href=\"https://github.com/jandrewrogers/MetroHash\">MetroHash: Faster, Better !       Hash Functions. </a> <br> !   [3] <a href=\"https://github.com/wangyi-fudan/wyhash\">WYHASH and WYRAND - The FASTEST !       QUALITY hash function, random number generators (PRNG) and hash map. </a> <br> !   [4] <a href=\"https://github.com/OpenHFT/Zero-Allocation-Hashing/tree/ea\"> !       Zero-Allocation Hashing for Java. </a> <br> !   [5] <a href=\"https://github.com/Cyan4973/xxHash\">xxHash: Extremely fast hash algorithm. </a> <br> !   [6] <a href=\"https://github.com/google/cityhash\">CityHash: a family of hash functions !       for strings. </a> <br> !   [7] <a href=\"https://github.com/google/farmhash\">FarmHash: a family of hash functions. </a> <br> !   [8] <a href=\"https://burtleburtle.net/bob/hash/spooky.html\">SpookyHash: a 128-bit !       non-cryptographic hash. </a> <br> !   [9] <a href=\"https://github.com/rurban/smhasher\">SMHasher by Reini Urban. </a> <br> !   [10] <a href=\"https://github.com/fortran-lang/stdlib\">Fortran Standard Library. </a> <br> !   [11] <a href=\"https://github.com/veorq/SipHash\">SipHash: high-speed secure pseudorandom !       function for short messages. </a> <br> !   [12] <a href=\"https://github.com/jonmaiga/mx3\">mx3: A bit mixer, pseudo random number !       generator and a hash function. </a> <br> !   [13] <a href=\"https://github.com/avaneev/komihash\">KOMIHASH - Very fast, high-quality !       hash function, discrete-incremental and streamed hashing-capable (non-cryptographic, !       in C) + PRNG.</a> <br> !   [14] <a href=\"https://github.com/vnmakarov/mir\">MIR Project: A lightweight JIT compiler !       based on MIR (Medium Internal Representation) and C11 JIT compiler and interpreter !       based on MIR. </a> <br> !   [15] <a href=\"https://github.com/vnmakarov/mum-hash\">MumHash: Hashing functions and !       PRNGs based on them. </a> <br> !   [15] <a href=\"https://github.com/tinypeng/pengyhash\">PengyHash: Fast 64-bit !       non-cryptographic function. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MClass_ByteConverter IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: CityHash_I64 PUBLIC :: FarmNaHash_I64 PUBLIC :: FarmUoHash_I64 PUBLIC :: KomiHash_I64 PUBLIC :: MetroHash_I64 PUBLIC :: MirHash_I64 PUBLIC :: MumHash_I64 PUBLIC :: Murmur3Hash_I128 PUBLIC :: Mx3Hash_I64 PUBLIC :: PengyHash_V02_I64 PUBLIC :: PengyHash_V03_I64 PUBLIC :: SipHash24_I64 PUBLIC :: SipHash_I128 PUBLIC :: SpookyHash_I128 PUBLIC :: TSipHash_I64 PUBLIC :: WyHash_I64 PUBLIC :: WyHash_F3_I64 PUBLIC :: XXHash_I64 PUBLIC :: XX3Hash_I64 PUBLIC :: XX3Hash_I128 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'ModBase_ReferenceHash64' ! The maximum (positive) number of hash code tUInt64 , PARAMETER :: MaxHash = ToInt64 ( Z '7FFFFFFFFFFFFFFF' ) !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: INTERFACE MODULE FUNCTION MetroHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the MetroHash64 hash algorithm by J. Andrew !  Rogers [2, 4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION MetroHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION Murmur3Hash_I128 ( Input , InpSize , StartHash , RemoveSign , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the Murmur3 hash algorithm by Austin Appleby [1, 4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION Murmur3Hash_I128 !---------------------------------------------------------------------- MODULE FUNCTION WyHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using version 3 (?) of the WyHash hash algorithm by !  Wang Yi [3, 4]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION WyHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION WyHash_F3_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the final version 3 of the WyHash hash algorithm !  by Wang Yi [3]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION WyHash_F3_I64 !---------------------------------------------------------------------- MODULE FUNCTION XXHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the XXHash hash algorithm by Yann Collet [4, 5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION XXHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION XX3Hash_I64 ( Input , InpSize , StartHash , RemoveSign , & Secret ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash64 hash algorithm by Yann Collet [4, 5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 :: HashCode !! hash code END FUNCTION XX3Hash_I64 !---------------------------------------------------------------------- MODULE FUNCTION XX3Hash_I128 ( Input , InpSize , StartHash , RemoveSign , & Secret , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the XX3Hash128 hash algorithm by Yann Collet [4, 5]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt8 , OPTIONAL , INTENT ( IN ) :: Secret (:) !&#94; a byte (8-bit integer) array (of at least 192 bytes) representing !  a custom secret <br> tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION XX3Hash_I128 !---------------------------------------------------------------------- MODULE FUNCTION CityHash_I64 ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the CityHash hash algorithm by Google Inc [4, 6]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION CityHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION FarmNaHash_I64 ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmNaHash hash algorithm by Google Inc [4, 7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION FarmNaHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION FarmUoHash_I64 ( Input , InpSize , StartHash , RemoveSign , & Seed ) RESULT ( HashCode ) !&#94; To compute hash code using the FarmUoHash hash algorithm by Google Inc [4, 7]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 :: HashCode !! hash code END FUNCTION FarmUoHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION SpookyHash_I128 ( Input , InpSize , StartHash , RemoveSign , & Seed , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using version 2 of the SpookyHash hash algorithm !  by Bob Jenkins [8]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( IN ) :: Seed !! optional seed tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION SpookyHash_I128 !---------------------------------------------------------------------- MODULE FUNCTION PengyHash_V03_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.3) by !  Alberto Fajardo [15]. <br> TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION PengyHash_V03_I64 !---------------------------------------------------------------------- MODULE FUNCTION PengyHash_V02_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the PengyHash hash algorithm (v0.2) by !  Alberto Fajardo [9, 10]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION PengyHash_V02_I64 !---------------------------------------------------------------------- MODULE FUNCTION SipHash24_I64 ( Input , InpSize , Key , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the SipHash24 hash algorithm by Jean-Philippe !  Aumasson [11]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , INTENT ( IN ) :: Key ( 0 : 15 ) !! key bytes tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION SipHash24_I64 !---------------------------------------------------------------------- MODULE FUNCTION TSipHash_I64 ( Input , InpSize , Key , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the TSipHash hash algorithm (a variant of SipHash) !  from SMHasher [9]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , INTENT ( IN ) :: Key ( 0 : 15 ) !! key bytes tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION TSipHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION Mx3Hash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the Mx3Hash hash algorithm by Jon Maiga [12]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION Mx3Hash_I64 !---------------------------------------------------------------------- MODULE FUNCTION KomiHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the KomiHash hash algorithm by Aleksey Vaneev [13]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION KomiHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION MirHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the MirHash hash algorithm by Vladimir Makarov [9, 14]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION MirHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION MumHash_I64 ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) !&#94; To compute hash code using the MumHash hash algorithm by Vladimir Makarov [9, 15]. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 :: HashCode !! hash code END FUNCTION MumHash_I64 !---------------------------------------------------------------------- MODULE FUNCTION SipHash_I128 ( Input , InpSize , Key , cRound , dRound , StartHash , & RemoveSign , HashPair ) RESULT ( HashCode ) !&#94; To compute hash code using the SipHash24 hash algorithm by Jean-Philippe !  Aumasson [11] where the numbers of rounds are specified. TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tUInt8 , INTENT ( IN ) :: Key ( 0 : 15 ) !! key bytes tIndex , INTENT ( IN ) :: cRound ! number of C rounds tIndex , INTENT ( IN ) :: dRound ! number of D rounds tUInt64 , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tUInt64 , OPTIONAL , INTENT ( OUT ) :: HashPair ( 2 ) !! dual (128-bit) hash codes tUInt64 :: HashCode !! single (64-bit) hash code END FUNCTION SipHash_I128 !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION UnsignedLongMultiplyorFold ( LHS , RHS ) RESULT ( Res ) !** PURPOSE OF THIS SUBROUTINE: ! To multiply or fold. !** SUBROUTINE ARGUMENT DECLARATIONS: tUInt64 , INTENT ( IN ) :: LHS tUInt64 , INTENT ( IN ) :: RHS tUInt64 :: Res !** SUBROUTINE PARAMETER DECLARATIONS: tUInt64 , PARAMETER :: MaxU32 = ToInt64 ( Z '00000000FFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tUInt64 :: LHS_Lo , LHS_Hi , RHS_Lo , RHS_Hi tUInt64 :: Lo_Lo , Hi_Lo tUInt64 :: Cross !** FLOW ! the Grade School method of multiplication. LHS_Lo = IAND ( LHS , MaxU32 ) LHS_Hi = SHIFTR ( LHS , 32 ) RHS_Lo = IAND ( RHS , MaxU32 ) RHS_Hi = SHIFTR ( RHS , 32 ) Lo_Lo = LHS_Lo * RHS_Lo Hi_Lo = LHS_Hi * RHS_Lo ! Add the products together. This will never overfLow. Cross = SHIFTR ( Lo_Lo , 32 ) + IAND ( Hi_Lo , MaxU32 ) + LHS_Lo * RHS_Hi Res = IEOR ( IOR ( SHIFTL ( Cross , 32 ), IAND ( Lo_Lo , MaxU32 )), & SHIFTR ( Hi_Lo , 32 ) + SHIFTR ( Cross , 32 ) + LHS_Hi * RHS_Hi ) RETURN END FUNCTION UnsignedLongMultiplyorFold !****************************************************************************** END MODULE MBase_ReferenceHash64 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_referencehash64.f90.html"},{"title":"MClass_SHA3.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SHA3 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SHA3* type and its related routines. !   The *SHA3* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *SHA3* type implements an incremental cryptographic hash !   function by employing the *Keccak message-digest* algorithm [1, 2]. !   The implementation here is mainly based on the references [3, 4]. <br> !   Unlike other digest types, which represent one or two hash functions, !   the *SHA3* type represents eight cryptographic hash functions; four of !   which are in the so-called SHA-3 family while the rest are in the !   so-called Keccak family.  These two families of hash functions employ !   the same Keccak message-digest algorithm; however, they use different !   padding strategies. <br> !   As the name suggested, the *SHA3* type represents the *SHA-3* family !   by default.  However, a user can specify the *IsKeccak* flag to true !   when initializing the digest object (by calling the *Create* method) !   in order to use the padding strategy of the *Keccak* family.  Also, !   the *SHA3* type employs the SHA3-256 hash function as a default !   algorithm.  This implies that the hash output has the output size !   and the strength of security (against pre-image attack) of 256 bits. !   The user can also specify the *Security* argument (to one of the four !   applicable values: 224, 256, 384 and 512) when initializing the digest !   object in order to use a different algorithm and get a different hash !   output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://csrc.nist.gov/csrc/media/Projects/hash-functions/documents/Keccak-reference-3.0.pdf\"> !       The Keccak Reference, Version 3.0. </a> <br> !   [2] <a href=\"https://doi.org/10.6028/NIST.FIPS.202\">SHA-3 Standard: !       Permutation-Based Hash and Extendable-Output Functions. </a> <br> !   [3] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !   [4] <a href=\"https://csrc.nist.gov/CSRC/media/Projects/Hash-Functions/documents/Keccak_FinalRnd.zip\"> !       The Keccak Reference Implementation in C. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackLE , ByteUnpackLE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: SHA3 PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tLong , PARAMETER :: RC ( 0 : 23 ) = [ & ToInt64 ( Z '0000000000000001' ), ToInt64 ( Z '0000000000008082' ), & ToInt64 ( Z '800000000000808A' ), ToInt64 ( Z '8000000080008000' ), & ToInt64 ( Z '000000000000808B' ), ToInt64 ( Z '0000000080000001' ), & ToInt64 ( Z '8000000080008081' ), ToInt64 ( Z '8000000000008009' ), & ToInt64 ( Z '000000000000008A' ), ToInt64 ( Z '0000000000000088' ), & ToInt64 ( Z '0000000080008009' ), ToInt64 ( Z '000000008000000A' ), & ToInt64 ( Z '000000008000808B' ), ToInt64 ( Z '800000000000008B' ), & ToInt64 ( Z '8000000000008089' ), ToInt64 ( Z '8000000000008003' ), & ToInt64 ( Z '8000000000008002' ), ToInt64 ( Z '8000000000000080' ), & ToInt64 ( Z '000000000000800A' ), ToInt64 ( Z '800000008000000A' ), & ToInt64 ( Z '8000000080008081' ), ToInt64 ( Z '8000000000008080' ), & ToInt64 ( Z '0000000080000001' ), ToInt64 ( Z '8000000080008008' )] !** DERIVED TYPE DEFINITIONS !> *SHA3* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the so-called Keccak hash !  functions, which is a family of message-digest algorithms. TYPE , EXTENDS ( MDEngine ) :: SHA3 PRIVATE !% buffer array used to store input data tByte :: BufInp ( 0 : 143 ) = 0_kInt8 !% state tLong :: State ( 0 : 24 ) = 0_kInt64 !% flag indicating whether the Keccak family is employed or not. tLogical :: IsKeccak = FalseVal !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = 32_kIndex !% length of data block to be processed when exceeded tIndex :: BlockLen = 136_kIndex !% length of temporary output buffer tIndex :: OutLen = 32_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWOption* method to !  initialize the *digest* object with specified options. PROCEDURE , PRIVATE :: InitializeWOption => SHA3_Initialize_wOption ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (SHA3-256). PROCEDURE :: Initialize => SHA3_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => SHA3_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => SHA3_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => SHA3_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => SHA3_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => SHA3_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => SHA3_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => SHA3_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => SHA3_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => SHA3_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (SHA3-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the Keccak-256 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.TRUE.) <br> !   ! initialize the object to employ the SHA3-384 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.FALSE., Security=384) <br> !   ! initialize the object to employ the Keccak-512 algorithm <br> !   --->    CALL MD%Create(IsKeccak=.TRUE., Security=512) <br> GENERIC :: Create => InitializeWOption END TYPE SHA3 !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE SHA3_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! to employ the SHA3-256 algorithm CALL MD % Create ( FalseVal ) RETURN END SUBROUTINE SHA3_Initialize !****************************************************************************** SUBROUTINE SHA3_Initialize_wOption ( MD , IsKeccak , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object tLogical , INTENT ( IN ) :: IsKeccak !&#94; flag indicating whether the Keccak family is employed or not. <br> !  - If true, use the Keccak family. <br> !  - Otherwise, use the SHA-3 algorithm. <br> tInteger , OPTIONAL , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Security )) THEN SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT ELSE MD % Security = 256 END IF MD % IsKeccak = IsKeccak MD % DigestLen = ToIndex ( SHIFTR ( MD % Security , 3 )) MD % BlockLen = 200_kIndex - 2_kIndex * MD % DigestLen MD % OutLen = IAND ( MD % DigestLen + 7_kIndex , NOT ( 7_kIndex )) CALL MD % Reset () RETURN END SUBROUTINE SHA3_Initialize_wOption !****************************************************************************** SUBROUTINE SHA3_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object !** SUBROUTINE PARAMETER DECLARATIONS: tLong , PARAMETER :: MaxU64 = ToInt64 ( Z 'FFFFFFFFFFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufInp = 0_kInt8 MD % State = 0_kInt64 MD % State ( 1 ) = MaxU64 MD % State ( 2 ) = MaxU64 MD % State ( 8 ) = MaxU64 MD % State ( 12 ) = MaxU64 MD % State ( 17 ) = MaxU64 MD % State ( 20 ) = MaxU64 CALL MD % EngineReset () RETURN END SUBROUTINE SHA3_Reset !****************************************************************************** SUBROUTINE SHA3_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( SHA3 :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( SHA3 ) CALL Dst % Create ( Src % IsKeccak , Src % Security ) Dst % State = Src % State Dst % BufInp = Src % BufInp CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE SHA3_GetClone !****************************************************************************** FUNCTION SHA3_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( IN ) :: MD !! 'SHA3' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( MD % IsKeccak ) THEN Name = 'Keccak-' // ToDecStrSigned ( MD % Security ) ELSE Name = 'SHA3-' // ToDecStrSigned ( MD % Security ) END IF RETURN END FUNCTION SHA3_GetName !****************************************************************************** FUNCTION SHA3_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( IN ) :: MD !! 'SHA3' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION SHA3_GetDigestLen !****************************************************************************** FUNCTION SHA3_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( IN ) :: MD !! 'SHA3' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % BlockLen RETURN END FUNCTION SHA3_GetBlockLen !****************************************************************************** SUBROUTINE SHA3_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), TARGET , INTENT ( INOUT ) :: MD !! 'SHA3' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufInp ( 0 : MD % BlockLen - 1 ) RETURN END SUBROUTINE SHA3_SetBufPtr !****************************************************************************** SUBROUTINE SHA3_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T tLong :: Z tIndex :: I , J ! FLOW DO I = 0 , SIZE ( BytesIn ) - 1 , 8 J = SHIFTR ( I , 3 ) CALL BytePackLE ( BytesIn , I , Z ) MD % State ( J ) = IEOR ( MD % State ( J ), Z ) END DO ! Unrolling two rounds. DO J = 0 , 23 , 2 ! Theta CALL Theta_Step_I ( MD % State ) ! Rho/Pi CALL RhoPi_Step_I ( MD % State ) ! Chi CALL Chi_Step_I ( MD % State ) ! Iota MD % State ( 0 ) = IEOR ( MD % State ( 0 ), RC ( J )) ! Theta CALL Theta_Step_II ( MD % State ) ! Rho/Pi CALL RhoPi_Step_II ( MD % State ) ! Chi CALL Chi_Step_II ( MD % State ) ! Iota MD % State ( 0 ) = IEOR ( MD % State ( 0 ), RC ( J + 1 )) ! re-arrange state T = MD % State ( 5 ) MD % State ( 5 ) = MD % State ( 18 ) MD % State ( 18 ) = MD % State ( 11 ) MD % State ( 11 ) = MD % State ( 10 ) MD % State ( 10 ) = MD % State ( 6 ) MD % State ( 6 ) = MD % State ( 22 ) MD % State ( 22 ) = MD % State ( 20 ) MD % State ( 20 ) = MD % State ( 12 ) MD % State ( 12 ) = MD % State ( 19 ) MD % State ( 19 ) = MD % State ( 15 ) MD % State ( 15 ) = MD % State ( 24 ) MD % State ( 24 ) = MD % State ( 8 ) MD % State ( 8 ) = T !... T = MD % State ( 1 ) MD % State ( 1 ) = MD % State ( 9 ) MD % State ( 9 ) = MD % State ( 14 ) MD % State ( 14 ) = MD % State ( 2 ) MD % State ( 2 ) = MD % State ( 13 ) MD % State ( 13 ) = MD % State ( 23 ) MD % State ( 23 ) = MD % State ( 4 ) MD % State ( 4 ) = MD % State ( 21 ) MD % State ( 21 ) = MD % State ( 16 ) MD % State ( 16 ) = MD % State ( 3 ) MD % State ( 3 ) = MD % State ( 17 ) MD % State ( 17 ) = MD % State ( 7 ) MD % State ( 7 ) = T END DO RETURN CONTAINS SUBROUTINE Theta_Step_I ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Theta step-mapping. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T ( 0 : 4 ) tLong :: TT0 , TT1 , TT2 , TT3 , TT4 tIndex :: I , J , K ! FLOW J = 1 K = 4 DO I = 0 , 4 TT0 = IEOR ( A ( J ), A ( J + 5 )) TT1 = IEOR ( A ( J + 10 ), A ( J + 15 )) TT0 = IEOR ( TT0 , IEOR ( A ( J + 20 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( K ), A ( K + 5 )) TT3 = IEOR ( A ( K + 10 ), A ( K + 15 )) TT0 = IEOR ( TT0 , A ( K + 20 )) TT2 = IEOR ( TT2 , TT3 ) T ( I ) = IEOR ( TT0 , TT2 ) J = J + 1 K = K + 1 IF ( J == 5 ) J = 0 IF ( K == 5 ) K = 0 END DO DO I = 0 , 20 , 5 A ( I ) = IEOR ( A ( I ), T ( 0 )) END DO DO I = 1 , 21 , 5 A ( I ) = IEOR ( A ( I ), T ( 1 )) END DO DO I = 2 , 22 , 5 A ( I ) = IEOR ( A ( I ), T ( 2 )) END DO DO I = 3 , 23 , 5 A ( I ) = IEOR ( A ( I ), T ( 3 )) END DO DO I = 4 , 24 , 5 A ( I ) = IEOR ( A ( I ), T ( 4 )) END DO RETURN END SUBROUTINE Theta_Step_I !************************************************************************** SUBROUTINE Theta_Step_II ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Theta step-mapping. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: T0 , T1 , T2 , T3 , T4 tLong :: TT0 , TT1 , TT2 , TT3 , TT4 tIndex :: I ! FLOW TT0 = IEOR ( A ( 6 ), A ( 9 )) TT1 = IEOR ( A ( 7 ), A ( 5 )) TT0 = IEOR ( TT0 , IEOR ( A ( 8 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( 24 ), A ( 22 )) TT3 = IEOR ( A ( 20 ), A ( 23 )) TT0 = IEOR ( TT0 , A ( 21 )) TT2 = IEOR ( TT2 , TT3 ) T0 = IEOR ( TT0 , TT2 ) TT0 = IEOR ( A ( 12 ), A ( 10 )) TT1 = IEOR ( A ( 13 ), A ( 11 )) TT0 = IEOR ( TT0 , IEOR ( A ( 14 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( 0 ), A ( 3 )) TT3 = IEOR ( A ( 1 ), A ( 4 )) TT0 = IEOR ( TT0 , A ( 2 )) TT2 = IEOR ( TT2 , TT3 ) T1 = IEOR ( TT0 , TT2 ) TT0 = IEOR ( A ( 18 ), A ( 16 )) TT1 = IEOR ( A ( 19 ), A ( 17 )) TT0 = IEOR ( TT0 , IEOR ( A ( 15 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( 6 ), A ( 9 )) TT3 = IEOR ( A ( 7 ), A ( 5 )) TT0 = IEOR ( TT0 , A ( 8 )) TT2 = IEOR ( TT2 , TT3 ) T2 = IEOR ( TT0 , TT2 ) TT0 = IEOR ( A ( 24 ), A ( 22 )) TT1 = IEOR ( A ( 20 ), A ( 23 )) TT0 = IEOR ( TT0 , IEOR ( A ( 21 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( 12 ), A ( 10 )) TT3 = IEOR ( A ( 13 ), A ( 11 )) TT0 = IEOR ( TT0 , A ( 14 )) TT2 = IEOR ( TT2 , TT3 ) T3 = IEOR ( TT0 , TT2 ) TT0 = IEOR ( A ( 0 ), A ( 3 )) TT1 = IEOR ( A ( 1 ), A ( 4 )) TT0 = IEOR ( TT0 , IEOR ( A ( 2 ), TT1 )) TT0 = RotateLeft ( TT0 , 1 ) TT2 = IEOR ( A ( 18 ), A ( 16 )) TT3 = IEOR ( A ( 19 ), A ( 17 )) TT0 = IEOR ( TT0 , A ( 15 )) TT2 = IEOR ( TT2 , TT3 ) T4 = IEOR ( TT0 , TT2 ) DO I = 0 , 4 A ( I ) = IEOR ( A ( I ), T0 ) END DO DO I = 5 , 9 A ( I ) = IEOR ( A ( I ), T1 ) END DO DO I = 10 , 14 A ( I ) = IEOR ( A ( I ), T2 ) END DO DO I = 15 , 19 A ( I ) = IEOR ( A ( I ), T3 ) END DO DO I = 20 , 24 A ( I ) = IEOR ( A ( I ), T4 ) END DO RETURN END SUBROUTINE Theta_Step_II !************************************************************************** SUBROUTINE RhoPi_Step_I ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Rho and Pi step-mappings. (The two steps are merged for optimal ! performance). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW A ( 5 ) = RotateLeft ( A ( 5 ), 36 ) A ( 10 ) = RotateLeft ( A ( 10 ), 3 ) A ( 15 ) = RotateLeft ( A ( 15 ), 41 ) A ( 20 ) = RotateLeft ( A ( 20 ), 18 ) A ( 1 ) = RotateLeft ( A ( 1 ), 1 ) A ( 6 ) = RotateLeft ( A ( 6 ), 44 ) A ( 11 ) = RotateLeft ( A ( 11 ), 10 ) A ( 16 ) = RotateLeft ( A ( 16 ), 45 ) A ( 21 ) = RotateLeft ( A ( 21 ), 2 ) A ( 2 ) = RotateLeft ( A ( 2 ), 62 ) A ( 7 ) = RotateLeft ( A ( 7 ), 6 ) A ( 12 ) = RotateLeft ( A ( 12 ), 43 ) A ( 17 ) = RotateLeft ( A ( 17 ), 15 ) A ( 22 ) = RotateLeft ( A ( 22 ), 61 ) A ( 3 ) = RotateLeft ( A ( 3 ), 28 ) A ( 8 ) = RotateLeft ( A ( 8 ), 55 ) A ( 13 ) = RotateLeft ( A ( 13 ), 25 ) A ( 18 ) = RotateLeft ( A ( 18 ), 21 ) A ( 23 ) = RotateLeft ( A ( 23 ), 56 ) A ( 4 ) = RotateLeft ( A ( 4 ), 27 ) A ( 9 ) = RotateLeft ( A ( 9 ), 20 ) A ( 14 ) = RotateLeft ( A ( 14 ), 39 ) A ( 19 ) = RotateLeft ( A ( 19 ), 8 ) A ( 24 ) = RotateLeft ( A ( 24 ), 14 ) RETURN END SUBROUTINE RhoPi_Step_I !************************************************************************** SUBROUTINE RhoPi_Step_II ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Rho and Pi step-mappings. (The two steps are merged for optimal ! performance). !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW A ( 3 ) = RotateLeft ( A ( 3 ), 36 ) A ( 1 ) = RotateLeft ( A ( 1 ), 3 ) A ( 4 ) = RotateLeft ( A ( 4 ), 41 ) A ( 2 ) = RotateLeft ( A ( 2 ), 18 ) A ( 6 ) = RotateLeft ( A ( 6 ), 1 ) A ( 9 ) = RotateLeft ( A ( 9 ), 44 ) A ( 7 ) = RotateLeft ( A ( 7 ), 10 ) A ( 5 ) = RotateLeft ( A ( 5 ), 45 ) A ( 8 ) = RotateLeft ( A ( 8 ), 2 ) A ( 12 ) = RotateLeft ( A ( 12 ), 62 ) A ( 10 ) = RotateLeft ( A ( 10 ), 6 ) A ( 13 ) = RotateLeft ( A ( 13 ), 43 ) A ( 11 ) = RotateLeft ( A ( 11 ), 15 ) A ( 14 ) = RotateLeft ( A ( 14 ), 61 ) A ( 18 ) = RotateLeft ( A ( 18 ), 28 ) A ( 16 ) = RotateLeft ( A ( 16 ), 55 ) A ( 19 ) = RotateLeft ( A ( 19 ), 25 ) A ( 17 ) = RotateLeft ( A ( 17 ), 21 ) A ( 15 ) = RotateLeft ( A ( 15 ), 56 ) A ( 24 ) = RotateLeft ( A ( 24 ), 27 ) A ( 22 ) = RotateLeft ( A ( 22 ), 20 ) A ( 20 ) = RotateLeft ( A ( 20 ), 39 ) A ( 23 ) = RotateLeft ( A ( 23 ), 8 ) A ( 21 ) = RotateLeft ( A ( 21 ), 14 ) RETURN END SUBROUTINE RhoPi_Step_II !************************************************************************** SUBROUTINE Chi_Step_I ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Chi step-mapping. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: C0 , C1 , C2 , C3 , C4 , BNN , KT ! FLOW BNN = NOT ( A ( 12 )) KT = IOR ( A ( 6 ), A ( 12 )) C0 = IEOR ( A ( 0 ), KT ) KT = IOR ( BNN , A ( 18 )) C1 = IEOR ( A ( 6 ), KT ) KT = IAND ( A ( 18 ), A ( 24 )) C2 = IEOR ( A ( 12 ), KT ) KT = IOR ( A ( 24 ), A ( 0 )) C3 = IEOR ( A ( 18 ), KT ) KT = IAND ( A ( 0 ), A ( 6 )) C4 = IEOR ( A ( 24 ), KT ) A ( 0 ) = C0 A ( 6 ) = C1 A ( 12 ) = C2 A ( 18 ) = C3 A ( 24 ) = C4 BNN = NOT ( A ( 22 )) KT = IOR ( A ( 9 ), A ( 10 )) C0 = IEOR ( A ( 3 ), KT ) KT = IAND ( A ( 10 ), A ( 16 )) C1 = IEOR ( A ( 9 ), KT ) KT = IOR ( A ( 16 ), BNN ) C2 = IEOR ( A ( 10 ), KT ) KT = IOR ( A ( 22 ), A ( 3 )) C3 = IEOR ( A ( 16 ), KT ) KT = IAND ( A ( 3 ), A ( 9 )) C4 = IEOR ( A ( 22 ), KT ) A ( 3 ) = C0 A ( 9 ) = C1 A ( 10 ) = C2 A ( 16 ) = C3 A ( 22 ) = C4 BNN = NOT ( A ( 19 )) KT = IOR ( A ( 7 ), A ( 13 )) C0 = IEOR ( A ( 1 ), KT ) KT = IAND ( A ( 13 ), A ( 19 )) C1 = IEOR ( A ( 7 ), KT ) KT = IAND ( BNN , A ( 20 )) C2 = IEOR ( A ( 13 ), KT ) KT = IOR ( A ( 20 ), A ( 1 )) C3 = IEOR ( BNN , KT ) KT = IAND ( A ( 1 ), A ( 7 )) C4 = IEOR ( A ( 20 ), KT ) A ( 1 ) = C0 A ( 7 ) = C1 A ( 13 ) = C2 A ( 19 ) = C3 A ( 20 ) = C4 BNN = NOT ( A ( 17 )) KT = IAND ( A ( 5 ), A ( 11 )) C0 = IEOR ( A ( 4 ), KT ) KT = IOR ( A ( 11 ), A ( 17 )) C1 = IEOR ( A ( 5 ), KT ) KT = IOR ( BNN , A ( 23 )) C2 = IEOR ( A ( 11 ), KT ) KT = IAND ( A ( 23 ), A ( 4 )) C3 = IEOR ( BNN , KT ) KT = IOR ( A ( 4 ), A ( 5 )) C4 = IEOR ( A ( 23 ), KT ) A ( 4 ) = C0 A ( 5 ) = C1 A ( 11 ) = C2 A ( 17 ) = C3 A ( 23 ) = C4 BNN = NOT ( A ( 8 )) KT = IAND ( BNN , A ( 14 )) C0 = IEOR ( A ( 2 ), KT ) KT = IOR ( A ( 14 ), A ( 15 )) C1 = IEOR ( BNN , KT ) KT = IAND ( A ( 15 ), A ( 21 )) C2 = IEOR ( A ( 14 ), KT ) KT = IOR ( A ( 21 ), A ( 2 )) C3 = IEOR ( A ( 15 ), KT ) KT = IAND ( A ( 2 ), A ( 8 )) C4 = IEOR ( A ( 21 ), KT ) A ( 2 ) = C0 A ( 8 ) = C1 A ( 14 ) = C2 A ( 15 ) = C3 A ( 21 ) = C4 RETURN END SUBROUTINE Chi_Step_I !************************************************************************** SUBROUTINE Chi_Step_II ( A ) !** PURPOSE OF THIS SUBROUTINE: ! To perform Chi step-mapping. !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: C0 , C1 , C2 , C3 , C4 , BNN , KT ! FLOW BNN = NOT ( A ( 13 )) KT = IOR ( A ( 9 ), A ( 13 )) C0 = IEOR ( A ( 0 ), KT ) KT = IOR ( BNN , A ( 17 )) C1 = IEOR ( A ( 9 ), KT ) KT = IAND ( A ( 17 ), A ( 21 )) C2 = IEOR ( A ( 13 ), KT ) KT = IOR ( A ( 21 ), A ( 0 )) C3 = IEOR ( A ( 17 ), KT ) KT = IAND ( A ( 0 ), A ( 9 )) C4 = IEOR ( A ( 21 ), KT ) A ( 0 ) = C0 A ( 9 ) = C1 A ( 13 ) = C2 A ( 17 ) = C3 A ( 21 ) = C4 BNN = NOT ( A ( 14 )) KT = IOR ( A ( 22 ), A ( 1 )) C0 = IEOR ( A ( 18 ), KT ) KT = IAND ( A ( 1 ), A ( 5 )) C1 = IEOR ( A ( 22 ), KT ) KT = IOR ( A ( 5 ), BNN ) C2 = IEOR ( A ( 1 ), KT ) KT = IOR ( A ( 14 ), A ( 18 )) C3 = IEOR ( A ( 5 ), KT ) KT = IAND ( A ( 18 ), A ( 22 )) C4 = IEOR ( A ( 14 ), KT ) A ( 18 ) = C0 A ( 22 ) = C1 A ( 1 ) = C2 A ( 5 ) = C3 A ( 14 ) = C4 BNN = NOT ( A ( 23 )) KT = IOR ( A ( 10 ), A ( 19 )) C0 = IEOR ( A ( 6 ), KT ) KT = IAND ( A ( 19 ), A ( 23 )) C1 = IEOR ( A ( 10 ), KT ) KT = IAND ( BNN , A ( 2 )) C2 = IEOR ( A ( 19 ), KT ) KT = IOR ( A ( 2 ), A ( 6 )) C3 = IEOR ( BNN , KT ) KT = IAND ( A ( 6 ), A ( 10 )) C4 = IEOR ( A ( 2 ), KT ) A ( 6 ) = C0 A ( 10 ) = C1 A ( 19 ) = C2 A ( 23 ) = C3 A ( 2 ) = C4 BNN = NOT ( A ( 11 )) KT = IAND ( A ( 3 ), A ( 7 )) C0 = IEOR ( A ( 24 ), KT ) KT = IOR ( A ( 7 ), A ( 11 )) C1 = IEOR ( A ( 3 ), KT ) KT = IOR ( BNN , A ( 15 )) C2 = IEOR ( A ( 7 ), KT ) KT = IAND ( A ( 15 ), A ( 24 )) C3 = IEOR ( BNN , KT ) KT = IOR ( A ( 24 ), A ( 3 )) C4 = IEOR ( A ( 15 ), KT ) A ( 24 ) = C0 A ( 3 ) = C1 A ( 7 ) = C2 A ( 11 ) = C3 A ( 15 ) = C4 BNN = NOT ( A ( 16 )) KT = IAND ( BNN , A ( 20 )) C0 = IEOR ( A ( 12 ), KT ) KT = IOR ( A ( 20 ), A ( 4 )) C1 = IEOR ( BNN , KT ) KT = IAND ( A ( 4 ), A ( 8 )) C2 = IEOR ( A ( 20 ), KT ) KT = IOR ( A ( 8 ), A ( 12 )) C3 = IEOR ( A ( 4 ), KT ) KT = IAND ( A ( 12 ), A ( 16 )) C4 = IEOR ( A ( 8 ), KT ) A ( 12 ) = C0 A ( 16 ) = C1 A ( 20 ) = C2 A ( 4 ) = C3 A ( 8 ) = C4 RETURN END SUBROUTINE Chi_Step_II !************************************************************************** END SUBROUTINE SHA3_ProcessBlock !****************************************************************************** SUBROUTINE SHA3_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE SHA3_DoPadding !****************************************************************************** SUBROUTINE SHA3_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SHA3 ), INTENT ( INOUT ) :: MD !! 'SHA3' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE ARGUMENT DECLARATIONS: tByte , PARAMETER :: Keccak_Suffix = ToInt8 ( Z '01' ) tByte , PARAMETER :: SHA3_Suffix = ToInt8 ( Z '06' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: Buf ( 0 : MD % BlockLen + 1 ) tIndex :: I , Ptr , BlockLen , BufLen tInteger :: BitsInQueue ! FLOW Ptr = MD % GetBufLen () BlockLen = MD % GetBlockLen () BitsInQueue = Ptr * 8 + NBits IF ( MD % IsKeccak ) THEN ! perform Keccak padding BLOCK tByte :: FinalInput ! execution FinalInput = IEOR ( SHIFTR ( LastByte , ( 8 - NBits )), & SHIFTL ( Keccak_Suffix , IAND ( BitsInQueue , 7 ))) IF ( Ptr == ( BlockLen - 1 )) THEN IF ( NBits == 7 ) THEN Buf ( 0 ) = FinalInput Buf ( 1 : BlockLen - 1 ) = FByte00 Buf ( BlockLen ) = FByte80 BufLen = BlockLen + 1 ELSE Buf ( 0 ) = IOR ( FinalInput , FByte80 ) BufLen = 1 END IF ELSE Buf ( 0 ) = FinalInput BufLen = BlockLen - Ptr Buf ( 1 : BufLen - 2 ) = FByte00 Buf ( BufLen - 1 ) = FByte80 END IF END BLOCK ELSE ! perform SHA-3 padding BLOCK tInteger :: FinalInput tByte :: FinalNBits ! execution FinalInput = IEOR ( SHIFTR ( LastByte , ( 8 - NBits )), & SHIFTL ( SHA3_Suffix , IAND ( BitsInQueue , 7 ))) FinalNBits = NBits + 2 IF ( Ptr == ( BlockLen - 1 )) THEN IF ( FinalNBits < 7 ) THEN Buf ( 0 ) = IOR ( ToInt8 ( FinalInput ), FByte80 ) BufLen = 1 ELSEIF ( FinalNBits == 7 ) THEN Buf ( 0 ) = ToInt8 ( FinalInput ) Buf ( 1 : BlockLen - 1 ) = FByte00 Buf ( BlockLen ) = FByte80 BufLen = BlockLen + 1 ELSE Buf ( 0 ) = ToInt8 ( FinalInput ) Buf ( 1 ) = ToInt8 ( SHIFTR ( FinalInput , 8 )) Buf ( 2 : BlockLen - 1 ) = FByte00 Buf ( BlockLen ) = FByte80 BufLen = BlockLen + 1 END IF ELSE IF ( FinalNBits < 8 ) THEN Buf ( 0 ) = ToInt8 ( FinalInput ) BufLen = BlockLen - Ptr Buf ( 1 : BufLen - 2 ) = FByte00 Buf ( BufLen - 1 ) = FByte80 ELSE IF ( Ptr == ( BlockLen - 2 )) THEN Buf ( 0 ) = ToInt8 ( FinalInput ) Buf ( 1 ) = IOR ( ToInt8 ( SHIFTR ( FinalInput , 8 )), FByte80 ) BufLen = BlockLen - Ptr ELSE Buf ( 0 ) = ToInt8 ( FinalInput ) Buf ( 1 ) = ToInt8 ( SHIFTR ( FinalInput , 8 )) BufLen = BlockLen - Ptr Buf ( 2 : BufLen - 2 ) = FByte00 Buf ( BufLen - 1 ) = FByte80 END IF END IF END IF END BLOCK END IF CALL MD % Update ( Buf , 0_kIndex , BufLen ) MD % State ( 1 ) = NOT ( MD % State ( 1 )) MD % State ( 2 ) = NOT ( MD % State ( 2 )) MD % State ( 8 ) = NOT ( MD % State ( 8 )) MD % State ( 12 ) = NOT ( MD % State ( 12 )) MD % State ( 17 ) = NOT ( MD % State ( 17 )) MD % State ( 20 ) = NOT ( MD % State ( 20 )) BLOCK !% buffer array used to store output data tByte :: BufOut ( 0 : MD % OutLen - 1 ) DO I = 0 , MD % DigestLen - 1 , 8 CALL ByteUnpackLE ( MD % State ( SHIFTR ( I , 3 )), BufOut , I ) END DO BytesOut ( Offset : Offset + MD % DigestLen - 1 ) = BufOut ( 0 : MD % DigestLen - 1 ) END BLOCK RETURN END SUBROUTINE SHA3_AddBitsNPad !****************************************************************************** END MODULE MClass_SHA3 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_sha3.f90.html"},{"title":"MClass_JHDigest.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_JHDigest !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *JHDigest* type and its related routines. !   The *JHDigest* type is a *digest* type that directly extends from the !   <a href=\"../module/mclass_mdengine.html#type-mdengine\">MDEngine</a> !   type.  As a *concrete* derived type, it provides all remaining !   deferred procedures required by all its abstract parent types. <br> !   The *JHDigest* type implements an incremental cryptographic hash !   function by employing the *JH message-digest* algorithm [1].  The !   implementation here is mainly based on the references [2]. <br> !   The *JHDigest* type represents four cryptographic hash functions: !   the *JH-224*, *JH-256*, *JH-384*, and *JH-512* hash functions.  By !   default, the *JHDigest* type represents the *JH-256* hash function. !   However, a user can specify the *Security* argument (to one of the !   four applicable values: 224, 256, 384 and 512) when initializing the !   digest object in order to use a different hash function and get a !   different hash output size. <br> !    <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://www3.ntu.edu.sg/home/wuhj/research/jh/\">Hash Function JH. </a> <br> !   [2] <a href=\"https://github.com/pornin/sphlib\">SPHLIB 3.0: A Set of !       Implementations of Various Hash Functions, Both in C and in Java. </a> <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToDecStrSigned USE MBase_BytePack , ONLY : BytePackBE , ByteUnpackBE USE MClass_BaseDigest USE MClass_MDEngine IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: JHDigest PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tByte       tUInt8 #define     tInteger    tUInt32 #define     tLong       tUInt64 !** MODULE PARAMETERS: tIndex , PARAMETER :: BlockLen = 64_kIndex tIndex , PARAMETER :: DLen224 = 28_kIndex tIndex , PARAMETER :: DLen256 = 32_kIndex tIndex , PARAMETER :: DLen384 = 48_kIndex tIndex , PARAMETER :: DLen512 = 64_kIndex tLong , PARAMETER :: IV224 ( 0 : 15 ) = [ & ToInt64 ( Z '2DFEDD62F99A98AC' ), ToInt64 ( Z 'AE7CACD619D634E7' ), & ToInt64 ( Z 'A4831005BC301216' ), ToInt64 ( Z 'B86038C6C9661494' ), & ToInt64 ( Z '66D9899F2580706F' ), ToInt64 ( Z 'CE9EA31B1D9B1ADC' ), & ToInt64 ( Z '11E8325F7B366E10' ), ToInt64 ( Z 'F994857F02FA06C1' ), & ToInt64 ( Z '1B4F1B5CD8C840B3' ), ToInt64 ( Z '97F6A17F6E738099' ), & ToInt64 ( Z 'DCDF93A5ADEAA3D3' ), ToInt64 ( Z 'A431E8DEC9539A68' ), & ToInt64 ( Z '22B4A98AEC86A1E4' ), ToInt64 ( Z 'D574AC959CE56CF0' ), & ToInt64 ( Z '15960DEAB5AB2BBF' ), ToInt64 ( Z '9611DCF0DD64EA6E' )] tLong , PARAMETER :: IV256 ( 0 : 15 ) = [ & ToInt64 ( Z 'EB98A3412C20D3EB' ), ToInt64 ( Z '92CDBE7B9CB245C1' ), & ToInt64 ( Z '1C93519160D4C7FA' ), ToInt64 ( Z '260082D67E508A03' ), & ToInt64 ( Z 'A4239E267726B945' ), ToInt64 ( Z 'E0FB1A48D41A9477' ), & ToInt64 ( Z 'CDB5AB26026B177A' ), ToInt64 ( Z '56F024420FFF2FA8' ), & ToInt64 ( Z '71A396897F2E4D75' ), ToInt64 ( Z '1D144908F77DE262' ), & ToInt64 ( Z '277695F776248F94' ), ToInt64 ( Z '87D5B6574780296C' ), & ToInt64 ( Z '5C5E272DAC8E0D6C' ), ToInt64 ( Z '518450C657057A0F' ), & ToInt64 ( Z '7BE4D367702412EA' ), ToInt64 ( Z '89E3AB13D31CD769' )] tLong , PARAMETER :: IV384 ( 0 : 15 ) = [ & ToInt64 ( Z '481E3BC6D813398A' ), ToInt64 ( Z '6D3B5E894ADE879B' ), & ToInt64 ( Z '63FAEA68D480AD2E' ), ToInt64 ( Z '332CCB21480F8267' ), & ToInt64 ( Z '98AEC84D9082B928' ), ToInt64 ( Z 'D455EA3041114249' ), & ToInt64 ( Z '36F555B2924847EC' ), ToInt64 ( Z 'C7250A93BAF43CE1' ), & ToInt64 ( Z '569B7F8A27DB454C' ), ToInt64 ( Z '9EFCBD496397AF0E' ), & ToInt64 ( Z '589FC27D26AA80CD' ), ToInt64 ( Z '80C08B8C9DEB2EDA' ), & ToInt64 ( Z '8A7981E8F8D5373A' ), ToInt64 ( Z 'F43967ADDDD17A71' ), & ToInt64 ( Z 'A9B4D3BDA475D394' ), ToInt64 ( Z '976C3FBA9842737F' )] tLong , PARAMETER :: IV512 ( 0 : 15 ) = [ & ToInt64 ( Z '6FD14B963E00AA17' ), ToInt64 ( Z '636A2E057A15D543' ), & ToInt64 ( Z '8A225E8D0C97EF0B' ), ToInt64 ( Z 'E9341259F2B3C361' ), & ToInt64 ( Z '891DA0C1536F801E' ), ToInt64 ( Z '2AA9056BEA2B6D80' ), & ToInt64 ( Z '588ECCDB2075BAA6' ), ToInt64 ( Z 'A90F3A76BAF83BF7' ), & ToInt64 ( Z '0169E60541E34A69' ), ToInt64 ( Z '46B58A8E2E6FE65A' ), & ToInt64 ( Z '1047A7D0C1843C24' ), ToInt64 ( Z '3B6E71B12D5AC199' ), & ToInt64 ( Z 'CF57F6EC9DB1F856' ), ToInt64 ( Z 'A706887C5716B156' ), & ToInt64 ( Z 'E3C2FCDFE68517FB' ), ToInt64 ( Z '545A4678CC8CDD4B' )] tLong , PARAMETER :: CParam ( 0 : 167 ) = [ & ToInt64 ( Z '72D5DEA2DF15F867' ), ToInt64 ( Z '7B84150AB7231557' ), & ToInt64 ( Z '81ABD6904D5A87F6' ), ToInt64 ( Z '4E9F4FC5C3D12B40' ), & ToInt64 ( Z 'EA983AE05C45FA9C' ), ToInt64 ( Z '03C5D29966B2999A' ), & ToInt64 ( Z '660296B4F2BB538A' ), ToInt64 ( Z 'B556141A88DBA231' ), & ToInt64 ( Z '03A35A5C9A190EDB' ), ToInt64 ( Z '403FB20A87C14410' ), & ToInt64 ( Z '1C051980849E951D' ), ToInt64 ( Z '6F33EBAD5EE7CDDC' ), & ToInt64 ( Z '10BA139202BF6B41' ), ToInt64 ( Z 'DC786515F7BB27D0' ), & ToInt64 ( Z '0A2C813937AA7850' ), ToInt64 ( Z '3F1ABFD2410091D3' ), & ToInt64 ( Z '422D5A0DF6CC7E90' ), ToInt64 ( Z 'DD629F9C92C097CE' ), & ToInt64 ( Z '185CA70BC72B44AC' ), ToInt64 ( Z 'D1DF65D663C6FC23' ), & ToInt64 ( Z '976E6C039EE0B81A' ), ToInt64 ( Z '2105457E446CECA8' ), & ToInt64 ( Z 'EEF103BB5D8E61FA' ), ToInt64 ( Z 'FD9697B294838197' ), & ToInt64 ( Z '4A8E8537DB03302F' ), ToInt64 ( Z '2A678D2DFB9F6A95' ), & ToInt64 ( Z '8AFE7381F8B8696C' ), ToInt64 ( Z '8AC77246C07F4214' ), & ToInt64 ( Z 'C5F4158FBDC75EC4' ), ToInt64 ( Z '75446FA78F11BB80' ), & ToInt64 ( Z '52DE75B7AEE488BC' ), ToInt64 ( Z '82B8001E98A6A3F4' ), & ToInt64 ( Z '8EF48F33A9A36315' ), ToInt64 ( Z 'AA5F5624D5B7F989' ), & ToInt64 ( Z 'B6F1ED207C5AE0FD' ), ToInt64 ( Z '36CAE95A06422C36' ), & ToInt64 ( Z 'CE2935434EFE983D' ), ToInt64 ( Z '533AF974739A4BA7' ), & ToInt64 ( Z 'D0F51F596F4E8186' ), ToInt64 ( Z '0E9DAD81AFD85A9F' ), & ToInt64 ( Z 'A7050667EE34626A' ), ToInt64 ( Z '8B0B28BE6EB91727' ), & ToInt64 ( Z '47740726C680103F' ), ToInt64 ( Z 'E0A07E6FC67E487B' ), & ToInt64 ( Z '0D550AA54AF8A4C0' ), ToInt64 ( Z '91E3E79F978EF19E' ), & ToInt64 ( Z '8676728150608DD4' ), ToInt64 ( Z '7E9E5A41F3E5B062' ), & ToInt64 ( Z 'FC9F1FEC4054207A' ), ToInt64 ( Z 'E3E41A00CEF4C984' ), & ToInt64 ( Z '4FD794F59DFA95D8' ), ToInt64 ( Z '552E7E1124C354A5' ), & ToInt64 ( Z '5BDF7228BDFE6E28' ), ToInt64 ( Z '78F57FE20FA5C4B2' ), & ToInt64 ( Z '05897CEFEE49D32E' ), ToInt64 ( Z '447E9385EB28597F' ), & ToInt64 ( Z '705F6937B324314A' ), ToInt64 ( Z '5E8628F11DD6E465' ), & ToInt64 ( Z 'C71B770451B920E7' ), ToInt64 ( Z '74FE43E823D4878A' ), & ToInt64 ( Z '7D29E8A3927694F2' ), ToInt64 ( Z 'DDCB7A099B30D9C1' ), & ToInt64 ( Z '1D1B30FB5BDC1BE0' ), ToInt64 ( Z 'DA24494FF29C82BF' ), & ToInt64 ( Z 'A4E7BA31B470BFFF' ), ToInt64 ( Z '0D324405DEF8BC48' ), & ToInt64 ( Z '3BAEFC3253BBD339' ), ToInt64 ( Z '459FC3C1E0298BA0' ), & ToInt64 ( Z 'E5C905FDF7AE090F' ), ToInt64 ( Z '947034124290F134' ), & ToInt64 ( Z 'A271B701E344ED95' ), ToInt64 ( Z 'E93B8E364F2F984A' ), & ToInt64 ( Z '88401D63A06CF615' ), ToInt64 ( Z '47C1444B8752AFFF' ), & ToInt64 ( Z '7EBB4AF1E20AC630' ), ToInt64 ( Z '4670B6C5CC6E8CE6' ), & ToInt64 ( Z 'A4D5A456BD4FCA00' ), ToInt64 ( Z 'DA9D844BC83E18AE' ), & ToInt64 ( Z '7357CE453064D1AD' ), ToInt64 ( Z 'E8A6CE68145C2567' ), & ToInt64 ( Z 'A3DA8CF2CB0EE116' ), ToInt64 ( Z '33E906589A94999A' ), & ToInt64 ( Z '1F60B220C26F847B' ), ToInt64 ( Z 'D1CEAC7FA0D18518' ), & ToInt64 ( Z '32595BA18DDD19D3' ), ToInt64 ( Z '509A1CC0AAA5B446' ), & ToInt64 ( Z '9F3D6367E4046BBA' ), ToInt64 ( Z 'F6CA19AB0B56EE7E' ), & ToInt64 ( Z '1FB179EAA9282174' ), ToInt64 ( Z 'E9BDF7353B3651EE' ), & ToInt64 ( Z '1D57AC5A7550D376' ), ToInt64 ( Z '3A46C2FEA37D7001' ), & ToInt64 ( Z 'F735C1AF98A4D842' ), ToInt64 ( Z '78EDEC209E6B6779' ), & ToInt64 ( Z '41836315EA3ADBA8' ), ToInt64 ( Z 'FAC33B4D32832C83' ), & ToInt64 ( Z 'A7403B1F1C2747F3' ), ToInt64 ( Z '5940F034B72D769A' ), & ToInt64 ( Z 'E73E4E6CD2214FFD' ), ToInt64 ( Z 'B8FD8D39DC5759EF' ), & ToInt64 ( Z '8D9B0C492B49EBDA' ), ToInt64 ( Z '5BA2D74968F3700D' ), & ToInt64 ( Z '7D3BAED07A8D5584' ), ToInt64 ( Z 'F5A5E9F0E4F88E65' ), & ToInt64 ( Z 'A0B8A2F436103B53' ), ToInt64 ( Z '0CA8079E753EEC5A' ), & ToInt64 ( Z '9168949256E8884F' ), ToInt64 ( Z '5BB05C55F8BABC4C' ), & ToInt64 ( Z 'E3BB3B99F387947B' ), ToInt64 ( Z '75DAF4D6726B1C5D' ), & ToInt64 ( Z '64AEAC28DC34B36D' ), ToInt64 ( Z '6C34A550B828DB71' ), & ToInt64 ( Z 'F861E2F2108D512A' ), ToInt64 ( Z 'E3DB643359DD75FC' ), & ToInt64 ( Z '1CACBCF143CE3FA2' ), ToInt64 ( Z '67BBD13C02E843B0' ), & ToInt64 ( Z '330A5BCA8829A175' ), ToInt64 ( Z '7F34194DB416535C' ), & ToInt64 ( Z '923B94C30E794D1E' ), ToInt64 ( Z '797475D7B6EEAF3F' ), & ToInt64 ( Z 'EAA8D4F7BE1A3921' ), ToInt64 ( Z '5CF47E094C232751' ), & ToInt64 ( Z '26A32453BA323CD2' ), ToInt64 ( Z '44A3174A6DA6D5AD' ), & ToInt64 ( Z 'B51D3EA6AFF2C908' ), ToInt64 ( Z '83593D98916B3C56' ), & ToInt64 ( Z '4CF87CA17286604D' ), ToInt64 ( Z '46E23ECC086EC7F6' ), & ToInt64 ( Z '2F9833B3B1BC765E' ), ToInt64 ( Z '2BD666A5EFC4E62A' ), & ToInt64 ( Z '06F4B6E8BEC1D436' ), ToInt64 ( Z '74EE8215BCEF2163' ), & ToInt64 ( Z 'FDC14E0DF453C969' ), ToInt64 ( Z 'A77D5AC406585826' ), & ToInt64 ( Z '7EC1141606E0FA16' ), ToInt64 ( Z '7E90AF3D28639D3F' ), & ToInt64 ( Z 'D2C9F2E3009BD20C' ), ToInt64 ( Z '5FAACE30B7D40C30' ), & ToInt64 ( Z '742A5116F2E03298' ), ToInt64 ( Z '0DEB30D8E3CEF89A' ), & ToInt64 ( Z '4BC59E7BB5F17992' ), ToInt64 ( Z 'FF51E66E048668D3' ), & ToInt64 ( Z '9B234D57E6966731' ), ToInt64 ( Z 'CCE6A6F3170A7505' ), & ToInt64 ( Z 'B17681D913326CCE' ), ToInt64 ( Z '3C175284F805A262' ), & ToInt64 ( Z 'F42BCBB378471547' ), ToInt64 ( Z 'FF46548223936A48' ), & ToInt64 ( Z '38DF58074E5E6565' ), ToInt64 ( Z 'F2FC7C89FC86508E' ), & ToInt64 ( Z '31702E44D00BCA86' ), ToInt64 ( Z 'F04009A23078474E' ), & ToInt64 ( Z '65A0EE39D1F73883' ), ToInt64 ( Z 'F75EE937E42C3ABD' ), & ToInt64 ( Z '2197B2260113F86F' ), ToInt64 ( Z 'A344EDD1EF9FDEE7' ), & ToInt64 ( Z '8BA0DF15762592D9' ), ToInt64 ( Z '3C85F7F612DC42BE' ), & ToInt64 ( Z 'D8A7EC7CAB27B07E' ), ToInt64 ( Z '538D7DDAAA3EA8DE' ), & ToInt64 ( Z 'AA25CE93BD0269D8' ), ToInt64 ( Z '5AF643FD1A7308F9' ), & ToInt64 ( Z 'C05FEFDA174A19A5' ), ToInt64 ( Z '974D66334CFD216A' ), & ToInt64 ( Z '35B49831DB411570' ), ToInt64 ( Z 'EA1E0FBBEDCD549B' ), & ToInt64 ( Z '9AD063A151974072' ), ToInt64 ( Z 'F6759DBF91476FE2' )] !** DERIVED TYPE DEFINITIONS !> *JHDigest* is a concrete *digest* type that implements an incremental !  cryptographic hash function based on the JH hash functions. TYPE , EXTENDS ( MDEngine ) :: JHDigest PRIVATE !% buffer array used to store input data tByte :: BufArr ( 0 : BlockLen - 1 ) = 0_kInt8 !% state tLong :: State ( 0 : 15 ) = IV256 ( 0 : 15 ) !% security strength in bits tInteger :: Security = 256 !% length of hash output in bytes tIndex :: DigestLen = DLen256 CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *InitializeWSecurity* method to !  initialize the *digest* object with specified security. PROCEDURE , PRIVATE :: InitializeWSecurity => JHDigest_Initialize_wSecurity ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> Use the *Create* method in place of the *Initialize* method to !  initialize the *digest* object with default algorithm (JH-256). PROCEDURE :: Initialize => JHDigest_Initialize !> **Type-Bound Subroutine**: Reset <br> !  **Purpose**:  To reset the *digest* object to its initial state. <br> !  **Usage**: <br> !   --->    CALL MD%Reset() PROCEDURE :: Reset => JHDigest_Reset !> **Type-Bound Subroutine**: GetClone <br> !  **Purpose**:  To clone the current state of the source object. The destination !                object evolves independently of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcMD%GetClone(DstMD) PROCEDURE :: GetClone => JHDigest_GetClone !> **Type-Bound Function**: GetName <br> !  **Purpose**:  To get the name of the *digest* object. <br> !  **Usage**: <br> !   --->    Name = MD%GetName() PROCEDURE :: GetName => JHDigest_GetName !> **Type-Bound Function**: GetDigestLen <br> !  **Purpose**:  To return the natural hash function output length (in bytes). <br> !  **Usage**: <br> !   --->    Length = MD%GetDigestLen() PROCEDURE :: GetDigestLen => JHDigest_GetDigestLen !> *GetBlockLen* is a procedure to return the block length of the digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: GetBlockLen => JHDigest_GetBlockLen !> *SetBufPtr* is a procedure to set a pointer to the buffer array of this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: SetBufPtr => JHDigest_SetBufPtr !> *ProcessBlock* is a procedure to process one block of data for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: ProcessBlock => JHDigest_ProcessBlock !> *DoPadding* is a procedure to perform padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: DoPadding => JHDigest_DoPadding !> *AddBitsNPad* is a procedure to add the final partial byte and then perform !  padding of the message for this digest. <br> !  This method is NOT intended to be used by a user. PROCEDURE :: AddBitsNPad => JHDigest_AddBitsNPad ! --------------------------------------------------------------------- ! -----                     Generic Interfaces                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Create <br> !  **Purpose**:  To perform any essential initialization of the *digest* object. <br> !  **Usage**: <br> !   ! initialize the object to employ the default (JH-256) algorithm <br> !   --->    CALL MD%Create() <br> !   ! initialize the object to employ the JH-512 algorithm <br> !   --->    CALL MD%Create(512) <br> GENERIC :: Create => InitializeWSecurity END TYPE JHDigest !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE JHDigest_Initialize ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with default algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % Security = 256 MD % DigestLen = DLen512 CALL MD % Reset () RETURN END SUBROUTINE JHDigest_Initialize !****************************************************************************** SUBROUTINE JHDigest_Initialize_wSecurity ( MD , Security ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the digest object with the specified Security. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object tInteger , INTENT ( IN ) :: Security !&#94; Strength of security in bits with four possible values: 224, 256, 384 and 512. !  If the specified value is NOT valid, it is set to the default (256) value. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Security ) CASE ( 224 , 256 , 384 , 512 ) MD % Security = Security CASE DEFAULT MD % Security = 256 END SELECT SELECT CASE ( MD % Security ) CASE ( 224 ) MD % DigestLen = DLen224 CASE ( 256 ) MD % DigestLen = DLen256 CASE ( 384 ) MD % DigestLen = DLen384 CASE ( 512 ) MD % DigestLen = DLen512 END SELECT CALL MD % Reset () RETURN END SUBROUTINE JHDigest_Initialize_wSecurity !****************************************************************************** SUBROUTINE JHDigest_Reset ( MD ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the hash algorithm state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MD % BufArr = 0_kInt8 SELECT CASE ( MD % Security ) CASE ( 224 ) MD % State = IV224 CASE ( 256 ) MD % State = IV256 CASE ( 384 ) MD % State = IV384 CASE ( 512 ) MD % State = IV512 END SELECT CALL MD % EngineReset () RETURN END SUBROUTINE JHDigest_Reset !****************************************************************************** SUBROUTINE JHDigest_GetClone ( Src , Dst ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clone the current state of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: Src !! a source object CLASS ( BaseDigest ), ALLOCATABLE , INTENT ( OUT ) :: Dst !! a destination object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( JHDigest :: Dst ) SELECT TYPE ( Dst ) TYPE IS ( JHDigest ) CALL Dst % Create ( Src % Security ) Dst % State = Src % State Dst % BufArr = Src % BufArr CALL Src % EngineClone ( Dst ) END SELECT RETURN END SUBROUTINE JHDigest_GetClone !****************************************************************************** FUNCTION JHDigest_GetName ( MD ) RESULT ( Name ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the algorithm name of the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( IN ) :: MD !! 'JHDigest' object tCharAlloc :: Name !! name of the hash function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Name = 'JH-' // ToDecStrSigned ( MD % Security ) RETURN END FUNCTION JHDigest_GetName !****************************************************************************** FUNCTION JHDigest_GetDigestLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the natural hash function output length (in bytes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( IN ) :: MD !! 'JHDigest' object tIndex :: Length !! the digest length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = MD % DigestLen RETURN END FUNCTION JHDigest_GetDigestLen !****************************************************************************** FUNCTION JHDigest_GetBlockLen ( MD ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the block length for the hash function. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( IN ) :: MD !! 'JHDigest' object tIndex :: Length !! the block length !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = BlockLen ASSOCIATE ( Dummy => MD ); END ASSOCIATE RETURN END FUNCTION JHDigest_GetBlockLen !****************************************************************************** SUBROUTINE JHDigest_SetBufPtr ( MD , BufPtr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the pointer *BufPtr* to the actual buffer array with starting index of zero. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), TARGET , INTENT ( INOUT ) :: MD !! 'JHDigest' object tByte , POINTER , INTENT ( INOUT ) :: BufPtr (:) !! a buffer pointer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW BufPtr => MD % BufArr RETURN END SUBROUTINE JHDigest_SetBufPtr !****************************************************************************** SUBROUTINE JHDigest_ProcessBlock ( MD , BytesIn ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process one block of data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object tByte , INTENT ( IN ) :: BytesIn ( 0 :) !! the data block !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: MS ( 0 : 7 ) tIndex :: I tInteger :: Round ! FLOW ! input block CALL BytePackBE ( BytesIn , 0_kIndex , MS ) ! initialize state values DO I = 0 , 7 MD % State ( I ) = IEOR ( MD % State ( I ), MS ( I )) END DO ! process data Round = 0 DO WHILE ( Round < 42 ) CALL DoS ( MD % State , Round ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '5555555555555555' ), 1 ) CALL DoS ( MD % State , Round + 1 ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '3333333333333333' ), 2 ) CALL DoS ( MD % State , Round + 2 ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '0F0F0F0F0F0F0F0F' ), 4 ) CALL DoS ( MD % State , Round + 3 ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '00FF00FF00FF00FF' ), 8 ) CALL DoS ( MD % State , Round + 4 ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '0000FFFF0000FFFF' ), 16 ) CALL DoS ( MD % State , Round + 5 ) CALL DoL ( MD % State ) CALL DoWgen ( MD % State , ToInt64 ( Z '00000000FFFFFFFF' ), 32 ) CALL DoS ( MD % State , Round + 6 ) CALL DoL ( MD % State ) CALL DoW6 ( MD % State ) Round = Round + 7 END DO ! return state values DO I = 0 , 7 MD % State ( I + 8 ) = IEOR ( MD % State ( I + 8 ), MS ( I )) END DO RETURN CONTAINS SUBROUTINE DoS ( H , R ) !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: H ( 0 : 15 ) tInteger , INTENT ( IN ) :: R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: X0 , X1 , X2 , X3 , CC , Tmp tInteger :: RShiftL , I ! FLOW RShiftL = SHIFTL ( R , 2 ) DO I = 0 , 3 CC = CPaRam ( RShiftL + I ) X0 = H ( I ) X1 = H ( I + 4 ) X2 = H ( I + 8 ) X3 = H ( I + 12 ) X3 = NOT ( X3 ) X0 = IEOR ( X0 , IAND ( CC , NOT ( X2 ))) Tmp = IEOR ( CC , IAND ( X0 , X1 )) X0 = IEOR ( X0 , IAND ( X2 , X3 )) X3 = IEOR ( X3 , IAND ( NOT ( X1 ), X2 )) X1 = IEOR ( X1 , IAND ( X0 , X2 )) X2 = IEOR ( X2 , IAND ( X0 , NOT ( X3 ))) X0 = IEOR ( X0 , IOR ( X1 , X3 )) X3 = IEOR ( X3 , IAND ( X1 , X2 )) X1 = IEOR ( X1 , IAND ( Tmp , X0 )) X2 = IEOR ( X2 , Tmp ) H ( I ) = X0 H ( I + 4 ) = X1 H ( I + 8 ) = X2 H ( I + 12 ) = X3 END DO RETURN END SUBROUTINE DoS !************************************************************************** SUBROUTINE DoL ( H ) !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: H ( 0 : 15 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: X0 , X1 , X2 , X3 , X4 , X5 , X6 , X7 ! FLOW X0 = H ( 0 ) X1 = H ( 4 ) X2 = H ( 8 ) X3 = H ( 12 ) X4 = H ( 2 ) X5 = H ( 6 ) X6 = H ( 10 ) X7 = H ( 14 ) X4 = IEOR ( X4 , X1 ) X5 = IEOR ( X5 , X2 ) X6 = IEOR ( X6 , IEOR ( X3 , X0 )) X7 = IEOR ( X7 , X0 ) X0 = IEOR ( X0 , X5 ) X1 = IEOR ( X1 , X6 ) X2 = IEOR ( X2 , IEOR ( X7 , X4 )) X3 = IEOR ( X3 , X4 ) H ( 0 ) = X0 H ( 4 ) = X1 H ( 8 ) = X2 H ( 12 ) = X3 H ( 2 ) = X4 H ( 6 ) = X5 H ( 10 ) = X6 H ( 14 ) = X7 X0 = H ( 1 ) X1 = H ( 5 ) X2 = H ( 9 ) X3 = H ( 13 ) X4 = H ( 3 ) X5 = H ( 7 ) X6 = H ( 11 ) X7 = H ( 15 ) X4 = IEOR ( X4 , X1 ) X5 = IEOR ( X5 , X2 ) X6 = IEOR ( X6 , IEOR ( X3 , X0 )) X7 = IEOR ( X7 , X0 ) X0 = IEOR ( X0 , X5 ) X1 = IEOR ( X1 , X6 ) X2 = IEOR ( X2 , IEOR ( X7 , X4 )) X3 = IEOR ( X3 , X4 ) H ( 1 ) = X0 H ( 5 ) = X1 H ( 9 ) = X2 H ( 13 ) = X3 H ( 3 ) = X4 H ( 7 ) = X5 H ( 11 ) = X6 H ( 15 ) = X7 RETURN END SUBROUTINE DoL !************************************************************************** SUBROUTINE DoWGen ( H , C , N ) !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: H ( 0 : 15 ) tLong , INTENT ( IN ) :: C tInteger , INTENT ( IN ) :: N !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW #define WGen(X, C, N)   IOR(SHIFTL(IAND(X, C), N), IAND(SHIFTR(X, N), C)) H ( 2 ) = WGen ( H ( 2 ), C , N ) H ( 3 ) = WGen ( H ( 3 ), C , N ) H ( 6 ) = WGen ( H ( 6 ), C , N ) H ( 7 ) = WGen ( H ( 7 ), C , N ) H ( 10 ) = WGen ( H ( 10 ), C , N ) H ( 11 ) = WGen ( H ( 11 ), C , N ) H ( 14 ) = WGen ( H ( 14 ), C , N ) H ( 15 ) = WGen ( H ( 15 ), C , N ) #undef WGen RETURN END SUBROUTINE DoWGen !************************************************************************** SUBROUTINE DoW6 ( H ) !** SUBROUTINE ARGUMENT DECLARATIONS: tLong , INTENT ( INOUT ) :: H ( 0 : 15 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLong :: Temp ! FLOW EXCHANGE ( H , 2 , 3 ) EXCHANGE ( H , 6 , 7 ) EXCHANGE ( H , 10 , 11 ) EXCHANGE ( H , 14 , 15 ) RETURN END SUBROUTINE DoW6 !************************************************************************** END SUBROUTINE JHDigest_ProcessBlock !****************************************************************************** SUBROUTINE JHDigest_DoPadding ( MD , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform the final padding and store the result in the !  provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! use the 'AddBitsNPad' method with no partial last byte CALL MD % AddBitsNPad ( 0_kInt8 , 0_kInt8 , BytesOut , Offset ) RETURN END SUBROUTINE JHDigest_DoPadding !****************************************************************************** SUBROUTINE JHDigest_AddBitsNPad ( MD , LastByte , NBits , BytesOut , Offset ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the last byte and then perform the final padding and !  store the result in the provided buffer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( JHDigest ), INTENT ( INOUT ) :: MD !! 'JHDigest' object tByte , INTENT ( IN ) :: LastByte !! the last byte tByte , INTENT ( IN ) :: NBits !! number of bits in the last byte tByte , INTENT ( INOUT ) :: BytesOut ( 0 :) !! the output buffer tIndex , INTENT ( IN ) :: Offset !! the output offset !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tByte :: TmpBuf ( 0 : 127 ) tIndex :: Rem , NumZ , I , DLen tLong :: BC tByte :: Z ! FLOW Rem = MD % GetBufLen () BC = MD % GetBlockCount () IF (( Rem == 0_kIndex ). AND .( NBits == 0_kInt8 )) THEN NumZ = 47_kIndex ELSE NumZ = 111_kIndex - Rem END IF Z = SHIFTR ( FByte80 , NBits ) TmpBuf ( 0 ) = IAND ( IOR ( IAND ( LastByte , - Z ), Z ), FByteFF ) TmpBuf ( 1 : NumZ ) = FByte00 CALL ByteUnpackBE ( SHIFTR ( BC , 55 ), TmpBuf , NumZ + 1_kIndex ) CALL ByteUnpackBE ( SHIFTL ( BC , 9 ) + SHIFTL ( Rem , 3 ) + NBits , TmpBuf , NumZ + 9_kIndex ) CALL MD % Update ( TmpBuf , 0_kIndex , NumZ + 17_kIndex ) DO I = 0 , 7 CALL ByteUnpackBE ( MD % State ( I + 8 ), TmpBuf , SHIFTL ( I , 3 )) END DO DLen = MD % GetDigestLen () BytesOut ( Offset : Offset + DLen - 1 ) = TmpBuf ( 64 - DLen : 63 ) RETURN END SUBROUTINE JHDigest_AddBitsNPad !****************************************************************************** END MODULE MClass_JHDigest !******************************************************************************","tags":"","loc":"sourcefile\\mclass_jhdigest.f90.html"}]}
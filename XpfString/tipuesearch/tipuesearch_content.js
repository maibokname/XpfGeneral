var tipuesearch = {"pages":[{"title":" eXPerimental Fortran Library (XpfLib) Documentation ","text":"eXPerimental Fortran Library (XpfLib) Documentation !+++ external: XpfBase=./XpfGeneral/XpfBase +++! ! Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"SyntaxNode – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(DoublyLinkedNode) :: SyntaxNode The SyntaxNode type is a node type... Components Type Visibility Attributes Name Initial integer(kind=kInt32), public :: Type = Node_Undefined node type integer(kind=kInt32), public :: ID = 0 node identification (only used for branch nodes) character(kind=kChar, len=1), public :: C = NULCHR character used only for LeafNode_Char Type-Bound Procedures procedure, public :: Copy => SyntaxNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine SyntaxNode_Copy(SrcObj, DstObj, IsDeep) To copy the SyntaxNode object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => SyntaxNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function SyntaxNode_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => SyntaxNode_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). private  subroutine SyntaxNode_MemFree(Obj) To free memory of the SyntaxNode object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(inout) :: Obj procedure, public :: ToString => SyntaxNode_ToString ToString is a deferred procedure to get the string representation of this object. private  function SyntaxNode_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: GetRight => SyntaxNode_GetRightNode Type-Bound Function : GetRight Purpose :  To get a pointer to the right node of the current node. Usage : --->    RightNode => CurrNode%GetRight() private  function SyntaxNode_GetRightNode(CurrNode) result(RightNode) To get the right node of the current node. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: CurrNode current node Return Value type( SyntaxNode ), POINTER right node procedure, public :: GetLeft => SyntaxNode_GetLeftNode Type-Bound Function : GetLeft Purpose :  To get a pointer to the left node of the current node. Usage : --->    LeftNode => CurrNode%GetLeft() private  function SyntaxNode_GetLeftNode(CurrNode) result(LeftNode) To get the left node of the current node. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: CurrNode current node Return Value type( SyntaxNode ), POINTER left node procedure, public :: SetRight => SyntaxNode_SetRightNode Type-Bound Subroutine : SetRight Purpose :  To set a pointer to the right node of the current node. Usage : --->    CALL CurrNode%SetRight(RightNode) private  subroutine SyntaxNode_SetRightNode(CurrNode, RightNode) To set the right node of the current node. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(inout) :: CurrNode current node type( SyntaxNode ), intent(in), TARGET :: RightNode right node procedure, public :: SetLeft => SyntaxNode_SetLeftNode Type-Bound Subroutine : SetLeft Purpose :  To set a pointer to the left node of the current node. Usage : --->    CALL CurrNode%SetLeft(LeftNode) private  subroutine SyntaxNode_SetLeftNode(CurrNode, LeftNode) To set the left node of the current node. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(inout) :: CurrNode current node type( SyntaxNode ), intent(in), TARGET :: LeftNode left node procedure, public :: HasRight => SyntaxNode_HasRightNode Type-Bound Function : HasRight Purpose :  To check whether the right node of the specified node is associated or not. Usage : --->    Flag = CurrNode%HasRight() --->    IF (.NOT.CurrNode%HasRight()) DoSomething private  function SyntaxNode_HasRightNode(CurrNode) result(Flag) To check whether the right node of the specified node is associated or not. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: CurrNode current node Return Value logical true if right node is associated procedure, public :: HasLeft => SyntaxNode_HasLeftNode Type-Bound Function : HasLeft Purpose :  To check whether the left node of the specified node is associated or not. Usage : --->    Flag = CurrNode%HasLeft() --->    IF (.NOT.CurrNode%HasLeft()) DoSomething private  function SyntaxNode_HasLeftNode(CurrNode) result(Flag) To check whether the left node of the specified node is associated or not. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(in) :: CurrNode current node Return Value logical true if right node is associated procedure, public :: Operate => SyntaxNode_Operate Type-Bound Subroutine : Operate Purpose :  To set a pointer to both the left and right nodes of the current node.\n               This operation is applicable only for the \"BranchNode_Or\", \"BranchNode_Many\",\n               or \"BranchNode_Concat\" node type. Usage : --->    CALL CurrNode%Operate(LeftNode, RightNode) private  subroutine SyntaxNode_Operate(CurrNode, LeftNode, RightNode) To set both the left and right nodes of the current node.  This operation is applicable\n only for the \"BranchNode_Or\", \"BranchNode_Many\", or \"BranchNode_Concat\" node type. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(inout) :: CurrNode current node class(DoublyLinkedNode), intent(in) :: LeftNode left node class(DoublyLinkedNode), intent(in) :: RightNode right node procedure, public :: SetChar => SyntaxNode_SetCharacter Type-Bound Subroutine : SetChar Purpose :  To set the specified character to the current node.  This operation is\n               only applicable for the \"LeafNode_Char\" node type. Usage : --->    CALL CurrNode%SetChar(C) private  subroutine SyntaxNode_SetCharacter(CurrNode, C) To set the specified character to the current node.  This operation is\n only applicable for the \"LeafNode_Char\" node type. Arguments Type Intent Optional Attributes Name class( SyntaxNode ), intent(inout) :: CurrNode current node character(kind=kChar, len=1), intent(in) :: C character to be set Source Code TYPE , EXTENDS ( DoublyLinkedNode ) :: SyntaxNode tSInt32 :: Type = Node_Undefined !! node type tSInt32 :: ID = 0 !! node identification (only used for branch nodes) tChar :: C = NULCHR !! character used only for LeafNode_Char CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => SyntaxNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => SyntaxNode_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => SyntaxNode_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => SyntaxNode_ToString ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetRight <br> !  **Purpose**:  To get a pointer to the right node of the current node. <br> !  **Usage**: <br> !   --->    RightNode => CurrNode%GetRight() PROCEDURE :: GetRight => SyntaxNode_GetRightNode !> **Type-Bound Function**: GetLeft <br> !  **Purpose**:  To get a pointer to the left node of the current node. <br> !  **Usage**: <br> !   --->    LeftNode => CurrNode%GetLeft() PROCEDURE :: GetLeft => SyntaxNode_GetLeftNode !> **Type-Bound Subroutine**: SetRight <br> !  **Purpose**:  To set a pointer to the right node of the current node. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetRight(RightNode) PROCEDURE :: SetRight => SyntaxNode_SetRightNode !> **Type-Bound Subroutine**: SetLeft <br> !  **Purpose**:  To set a pointer to the left node of the current node. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetLeft(LeftNode) PROCEDURE :: SetLeft => SyntaxNode_SetLeftNode !> **Type-Bound Function**: HasRight <br> !  **Purpose**:  To check whether the right node of the specified node is associated or not. <br> !  **Usage**: <br> !   --->    Flag = CurrNode%HasRight() <br> !   --->    IF (.NOT.CurrNode%HasRight()) DoSomething <br> PROCEDURE :: HasRight => SyntaxNode_HasRightNode !> **Type-Bound Function**: HasLeft <br> !  **Purpose**:  To check whether the left node of the specified node is associated or not. <br> !  **Usage**: <br> !   --->    Flag = CurrNode%HasLeft() <br> !   --->    IF (.NOT.CurrNode%HasLeft()) DoSomething <br> PROCEDURE :: HasLeft => SyntaxNode_HasLeftNode !> **Type-Bound Subroutine**: Operate <br> !  **Purpose**:  To set a pointer to both the left and right nodes of the current node. !                This operation is applicable only for the \"BranchNode_Or\", \"BranchNode_Many\", !                or \"BranchNode_Concat\" node type. <br> !  **Usage**: <br> !   --->    CALL CurrNode%Operate(LeftNode, RightNode) PROCEDURE :: Operate => SyntaxNode_Operate !> **Type-Bound Subroutine**: SetChar <br> !  **Purpose**:  To set the specified character to the current node.  This operation is !                only applicable for the \"LeafNode_Char\" node type. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetChar(C) PROCEDURE :: SetChar => SyntaxNode_SetCharacter END TYPE SyntaxNode","tags":"","loc":"type\\syntaxnode.html"},{"title":"FvlStr – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(Comparable) :: FvlStr FvlStr is a string type that represents a variable-length string class.\n It provides various methods/procedures to handle and manipulate strings. Constructor public        interface FvlStr Function Interface : FvlStr Purpose :  To construct a FvlStr object based on specified input. Usage : ! construct a FvlStr object from an array of characters --->    vStr = FvlStr(cArray) ! construct a FvlStr object from double-precision real number --->    vStr = FvlStr(R64, IsScientific=.TRUE.) private module function CharacterArray_To_FvlStr(cArr, IsCString) result(vStr) To convert an array of characters to a FvlStr object. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: cArr (:) array of characters logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array must contain a null character. Default is FALSE. Return Value type( FvlStr ) FvlStr object private module function IByte_To_FvlStr(IntNum) result(vStr) To convert an 8-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function IShort_To_FvlStr(IntNum) result(vStr) To convert a 16-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function Integer_To_FvlStr(IntNum) result(vStr) To convert a 32-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function ILong_To_FvlStr(IntNum) result(vStr) To convert a 64-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function RSingle_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a single-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RDouble_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a double-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RQuad_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a quadruple-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CSingle_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a single-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CDouble_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a double-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CQuad_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a quadruple-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function Logical_To_FvlStr(Boolean) result(vStr) To convert a logical value to a FvlStr object. Arguments Type Intent Optional Attributes Name logical, intent(in) :: Boolean logical value Return Value type( FvlStr ) FvlStr object Finalization Procedures final :: FinalizeFvlStr private  subroutine FinalizeFvlStr(vStr) To finalize the FvlStr object Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: vStr FvlStr object Type-Bound Procedures procedure, public :: ToCharString => CharAlloc_From_FvlStr Type-Bound Function : ToCharString Purpose :  To convert a FvlStr object to an allocatable character\n      string. Usage : --->    cStr = vStr%ToCharString() interface private module function CharAlloc_From_FvlStr(vStr) result(cStr) To convert a FvlStr object to an allocatable character string. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object Return Value character(kind=kChar, len=:), ALLOCATABLE character string procedure, public :: ToChrArrAlloc => CharArray_From_FvlStr Type-Bound Function : ToChrArrAlloc Purpose :  To convert a FvlStr object to an allocatable array\n      of characters. Usage : ! convert a FvlStr object to a character array --->    cArray = vStr%ToChrArrAlloc() ! convert a FvlStr object to a character array with a null character --->    cArray = vStr%ToChrArrAlloc(IsCString=.TRUE.) interface private module function CharArray_From_FvlStr(vStr, IsCString) result(cArr) To convert a FvlStr object to an allocatable array of characters. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array will contain a null character. Default is FALSE. Return Value character(kind=kChar, len=1), ALLOCATABLE, (:) character array procedure, public :: ParseByte => IByte_From_FvlStr Type-Bound Function : ParseByte Purpose :  To parse the string of a FvlStr object as an 8-bit integer number. Usage : --->    NumVal = vStr%ParseByte() --->    NumVal = vStr%ParseByte(ErrFlag, ErrMsg) interface private module function IByte_From_FvlStr(vStr, ErrFlag, ErrMsg) result(IntNum) To convert a FvlStr object to an 8-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt8) integer number procedure, public :: ParseShort => IShort_From_FvlStr Type-Bound Function : ParseShort Purpose :  To parse the string of a FvlStr object as a 16-bit integer number. Usage : --->    NumVal = vStr%ParseShort() --->    NumVal = vStr%ParseShort(ErrFlag, ErrMsg) interface private module function IShort_From_FvlStr(vStr, ErrFlag, ErrMsg) result(IntNum) To convert a FvlStr object to a 16-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt16) integer number procedure, public :: ParseInteger => Integer_From_FvlStr Type-Bound Function : ParseInteger Purpose :  To parse the string of a FvlStr object as a 32-bit integer number. Usage : --->    NumVal = vStr%ParseInteger() --->    NumVal = vStr%ParseInteger(ErrFlag, ErrMsg) interface private module function Integer_From_FvlStr(vStr, ErrFlag, ErrMsg) result(IntNum) To convert a FvlStr object to a 32-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) integer number procedure, public :: ParseLong => ILong_From_FvlStr Type-Bound Function : ParseLong Purpose :  To parse the string of a FvlStr object as a 8-bit integer number. Usage : --->    NumVal = vStr%ParseLong() --->    NumVal = vStr%ParseLong(ErrFlag, ErrMsg) interface private module function ILong_From_FvlStr(vStr, ErrFlag, ErrMsg) result(IntNum) To convert a FvlStr object to a 64-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) integer number procedure, public :: ParseRSingle => RSingle_From_FvlStr Type-Bound Function : ParseRSingle Purpose :  To parse the string of a FvlStr object as a single-precision real number. Usage : --->    NumVal = vStr%ParseRSingle() --->    NumVal = vStr%ParseRSingle(ErrFlag, ErrMsg) interface private module function RSingle_From_FvlStr(vStr, ErrFlag, ErrMsg) result(RealNum) To convert a FvlStr object to a single-precision real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value real(kind=kSingle) real number procedure, public :: ParseRDouble => RDouble_From_FvlStr Type-Bound Function : ParseRDouble Purpose :  To parse the string of a FvlStr object as a double-precision real number. Usage : --->    NumVal = vStr%ParseRDouble() --->    NumVal = vStr%ParseRDouble(ErrFlag, ErrMsg) interface private module function RDouble_From_FvlStr(vStr, ErrFlag, ErrMsg) result(RealNum) To convert a FvlStr object to a double-precision real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value real(kind=kDouble) real number procedure, public :: ParseRQuad => RQuad_From_FvlStr Type-Bound Function : ParseRQuad Purpose :  To parse the string of a FvlStr object as a quadruple-precision real number. Usage : --->    NumVal = vStr%ParseRQuad() --->    NumVal = vStr%ParseRQuad(ErrFlag, ErrMsg) interface private module function RQuad_From_FvlStr(vStr, ErrFlag, ErrMsg) result(RealNum) To convert a FvlStr object to a quadruple-precision real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value real(kind=kQuad) real number procedure, public :: ParseCSingle => CSingle_From_FvlStr Type-Bound Function : ParseCSingle Purpose :  To parse the string of a FvlStr object as a single-precision complex number. Usage : --->    NumVal = vStr%ParseCSingle() --->    NumVal = vStr%ParseCSingle(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. interface private module function CSingle_From_FvlStr(vStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a FvlStr object to a single-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value complex(kind=kSingle) complex number procedure, public :: ParseCDouble => CDouble_From_FvlStr Type-Bound Function : ParseCDouble Purpose :  To parse the string of a FvlStr object as a double-precision complex number. Usage : --->    NumVal = vStr%ParseCDouble() --->    NumVal = vStr%ParseCDouble(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. interface private module function CDouble_From_FvlStr(vStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a FvlStr object to a double-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value complex(kind=kDouble) complex number procedure, public :: ParseCQuad => CQuad_From_FvlStr Type-Bound Function : ParseCQuad Purpose :  To parse the string of a FvlStr object as a quadruple-precision complex number. Usage : --->    NumVal = vStr%ParseCQuad() --->    NumVal = vStr%ParseCQuad(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. interface private module function CQuad_From_FvlStr(vStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a FvlStr object to a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value complex(kind=kQuad) complex number procedure, public :: ParseLogical => Logical_From_FvlStr Type-Bound Function : ParseLogical Purpose :  To parse the string of a FvlStr object as a logical value. Usage : --->    LogVal = vStr%ParseLogical() interface private module function Logical_From_FvlStr(vStr) result(Boolean) To convert a FvlStr object to a logical value. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object Return Value logical logical value procedure, public :: Length => GetLength Type-Bound Function : Length Purpose :  To return the length of the character string of a FvlStr object. Usage : --->    StrLen = vStr%Length() private module function GetLength(vStr) result(Length) To return length of the character string of a FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr Return Value integer(kind=kInt32) procedure, public :: cSubStr => GetSubstring_CHS Type-Bound Function : cSubStr Purpose :  To return a substring from FvlStr object based on the specified lPos\n      and rPos where the returned substring is an allocatable character string. Usage : --->    SubStr = vStr%cSubStr(lPos, rPos) Note: the above example is functionally equivalent to the following Fortran\n        intrinsic statement: SubStr = cStr(lPos:rPos) interface private module function GetSubstring_CHS(vStr, lPos, rPos) result(cSub) To get a specified substring from FvlStr object based on lPos and rPos. If lPos is less than 1, then 1 is used as a starting point of the substring. Similarly, if rPos is greater than the length of the FvlStr's string, then\n the length is used as an ending point. If rPos is less than lPos, a zero-length string is returned. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: lPos the leftmost character position of the substring integer(kind=kInt32), intent(in) :: rPos the rightmost character position of the substring Return Value character(kind=kChar, len=:), ALLOCATABLE substring procedure, public :: vSubStr => GetSubstring_VLS Type-Bound Function : vSubStr Purpose :  To return a substring from FvlStr object based on the specified lPos\n      and rPos where the returned substring is another FvlStr object. Usage : --->    SubStr = vStr%vSubStr(lPos, rPos) interface private module function GetSubstring_VLS(vStr, lPos, rPos) result(vSub) See the \"GetSubstring_CHS\" procedure, where the only difference\n between these two procedures is the type of the returned argument. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr integer(kind=kInt32), intent(in) :: lPos integer(kind=kInt32), intent(in) :: rPos Return Value type( FvlStr ) procedure, public :: cSlice => GetSlice_CHS Type-Bound Function : cSlice Purpose :  To extract the characters from the region between first and last indices (both inclusive) of a FvlStr object by taking strides of length stride .\n      The returned character slice is an allocatable character string. Usage : --->    Slice = vStr%cSlice(first, last, stride) Note: the above example is functionally equivalent to the following Fortran\n        intrinsic statement: Slice = cStr(first:last:stride) interface private module function GetSlice_CHS(vStr, First, Last, Stride) result(Slice) To extract the characters from the region between First and Last indices\n(both inclusive) of the given string by taking strides of length Stride . Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in), optional :: First the first index integer(kind=kInt32), intent(in), optional :: Last the last index integer(kind=kInt32), intent(in), optional :: Stride the stride Return Value character(kind=kChar, len=:), ALLOCATABLE character slice procedure, public :: vSlice => GetSlice_VLS Type-Bound Function : vSlice Purpose :  To extract the characters from the region between First and Last indices (both inclusive) of a FvlStr object by taking strides of length Stride .\n      The returned character slice is another FvlStr object. Usage : --->    Slice = vStr%vSlice(First, Last, Stride) interface private module function GetSlice_VLS(vStr, First, Last, Stride) result(Slice) See the \"GetSlice_CHS\" procedure, where the only difference\n between these two procedures is the type of the returned argument. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr integer(kind=kInt32), intent(in), optional :: First integer(kind=kInt32), intent(in), optional :: Last integer(kind=kInt32), intent(in), optional :: Stride Return Value type( FvlStr ) procedure, public :: Char => GetCharacter Type-Bound Function : Char Purpose :  To return a (single) character from a FvlStr object based on\n      the specified position. Usage : --->    Chr = vStr%Char(Pos) interface private module function GetCharacter(vStr, Pos) result(Chr) To get a character from FvlStr object based on the specified position. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: Pos the position of the desired character Return Value character(kind=kChar, len=1) the character desired procedure, public :: IsNumber => Is_FvlStr_Number Type-Bound Function : IsNumber Purpose :  To return a flag indicating whether the string of a FvlStr object\n      is a valid number and if so, what kind of number it is. If the returned flag is -1, the string is NOT a number. If the returned flag is  0, the string is a valid integer or real number. If the returned flag is  1, the string is strictly an integer number. If the returned flag is  2, the string is strictly a real number. If the returned flag is  3, the string is a valid complex number. Usage : ! return -1, 0 or 3 --->    Flag = vStr%IsNumber() ! return -1, 1, 2 or 3 --->    Flag = vStr%IsNumber(Strict=.TRUE.) ! return a flag (-1, 0 or 3) and value of the string if it is a number --->    Flag = vStr%IsNumber(NumVal=Value) Technical Notes : A (strict) integer number is a whole number with no decimal point.\n  It can have a leading sign and is interpreted as a decimal number.\n  It takes a general form of [s]n[n...] where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A (strict) real number is a number with decimal point or an exponent part.\n  The general form of a real number with no exponent part is [s]n[n...] and\n  a real number with an exponent part has a general form of [s]n[n...]E[s]nn...\n  where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A decimal point must appear if\n    the real number has no exponent part. - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. A complex number is a pair of real or integer numbers, separated by a comma,\n  and enclosed in parentheses.  The first number represents the real part and\n  the second number represents the imaginary part. interface private module function Is_FvlStr_Number(vStr, Strict, NumVal) result(NumFlag) To check whether a FvlStr object represents a valid number and\n if so, what kind of number it is. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(in), optional :: Strict Flag requesting for strict integer/real number. If true, NumFlag is 1 or 2 if the FvlStr object is a valid integer or real number. Otherwise, NumFlag is 0 if the FvlStr object is a valid integer or real number. Default is false. class(*), intent(out), ALLOCATABLE, optional :: NumVal Value of number if it is valid. Return Value integer(kind=kInt32) Flag indicating what kind of number the FvlStr object represents. NumFlag = -1, the string is NOT a number. NumFlag =  0, the string is a valid integer or real number. NumFlag =  1, the string is strictly an integer number. NumFlag =  2, the string is strictly a real number. NumFlag =  3, the string is a valid complex number. procedure, public :: IsLogical => Is_FvlStr_Logical Type-Bound Function : IsLogical Purpose :  To return true value if the string of a FvlStr object is a logical\n      value where valid logical values include 'T', 'F', 't', 'f', 'TRUE', 'FALSE',\n      'true', 'false'.  Otherwise, return false value. Usage : ! only return the flag --->    Flag = vStr%IsLogical() ! return the flag and also get logical value if the returned flag is true --->    Flag = vStr%IsLogical(LogVal) interface private module function Is_FvlStr_Logical(vStr, Boolean) result(LogFlag) To check whether a FvlStr object represents a logical value where valid\n string include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true', and 'false'. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object logical, intent(out), optional :: Boolean logical value if flag is true; otherwise, set to FalseVal Return Value logical true if FvlStr object is a logical value procedure, public :: IsInClass => Is_FvlStr_InClass Type-Bound Function : IsInClass Purpose :  To check whether a FvlStr object is in the specified class where\n      the recognized classes include ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX,\n      CONTROL, DIGIT, FNAME, GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION,\n      PRINTABLE, REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. Usage : --->    Flag = vStr%IsInClass('ALPHANUM') --->    Flag = vStr%IsInClass('GRAPHICAL', FailIndex) --->    IF (.NOT.vStr%IsInClass('FNAME')) DoSomething Technical Notes :  See explanations of various recognized classes in the IsCharacterInClass function interface and the IsStringInClass function interface of the MBase_ChrStr module. interface private module function Is_FvlStr_InClass(vStr, ClassType, FailIndex) result(ClassFlag) To check whether a FvlStr object is in the specified class. The following FvlStr classes are recognized: ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX, CONTROL, DIGIT, FNAME,\n  GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION, PRINTABLE,\n  REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. See explanations of classes in the \"IsStringInClass\" and\n  \"IsCharacterInClass\" routines in the \"MBase_ChrStr\" module. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: ClassType FvlStr class integer(kind=kInt32), intent(out), optional :: FailIndex flag indicating position of the failed character Return Value logical true if FvlStr object is in the specified class generic, public :: CountSubstring => CountSubstring_CHS, CountSubstring_VLS Function Interface : CountSubstring Purpose :  To count the number of occurrences of the given substring\n      in the specified FvlStr object. Usage : --->    Count = vStr%CountSubstring(SubStr) --->    Count = vStr%CountSubstring(SubStr, Overlap=.TRUE.) private  interface CountSubstring_CHS() Arguments None private  interface CountSubstring_VLS() Arguments None generic, public :: CountCharacters => CountCharacters_CHS, CountCharacters_VLS Function Interface : CountCharacters Purpose :  To count the number of occurrences of character(s) in the\n      specified FvlStr object for any character appearing in the given\n      character set.  Optionally, a user can specify flags indicating\n      whether protected regions exist or not and whether the exclamation\n      mark is used to protect regions. Usage : --->    Count = vStr%CountCharacters(CharSet) --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE.) --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) private  interface CountCharacters_CHS() Arguments None private  interface CountCharacters_VLS() Arguments None procedure, public :: CountWords => CountWords_VLS Function Interface : CountWords Purpose :  To count the number of words (separated by blanks) in the\n      specified FvlStr object where blanks are characters in the SET_BLANKS character set. Usage : --->    Count = vStr%CountWords() interface private module function CountWords_VLS(vStr) result(nCount) To count the number of words (separated by blanks) in the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object Return Value integer(kind=kInt32) number of words procedure, public :: FindProtectedRegions => FindProtectedRegions_VLS Function Interface : FindProtectedRegions Purpose :  To find the number of protected regions marked by two (single\n      or double) quotes and/or by an exclamation mark.  Also, return positions\n      of the first and last characters of each region. Usage : --->    nRegion = vStr%FindProtectedRegions(lPos, rPos) --->    nRegion = vStr%FindProtectedRegions(lPos, rPos, ExclMrk=.FALSE.) interface private module function FindProtectedRegions_VLS(vStr, lPos, rPos, ExclMrk) result(nRegion) To look for quotes (and/or an exclamation mark) to find regions\n that must be protected from string editing.  Return the number\n of protected regions as well as positions of the first and last\n characters of each region. Technical Notes : - Single quote, double quote and optionally exclamation mark are used as\n   delimiters to find protected regions. - Two single quotes or two double quotes are used to define a protected\n   region whereas an exclamation mark indicates that all characters\n   following it are all protected. - This routine is designed specifically for manipulating Fortran source code\n   where an exclamation mark is used for a comment and two (single or double)\n   quotes are used to specify a value to a character variable or literal. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(out), ALLOCATABLE :: lPos (:) positions of the first character of protected regions integer(kind=kInt32), intent(out), ALLOCATABLE :: rPos (:) positions of the last character of protected regions logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of protected regions generic, public :: FindSubstring => FindSubstring_CHS, FindSubstring_VLS Function Interface : FindSubstring Purpose :  To count the number of non-overlapping occurrences of the given\n      substring in the specified FvlStr object and also return position(s) of\n      the first character of substring found.  Optionally, a user can specify\n      flags indicating whether protected regions exist or not and whether the\n      exclamation mark is used to protect regions. Usage : --->    Count = vStr%FindSubstring(SubStr, FirstPos) --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE.) --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE., ExclMrk=.FALSE.) private  interface FindSubstring_CHS() Arguments None private  interface FindSubstring_VLS() Arguments None generic, public :: FindDelimiters => FindDelimiters_CHS, FindDelimiters_VLS Function Interface : FindDelimiters Purpose :  To count the number of occurrences of delimiter(s) in the\n      specified FvlStr object and also return position(s) of the delimiter(s)\n      found.  A delimiter is any character appearing in the given character\n      set.  Optionally, a user can specify flags indicating whether protected\n      regions exist or not and whether the exclamation mark is used to protect\n      regions. Usage : --->    Count = vStr%FindDelimiters(CharSet, DPos) --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE.) --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE., ExclMrk=.FALSE.) private  interface FindDelimiters_CHS() Arguments None private  interface FindDelimiters_VLS() Arguments None generic, public :: FindSeparators => FindSeparators_CHS, FindSeparators_VLS Function Interface : FindSeparators Purpose :  To count the number of occurrences of separator(s) in the\n      specified FvlStr object and also return (the first) position(s) of the\n      separator(s) found.  Optionally, a user can specify flags indicating\n      whether protected regions exist or not and whether the exclamation\n      mark is used to protect regions. Usage : ! a separator is any (single) character in the Separator argument --->    Count = vStr%FindSeparators(Separator, .TRUE., Pos) ! a separator is a character string specified by the Separator argument --->    Count = vStr%FindSeparators(Separator, .FALSE., Pos) ! both quotes and an exclamation mark used to define protected regions. --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE.)  ! separator is a single character --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE.) ! separator is a character string ! only quotes used to define protected regions. --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) private  interface FindSeparators_CHS() Arguments None private  interface FindSeparators_VLS() Arguments None generic, public :: StartWith => StartWith_CHS, StartWith_VLS Function Interface : StartWith Purpose :  To check whether the string of a FvlStr object starts with the\n      specified substring or not.  Both the string and the substring must not\n      have a zero length. Usage : --->    Flag = vStr%StartWith(SubStr) --->    IF (.NOT.vStr%StartWith(SubStr)) DoSomething private  interface StartWith_CHS() Arguments None private  interface StartWith_VLS() Arguments None generic, public :: EndWith => EndWith_CHS, EndWith_VLS Function Interface : EndWith Purpose :  To check whether the string of a FvlStr object ends with the\n      specified substring or not.  Both the string and the substring must not\n      have a zero length. Usage : --->    Flag = vStr%EndWith(SubStr) --->    IF (.NOT.vStr%EndWith(SubStr)) DoSomething private  interface EndWith_CHS() Arguments None private  interface EndWith_VLS() Arguments None generic, public :: ChangeCase => AlterCase, AlterCaseProtect Subroutine Interface : ChangeCase Purpose :  To change case of all alphabet characters of the string of the\n      specified FvlStr object according to the given flag.  If protected regions\n      are specified, only characters in unprotected regions are changed. Usage : ! change all alphabet characters to upper cases --->    CALL vStr%ChangeCase(.TRUE.) ! change all alphabet characters only in unprotected regions to lower cases --->    CALL vStr%ChangeCase(nRegion, lPos, rPos, .FALSE.) private  interface AlterCase() Arguments None private  interface AlterCaseProtect() Arguments None procedure, public :: ChangeCaseBC => BlankCompressAlterCase Subroutine Interface : ChangeCaseBC Purpose :  To first remove all blank characters and then change case of all\n      alphabet characters of the string of the specified FvlStr object according\n      to the given flag. Usage : --->    CALL vStr%ChangeCaseBC(.TRUE.) interface private module subroutine BlankCompressAlterCase(vStr, ToUpper) To first remove all blanks and then change case of the character string\n of the FvlStr object according to flag. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. procedure, public :: CropBlanks => CropBlanks_VLS Subroutine Interface : CropBlanks Purpose :  To remove leading and trailing blanks from the string of the\n      specified FvlStr object. Usage : --->    CALL vStr%CropBlanks() --->    CALL vStr%CropBlanks(SpaceOnly=.TRUE.) interface private module subroutine CropBlanks_VLS(vStr, SpaceOnly) To remove leading and trailing blanks from the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object logical, intent(in), optional :: SpaceOnly flag indicating whether to only remove the space character or not. - True if requesting to remove only the space character. - False if requesting to remove both the tab and the space characters. Default is false. procedure, public :: Compact => CompactString_VLS Subroutine Interface : Compact Purpose :  To convert multiple spaces and tabs into a single space, delete\n      control characters and removes initial (leading and trailing) spaces. Usage : --->    CALL vStr%Compact() interface private module subroutine CompactString_VLS(vStr) To convert multiple spaces and tabs into a single space, delete\n control characters and removes initial (leading and trailing) spaces\n of the string of the specified FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr procedure, public :: Compress => CompressString_VLS Subroutine Interface : Compress Purpose :  To remove spaces, tabs and control characters from the string\n      of the specified FvlStr object. Usage : --->    CALL vStr%Compress() Note : Unlike the Compact method, the returned string contains no space\n           between its characters. interface private module subroutine CompressString_VLS(vStr) To remove spaces, tabs and control characters from the string\n of the specified FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr generic, public :: InsertSubstring => InsertSubstring_CHS, InsertSubstring_VLS Subroutine Interface : InsertSubstring Purpose :  To insert a given substring into the string of the given\n      FvlStr object at a specified position. Usage : --->    CALL vStr%InsertSubstring(Pos, SubStr) private  interface InsertSubstring_CHS() Arguments None private  interface InsertSubstring_VLS() Arguments None generic, public :: RemoveCharacters => RemoveCharacters_CHS, RemoveCharacters_VLS Subroutine Interface : RemoveCharacters Purpose :  To remove characters from the string of the given FvlStr\n      object depending on specified input. Usage : --->    CALL vStr%RemoveCharacters(CharSet) --->    CALL vStr%RemoveCharacters(CharSet, Option=2) --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE.) --->    CALL vStr%RemoveCharacters(CharSet, 2, Protect=.TRUE.) --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%RemoveCharacters(CharSet, 3, .TRUE., .FALSE.) private  interface RemoveCharacters_CHS() Arguments None private  interface RemoveCharacters_VLS() Arguments None generic, public :: RemoveSubstring => RemoveSubstring_CHS, RemoveSubstring_VLS, Delete_Substring Subroutine Interface : RemoveSubstring Purpose :  To remove the substring from the string of the given FvlStr\n      object based on specified input. Usage : --->    CALL vStr%RemoveSubstring(SubStr) --->    CALL vStr%RemoveSubstring(lPos, rPos) --->    CALL vStr%RemoveSubstring(SubStr, FirstOnly=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., FirstOnly=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, .TRUE., .FALSE., .TRUE.) private  interface RemoveSubstring_CHS() Arguments None private  interface RemoveSubstring_VLS() Arguments None private  interface Delete_Substring() Arguments None generic, public :: ReplaceSubstring => ReplaceSubstring_CHS_CHS, ReplaceSubstring_VLS_CHS, ReplaceSubstring_CHS_VLS, ReplaceSubstring_VLS_VLS Subroutine Interface : ReplaceSubstring Purpose :  To replace all occurrences of the original substring found\n      in the string of the given FvlStr object with the new substring based\n      on specified input. Usage : --->    CALL vStr%ReplaceSubstring(OldSub, NewSub) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., Recur=.TRUE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, .TRUE., .TRUE., .FALSE.) private  interface ReplaceSubstring_CHS_CHS() Arguments None private  interface ReplaceSubstring_VLS_CHS() Arguments None private  interface ReplaceSubstring_CHS_VLS() Arguments None private  interface ReplaceSubstring_VLS_VLS() Arguments None generic, public :: Partition => PartitionSepSub_CHS, PartitionSepSub_VLS, PartitionSepChr_CHS, PartitionSepChr_VLS Subroutine Interface : Partition Purpose :  To partition the string of the given FvlStr object into two\n      substrings by a separator (single character or a multiple-character\n      string).  The partition occurs at the first occurrence of the separator\n      found. Usage : ! SepSub is a multiple-character string separator. --->    CALL vStr%Partition(SepSub, SubStr) ! SepSet is a set of characters where a character in the set is a valid ! separator.  Also, search the first separator from the back. --->    CALL vStr%Partition(SepSet, SubStr, SepChr, Back=.TRUE.) private  interface PartitionSepSub_CHS() Arguments None private  interface PartitionSepSub_VLS() Arguments None private  interface PartitionSepChr_CHS() Arguments None private  interface PartitionSepChr_VLS() Arguments None generic, public :: Split => SplitSepSub_CHS, SplitSepSub_VLS, SplitSepChr_CHS, SplitSepChr_VLS Subroutine Interface : Split Purpose :  To split the string of the given FvlStr object into multiple\n       substrings by a separator (single character or a multiple-character string). Usage : ! SepSub is a multiple-character string separator. --->    CALL vStr%Split(SepSub, SubStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL vStr%Split(SepSet, SubStr, SepChr) ! only find a separator in the unprotected regions. --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE.) ! only find separators in the unprotected regions. --->    CALL vStr%Split(SepSet, SubStr, SepChr, Protect=.TRUE.) ! The exclamation mark is NOT used to define the protected regions. --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE., ExclMrk=.FALSE.) private  interface SplitSepSub_CHS() Arguments None private  interface SplitSepSub_VLS() Arguments None private  interface SplitSepChr_CHS() Arguments None private  interface SplitSepChr_VLS() Arguments None procedure, public :: WriteOutput Subroutine Interface : WriteOutput Purpose :  To write the string of a FvlStr object to a connected\n      formatted unit. Usage : --->    CALL vStr%WriteOutput(IOUnit) --->    CALL vStr%WriteOutput(IOUnit,IOStat,IOMsg) interface private module subroutine WriteOutput(vStr, IOUnit, IOStat, IOMsg) To write a character string of the FvlStr object to a connected formatted unit. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out), optional :: IOStat status of io operation character(kind=kChar, len=*), intent(inout), optional :: IOMsg an io message if is IOStat is non-zero procedure, public :: ReadComnandLine Subroutine Interface : ReadComnandLine Purpose :  To read a character sequence from a command line into the\n      FvlStr object. Usage : --->    CALL vStr%ReadComnandLine() interface private module subroutine ReadComnandLine(vStr) To read a character sequence from a command line into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object procedure, public :: ReadInput Subroutine Interface : ReadInput Purpose :  To read a character sequence from a connected formatted unit\n      into the FvlStr object. Usage : --->    CALL vStr%ReadInput(IOUnit) --->    CALL vStr%ReadInput(IOUnit,IOStat,IOMsg) interface private module subroutine ReadInput(vStr, IOUnit, IOStat, IOMsg) To read a character sequence from a connected formatted unit into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out), optional :: IOStat status of io operation character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: IOMsg an io message procedure, public :: Copy => FvlStr_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine FvlStr_Copy(SrcObj, DstObj, IsDeep) To perform copy of the source object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => FvlStr_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function FvlStr_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => FvlStr_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine FvlStr_MemFree(Obj) To free memory of the FvlStr object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: Obj procedure, public :: ToString => FvlStr_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function FvlStr_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => FvlStr_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function FvlStr_HashCode(Obj) result(Code) To get compute hash code for the given key.\n This is a deferred procedure inherited from the Hashable type. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: CompareTo => FvlStr_CompareTo Use a common logical expression to compare two Comparable objects. private  function FvlStr_CompareTo(A, B) result(Flag) To compare a FvlStr object with a Comparable object.\n This is a deferred procedure inherited from the Comparable type. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: A FvlStr object class(Comparable), intent(in) :: B Comparable object Return Value integer(kind=kInt32) output flag with value of -1 if A < B, 0 if A == B, or +1 if A > B. Source Code TYPE , EXTENDS ( Comparable ) :: FvlStr PRIVATE tCharAlloc :: cStr ! character string CONTAINS ! --------------------------------------------------------------------- ! -----                 Conversion Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToCharString <br> !  **Purpose**:  To convert a FvlStr object to an allocatable character !       string. <br> !  **Usage**: <br> !   --->    cStr = vStr%ToCharString() <br> PROCEDURE :: ToCharString => CharAlloc_From_FvlStr !> **Type-Bound Function**: ToChrArrAlloc <br> !  **Purpose**:  To convert a FvlStr object to an allocatable array !       of characters. <br> !  **Usage**: <br> !   ! convert a FvlStr object to a character array <br> !   --->    cArray = vStr%ToChrArrAlloc() <br> !   ! convert a FvlStr object to a character array with a null character <br> !   --->    cArray = vStr%ToChrArrAlloc(IsCString=.TRUE.) <br> PROCEDURE :: ToChrArrAlloc => CharArray_From_FvlStr !> **Type-Bound Function**: ParseByte <br> !  **Purpose**:  To parse the string of a FvlStr object as an 8-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseByte() <br> !   --->    NumVal = vStr%ParseByte(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseByte => IByte_From_FvlStr !> **Type-Bound Function**: ParseShort <br> !  **Purpose**:  To parse the string of a FvlStr object as a 16-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseShort() <br> !   --->    NumVal = vStr%ParseShort(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseShort => IShort_From_FvlStr !> **Type-Bound Function**: ParseInteger <br> !  **Purpose**:  To parse the string of a FvlStr object as a 32-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseInteger() <br> !   --->    NumVal = vStr%ParseInteger(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseInteger => Integer_From_FvlStr !> **Type-Bound Function**: ParseLong <br> !  **Purpose**:  To parse the string of a FvlStr object as a 8-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseLong() <br> !   --->    NumVal = vStr%ParseLong(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseLong => ILong_From_FvlStr !> **Type-Bound Function**: ParseRSingle <br> !  **Purpose**:  To parse the string of a FvlStr object as a single-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRSingle() <br> !   --->    NumVal = vStr%ParseRSingle(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRSingle => RSingle_From_FvlStr !> **Type-Bound Function**: ParseRDouble <br> !  **Purpose**:  To parse the string of a FvlStr object as a double-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRDouble() <br> !   --->    NumVal = vStr%ParseRDouble(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRDouble => RDouble_From_FvlStr !> **Type-Bound Function**: ParseRQuad <br> !  **Purpose**:  To parse the string of a FvlStr object as a quadruple-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRQuad() <br> !   --->    NumVal = vStr%ParseRQuad(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRQuad => RQuad_From_FvlStr !> **Type-Bound Function**: ParseCSingle <br> !  **Purpose**:  To parse the string of a FvlStr object as a single-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCSingle() <br> !   --->    NumVal = vStr%ParseCSingle(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCSingle => CSingle_From_FvlStr !> **Type-Bound Function**: ParseCDouble <br> !  **Purpose**:  To parse the string of a FvlStr object as a double-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCDouble() <br> !   --->    NumVal = vStr%ParseCDouble(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCDouble => CDouble_From_FvlStr !> **Type-Bound Function**: ParseCQuad <br> !  **Purpose**:  To parse the string of a FvlStr object as a quadruple-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCQuad() <br> !   --->    NumVal = vStr%ParseCQuad(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCQuad => CQuad_From_FvlStr !> **Type-Bound Function**: ParseLogical<br> !  **Purpose**:  To parse the string of a FvlStr object as a logical value. <br> !  **Usage**: <br> !   --->    LogVal = vStr%ParseLogical() <br> PROCEDURE :: ParseLogical => Logical_From_FvlStr ! --------------------------------------------------------------------- ! -----                 Getter Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: Length <br> !  **Purpose**:  To return the length of the character string of a FvlStr object. <br> !  **Usage**: <br> !   --->    StrLen = vStr%Length() <br> PROCEDURE :: Length => GetLength !> **Type-Bound Function**: cSubStr <br> !  **Purpose**:  To return a substring from FvlStr object based on the specified lPos !       and rPos where the returned substring is an allocatable character string. <br> !  **Usage**: <br> !   --->    SubStr = vStr%cSubStr(lPos, rPos) <br> !   Note: the above example is functionally equivalent to the following Fortran !         intrinsic statement: <br> !           SubStr = cStr(lPos:rPos) PROCEDURE :: cSubStr => GetSubstring_CHS !> **Type-Bound Function**: vSubStr <br> !  **Purpose**:  To return a substring from FvlStr object based on the specified lPos !       and rPos where the returned substring is another FvlStr object. <br> !  **Usage**: <br> !   --->    SubStr = vStr%vSubStr(lPos, rPos) <br> PROCEDURE :: vSubStr => GetSubstring_VLS !> **Type-Bound Function**: cSlice <br> !  **Purpose**:  To extract the characters from the region between *first* and *last* !       indices (both inclusive) of a FvlStr object by taking strides of length *stride*. !       The returned character slice is an allocatable character string. <br> !  **Usage**: <br> !   --->    Slice = vStr%cSlice(first, last, stride) <br> !   Note: the above example is functionally equivalent to the following Fortran !         intrinsic statement: <br> !           Slice = cStr(first:last:stride) PROCEDURE :: cSlice => GetSlice_CHS !> **Type-Bound Function**: vSlice <br> !  **Purpose**:  To extract the characters from the region between *First* and *Last* !       indices (both inclusive) of a FvlStr object by taking strides of length *Stride*. !       The returned character slice is another FvlStr object. <br> !  **Usage**: <br> !   --->    Slice = vStr%vSlice(First, Last, Stride) <br> PROCEDURE :: vSlice => GetSlice_VLS !> **Type-Bound Function**: Char <br> !  **Purpose**:  To return a (single) character from a FvlStr object based on !       the specified position. <br> !  **Usage**: <br> !   --->    Chr = vStr%Char(Pos) <br> PROCEDURE :: Char => GetCharacter ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: CountSubstring_CHS PROCEDURE , PRIVATE :: CountSubstring_VLS PROCEDURE , PRIVATE :: CountCharacters_CHS PROCEDURE , PRIVATE :: CountCharacters_VLS PROCEDURE , PRIVATE :: FindSubstring_CHS PROCEDURE , PRIVATE :: FindSubstring_VLS PROCEDURE , PRIVATE :: FindDelimiters_CHS PROCEDURE , PRIVATE :: FindDelimiters_VLS PROCEDURE , PRIVATE :: FindSeparators_CHS PROCEDURE , PRIVATE :: FindSeparators_VLS PROCEDURE , PRIVATE :: StartWith_CHS PROCEDURE , PRIVATE :: StartWith_VLS PROCEDURE , PRIVATE :: EndWith_CHS PROCEDURE , PRIVATE :: EndWith_VLS !> **Type-Bound Function**: IsNumber <br> !  **Purpose**:  To return a flag indicating whether the string of a FvlStr object !       is a valid number and if so, what kind of number it is. <br> !       If the returned flag is -1, the string is NOT a number. <br> !       If the returned flag is  0, the string is a valid integer or real number. <br> !       If the returned flag is  1, the string is strictly an integer number. <br> !       If the returned flag is  2, the string is strictly a real number. <br> !       If the returned flag is  3, the string is a valid complex number. <br> !  **Usage**: <br> !   ! return -1, 0 or 3 <br> !   --->    Flag = vStr%IsNumber() <br> !   ! return -1, 1, 2 or 3 <br> !   --->    Flag = vStr%IsNumber(Strict=.TRUE.) <br> !   ! return a flag (-1, 0 or 3) and value of the string if it is a number <br> !   --->    Flag = vStr%IsNumber(NumVal=Value) <br> !  **Technical Notes**: <br> !   A (strict) integer number is a whole number with no decimal point. !   It can have a leading sign and is interpreted as a decimal number. !   It takes a general form of [s]n[n...] where <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). <br> !   A (strict) real number is a number with decimal point or an exponent part. !   The general form of a real number with no exponent part is [s]n[n...] and !   a real number with an exponent part has a general form of [s]n[n...]E[s]nn... !   where  <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). A decimal point must appear if !     the real number has no exponent part. <br> !   - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. <br> !   A complex number is a pair of real or integer numbers, separated by a comma, !   and enclosed in parentheses.  The first number represents the real part and !   the second number represents the imaginary part. PROCEDURE :: IsNumber => Is_FvlStr_Number !> **Type-Bound Function**: IsLogical <br> !  **Purpose**:  To return true value if the string of a FvlStr object is a logical !       value where valid logical values include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', !       'true', 'false'.  Otherwise, return false value. <br> !  **Usage**: <br> !   ! only return the flag <br> !   --->    Flag = vStr%IsLogical() <br> !   ! return the flag and also get logical value if the returned flag is true <br> !   --->    Flag = vStr%IsLogical(LogVal) <br> PROCEDURE :: IsLogical => Is_FvlStr_Logical !> **Type-Bound Function**: IsInClass <br> !  **Purpose**:  To check whether a FvlStr object is in the specified class where !       the recognized classes include ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX, !       CONTROL, DIGIT, FNAME, GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION, !       PRINTABLE, REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. <br> !  **Usage**: <br> !   --->    Flag = vStr%IsInClass('ALPHANUM') <br> !   --->    Flag = vStr%IsInClass('GRAPHICAL', FailIndex) <br> !   --->    IF (.NOT.vStr%IsInClass('FNAME')) DoSomething <br> !  **Technical Notes**:  See explanations of various recognized classes in the !       <a href=\"../module/mbase_chrstr.html#interface-ischaracterinclass\"> !       IsCharacterInClass</a> function interface and the !       <a href=\"../module/mbase_chrstr.html#interface-isstringinclass\"> !       IsStringInClass</a> function interface of the !       <a href=\"../module/mbase_chrstr.html\">MBase_ChrStr</a> module. <br> PROCEDURE :: IsInClass => Is_FvlStr_InClass !> **Function Interface**: CountSubstring <br> !  **Purpose**:  To count the number of occurrences of the given substring !       in the specified FvlStr object. <br> !  **Usage**: <br> !   --->    Count = vStr%CountSubstring(SubStr) <br> !   --->    Count = vStr%CountSubstring(SubStr, Overlap=.TRUE.) <br> GENERIC :: CountSubstring => CountSubstring_CHS , CountSubstring_VLS !> **Function Interface**: CountCharacters <br> !  **Purpose**:  To count the number of occurrences of character(s) in the !       specified FvlStr object for any character appearing in the given !       character set.  Optionally, a user can specify flags indicating !       whether protected regions exist or not and whether the exclamation !       mark is used to protect regions. <br> !  **Usage**: <br> !   --->    Count = vStr%CountCharacters(CharSet) <br> !   --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE.) <br> !   --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: CountCharacters => CountCharacters_CHS , CountCharacters_VLS !> **Function Interface**: CountWords <br> !  **Purpose**:  To count the number of words (separated by blanks) in the !       specified FvlStr object where blanks are characters in the !       <a href=\"../module/mbase_chrstr.html#variable-set_blanks\"> !       SET_BLANKS</a> character set. <br> !  **Usage**: <br> !   --->    Count = vStr%CountWords() <br> PROCEDURE :: CountWords => CountWords_VLS !> **Function Interface**: FindProtectedRegions <br> !  **Purpose**:  To find the number of protected regions marked by two (single !       or double) quotes and/or by an exclamation mark.  Also, return positions !       of the first and last characters of each region. <br> !  **Usage**: <br> !   --->    nRegion = vStr%FindProtectedRegions(lPos, rPos) <br> !   --->    nRegion = vStr%FindProtectedRegions(lPos, rPos, ExclMrk=.FALSE.) <br> PROCEDURE :: FindProtectedRegions => FindProtectedRegions_VLS !> **Function Interface**: FindSubstring <br> !  **Purpose**:  To count the number of non-overlapping occurrences of the given !       substring in the specified FvlStr object and also return position(s) of !       the first character of substring found.  Optionally, a user can specify !       flags indicating whether protected regions exist or not and whether the !       exclamation mark is used to protect regions. <br> !  **Usage**: <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos) <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE.) <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindSubstring => FindSubstring_CHS , FindSubstring_VLS !> **Function Interface**: FindDelimiters <br> !  **Purpose**:  To count the number of occurrences of delimiter(s) in the !       specified FvlStr object and also return position(s) of the delimiter(s) !       found.  A delimiter is any character appearing in the given character !       set.  Optionally, a user can specify flags indicating whether protected !       regions exist or not and whether the exclamation mark is used to protect !       regions. <br> !  **Usage**: <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos) <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE.) <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindDelimiters => FindDelimiters_CHS , FindDelimiters_VLS !> **Function Interface**: FindSeparators <br> !  **Purpose**:  To count the number of occurrences of separator(s) in the !       specified FvlStr object and also return (the first) position(s) of the !       separator(s) found.  Optionally, a user can specify flags indicating !       whether protected regions exist or not and whether the exclamation !       mark is used to protect regions. <br> !  **Usage**: <br> !   ! a separator is any (single) character in the *Separator* argument <br> !   --->    Count = vStr%FindSeparators(Separator, .TRUE., Pos) <br> !   ! a separator is a character string specified by the *Separator* argument <br> !   --->    Count = vStr%FindSeparators(Separator, .FALSE., Pos) <br> !   ! both quotes and an exclamation mark used to define protected regions. <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE.)  ! separator is a single character <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE.) ! separator is a character string <br> !   ! only quotes used to define protected regions.  <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindSeparators => FindSeparators_CHS , FindSeparators_VLS !> **Function Interface**: StartWith <br> !  **Purpose**:  To check whether the string of a FvlStr object starts with the !       specified substring or not.  Both the string and the substring must not !       have a zero length. <br> !  **Usage**: <br> !   --->    Flag = vStr%StartWith(SubStr) <br> !   --->    IF (.NOT.vStr%StartWith(SubStr)) DoSomething GENERIC :: StartWith => StartWith_CHS , StartWith_VLS !> **Function Interface**: EndWith <br> !  **Purpose**:  To check whether the string of a FvlStr object ends with the !       specified substring or not.  Both the string and the substring must not !       have a zero length. <br> !  **Usage**: <br> !   --->    Flag = vStr%EndWith(SubStr) <br> !   --->    IF (.NOT.vStr%EndWith(SubStr)) DoSomething GENERIC :: EndWith => EndWith_CHS , EndWith_VLS ! --------------------------------------------------------------------- ! -----             Manipulation Procedures                       ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AlterCase PROCEDURE , PRIVATE :: AlterCaseProtect PROCEDURE , PRIVATE :: InsertSubstring_CHS PROCEDURE , PRIVATE :: InsertSubstring_VLS PROCEDURE , PRIVATE :: RemoveCharacters_CHS PROCEDURE , PRIVATE :: RemoveCharacters_VLS PROCEDURE , PRIVATE :: RemoveSubstring_CHS PROCEDURE , PRIVATE :: RemoveSubstring_VLS PROCEDURE , PRIVATE :: Delete_Substring PROCEDURE , PRIVATE :: ReplaceSubstring_CHS_CHS PROCEDURE , PRIVATE :: ReplaceSubstring_VLS_CHS PROCEDURE , PRIVATE :: ReplaceSubstring_CHS_VLS PROCEDURE , PRIVATE :: ReplaceSubstring_VLS_VLS PROCEDURE , PRIVATE :: PartitionSepSub_CHS PROCEDURE , PRIVATE :: PartitionSepSub_VLS PROCEDURE , PRIVATE :: PartitionSepChr_CHS PROCEDURE , PRIVATE :: PartitionSepChr_VLS PROCEDURE , PRIVATE :: SplitSepSub_CHS PROCEDURE , PRIVATE :: SplitSepSub_VLS PROCEDURE , PRIVATE :: SplitSepChr_CHS PROCEDURE , PRIVATE :: SplitSepChr_VLS !> **Subroutine Interface**: ChangeCase <br> !  **Purpose**:  To change case of all alphabet characters of the string of the !       specified FvlStr object according to the given flag.  If protected regions !       are specified, only characters in unprotected regions are changed. <br> !  **Usage**: <br> !   ! change all alphabet characters to upper cases <br> !   --->    CALL vStr%ChangeCase(.TRUE.) <br> !   ! change all alphabet characters only in unprotected regions to lower cases <br> !   --->    CALL vStr%ChangeCase(nRegion, lPos, rPos, .FALSE.) GENERIC :: ChangeCase => AlterCase , AlterCaseProtect !> **Subroutine Interface**: ChangeCaseBC <br> !  **Purpose**:  To first remove all blank characters and then change case of all !       alphabet characters of the string of the specified FvlStr object according !       to the given flag. <br> !  **Usage**: <br> !   --->    CALL vStr%ChangeCaseBC(.TRUE.) PROCEDURE :: ChangeCaseBC => BlankCompressAlterCase !> **Subroutine Interface**: CropBlanks <br> !  **Purpose**:  To remove leading and trailing blanks from the string of the !       specified FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%CropBlanks() <br> !   --->    CALL vStr%CropBlanks(SpaceOnly=.TRUE.) <br> PROCEDURE :: CropBlanks => CropBlanks_VLS !> **Subroutine Interface**: Compact <br> !  **Purpose**:  To convert multiple spaces and tabs into a single space, delete !       control characters and removes initial (leading and trailing) spaces. <br> !  **Usage**: <br> !   --->    CALL vStr%Compact() <br> PROCEDURE :: Compact => CompactString_VLS !> **Subroutine Interface**: Compress <br> !  **Purpose**:  To remove spaces, tabs and control characters from the string !       of the specified FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%Compress() <br> !  **Note**: Unlike the *Compact* method, the returned string contains no space !            between its characters. PROCEDURE :: Compress => CompressString_VLS !> **Subroutine Interface**: InsertSubstring <br> !  **Purpose**:  To insert a given substring into the string of the given !       FvlStr object at a specified position. <br> !  **Usage**: <br> !   --->    CALL vStr%InsertSubstring(Pos, SubStr) GENERIC :: InsertSubstring => InsertSubstring_CHS , InsertSubstring_VLS !> **Subroutine Interface**: RemoveCharacters <br> !  **Purpose**:  To remove characters from the string of the given FvlStr !       object depending on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%RemoveCharacters(CharSet) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Option=2) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, 2, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, 3, .TRUE., .FALSE.) <br> GENERIC :: RemoveCharacters => RemoveCharacters_CHS , RemoveCharacters_VLS !> **Subroutine Interface**: RemoveSubstring <br> !  **Purpose**:  To remove the substring from the string of the given FvlStr !       object based on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%RemoveSubstring(SubStr) <br> !   --->    CALL vStr%RemoveSubstring(lPos, rPos) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, FirstOnly=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., FirstOnly=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, .TRUE., .FALSE., .TRUE.) <br> GENERIC :: RemoveSubstring => RemoveSubstring_CHS , RemoveSubstring_VLS , & Delete_Substring !> **Subroutine Interface**: ReplaceSubstring <br> !  **Purpose**:  To replace all occurrences of the original substring found !       in the string of the given FvlStr object with the new substring based !       on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., Recur=.TRUE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, .TRUE., .TRUE., .FALSE.) <br> GENERIC :: ReplaceSubstring => ReplaceSubstring_CHS_CHS , ReplaceSubstring_VLS_CHS , & ReplaceSubstring_CHS_VLS , ReplaceSubstring_VLS_VLS !> **Subroutine Interface**: Partition <br> !  **Purpose**:  To partition the string of the given FvlStr object into two !       substrings by a separator (single character or a multiple-character !       string).  The partition occurs at the first occurrence of the separator !       found. <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL vStr%Partition(SepSub, SubStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid <br> !   ! separator.  Also, search the first separator from the back. <br> !   --->    CALL vStr%Partition(SepSet, SubStr, SepChr, Back=.TRUE.) <br> GENERIC :: Partition => PartitionSepSub_CHS , PartitionSepSub_VLS , & PartitionSepChr_CHS , PartitionSepChr_VLS !> **Subroutine Interface**: Split <br> !  **Purpose**:  To split the string of the given FvlStr object into multiple !        substrings by a separator (single character or a multiple-character string). <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL vStr%Split(SepSub, SubStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid separator. <br> !   --->    CALL vStr%Split(SepSet, SubStr, SepChr) <br> !   ! only find a separator in the unprotected regions. <br> !   --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE.) <br> !   ! only find separators in the unprotected regions. <br> !   --->    CALL vStr%Split(SepSet, SubStr, SepChr, Protect=.TRUE.) <br> !   ! The exclamation mark is NOT used to define the protected regions. <br> !   --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: Split => SplitSepSub_CHS , SplitSepSub_VLS , & SplitSepChr_CHS , SplitSepChr_VLS ! --------------------------------------------------------------------- ! -----         Reading and Writing Procedures                    ----- ! --------------------------------------------------------------------- !> **Subroutine Interface**: WriteOutput <br> !  **Purpose**:  To write the string of a FvlStr object to a connected !       formatted unit. <br> !  **Usage**: <br> !   --->    CALL vStr%WriteOutput(IOUnit) <br> !   --->    CALL vStr%WriteOutput(IOUnit,IOStat,IOMsg) <br> PROCEDURE :: WriteOutput !> **Subroutine Interface**: ReadComnandLine <br> !  **Purpose**:  To read a character sequence from a command line into the !       FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%ReadComnandLine() <br> PROCEDURE :: ReadComnandLine !> **Subroutine Interface**: ReadInput <br> !  **Purpose**:  To read a character sequence from a connected formatted unit !       into the FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%ReadInput(IOUnit) <br> !   --->    CALL vStr%ReadInput(IOUnit,IOStat,IOMsg) <br> PROCEDURE :: ReadInput ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => FvlStr_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => FvlStr_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => FvlStr_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => FvlStr_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => FvlStr_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Comparable Type          ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => FvlStr_CompareTo ! --------------------------------------------------------------------- ! -----                 Final Procedure                           ----- ! --------------------------------------------------------------------- FINAL :: FinalizeFvlStr ! --------------------------------------------------------------------- END TYPE FvlStr","tags":"","loc":"type\\fvlstr.html"},{"title":"PatternFinder – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PatternFinder The PatternFinder type is a string type that provides various efficient\n algorithms for a substring searching operation. Finalization Procedures final :: PatternFinder_Finalize To perform finalization of the PatternFinder object. private  subroutine PatternFinder_Finalize(Finder) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PatternFinder ), intent(inout) :: Finder 'PatternFinder' object Type-Bound Procedures procedure, public :: SetPattern => PatternFinder_SetPattern Type-Bound Subroutine : SetPattern Purpose :  To process the specified pattern based on the specified searching algorithm. Usage : --->    CALL Finder%SetPattern(Pattern, SearchAlgo) --->    CALL Finder%SetPattern(Pattern, BNDM, WildCard='.') --->    CALL Finder%SetPattern(Pattern, BNDM, Insensitive=.TRUE.) --->    CALL Finder%SetPattern(Pattern, BNDM, .TRUE., ' ') Note : 1. If the length of the pattern is zero, the method just returns without doing anything. 2. The optional Insensitive and WildCard* arguments are applicable for the BNDM method only. private  subroutine PatternFinder_SetPattern(Finder, Pattern, SearchAlgo, Insensitive, WildCard) To process the specified pattern based on the specified searching algorithm.\n If the length of the pattern is zero, just return without doing anything. Arguments Type Intent Optional Attributes Name class( PatternFinder ), intent(inout) :: Finder 'PatternFinder' object character(kind=kChar, len=*), intent(in), TARGET :: Pattern the pattern integer(kind=kInt32), intent(in) :: SearchAlgo search algorithm logical, intent(in), optional :: Insensitive true if the pattern is case-insensitive; default is false; only applicable for BNDM algorithm. character(kind=kChar, len=1), intent(in), optional :: WildCard a wild card character; default is \"?\"; only applicable for BNDM algorithm. procedure, public :: FindIndex => PatternFinder_FindIndex Type-Bound Function : FindIndex Purpose :  To find the first occurrence of the (previously specified) pattern within the\n      specified text .  Return an (one-based) index representing the position of the first\n      character of the occurrence found.  Return zero if there is no such pattern found.  If the\n      pattern has not yet been set, return one. Usage : ! start searching from the beginning of the text --->    Index = Finder%FindIndex(Text) ! start searching from the specified position (one-based) of the text --->    Index = Finder%FindIndex(Text, StartPos) private  function PatternFinder_FindIndex(Finder, Text, StartID) result(Index) To return the one-based index of the first occurrence of the pattern string\n in the text string.  Return zero if there is no such pattern found.  If the\n pattern has not yet been set, return one. Note: The unset pattern is equivalent to the zero-length pattern. Arguments Type Intent Optional Attributes Name class( PatternFinder ), intent(inout) :: Finder 'PatternFinder' object character(kind=kChar, len=*), intent(in), TARGET :: Text the text string integer(kind=kInt32), intent(in), optional :: StartID (one-based) starting index of the text string;\n if not present, starting at 1. Return Value integer(kind=kInt32) (one-based) index of the first occurrence;\n if pattern not found, return 0. procedure, public :: FindNext => PatternFinder_FindNext Type-Bound Function : FindNext Purpose :  To find the next occurrence of the (previously specified) pattern within the\n       (previously specified) text . Usage : --->    Index = Finder%FindNext() Note : Must call the SetPattern and FindIndex methods before calling this method. private  function PatternFinder_FindNext(Finder) result(Index) To return the one-based index of the next occurrence of the pattern string\n in the text string.  Return zero if there is no more pattern found.  This\n routine assumes that the SetPattern and the FindIndex methods have\n already been called.  If that is not true, return -1. Arguments Type Intent Optional Attributes Name class( PatternFinder ), intent(inout) :: Finder 'PatternFinder' object Return Value integer(kind=kInt32) (one-based) index of the first occurrence;\n if pattern not found, return 0. procedure, public :: Clear => PatternFinder_Clear Type-Bound Subroutine : Clear Purpose :  To reset/clear all components of the PatternFinder object. Usage : --->    CALL Finder%Clear() Note : If the length of the pattern is zero, the method just returns without doing anything. private  subroutine PatternFinder_Clear(Finder) To reset the 'PatternFinder' object. Arguments Type Intent Optional Attributes Name class( PatternFinder ), intent(inout) :: Finder 'PatternFinder' object Source Code TYPE PatternFinder PRIVATE !% searching algorithm tSInt32 :: Algo = BoyerMoore !% current starting (one-based) index of the pattern tIndex :: Index = 0_kIndex !% string representing the pattern tChar , POINTER :: PatTxt (:) => NULL () !% string representing the searched text tCharLen (:), POINTER :: InpTxt => NULL () !% pattern object containing processed information CLASS ( BasePattern ), ALLOCATABLE :: PatObj CONTAINS !> **Type-Bound Subroutine**: SetPattern <br> !  **Purpose**:  To process the specified pattern based on the specified searching algorithm. <br> !  **Usage**: <br> !   --->    CALL Finder%SetPattern(Pattern, SearchAlgo) <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, WildCard='.') <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, Insensitive=.TRUE.) <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, .TRUE., '*') <br> !  **Note**: <br> !   1. If the length of the pattern is zero, the method just returns without doing anything. <br> !   2. The optional *Insensitive* and *WildCard* arguments are applicable for the BNDM method only. <br> PROCEDURE :: SetPattern => PatternFinder_SetPattern !> **Type-Bound Function**: FindIndex <br> !  **Purpose**:  To find the first occurrence of the (previously specified) *pattern* within the !       specified *text*.  Return an (one-based) index representing the position of the first !       character of the occurrence found.  Return zero if there is no such pattern found.  If the !       pattern has not yet been set, return one. <br> !  **Usage**: <br> !   ! start searching from the beginning of the text <br> !   --->    Index = Finder%FindIndex(Text) <br> !   ! start searching from the specified position (one-based) of the text <br> !   --->    Index = Finder%FindIndex(Text, StartPos) <br> PROCEDURE :: FindIndex => PatternFinder_FindIndex !> **Type-Bound Function**: FindNext <br> !  **Purpose**:  To find the next occurrence of the (previously specified) *pattern* within the !        (previously specified) *text*. <br> !  **Usage**: <br> !   --->    Index = Finder%FindNext() <br> !  **Note**: Must call the *SetPattern* and *FindIndex* methods before calling this method. <br> PROCEDURE :: FindNext => PatternFinder_FindNext !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To reset/clear all components of the *PatternFinder* object. <br> !  **Usage**: <br> !   --->    CALL Finder%Clear() <br> !  **Note**: If the length of the pattern is zero, the method just returns without doing anything. <br> PROCEDURE :: Clear => PatternFinder_Clear !% To perform finalization of the *PatternFinder* object. FINAL :: PatternFinder_Finalize END TYPE PatternFinder","tags":"","loc":"type\\patternfinder.html"},{"title":"AlphabetTrie – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: AlphabetTrie The AlphabetTrie type is a container type that utilizes a multi-way trie\n implementation to provide common operations for a symbol table where its\n keys are character strings and its values can be of any type. Finalization Procedures final :: AlphabetTrie_Finalizer To perform finalization of the symbol table. private  subroutine AlphabetTrie_Finalizer(Table) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( AlphabetTrie ), intent(inout) :: Table symbol table Type-Bound Procedures procedure, public :: CreateEmpty => AlphabetTrie_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty symbol table. Usage : --->    CALL Table%CreateEmpty(Alphabet) private  subroutine AlphabetTrie_CreateEmpty(Table, Alpha) To construct an empty symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table class( BaseAlphabet ), intent(in), TARGET :: Alpha Alphabet object generic, public :: Construct => AlphabetTrie_ConstructByArray_ChrStr, AlphabetTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(Alphabet, 10, KeyArr, ValArr) private  subroutine AlphabetTrie_ConstructByArray_ChrStr(Table, Alpha, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table class( BaseAlphabet ), intent(in), TARGET :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: N number of keys character(kind=kChar, len=*), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values private  subroutine AlphabetTrie_ConstructByArray_FvlStr(Table, Alpha, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table class( BaseAlphabet ), intent(in), TARGET :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: N number of keys type( FvlStr ), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values procedure, public :: Clear => AlphabetTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() private  subroutine AlphabetTrie_Clear(Table) To destruct a symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table generic, public :: Destruct => AlphabetTrie_Destructor_ChrStr, AlphabetTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine AlphabetTrie_Destructor_ChrStr(Table, KeyQ, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ a queue of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values private  subroutine AlphabetTrie_Destructor_FvlStr(Table, KeyArr, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: KeyArr (:) an array of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values generic, public :: Insert => AlphabetTrie_Insert_ChrStr, AlphabetTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine AlphabetTrie_Insert_ChrStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(in) :: Value value private  subroutine AlphabetTrie_Insert_FvlStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(in) :: Value value generic, public :: Remove => AlphabetTrie_Remove_ChrStr, AlphabetTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) private  subroutine AlphabetTrie_Remove_ChrStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value private  subroutine AlphabetTrie_Remove_FvlStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value generic, public :: Contain => AlphabetTrie_Contain_ChrStr, AlphabetTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function AlphabetTrie_Contain_ChrStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key Return Value logical true if key found private  function AlphabetTrie_Contain_FvlStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key Return Value logical true if key found procedure, public :: GetSize => AlphabetTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() private  function AlphabetTrie_GetSize(Table) result(Size) To get size (number of keys stored) of the table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(in) :: Table symbol table Return Value integer(kind=kInt32) size of the table procedure, public :: IsEmpty => AlphabetTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function AlphabetTrie_IsEmpty(Table) result(Flag) To check whether the table is empty or not. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(in) :: Table symbol table Return Value logical true if the table is empty generic, public :: StartWith => AlphabetTrie_StartWith_ChrStr, AlphabetTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing private  function AlphabetTrie_StartWith_ChrStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found private  function AlphabetTrie_StartWith_FvlStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found generic, public :: GetValue => AlphabetTrie_GetValue_ChrStr, AlphabetTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) private  subroutine AlphabetTrie_GetValue_ChrStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value private  subroutine AlphabetTrie_GetValue_FvlStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value generic, public :: GetAllKeys => AlphabetTrie_AllKeys_ChrStr, AlphabetTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine AlphabetTrie_AllKeys_ChrStr(Table, KeyQ) To return a queue of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ queue of all keys private  subroutine AlphabetTrie_AllKeys_FvlStr(Table, Keys) To return an array of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysWithPrefix => AlphabetTrie_KeysWithPrefix_CHCH, AlphabetTrie_KeysWithPrefix_CHVL, AlphabetTrie_KeysWithPrefix_VLCH, AlphabetTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine AlphabetTrie_KeysWithPrefix_CHCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine AlphabetTrie_KeysWithPrefix_CHVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine AlphabetTrie_KeysWithPrefix_VLCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine AlphabetTrie_KeysWithPrefix_VLVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysThatMatch => AlphabetTrie_KeysThatMatch_CHCH, AlphabetTrie_KeysThatMatch_CHVL, AlphabetTrie_KeysThatMatch_VLCH, AlphabetTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine AlphabetTrie_KeysThatMatch_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine AlphabetTrie_KeysThatMatch_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine AlphabetTrie_KeysThatMatch_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine AlphabetTrie_KeysThatMatch_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetWildcardKeys => AlphabetTrie_WildcardKeys_CHCH, AlphabetTrie_WildcardKeys_CHVL, AlphabetTrie_WildcardKeys_VLCH, AlphabetTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. private  subroutine AlphabetTrie_WildcardKeys_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine AlphabetTrie_WildcardKeys_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine AlphabetTrie_WildcardKeys_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine AlphabetTrie_WildcardKeys_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetLongestPrefixOf => AlphabetTrie_LongestPrefixOf_ChrStr, AlphabetTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix) private  subroutine AlphabetTrie_LongestPrefixOf_ChrStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Query a query character(kind=kChar, len=:), intent(out), ALLOCATABLE :: Prefix the longest prefix of the query private  subroutine AlphabetTrie_LongestPrefixOf_FvlStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( AlphabetTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Query a query type( FvlStr ), intent(out) :: Prefix the longest prefix of the query Source Code TYPE AlphabetTrie PRIVATE CLASS ( Alphabet ), POINTER :: Alpha => NULL () !! alphabet object TYPE ( TrieNode ) :: Root !! root of trie tIndex :: N !! number of keys CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => AlphabetTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => AlphabetTrie_Delete !% *Get* is a working method for key inquiring operation PROCEDURE , PRIVATE :: Get => AlphabetTrie_GetNode !% *LongestPrefixLen* is a working method for getting the longest prefix PROCEDURE , PRIVATE :: LongestPrefixLen => AlphabetTrie_LengthOfLongestPrefix !% *Collect* is a working method for key collecting operation PROCEDURE , PRIVATE :: AlphabetTrie_CollectKeys PROCEDURE , PRIVATE :: AlphabetTrie_AssembleKeys PROCEDURE , PRIVATE :: AlphabetTrie_GatherWildcardKeys GENERIC , PRIVATE :: Collect => AlphabetTrie_CollectKeys , & AlphabetTrie_AssembleKeys , & AlphabetTrie_GatherWildcardKeys !% procedures with generic interfaces PROCEDURE , PRIVATE :: AlphabetTrie_Insert_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Insert_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Remove_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Remove_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Contain_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Contain_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> ! **Purpose**:  To construct an empty symbol table.  <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(Alphabet) PROCEDURE :: CreateEmpty => AlphabetTrie_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(Alphabet, 10, KeyArr, ValArr) GENERIC :: Construct => AlphabetTrie_ConstructByArray_ChrStr , & AlphabetTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => AlphabetTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => AlphabetTrie_Destructor_ChrStr , & AlphabetTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => AlphabetTrie_Insert_ChrStr , & AlphabetTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => AlphabetTrie_Remove_ChrStr , & AlphabetTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => AlphabetTrie_Contain_ChrStr , & AlphabetTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => AlphabetTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => AlphabetTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => AlphabetTrie_StartWith_ChrStr , & AlphabetTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => AlphabetTrie_GetValue_ChrStr , & AlphabetTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => AlphabetTrie_AllKeys_ChrStr , & AlphabetTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => AlphabetTrie_KeysWithPrefix_CHCH , & AlphabetTrie_KeysWithPrefix_CHVL , & AlphabetTrie_KeysWithPrefix_VLCH , & AlphabetTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => AlphabetTrie_KeysThatMatch_CHCH , & AlphabetTrie_KeysThatMatch_CHVL , & AlphabetTrie_KeysThatMatch_VLCH , & AlphabetTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => AlphabetTrie_WildcardKeys_CHCH , & AlphabetTrie_WildcardKeys_CHVL , & AlphabetTrie_WildcardKeys_VLCH , & AlphabetTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => AlphabetTrie_LongestPrefixOf_ChrStr , & AlphabetTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: AlphabetTrie_Finalizer ! --------------------------------------------------------------------- END TYPE AlphabetTrie","tags":"","loc":"type\\alphabettrie.html"},{"title":"MultiwayTrie – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: MultiwayTrie The MultiwayTrie type is a container type that utilizes a multi-way trie\n implementation to provide common operations for a symbol table where its\n keys are character strings and its values can be of any type. Finalization Procedures final :: MultiwayTrie_Finalizer To perform finalization of the symbol table. private  subroutine MultiwayTrie_Finalizer(Table) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( MultiwayTrie ), intent(inout) :: Table symbol table Type-Bound Procedures generic, public :: Construct => MultiwayTrie_ConstructByArray_ChrStr, MultiwayTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(10, KeyArr, ValArr) private  subroutine MultiwayTrie_ConstructByArray_ChrStr(Table, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table integer(kind=kInt32), intent(in) :: N number of keys character(kind=kChar, len=*), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values private  subroutine MultiwayTrie_ConstructByArray_FvlStr(Table, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table integer(kind=kInt32), intent(in) :: N number of keys type( FvlStr ), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values procedure, public :: Clear => MultiwayTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() private  subroutine MultiwayTrie_Clear(Table) To destruct a symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table generic, public :: Destruct => MultiwayTrie_Destructor_ChrStr, MultiwayTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine MultiwayTrie_Destructor_ChrStr(Table, KeyQ, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ a queue of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values private  subroutine MultiwayTrie_Destructor_FvlStr(Table, KeyArr, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: KeyArr (:) an array of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values generic, public :: Insert => MultiwayTrie_Insert_ChrStr, MultiwayTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine MultiwayTrie_Insert_ChrStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(in) :: Value value private  subroutine MultiwayTrie_Insert_FvlStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(in) :: Value value generic, public :: Remove => MultiwayTrie_Remove_ChrStr, MultiwayTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) private  subroutine MultiwayTrie_Remove_ChrStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value private  subroutine MultiwayTrie_Remove_FvlStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value generic, public :: Contain => MultiwayTrie_Contain_ChrStr, MultiwayTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function MultiwayTrie_Contain_ChrStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key Return Value logical true if key found private  function MultiwayTrie_Contain_FvlStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key Return Value logical true if key found procedure, public :: GetSize => MultiwayTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() private  function MultiwayTrie_GetSize(Table) result(Size) To get size (number of keys stored) of the table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(in) :: Table symbol table Return Value integer(kind=kInt32) size of the table procedure, public :: IsEmpty => MultiwayTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function MultiwayTrie_IsEmpty(Table) result(Flag) To check whether the table is empty or not. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(in) :: Table symbol table Return Value logical true if the table is empty generic, public :: StartWith => MultiwayTrie_StartWith_ChrStr, MultiwayTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing private  function MultiwayTrie_StartWith_ChrStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found private  function MultiwayTrie_StartWith_FvlStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found generic, public :: GetValue => MultiwayTrie_GetValue_ChrStr, MultiwayTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) private  subroutine MultiwayTrie_GetValue_ChrStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value private  subroutine MultiwayTrie_GetValue_FvlStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value generic, public :: GetAllKeys => MultiwayTrie_AllKeys_ChrStr, MultiwayTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine MultiwayTrie_AllKeys_ChrStr(Table, KeyQ) To return a queue of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ queue of all keys private  subroutine MultiwayTrie_AllKeys_FvlStr(Table, Keys) To return an array of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysWithPrefix => MultiwayTrie_KeysWithPrefix_CHCH, MultiwayTrie_KeysWithPrefix_CHVL, MultiwayTrie_KeysWithPrefix_VLCH, MultiwayTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine MultiwayTrie_KeysWithPrefix_CHCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine MultiwayTrie_KeysWithPrefix_CHVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine MultiwayTrie_KeysWithPrefix_VLCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine MultiwayTrie_KeysWithPrefix_VLVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysThatMatch => MultiwayTrie_KeysThatMatch_CHCH, MultiwayTrie_KeysThatMatch_CHVL, MultiwayTrie_KeysThatMatch_VLCH, MultiwayTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine MultiwayTrie_KeysThatMatch_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine MultiwayTrie_KeysThatMatch_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine MultiwayTrie_KeysThatMatch_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine MultiwayTrie_KeysThatMatch_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetWildcardKeys => MultiwayTrie_WildcardKeys_CHCH, MultiwayTrie_WildcardKeys_CHVL, MultiwayTrie_WildcardKeys_VLCH, MultiwayTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. private  subroutine MultiwayTrie_WildcardKeys_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine MultiwayTrie_WildcardKeys_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine MultiwayTrie_WildcardKeys_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine MultiwayTrie_WildcardKeys_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetLongestPrefixOf => MultiwayTrie_LongestPrefixOf_ChrStr, MultiwayTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix) private  subroutine MultiwayTrie_LongestPrefixOf_ChrStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Query a query character(kind=kChar, len=:), intent(out), ALLOCATABLE :: Prefix the longest prefix of the query private  subroutine MultiwayTrie_LongestPrefixOf_FvlStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( MultiwayTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Query a query type( FvlStr ), intent(out) :: Prefix the longest prefix of the query Source Code TYPE MultiwayTrie PRIVATE TYPE ( TrieNode ) :: Root !! root of trie tIndex :: N !! number of keys CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => MultiwayTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => MultiwayTrie_Delete !% procedures with generic interfaces PROCEDURE , PRIVATE :: MultiwayTrie_Insert_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Insert_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Remove_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Remove_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Contain_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Contain_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(10, KeyArr, ValArr) GENERIC :: Construct => MultiwayTrie_ConstructByArray_ChrStr , & MultiwayTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => MultiwayTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => MultiwayTrie_Destructor_ChrStr , & MultiwayTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => MultiwayTrie_Insert_ChrStr , & MultiwayTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => MultiwayTrie_Remove_ChrStr , & MultiwayTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => MultiwayTrie_Contain_ChrStr , & MultiwayTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => MultiwayTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => MultiwayTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => MultiwayTrie_StartWith_ChrStr , & MultiwayTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => MultiwayTrie_GetValue_ChrStr , & MultiwayTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => MultiwayTrie_AllKeys_ChrStr , & MultiwayTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => MultiwayTrie_KeysWithPrefix_CHCH , & MultiwayTrie_KeysWithPrefix_CHVL , & MultiwayTrie_KeysWithPrefix_VLCH , & MultiwayTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => MultiwayTrie_KeysThatMatch_CHCH , & MultiwayTrie_KeysThatMatch_CHVL , & MultiwayTrie_KeysThatMatch_VLCH , & MultiwayTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => MultiwayTrie_WildcardKeys_CHCH , & MultiwayTrie_WildcardKeys_CHVL , & MultiwayTrie_WildcardKeys_VLCH , & MultiwayTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => MultiwayTrie_LongestPrefixOf_ChrStr , & MultiwayTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: MultiwayTrie_Finalizer ! --------------------------------------------------------------------- END TYPE MultiwayTrie","tags":"","loc":"type\\multiwaytrie.html"},{"title":"RECompiler – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: RECompiler The RECompiler type is a ... Type-Bound Procedures procedure, public :: Compile => RECompiler_Compile private  function RECompiler_Compile(Compiler, RegexPat, ErrFlag) result(PG) To compile a regular expression pattern into a program runnable by the pattern\n matcher class 'REMatcher'. Arguments Type Intent Optional Attributes Name class( RECompiler ), intent(inout) :: Compiler RECompiler object character(kind=kChar, len=*), intent(in) :: RegexPat regular expression pattern logical, intent(out) :: ErrFlag true if error occurred Return Value type( REProgram ) REProgram object Source Code TYPE RECompiler PRIVATE ! ----- The compiled program ----- tChar , ALLOCATABLE :: instruction (:) !! The compiled regular expression 'program' tSInt32 :: lenInstruction !! The amount of the instruction buffer currently in use ! ----- Input state for compiling regular expression ----- tChar , ALLOCATABLE :: pattern (:) !! Input string tSInt32 :: len !! Length of the pattern string tSInt32 :: idx !! Current input index into ac tSInt32 :: parens !! Total number of parentheses pairs ! ----- {m,n} stacks ----- tSInt32 :: bracketMin !! Minimum number of matches tSInt32 :: bracketOpt !! Additional optional matches CONTAINS ! -----                 Private Procedures                      ----- PROCEDURE , PRIVATE :: Initialize => RECompiler_Initialize PROCEDURE , PRIVATE :: Ensure => RECompiler_Ensure PROCEDURE , PRIVATE :: Emit => RECompiler_Emit PROCEDURE , PRIVATE :: NodeInsert => RECompiler_NodeInsert PROCEDURE , PRIVATE :: SetNextOfEnd => RECompiler_SetNextOfEnd PROCEDURE , PRIVATE :: Node => RECompiler_Node PROCEDURE , PRIVATE :: Bracket => RECompiler_Bracket PROCEDURE , PRIVATE :: Escape => RECompiler_Escape PROCEDURE , PRIVATE :: CharacterClass => RECompiler_CharacterClass PROCEDURE , PRIVATE :: Atom => RECompiler_Atom PROCEDURE , PRIVATE :: Terminal => RECompiler_Terminal PROCEDURE , PRIVATE :: Closure => RECompiler_Closure PROCEDURE , PRIVATE :: Branch => RECompiler_Branch PROCEDURE , PRIVATE :: Expression => RECompiler_Expression ! -----                 Public Procedures                       ----- PROCEDURE :: Compile => RECompiler_Compile END TYPE RECompiler","tags":"","loc":"type\\recompiler.html"},{"title":"BaseAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT :: BaseAlphabet The BaseAlphabet type is an abstract data type for alphabets intended to\n be used with string-processing code that must convert between an alphabet\n of size R and the integers through 1 through R. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index Source Code TYPE , ABSTRACT :: BaseAlphabet PRIVATE tIndex :: Radix !! the radix of the alphabet TYPE ( CharIndex ), ALLOCATABLE :: KeyVal (:) !! the character-index pairs of the alphabet TYPE ( IntrusiveHashTree ) :: HashMap !! map of the character-index pairs CONTAINS PROCEDURE , PRIVATE :: FromCharSet => Alphabet_FromCharSet PROCEDURE , PRIVATE :: FromRadix => Alphabet_FromRadix PROCEDURE , PRIVATE :: Finalize => Alphabet_Finalize PROCEDURE , PRIVATE :: Alphabet_Verify_ChrStr PROCEDURE , PRIVATE :: Alphabet_Verify_FvlStr !> **Type-Bound Function**: IsReady <br> !  **Purpose**: To check whether the Alphabet object is ready to be used. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%IsReady() <br> !   --->    IF (.NOT.Alphabet%IsReady()) DoSomething PROCEDURE :: IsReady => Alphabet_IsReady !> **Type-Bound Function**: Contain <br> !  **Purpose**: To check whether the Alphabet object contains the specified character or not. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%Contain(Chr) <br> !   --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething PROCEDURE :: Contain => Alphabet_Contain !> **Type-Bound Function**: Verify <br> !  **Purpose**: To verify that all characters in the specified word are in the set of !               characters of this alphabet.  Return 0 if they are.  Otherwise, return !               a number indicating the first position (index) of the character that !               is not in the set. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%Verify(Word) <br> !   --->    IF (Alphabet%Verify(Word) /= 0) DoSomething GENERIC :: Verify => Alphabet_Verify_ChrStr , Alphabet_Verify_FvlStr !> **Type-Bound Function**: GetRadix <br> !  **Purpose**: To return the number of characters in the Alphabet object. <br> !  **Usage**: <br> !   --->    Radix = Alphabet%GetRadix() <br> PROCEDURE :: GetRadix => Alphabet_Radix !> **Type-Bound Function**: GetIndex <br> !  **Purpose**: To return the index corresponding to the specified character.  If the !               character is not in the Alphabet object, return -1. <br> !  **Usage**: <br> !   --->    Index = Alphabet%GetIndex() <br> PROCEDURE :: GetIndex => Alphabet_ToIndex !> **Type-Bound Function**: GetChar <br> !  **Purpose**: To return the character corresponding to the specified index.  If the !               index is not in the valid range (1 to Radix), return an empty character. <br> !  **Usage**: <br> !   --->    Chr = Alphabet%GetChar() <br> PROCEDURE :: GetChar => Alphabet_ToChar END TYPE BaseAlphabet","tags":"","loc":"type\\basealphabet.html"},{"title":"GenericAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: GenericAlphabet The GenericAlphabet type is a generic data type that can represent any alphabets.\n An instance of the GenericAlphabet type can be created via the Construct method\n from either a given set of characters or a radix (representing a number of characters\n in the set where the characters' code are from 0 to radix-1). Finalization Procedures final :: GenericAlphabet_Finalize To perform finalization of this object. private  subroutine GenericAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( GenericAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index generic, public :: Construct => GenericAlphabet_FromCharSet, GenericAlphabet_FromRadix Type-Bound Subroutine : Construct Purpose : To create this Alphabet object either from a specified set of characters\n              or from the radix (which is the number of characters in the set where\n              characters' code ranges from 0 to radix-1). Usage : --->    CALL Alphabet%Construct(CharSet) --->    CALL Alphabet%Construct(Radix) private  subroutine GenericAlphabet_FromCharSet(Alpha, CharSet) To construct the Alphabet object from the specified string representing\n a given set of characters. Arguments Type Intent Optional Attributes Name class( GenericAlphabet ), intent(out) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: CharSet a set of characters private  subroutine GenericAlphabet_FromRadix(Alpha, Radix) To construct the Alphabet object from a set of characters where their codes are\n from 0 to Radix-1. Arguments Type Intent Optional Attributes Name class( GenericAlphabet ), intent(out) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Radix the number of characters in the alphabet Source Code TYPE , EXTENDS ( BaseAlphabet ) :: GenericAlphabet CONTAINS PROCEDURE , PRIVATE :: GenericAlphabet_FromCharSet PROCEDURE , PRIVATE :: GenericAlphabet_FromRadix !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object either from a specified set of characters !               or from the radix (which is the number of characters in the set where !               characters' code ranges from 0 to radix-1). <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct(CharSet) <br> !   --->    CALL Alphabet%Construct(Radix) <br> GENERIC :: Construct => GenericAlphabet_FromCharSet , & GenericAlphabet_FromRadix !% To perform finalization of this object. FINAL :: GenericAlphabet_Finalize END TYPE GenericAlphabet","tags":"","loc":"type\\genericalphabet.html"},{"title":"BinaryAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: BinaryAlphabet The BinaryAlphabet type is a data type representing the binary alphabet { 0, 1 }. Finalization Procedures final :: BinaryAlphabet_Finalize To perform finalization of this object. private  subroutine BinaryAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( BinaryAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => BinaryAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine BinaryAlphabet_Construct(Alpha) To construct the BinaryAlphabet object. Arguments Type Intent Optional Attributes Name class( BinaryAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: BinaryAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => BinaryAlphabet_Construct !% To perform finalization of this object. FINAL :: BinaryAlphabet_Finalize END TYPE BinaryAlphabet","tags":"","loc":"type\\binaryalphabet.html"},{"title":"OctalAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: OctalAlphabet The OctalAlphabet type is a data type representing the octal alphabet { 0, 1, 2, 3, 4, 5, 6, 7 }. Finalization Procedures final :: OctalAlphabet_Finalize To perform finalization of this object. private  subroutine OctalAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( OctalAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => OctalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine OctalAlphabet_Construct(Alpha) To construct the OctalAlphabet object. Arguments Type Intent Optional Attributes Name class( OctalAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: OctalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => OctalAlphabet_Construct !% To perform finalization of this object. FINAL :: OctalAlphabet_Finalize END TYPE OctalAlphabet","tags":"","loc":"type\\octalalphabet.html"},{"title":"DecimalAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: DecimalAlphabet The DecimalAlphabet type is a data type representing the decimal alphabet\n { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }. Finalization Procedures final :: DecimalAlphabet_Finalize To perform finalization of this object. private  subroutine DecimalAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DecimalAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => DecimalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine DecimalAlphabet_Construct(Alpha) To construct the DecimalAlphabet object. Arguments Type Intent Optional Attributes Name class( DecimalAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: DecimalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => DecimalAlphabet_Construct !% To perform finalization of this object. FINAL :: DecimalAlphabet_Finalize END TYPE DecimalAlphabet","tags":"","loc":"type\\decimalalphabet.html"},{"title":"HexadecimalAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: HexadecimalAlphabet The HexadecimalAlphabet type is a data type representing the hexadecimal alphabet\n { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F }. Finalization Procedures final :: HexadecimalAlphabet_Finalize To perform finalization of this object. private  subroutine HexadecimalAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( HexadecimalAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => HexadecimalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine HexadecimalAlphabet_Construct(Alpha) To construct the HexadecimalAlphabet object. Arguments Type Intent Optional Attributes Name class( HexadecimalAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: HexadecimalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => HexadecimalAlphabet_Construct !% To perform finalization of this object. FINAL :: HexadecimalAlphabet_Finalize END TYPE HexadecimalAlphabet","tags":"","loc":"type\\hexadecimalalphabet.html"},{"title":"DnaAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: DnaAlphabet The DnaAlphabet type is a data type representing the DNA alphabet { A, C, T, G }. Finalization Procedures final :: DnaAlphabet_Finalize To perform finalization of this object. private  subroutine DnaAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DnaAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => DnaAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine DnaAlphabet_Construct(Alpha) To construct the DnaAlphabet object. Arguments Type Intent Optional Attributes Name class( DnaAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: DnaAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => DnaAlphabet_Construct !% To perform finalization of this object. FINAL :: DnaAlphabet_Finalize END TYPE DnaAlphabet","tags":"","loc":"type\\dnaalphabet.html"},{"title":"ProteinAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: ProteinAlphabet The ProteinAlphabet type is a data type representing the protein alphabet\n { A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y }. Finalization Procedures final :: ProteinAlphabet_Finalize To perform finalization of this object. private  subroutine ProteinAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ProteinAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => ProteinAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine ProteinAlphabet_Construct(Alpha) To construct the ProteinAlphabet object. Arguments Type Intent Optional Attributes Name class( ProteinAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: ProteinAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => ProteinAlphabet_Construct !% To perform finalization of this object. FINAL :: ProteinAlphabet_Finalize END TYPE ProteinAlphabet","tags":"","loc":"type\\proteinalphabet.html"},{"title":"LowercaseAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: LowercaseAlphabet The LowercaseAlphabet type is a data type representing the lowercase alphabet\n { a, b, c, ..., z }. Finalization Procedures final :: LowercaseAlphabet_Finalize To perform finalization of this object. private  subroutine LowercaseAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( LowercaseAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => LowercaseAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine LowercaseAlphabet_Construct(Alpha) To construct the LowercaseAlphabet object. Arguments Type Intent Optional Attributes Name class( LowercaseAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: LowercaseAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => LowercaseAlphabet_Construct !% To perform finalization of this object. FINAL :: LowercaseAlphabet_Finalize END TYPE LowercaseAlphabet","tags":"","loc":"type\\lowercasealphabet.html"},{"title":"UppercaseAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: UppercaseAlphabet The UppercaseAlphabet type is a data type representing the uppercase alphabet\n { A, B, C, ..., Z }. Finalization Procedures final :: UppercaseAlphabet_Finalize To perform finalization of this object. private  subroutine UppercaseAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( UppercaseAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => UppercaseAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine UppercaseAlphabet_Construct(Alpha) To construct the UppercaseAlphabet object. Arguments Type Intent Optional Attributes Name class( UppercaseAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: UppercaseAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => UppercaseAlphabet_Construct !% To perform finalization of this object. FINAL :: UppercaseAlphabet_Finalize END TYPE UppercaseAlphabet","tags":"","loc":"type\\uppercasealphabet.html"},{"title":"Base64Alphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: Base64Alphabet The Base64Alphabet type is a data type representing the base-64 alphabet { 64 characters }. Finalization Procedures final :: Base64Alphabet_Finalize To perform finalization of this object. private  subroutine Base64Alphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( Base64Alphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => Base64Alphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine Base64Alphabet_Construct(Alpha) To construct the Base64Alphabet object. Arguments Type Intent Optional Attributes Name class( Base64Alphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: Base64Alphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => Base64Alphabet_Construct !% To perform finalization of this object. FINAL :: Base64Alphabet_Finalize END TYPE Base64Alphabet","tags":"","loc":"type\\base64alphabet.html"},{"title":"Code39Alphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: Code39Alphabet The Code39Alphabet type is a data type representing the Code-39 alphabet { 43+1 characters }. Finalization Procedures final :: Code39Alphabet_Finalize To perform finalization of this object. private  subroutine Code39Alphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( Code39Alphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => Code39Alphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine Code39Alphabet_Construct(Alpha) To construct the Code39Alphabet object. Arguments Type Intent Optional Attributes Name class( Code39Alphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: Code39Alphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => Code39Alphabet_Construct !% To perform finalization of this object. FINAL :: Code39Alphabet_Finalize END TYPE Code39Alphabet","tags":"","loc":"type\\code39alphabet.html"},{"title":"AsciiAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: AsciiAlphabet The AsciiAlphabet type is a data type representing the ASCII alphabet { 0-127 characters' code }. Finalization Procedures final :: AsciiAlphabet_Finalize To perform finalization of this object. private  subroutine AsciiAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( AsciiAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => AsciiAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine AsciiAlphabet_Construct(Alpha) To construct the AsciiAlphabet object. Arguments Type Intent Optional Attributes Name class( AsciiAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: AsciiAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => AsciiAlphabet_Construct !% To perform finalization of this object. FINAL :: AsciiAlphabet_Finalize END TYPE AsciiAlphabet","tags":"","loc":"type\\asciialphabet.html"},{"title":"ExtendedAsciiAlphabet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseAlphabet ) :: ExtendedAsciiAlphabet The ExtendedAsciiAlphabet type is a data type representing the extended ASCII alphabet\n { 0-255 characters' code }. Finalization Procedures final :: ExtendedAsciiAlphabet_Finalize To perform finalization of this object. private  subroutine ExtendedAsciiAlphabet_Finalize(Alpha) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ExtendedAsciiAlphabet ), intent(inout) :: Alpha Alphabet object Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething private pure function Alphabet_IsReady(Alpha) result(Flag) To check whether the Alphabet object is ready to be used. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value logical true if the object is ready to be used procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething private  function Alphabet_Contain(Alpha, C) result(Flag) To check whether the Alphabet object contains the specified character or not. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value logical true if the character is in the Alphabet object generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr private  function Alphabet_Verify_ChrStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=*), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set private  function Alphabet_Verify_FvlStr(Alpha, Word) result(Flag) To verify that all characters in the specified word are in the set of\n characters of this alphabet.  Return 0 if they are.  Otherwise, return\n a number indicating the first position (index) of the character that\n is not in the set. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object type( FvlStr ), intent(in) :: Word a word Return Value integer(kind=kInt32) return number indicating whether all characters are in the set procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() private pure function Alphabet_Radix(Alpha) result(Radix) To return the number of characters in the Alphabet object. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object Return Value integer(kind=kInt32) the number of characters in the alphabet procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() private  function Alphabet_ToIndex(Alpha, C) result(Idx) To return the index corresponding to the specified character.  If the character\n is not in the Alphabet object, return -1. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object character(kind=kChar, len=1), intent(in) :: C a character Return Value integer(kind=kInt32) index corresponding to the specified character procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() private  function Alphabet_ToChar(Alpha, Idx) result(C) To return the character corresponding to the specified index.  If the index\n is not in the valid range (1 to Radix), return an empty character. Arguments Type Intent Optional Attributes Name class( BaseAlphabet ), intent(in) :: Alpha Alphabet object integer(kind=kInt32), intent(in) :: Idx an index Return Value character(kind=kChar, len=1) character corresponding to the specified index procedure, public :: Construct => ExtendedAsciiAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() private  subroutine ExtendedAsciiAlphabet_Construct(Alpha) To construct the ExtendedAsciiAlphabet object. Arguments Type Intent Optional Attributes Name class( ExtendedAsciiAlphabet ), intent(out) :: Alpha Alphabet object Source Code TYPE , EXTENDS ( BaseAlphabet ) :: ExtendedAsciiAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => ExtendedAsciiAlphabet_Construct !% To perform finalization of this object. FINAL :: ExtendedAsciiAlphabet_Finalize END TYPE ExtendedAsciiAlphabet","tags":"","loc":"type\\extendedasciialphabet.html"},{"title":"RegexFinder – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: RegexFinder The RegexFinder type is a string type that provides various efficient\n algorithms for a substring searching operation. Type-Bound Procedures procedure, public :: SetPattern => RegexFinder_SetPattern Type-Bound Subroutine : SetPattern Purpose :  To set and compile the specified pattern. Usage : --->    CALL Finder%SetPattern(Pattern) private  subroutine RegexFinder_SetPattern(Finder, Pattern) To process the specified pattern based on the specified searching algorithm.\n If the length of the pattern is zero, just return without doing anything. Arguments Type Intent Optional Attributes Name class( RegexFinder ), intent(inout) :: Finder 'RegexFinder' object character(kind=kChar, len=*), intent(in) :: Pattern the pattern procedure, public :: IsMatch => RegexFinder_IsMatch Type-Bound Function : IsMatch Purpose :  To check whether the specified text matches the previously compiled pattern\n               (or the optionally specified pattern). Usage : --->    Flag = Finder%IsMatch(Text) --->    IF (.NOT.Finder%IsMatch(Text, Pattern)) DoSomething private  function RegexFinder_IsMatch(Finder, Text, Pattern) result(Flag) To check whether the specified text matches the previously compiled pattern\n (or the optionally specified pattern). Arguments Type Intent Optional Attributes Name class( RegexFinder ), intent(inout) :: Finder 'RegexFinder' object character(kind=kChar, len=*), intent(in) :: Text the specified text character(kind=kChar, len=*), intent(in), optional :: Pattern the specified pattern Return Value logical true if the specified text matches the pattern procedure, public :: FindSubstring => RegexFinder_FindSubstring Type-Bound Function : FindSubstring Purpose :  To find a substring within the specified text that matches the previously\n               compiled pattern (or the optionally specified pattern).  If the 'StartPos'\n               argument is present and greater than 0 and less than the text length, the\n               search starts at the 'StartPos' position.  Otherwise, the search start at\n               the first position of the text.  The routine returns indices indicating\n               the starting and ending positions of the substring if found.  If the\n               substring is not found, both indices are set to zeros. Usage : ! find a substring within the text starting at 1 where the pattern has already been set. --->    Indices = Finder%FindSubstring(Text) ! find a substring within the text starting at StartPos. --->    Indices = Finder%FindSubstring(Text, StartPos=StartPos) ! find a substring within the text where the pattern has not yet been set. --->    Indices = Finder%FindSubstring(Text, Pattern=Pattern) ! find a substring within the text starting at StartPos where the pattern has not yet been set. --->    Indices = Finder%FindSubstring(Text, StartPos, Pattern) private  function RegexFinder_FindSubstring(Finder, Text, StartPos, Pattern) result(Indices) To find a substring within the specified text that matches the previously\n compiled pattern (or the optionally specified pattern).  If the 'StartPos'\n argument is present and greater than 0 and less than the text length,\n the search starts at the 'StartPos' position.  Otherwise, the search start\n at the first position of the text. The routine returns indices indicating the starting and ending positions of\n the substring if found.  If the substring is not found, both indices are set\n to zeros. Arguments Type Intent Optional Attributes Name class( RegexFinder ), intent(inout) :: Finder 'RegexFinder' object character(kind=kChar, len=*), intent(in) :: Text the specified text integer(kind=kInt32), intent(in), optional :: StartPos the starting position character(kind=kChar, len=*), intent(in), optional :: Pattern the specified pattern Return Value integer(kind=kInt32), (2) indices of the substring Source Code TYPE RegexFinder PRIVATE !% the cached regular expression string pattern tCharAlloc :: RegexPattern !% the cached regular expression string compiled pattern TYPE ( CompiledRegex ) :: CompiledPattern CONTAINS !> **Type-Bound Subroutine**: SetPattern <br> !  **Purpose**:  To set and compile the specified pattern. <br> !  **Usage**: <br> !   --->    CALL Finder%SetPattern(Pattern) <br> PROCEDURE :: SetPattern => RegexFinder_SetPattern !> **Type-Bound Function**: IsMatch <br> !  **Purpose**:  To check whether the specified text matches the previously compiled pattern !                (or the optionally specified pattern). <br> !  **Usage**: <br> !   --->    Flag = Finder%IsMatch(Text) <br> !   --->    IF (.NOT.Finder%IsMatch(Text, Pattern)) DoSomething <br> PROCEDURE :: IsMatch => RegexFinder_IsMatch !> **Type-Bound Function**: FindSubstring <br> !  **Purpose**:  To find a substring within the specified text that matches the previously !                compiled pattern (or the optionally specified pattern).  If the 'StartPos' !                argument is present and greater than 0 and less than the text length, the !                search starts at the 'StartPos' position.  Otherwise, the search start at !                the first position of the text.  The routine returns indices indicating !                the starting and ending positions of the substring if found.  If the !                substring is not found, both indices are set to zeros. <br> !  **Usage**: <br> !   ! find a substring within the text starting at 1 where the pattern has already been set. <br> !   --->    Indices = Finder%FindSubstring(Text) <br> !   ! find a substring within the text starting at StartPos. <br> !   --->    Indices = Finder%FindSubstring(Text, StartPos=StartPos) <br> !   ! find a substring within the text where the pattern has not yet been set. <br> !   --->    Indices = Finder%FindSubstring(Text, Pattern=Pattern) <br> !   ! find a substring within the text starting at StartPos where the pattern has not yet been set. <br> !   --->    Indices = Finder%FindSubstring(Text, StartPos, Pattern) <br> PROCEDURE :: FindSubstring => RegexFinder_FindSubstring END TYPE RegexFinder","tags":"","loc":"type\\regexfinder.html"},{"title":"CompiledRegex – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: CompiledRegex Components Type Visibility Attributes Name Initial integer(kind=kInt32), public, ALLOCATABLE :: TransitionTable (:,:) integer(kind=kInt32), public :: IS = -1 integer(kind=kInt32), public :: RS = -1 logical, public, ALLOCATABLE :: FS (:) Source Code TYPE CompiledRegex tSInt32 , ALLOCATABLE :: TransitionTable (:,:) tSInt32 :: IS = - 1 ! initial state tSInt32 :: RS = - 1 ! rejected state tLogical , ALLOCATABLE :: FS (:) ! final states END TYPE CompiledRegex","tags":"","loc":"type\\compiledregex.html"},{"title":"DFAutomaton – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DFAutomaton The DFAutomaton type is a node type... Components Type Visibility Attributes Name Initial type( BitmapStateManager ), public, POINTER :: Manager => NULL() type( BitmapState ), public, POINTER :: States (:) => NULL() Type-Bound Procedures procedure, public :: Construct => DFAutomaton_Construct private  function DFAutomaton_Construct(DFA, Manager) result(RegexPat) To construct the DFAutomaton object. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(out) :: DFA type( BitmapStateManager ), intent(in), TARGET :: Manager Return Value type( CompiledRegex ) procedure, public :: Destruct => DFAutomaton_Destruct private  subroutine DFAutomaton_Destruct(DFA) To destruct the DFAutomaton object. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA procedure, public :: Initialize => DFAutomaton_Initialize private  subroutine DFAutomaton_Initialize(DFA, RegexPat) To perform initialization of the DFAutomaton object. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type( CompiledRegex ), intent(inout) :: RegexPat procedure, public :: NFATransMap => DFAutomaton_NFATransMap private  subroutine DFAutomaton_NFATransMap(DFA, ClosureMap, NFATransMap) To construct the NFA transition map. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type(IntrusiveHashList), intent(inout) :: ClosureMap type(IntrusiveHashList), intent(inout) :: NFATransMap procedure, public :: OriginalDFA => DFAutomaton_OriginalDFA private  subroutine DFAutomaton_OriginalDFA(DFA, StateSet, NFATransMap, DFATransMap) To construct the original DFAutomaton object. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type( BitmapStatePack ), intent(inout) :: StateSet type(IntrusiveHashList), intent(inout) :: NFATransMap type(IntrusiveHashList), intent(inout) :: DFATransMap procedure, public :: CalculateClosure => DFAutomaton_CalculateClosure private  function DFAutomaton_CalculateClosure(DFA, States) result(ClosureMap) To perform ... Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type( BitmapState ), intent(inout) :: States (0:) Return Value type(IntrusiveHashList) procedure, public :: DfsClosure => DFAutomaton_DfsClosure private  subroutine DFAutomaton_DfsClosure(DFA, State, Closure) To perform ... Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type( BitmapState ), intent(inout) :: State type( BitmapStatePack ), intent(inout) :: Closure procedure, public :: TraceReachable => DFAutomaton_TraceReachable private  function DFAutomaton_TraceReachable(DFA, Closure, Chr, ClosureMap) result(ResPack) To perform ... Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type( BitmapStatePack ), intent(inout) :: Closure character(kind=kChar, len=1), intent(in) :: Chr type(IntrusiveHashList), intent(inout) :: ClosureMap Return Value type( BitmapStatePack ), POINTER procedure, public :: Minimize => DFAutomaton_Minimize private  subroutine DFAutomaton_Minimize(DFA, TransMap, InitClosure, FinalState, RegexPat) To construct minimum DFA. Arguments Type Intent Optional Attributes Name class( DFAutomaton ), intent(inout) :: DFA type(IntrusiveHashList), intent(inout) :: TransMap type( BitmapStatePack ), intent(in) :: InitClosure type( BitmapState ), intent(in) :: FinalState type( CompiledRegex ), intent(inout) :: RegexPat Source Code TYPE DFAutomaton TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () TYPE ( BitmapState ), POINTER :: States (:) => NULL () CONTAINS PROCEDURE :: Construct => DFAutomaton_Construct PROCEDURE :: Destruct => DFAutomaton_Destruct PROCEDURE :: Initialize => DFAutomaton_Initialize PROCEDURE :: NFATransMap => DFAutomaton_NFATransMap PROCEDURE :: OriginalDFA => DFAutomaton_OriginalDFA PROCEDURE :: CalculateClosure => DFAutomaton_CalculateClosure PROCEDURE :: DfsClosure => DFAutomaton_DfsClosure PROCEDURE :: TraceReachable => DFAutomaton_TraceReachable PROCEDURE :: Minimize => DFAutomaton_Minimize END TYPE DFAutomaton","tags":"","loc":"type\\dfautomaton.html"},{"title":"NFAutomaton – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: NFAutomaton The NFAutomaton type is a node type... Components Type Visibility Attributes Name Initial type(IntrusiveLinearList), public :: List type(IntrusiveLinearList), public :: Stack integer(kind=kInt32), public :: NextID = 0 Type-Bound Procedures procedure, public :: Construct => NFAutomaton_Construct private  subroutine NFAutomaton_Construct(NFA, Root) To construct the NFAutomaton object. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(out) :: NFA type( SyntaxNode ), intent(inout), POINTER :: Root procedure, public :: Destruct => NFAutomaton_Destruct private  subroutine NFAutomaton_Destruct(NFA) To destruct the NFAutomaton object. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(inout) :: NFA procedure, public :: NewState => NFAutomaton_NewState private  function NFAutomaton_NewState(NFA) result(NewState) To create new NFA state. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(inout) :: NFA Return Value type( NFAState ), POINTER procedure, public :: DepthFirstSearch => NFAutomaton_DepthFirstSearch private recursive subroutine NFAutomaton_DepthFirstSearch(NFA, Node) To perform depth first search. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(inout) :: NFA type( SyntaxNode ), intent(inout) :: Node procedure, public :: Visit => NFAutomaton_Visit private  subroutine NFAutomaton_Visit(NFA, Node) To perform visit operation. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(inout) :: NFA type( SyntaxNode ), intent(inout) :: Node procedure, public :: AsBitmapStateManager => NFAutomaton_AsBitmapStateManager private  function NFAutomaton_AsBitmapStateManager(NFA) result(Manager) To create new NFA state. Arguments Type Intent Optional Attributes Name class( NFAutomaton ), intent(inout) :: NFA Return Value type( BitmapStateManager ) Source Code TYPE NFAutomaton TYPE ( IntrusiveLinearList ) :: List TYPE ( IntrusiveLinearList ) :: Stack tSInt32 :: NextID = 0 CONTAINS PROCEDURE , PRIVATE :: StackPop => NFAutomaton_StackPop PROCEDURE :: Construct => NFAutomaton_Construct PROCEDURE :: Destruct => NFAutomaton_Destruct PROCEDURE :: NewState => NFAutomaton_NewState PROCEDURE :: DepthFirstSearch => NFAutomaton_DepthFirstSearch PROCEDURE :: Visit => NFAutomaton_Visit PROCEDURE :: AsBitmapStateManager => NFAutomaton_AsBitmapStateManager END TYPE NFAutomaton","tags":"","loc":"type\\nfautomaton.html"},{"title":"BitmapStatePack – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(DoublyLinkedNode) :: BitmapStatePack The BitmapStatePack type is a node type... Type-Bound Procedures procedure, public :: Copy => BitmapStatePack_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine BitmapStatePack_Copy(SrcObj, DstObj, IsDeep) To copy the BitmapStatePack object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => BitmapStatePack_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function BitmapStatePack_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => BitmapStatePack_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). private  subroutine BitmapStatePack_MemFree(Obj) To free memory of the BitmapStatePack object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Obj procedure, public :: ToString => BitmapStatePack_ToString ToString is a deferred procedure to get the string representation of this object. private  function BitmapStatePack_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: HashCode => BitmapStatePack_HashCode HashCode is a deferred procedure to compute hash code of this object. private  function BitmapStatePack_HashCode(Obj) result(Code) To compute hash code of the specified object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: Obj object Return Value integer(kind=kInt32) hash code procedure, public :: Construct => BitmapStatePack_Construct private  subroutine BitmapStatePack_Construct(Pack, Manager) To construct the BitmapState object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(out) :: Pack type( BitmapStateManager ), intent(in), TARGET :: Manager procedure, public :: Destruct => BitmapStatePack_Destruct private  subroutine BitmapStatePack_Destruct(Pack) To destruct the BitmapState object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Pack procedure, public :: AddState => BitmapStatePack_AddState private  subroutine BitmapStatePack_AddState(Pack, StateID) To add state to the pack object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Pack integer(kind=kInt32), intent(in) :: StateID procedure, public :: AddAll => BitmapStatePack_AddAll private  subroutine BitmapStatePack_AddAll(Pack, Other) To add state to the pack object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Pack type( BitmapStatePack ), intent(in) :: Other procedure, public :: Contain => BitmapStatePack_Contain private  function BitmapStatePack_Contain(Pack, StateID) result(Flag) To check whether the pack object contains the specified ID or not. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: Pack integer(kind=kInt32), intent(in) :: StateID Return Value logical procedure, public :: IsEmpty => BitmapStatePack_IsEmpty private  function BitmapStatePack_IsEmpty(Pack) result(Flag) To check whether the pack object is empty or not. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: Pack Return Value logical procedure, public :: Size => BitmapStatePack_Size private  function BitmapStatePack_Size(Pack) result(StateSize) To get size of states of the pack object. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: Pack Return Value integer(kind=kInt32) procedure, public :: AsList => BitmapStatePack_AsList private  function BitmapStatePack_AsList(Pack) result(List) To get the pack object as a list of states. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout), TARGET :: Pack Return Value type(IntrusiveLinearList), POINTER procedure, public :: Freeze => BitmapStatePack_Freeze private  subroutine BitmapStatePack_Freeze(Pack) To perform freezing operation. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Pack procedure, public :: EnsureWritable => BitmapStatePack_EnsureWritable private  subroutine BitmapStatePack_EnsureWritable(Pack) To report error if wriable is false. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(inout) :: Pack procedure, public :: IsEqual => BitmapStatePack_IsEqual private  function BitmapStatePack_IsEqual(LhsObj, RhsObj) result(Flag) To check whether the two specified objects are equal to one another or not. Arguments Type Intent Optional Attributes Name class( BitmapStatePack ), intent(in) :: LhsObj an object type( BitmapStatePack ), intent(in) :: RhsObj another object Return Value logical true if keys of both objects are equal Source Code TYPE , EXTENDS ( DoublyLinkedNode ) :: BitmapStatePack PRIVATE tSInt64 , ALLOCATABLE :: StateBitmap (:) TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () tLogical :: Writable TYPE ( IntrusiveLinearList ) :: List ! use BitmapState as node CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapStatePack_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapStatePack_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitmapStatePack_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapStatePack_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapStatePack_HashCode ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE :: Construct => BitmapStatePack_Construct PROCEDURE :: Destruct => BitmapStatePack_Destruct PROCEDURE :: AddState => BitmapStatePack_AddState PROCEDURE :: AddAll => BitmapStatePack_AddAll PROCEDURE :: Contain => BitmapStatePack_Contain PROCEDURE :: IsEmpty => BitmapStatePack_IsEmpty PROCEDURE :: Size => BitmapStatePack_Size PROCEDURE :: AsList => BitmapStatePack_AsList PROCEDURE :: Freeze => BitmapStatePack_Freeze PROCEDURE :: EnsureWritable => BitmapStatePack_EnsureWritable PROCEDURE :: IsEqual => BitmapStatePack_IsEqual END TYPE BitmapStatePack","tags":"","loc":"type\\bitmapstatepack.html"},{"title":"BitmapState – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(DoublyLinkedNode) :: BitmapState The BitmapState type is a node type... Type-Bound Procedures procedure, public :: Copy => BitmapState_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine BitmapState_Copy(SrcObj, DstObj, IsDeep) To copy the BitmapState object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => BitmapState_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function BitmapState_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => BitmapState_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). private  subroutine BitmapState_MemFree(Obj) To free memory of the BitmapState object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: Obj procedure, public :: ToString => BitmapState_ToString ToString is a deferred procedure to get the string representation of this object. private  function BitmapState_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: HashCode => BitmapState_HashCode HashCode is a deferred procedure to compute hash code of this object. private  function BitmapState_HashCode(Obj) result(Code) To compute hash code of the specified object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: Obj object Return Value integer(kind=kInt32) hash code procedure, public :: Construct => BitmapState_Construct private  subroutine BitmapState_Construct(State, ID, Manager) To construct the BitmapState object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(out) :: State integer(kind=kInt32), intent(in) :: ID type( BitmapStateManager ), intent(in), TARGET :: Manager procedure, public :: Destruct => BitmapState_Destruct private  subroutine BitmapState_Destruct(State) To destruct the BitmapState object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: State procedure, public :: TransitionRule => BitmapState_TransitionRule private  subroutine BitmapState_TransitionRule(State, Chr, TargetID) To perform transition rule. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: State character(kind=kChar, len=1), intent(in) :: Chr integer(kind=kInt32), intent(in) :: TargetID procedure, public :: DirectRule => BitmapState_DirectRule private  subroutine BitmapState_DirectRule(State, TargetID) To perform direct rule. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: State integer(kind=kInt32), intent(in) :: TargetID procedure, public :: GetTransitionMap => BitmapState_GetTransitionMap private  function BitmapState_GetTransitionMap(State) result(TransMap) To get the transition map of the object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in), TARGET :: State object Return Value type(IntrusiveHashList), POINTER procedure, public :: GetDirectTable => BitmapState_GetDirectTable private  function BitmapState_GetDirectTable(State) result(Table) To get the direct table of the object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in), TARGET :: State object Return Value type( BitmapStatePack ), POINTER procedure, public :: GetID => BitmapState_GetID private  function BitmapState_GetID(State) result(ID) To get ID of the object. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: State object Return Value integer(kind=kInt32) procedure, public :: Freeze => BitmapState_Freeze private  subroutine BitmapState_Freeze(State) To perform freezing operation. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: State procedure, public :: EnsureWritable => BitmapState_EnsureWritable private  subroutine BitmapState_EnsureWritable(State) To report error if wriable is false. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(inout) :: State procedure, public :: IsEqual => BitmapState_IsEqual private  function BitmapState_IsEqual(LhsObj, RhsObj) result(Flag) To check whether the two specified objects are equal to one another or not. Arguments Type Intent Optional Attributes Name class( BitmapState ), intent(in) :: LhsObj an object type( BitmapState ), intent(in) :: RhsObj another object Return Value logical true if keys of both objects are equal Source Code TYPE , EXTENDS ( DoublyLinkedNode ) :: BitmapState PRIVATE TYPE ( BitmapStatePack ) :: DirectTable TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () TYPE ( IntrusiveHashList ) :: TransitionMap ! use BitMapNode as node tSInt32 :: ID tLogical :: Writable = TrueVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapState_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapState_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitmapState_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapState_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapState_HashCode ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE :: Construct => BitmapState_Construct PROCEDURE :: Destruct => BitmapState_Destruct PROCEDURE :: TransitionRule => BitmapState_TransitionRule PROCEDURE :: DirectRule => BitmapState_DirectRule PROCEDURE :: GetTransitionMap => BitmapState_GetTransitionMap PROCEDURE :: GetDirectTable => BitmapState_GetDirectTable PROCEDURE :: GetID => BitmapState_GetID PROCEDURE :: Freeze => BitmapState_Freeze PROCEDURE :: EnsureWritable => BitmapState_EnsureWritable PROCEDURE :: IsEqual => BitmapState_IsEqual END TYPE BitmapState","tags":"","loc":"type\\bitmapstate.html"},{"title":"BitmapStateManager – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: BitmapStateManager The BitmapStateManager type is a node type... Type-Bound Procedures procedure, public :: Construct => BitmapStateManager_Construct private  subroutine BitmapStateManager_Construct(Manager, StateList) To construct the BitmapStateManager object. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(out) :: Manager type(IntrusiveLinearList), intent(inout) :: StateList procedure, public :: Destruct => BitmapStateManager_Destruct private  subroutine BitmapStateManager_Destruct(Manager) To destruct the BitmapStateManager object. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(inout) :: Manager procedure, public :: GetState => BitmapStateManager_GetState private  function BitmapStateManager_GetState(Manager, ID) result(State) To get a pointer to the specified state of the BitmapStateManager object\n according to the specified ID. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(in), TARGET :: Manager integer(kind=kInt32), intent(in) :: ID Return Value type( BitmapState ), POINTER procedure, public :: GetStates => BitmapStateManager_GetStates private  function BitmapStateManager_GetStates(Manager) result(States) To get a pointer to states of the BitmapStateManager object. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(in), TARGET :: Manager Return Value type( BitmapState ), POINTER, (:) procedure, public :: StateCount => BitmapStateManager_StateCount private  function BitmapStateManager_StateCount(Manager) result(Count) To get size of the states of the object. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(in) :: Manager Return Value integer(kind=kInt32) procedure, public :: NewEmptyPack => BitmapStateManager_NewEmptyPack private  subroutine BitmapStateManager_NewEmptyPack(Manager, Pack) To get size of the states of the object. Arguments Type Intent Optional Attributes Name class( BitmapStateManager ), intent(in) :: Manager type( BitmapStatePack ), intent(inout), POINTER :: Pack Source Code TYPE BitmapStateManager PRIVATE TYPE ( BitmapState ), ALLOCATABLE :: IStates (:) CONTAINS PROCEDURE :: Construct => BitmapStateManager_Construct PROCEDURE :: Destruct => BitmapStateManager_Destruct PROCEDURE :: GetState => BitmapStateManager_GetState PROCEDURE :: GetStates => BitmapStateManager_GetStates PROCEDURE :: StateCount => BitmapStateManager_StateCount PROCEDURE :: NewEmptyPack => BitmapStateManager_NewEmptyPack END TYPE BitmapStateManager","tags":"","loc":"type\\bitmapstatemanager.html"},{"title":"BitMapNode – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(HashListNode) :: BitMapNode The BitMapNode type is a node type... Components Type Visibility Attributes Name Initial character(kind=kChar, len=1), public :: Chr type( BitmapStatePack ), public, POINTER :: State => NULL() Type-Bound Procedures procedure, public :: Copy => BitmapNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine BitmapNode_Copy(SrcObj, DstObj, IsDeep) To copy the BitmapNode object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => BitmapNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function BitmapNode_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => BitMapNode_FreeMemory FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). private  subroutine BitMapNode_FreeMemory(Obj) To free storage/memory of an object with pointer and/or allocatable components. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(inout) :: Obj procedure, public :: ToString => BitmapNode_ToString ToString is a deferred procedure to get the string representation of this object. private  function BitmapNode_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: HashCode => BitMapNode_HashCode HashCode is a deferred procedure to compute hash code of this object. private  function BitMapNode_HashCode(Obj) result(Code) To compute hash code of the key component of the specified object. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(in) :: Obj object Return Value integer(kind=kInt32) hash code procedure, public :: IsKeyEqual => BitMapNode_IsKeyEqual private  function BitMapNode_IsKeyEqual(LhsObj, RhsObj) result(Flag) To check whether key components of the two specified objects are equal to one another or not. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(inout) :: LhsObj an object class(HashListNode), intent(inout) :: RhsObj another object Return Value logical true if keys of both objects are equal procedure, public :: Construct => BitMapNode_Construct private  subroutine BitMapNode_Construct(Node, Chr, Manager, State) To construct the BitMapNode object. Arguments Type Intent Optional Attributes Name class( BitMapNode ), intent(out) :: Node character(kind=kChar, len=1), intent(in) :: Chr type( BitmapStateManager ), intent(in) :: Manager type( BitmapStatePack ), intent(in), optional, TARGET :: State Source Code TYPE , EXTENDS ( HashListNode ) :: BitMapNode tChar :: Chr TYPE ( BitmapStatePack ), POINTER :: State => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapNode_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitMapNode_FreeMemory !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapNode_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapNode_HashCode ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => BitMapNode_IsKeyEqual !        PROCEDURE   :: MemFree      => BitMapNode_FreeMemory !        PROCEDURE   :: HashCode     => BitMapNode_HashCode PROCEDURE :: Construct => BitMapNode_Construct ! --------------------------------------------------------------------- END TYPE BitMapNode","tags":"","loc":"type\\bitmapnode.html"},{"title":"TernaryTrie – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TernaryTrie The TernaryTrie type is a container type that utilizes a ternary search\n tree implementation to provide common operations for a symbol table where\n its keys are character strings and its values can be of any type. Finalization Procedures final :: TernaryTrie_Finalizer To perform finalization of the symbol table. private  subroutine TernaryTrie_Finalizer(Table) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TernaryTrie ), intent(inout) :: Table symbol table Type-Bound Procedures generic, public :: Construct => TernaryTrie_ConstructByArray_ChrStr, TernaryTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(10, KeyArr, ValArr) private  subroutine TernaryTrie_ConstructByArray_ChrStr(Table, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table integer(kind=kInt32), intent(in) :: N number of keys character(kind=kChar, len=*), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values private  subroutine TernaryTrie_ConstructByArray_FvlStr(Table, N, Keys, Values) To construct a symbol table based on specified arrays. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table integer(kind=kInt32), intent(in) :: N number of keys type( FvlStr ), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values procedure, public :: Clear => TernaryTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() private  subroutine TernaryTrie_Clear(Table) To destruct a symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table generic, public :: Destruct => TernaryTrie_Destructor_ChrStr, TernaryTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine TernaryTrie_Destructor_ChrStr(Table, KeyQ, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ a queue of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values private  subroutine TernaryTrie_Destructor_FvlStr(Table, KeyArr, ValueQ) To destruct a symbol table and get its pair data. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: KeyArr (:) an array of stored keys type(QueueAny), intent(out), optional :: ValueQ a queue of stored values generic, public :: Insert => TernaryTrie_Insert_ChrStr, TernaryTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine TernaryTrie_Insert_ChrStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(in) :: Value value private  subroutine TernaryTrie_Insert_FvlStr(Table, Key, Value) To insert a key-value pair into the symbol table, overwriting the old value\n with the new value if the key is already in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(in) :: Value value generic, public :: Remove => TernaryTrie_Remove_ChrStr, TernaryTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) private  subroutine TernaryTrie_Remove_ChrStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value private  subroutine TernaryTrie_Remove_FvlStr(Table, Key, Value) To remove a key-value pair from the symbol table if the specified key is found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value generic, public :: Contain => TernaryTrie_Contain_ChrStr, TernaryTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function TernaryTrie_Contain_ChrStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key Return Value logical true if key found private  function TernaryTrie_Contain_FvlStr(Table, Key) result(Found) To check whether the symbol table contains the specified key or not. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key Return Value logical true if key found procedure, public :: GetSize => TernaryTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() private  function TernaryTrie_GetSize(Table) result(Size) To get size (number of keys stored) of the table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(in) :: Table symbol table Return Value integer(kind=kInt32) size of the table procedure, public :: IsEmpty => TernaryTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function TernaryTrie_IsEmpty(Table) result(Flag) To check whether the table is empty or not. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(in) :: Table symbol table Return Value logical true if the table is empty generic, public :: StartWith => TernaryTrie_StartWith_ChrStr, TernaryTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing private  function TernaryTrie_StartWith_ChrStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found private  function TernaryTrie_StartWith_FvlStr(Table, Prefix) result(Found) To return a flag indicating whether the symbol table contains a key\n starting with the specified prefix. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string Return Value logical true if a key starting with the prefix found generic, public :: GetValue => TernaryTrie_GetValue_ChrStr, TernaryTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) private  subroutine TernaryTrie_GetValue_ChrStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value private  subroutine TernaryTrie_GetValue_FvlStr(Table, Key, Value) To retrieve the value associated with the specified key.  Return\n an unallocated value if the key is not found in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Key key class(*), intent(out), ALLOCATABLE :: Value value generic, public :: GetAllKeys => TernaryTrie_AllKeys_ChrStr, TernaryTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine TernaryTrie_AllKeys_ChrStr(Table, KeyQ) To return a queue of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type(QueueString), intent(out) :: KeyQ queue of all keys private  subroutine TernaryTrie_AllKeys_FvlStr(Table, Keys) To return an array of all the keys in the symbol table. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysWithPrefix => TernaryTrie_KeysWithPrefix_CHCH, TernaryTrie_KeysWithPrefix_CHVL, TernaryTrie_KeysWithPrefix_VLCH, TernaryTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine TernaryTrie_KeysWithPrefix_CHCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine TernaryTrie_KeysWithPrefix_CHVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine TernaryTrie_KeysWithPrefix_VLCH(Table, Prefix, KeyQ) To return a queue of all the keys in the symbol table that start with the\n specified prefix.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type(QueueString), intent(out) :: KeyQ queue of keys starting with the specified prefix private  subroutine TernaryTrie_KeysWithPrefix_VLVL(Table, Prefix, Keys) To return an array of all the keys in the symbol table that start with the\n specified prefix.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Prefix prefix string type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetKeysThatMatch => TernaryTrie_KeysThatMatch_CHCH, TernaryTrie_KeysThatMatch_CHVL, TernaryTrie_KeysThatMatch_VLCH, TernaryTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. private  subroutine TernaryTrie_KeysThatMatch_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine TernaryTrie_KeysThatMatch_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine TernaryTrie_KeysThatMatch_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine TernaryTrie_KeysThatMatch_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetWildcardKeys => TernaryTrie_WildcardKeys_CHCH, TernaryTrie_WildcardKeys_CHVL, TernaryTrie_WildcardKeys_VLCH, TernaryTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. private  subroutine TernaryTrie_WildcardKeys_CHCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine TernaryTrie_WildcardKeys_CHVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys private  subroutine TernaryTrie_WildcardKeys_VLCH(Table, Pattern, KeyQ) To return a queue of all the keys in the symbol table that match the\n specified pattern.  Return an empty queue if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type(QueueString), intent(out) :: KeyQ queue of keys that match the specified pattern private  subroutine TernaryTrie_WildcardKeys_VLVL(Table, Pattern, Keys) To return an array of all the keys in the symbol table that match the\n specified pattern.  Return an unallocated array if no such key(s) found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Pattern a pattern type( FvlStr ), intent(out), ALLOCATABLE :: Keys (:) array of all keys generic, public :: GetLongestPrefixOf => TernaryTrie_LongestPrefixOf_ChrStr, TernaryTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix) private  subroutine TernaryTrie_LongestPrefixOf_ChrStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table character(kind=kChar, len=*), intent(in) :: Query a query character(kind=kChar, len=:), intent(out), ALLOCATABLE :: Prefix the longest prefix of the query private  subroutine TernaryTrie_LongestPrefixOf_FvlStr(Table, Query, Prefix) To return the string in the symbol table that is the longest prefix of the\n specified query.  Return an unallocated string if no such string found. Arguments Type Intent Optional Attributes Name class( TernaryTrie ), intent(inout) :: Table symbol table type( FvlStr ), intent(in) :: Query a query type( FvlStr ), intent(out) :: Prefix the longest prefix of the query Source Code TYPE TernaryTrie PRIVATE !% root of trie TYPE ( TrieNode ), POINTER :: Root => NULL () !% number of keys tIndex :: N CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => TernaryTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => TernaryTrie_Delete !% procedures with generic interfaces PROCEDURE , PRIVATE :: TernaryTrie_Insert_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Insert_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Remove_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Remove_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Contain_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Contain_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: TernaryTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(10, KeyArr, ValArr) GENERIC :: Construct => TernaryTrie_ConstructByArray_ChrStr , & TernaryTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => TernaryTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => TernaryTrie_Destructor_ChrStr , & TernaryTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => TernaryTrie_Insert_ChrStr , & TernaryTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => TernaryTrie_Remove_ChrStr , & TernaryTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => TernaryTrie_Contain_ChrStr , & TernaryTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => TernaryTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => TernaryTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => TernaryTrie_StartWith_ChrStr , & TernaryTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => TernaryTrie_GetValue_ChrStr , & TernaryTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => TernaryTrie_AllKeys_ChrStr , & TernaryTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => TernaryTrie_KeysWithPrefix_CHCH , & TernaryTrie_KeysWithPrefix_CHVL , & TernaryTrie_KeysWithPrefix_VLCH , & TernaryTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => TernaryTrie_KeysThatMatch_CHCH , & TernaryTrie_KeysThatMatch_CHVL , & TernaryTrie_KeysThatMatch_VLCH , & TernaryTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => TernaryTrie_WildcardKeys_CHCH , & TernaryTrie_WildcardKeys_CHVL , & TernaryTrie_WildcardKeys_VLCH , & TernaryTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => TernaryTrie_LongestPrefixOf_ChrStr , & TernaryTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: TernaryTrie_Finalizer ! --------------------------------------------------------------------- END TYPE TernaryTrie","tags":"","loc":"type\\ternarytrie.html"},{"title":"HashMapNode – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(HashListNode) :: HashMapNode Type-Bound Procedures procedure, public :: Copy => HashMapNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine HashMapNode_Copy(SrcObj, DstObj, IsDeep) To copy the HashMapNode object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => HashMapNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function HashMapNode_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: ToString => HashMapNode_ToString ToString is a deferred procedure to get the string representation of this object. private  function HashMapNode_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: IsKeyEqual => HashMapNode_IsKeyEqual private  function HashMapNode_IsKeyEqual(LhsObj, RhsObj) result(Flag) To check whether key components of the two specified objects are equal to one another or not. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(inout) :: LhsObj an object class(HashListNode), intent(inout) :: RhsObj another object Return Value logical true if keys of both objects are equal procedure, public :: MemFree => HashMapNode_FreeMemory private  subroutine HashMapNode_FreeMemory(Obj) To free storage/memory of an object with pointer and/or allocatable components. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(inout) :: Obj procedure, public :: HashCode => HashMapNode_HashCode private  function HashMapNode_HashCode(Obj) result(Code) To compute hash code of the key component of the specified object. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in) :: Obj object Return Value integer(kind=kInt32) hash code procedure, public :: Construct => HashMapNode_Construct private  subroutine HashMapNode_Construct(State, Chr) To construct the HashMapNode object. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(out) :: State character(kind=kChar, len=1), intent(in) :: Chr procedure, public :: GetSet => HashMapNode_GetSet private  function HashMapNode_GetSet(Node) result(Set) To compute hash code of the key component of the specified object. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in), TARGET :: Node Return Value type(IntrusiveHashList), POINTER procedure, public :: GetChar => HashMapNode_GetChar private  function HashMapNode_GetChar(Node) result(Chr) To compute hash code of the key component of the specified object. Arguments Type Intent Optional Attributes Name class( HashMapNode ), intent(in) :: Node Return Value character(kind=kChar, len=1) Source Code TYPE , EXTENDS ( HashListNode ) :: HashMapNode PRIVATE tChar :: Chr TYPE ( IntrusiveHashList ) :: Set ! use NFAState as node CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => HashMapNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashMapNode_IsEqualTo !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => HashMapNode_ToString ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => HashMapNode_IsKeyEqual PROCEDURE :: MemFree => HashMapNode_FreeMemory PROCEDURE :: HashCode => HashMapNode_HashCode ! specific PROCEDURE :: Construct => HashMapNode_Construct PROCEDURE :: GetSet => HashMapNode_GetSet PROCEDURE :: GetChar => HashMapNode_GetChar END TYPE HashMapNode","tags":"","loc":"type\\hashmapnode.html"},{"title":"NFAState – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(HashListNode) :: NFAState The NFAState type is a node type... Type-Bound Procedures procedure, public :: Copy => NFAState_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. private  subroutine NFAState_Copy(SrcObj, DstObj, IsDeep) To copy the NFAState object.  This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => NFAState_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function NFAState_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: ToString => NFAState_ToString ToString is a deferred procedure to get the string representation of this object. private  function NFAState_ToString(Obj) result(Str) To get the string representation of this object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE string representation of the object procedure, public :: IsKeyEqual => NFAState_IsKeyEqual private  function NFAState_IsKeyEqual(LhsObj, RhsObj) result(Flag) To check whether key components of the two specified objects are equal to one another or not. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(inout) :: LhsObj an object class(HashListNode), intent(inout) :: RhsObj another object Return Value logical true if keys of both objects are equal procedure, public :: MemFree => NFAState_FreeMemory private  subroutine NFAState_FreeMemory(Obj) To free storage/memory of an object with pointer and/or allocatable components. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(inout) :: Obj procedure, public :: HashCode => NFAState_HashCode private  function NFAState_HashCode(Obj) result(Code) To compute hash code of the key component of the specified object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in) :: Obj object Return Value integer(kind=kInt32) hash code procedure, public :: Construct => NFAState_Construct private  subroutine NFAState_Construct(State, ID) To construct the NFAState object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(out) :: State integer(kind=kInt32), intent(in) :: ID procedure, public :: TransitionRule => NFAState_TransitionRule private  subroutine NFAState_TransitionRule(CurrState, Chr, State) To perform transition rule. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(inout) :: CurrState character(kind=kChar, len=1), intent(in) :: Chr type( NFAState ), intent(inout), POINTER :: State procedure, public :: DirectRule => NFAState_DirectRule private  subroutine NFAState_DirectRule(CurrState, State) To perform direct rule. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(inout) :: CurrState type( NFAState ), intent(inout), POINTER :: State procedure, public :: GetTransitionMap => NFAState_GetTransitionMap private  function NFAState_GetTransitionMap(State) result(TransMap) To get the transition map of the object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in), TARGET :: State object Return Value type(IntrusiveHashList), POINTER procedure, public :: GetDirectTable => NFAState_GetDirectTable private  function NFAState_GetDirectTable(State) result(Table) To get the direct table of the object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in), TARGET :: State object Return Value type(IntrusiveHashList), POINTER procedure, public :: GetID => NFAState_GetID private  function NFAState_GetID(State) result(ID) To get ID of the object. Arguments Type Intent Optional Attributes Name class( NFAState ), intent(in) :: State object Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( HashListNode ) :: NFAState PRIVATE TYPE ( IntrusiveHashList ) :: DirectTable ! use NFAState as node TYPE ( IntrusiveHashList ) :: TransitionMap ! use HashMapNode as node tSInt32 :: ID CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => NFAState_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => NFAState_IsEqualTo !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => NFAState_ToString ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => NFAState_IsKeyEqual PROCEDURE :: MemFree => NFAState_FreeMemory PROCEDURE :: HashCode => NFAState_HashCode ! specific PROCEDURE :: Construct => NFAState_Construct PROCEDURE :: TransitionRule => NFAState_TransitionRule PROCEDURE :: DirectRule => NFAState_DirectRule PROCEDURE :: GetTransitionMap => NFAState_GetTransitionMap PROCEDURE :: GetDirectTable => NFAState_GetDirectTable PROCEDURE :: GetID => NFAState_GetID END TYPE NFAState","tags":"","loc":"type\\nfastate.html"},{"title":"SyntaxTree – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: SyntaxTree The SyntaxTree type is a tree type... Type-Bound Procedures procedure, public :: Construct => SyntaxTree_Construct private  subroutine SyntaxTree_Construct(Tree, Regex) To construct the syntax tree based on the specified regular expression pattern. Arguments Type Intent Optional Attributes Name class( SyntaxTree ), intent(out) :: Tree character(kind=kChar, len=*), intent(in) :: Regex procedure, public :: Destruct => SyntaxTree_Destruct private  subroutine SyntaxTree_Destruct(Tree) To destruct the syntax tree. Arguments Type Intent Optional Attributes Name class( SyntaxTree ), intent(inout) :: Tree procedure, public :: GetRoot => SyntaxTree_GetRoot private  function SyntaxTree_GetRoot(Tree) result(Root) To get the root node of the syntax tree. Arguments Type Intent Optional Attributes Name class( SyntaxTree ), intent(in) :: Tree Return Value type( SyntaxNode ), POINTER Source Code TYPE :: SyntaxTree PRIVATE tCharAlloc :: Regex tLogical :: ItemTerminated = . FALSE . TYPE ( IntrusiveLinearList ) :: List TYPE ( IntrusiveLinearList ) :: Stack TYPE ( SyntaxNode ), POINTER :: Root => NULL () CONTAINS PRIVATE PROCEDURE , PUBLIC :: Construct => SyntaxTree_Construct PROCEDURE , PUBLIC :: Destruct => SyntaxTree_Destruct PROCEDURE , PUBLIC :: GetRoot => SyntaxTree_GetRoot PROCEDURE :: Build => SyntaxTree_Build PROCEDURE :: Shunt => SyntaxTree_Shunt PROCEDURE :: Normalize => SyntaxTree_Normalize PROCEDURE :: PerformMany => SyntaxTree_PerformMany PROCEDURE :: TryConcatenation => SyntaxTree_TryConcatenation END TYPE SyntaxTree","tags":"","loc":"type\\syntaxtree.html"},{"title":"REProgram – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: REProgram The REProgram type is a derive type that holds compiled regular expressions. Type-Bound Procedures procedure, public :: Construct => REProgram_Construct private  subroutine REProgram_Construct(PG, Instruction, Parens) To construct a regular expression program from the specified instruction. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(inout) :: PG 'REProgram' object character(kind=kChar, len=1), intent(in) :: Instruction (0:) RE opcode instructions integer(kind=kInt32), intent(in), optional :: Parens Count of parens in the program procedure, public :: Destruct => REProgram_Destruct private  subroutine REProgram_Destruct(PG) To destruct the 'REProgram' object. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(inout) :: PG 'REProgram' object procedure, public :: GetInstructions => REProgram_GetInstructions private  function REProgram_GetInstructions(PG) result(Instruction) To get a pointer to the program instructions.  Return null\n if the program has not yet been compiled. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(in), TARGET :: PG 'REProgram' object Return Value character(kind=kChar, len=1), POINTER, (:) Program instructions procedure, public :: GetPrefix => REProgram_GetPrefix private  function REProgram_GetPrefix(PG) result(Prefix) To get a pointer to the program prefix.  Return null\n if the program has not yet been compiled. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(in), TARGET :: PG 'REProgram' object Return Value character(kind=kChar, len=1), POINTER, (:) Program prefix procedure, public :: GetMaxParen => REProgram_GetMaxParen private  function REProgram_GetMaxParen(PG) result(MaxParen) To get maximum parentheses. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(in) :: PG 'REProgram' object Return Value integer(kind=kInt32) maximum parentheses procedure, public :: GetFlag => REProgram_GetFlag private  function REProgram_GetFlag(PG) result(Flag) To get flag. Arguments Type Intent Optional Attributes Name class( REProgram ), intent(in) :: PG 'REProgram' object Return Value integer(kind=kInt32) flag Source Code TYPE REProgram PRIVATE !% The compiled regular expression 'program' tChar , ALLOCATABLE :: Instruction (:) !% the prefix string optimization tChar , ALLOCATABLE :: Prefix (:) !% optimization flags tSInt32 :: Flags !% maximum parentheses tSInt32 :: MaxParen = - 1 CONTAINS PROCEDURE , PRIVATE :: SetInstructions => REProgram_SetInstructions PROCEDURE :: Construct => REProgram_Construct PROCEDURE :: Destruct => REProgram_Destruct PROCEDURE :: GetInstructions => REProgram_GetInstructions PROCEDURE :: GetPrefix => REProgram_GetPrefix PROCEDURE :: GetMaxParen => REProgram_GetMaxParen PROCEDURE :: GetFlag => REProgram_GetFlag END TYPE REProgram","tags":"","loc":"type\\reprogram.html"},{"title":"StringBuilder – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(Comparable) :: StringBuilder The StringBuilder type is string type that provides a convenient way\n to build a string from multiple strings. Finalization Procedures final :: StringBuilder_Finalize To perform finalization of the StringBuilder object. private  subroutine StringBuilder_Finalize(StrBld) To perform finalization of a 'StringBuilder' object. Arguments Type Intent Optional Attributes Name type( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object Type-Bound Procedures procedure, public :: CreateEmpty => StringBuilder_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty string builder. Usage : ! use default initial capacity --->    CALL StrBld%CreateEmpty() ! specify initial capacity --->    CALL StrBld%CreateEmpty(InitCap=256) private  subroutine StringBuilder_CreateEmpty(StrBld, InitCap) To create an empty 'StringBuilder' object with optionally specified initial capacity. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity procedure, public :: Construct => StringBuilder_Construct Type-Bound Subroutine : Construct Purpose :  To construct a string builder with the specified value.  This method\n      provides a convenient way to create an empty string builder and then add the\n      first value into the builder. Usage : --->    CALL StrBld%Construct(Value) private  subroutine StringBuilder_Construct(StrBld, Value) To construct a string builder with the specified value.  This routine\n provides a convenient way to create an empty string builder and then\n add the first value into the builder. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object class(*), intent(in) :: Value value of any valid type procedure, public :: Clear => StringBuilder_Clear Type-Bound Subroutine : Clear Purpose :  To clear the buffer string of the string builder. Usage : --->    CALL StrBld%Clear() private  subroutine StringBuilder_Clear(StrBld) To clear the buffer string of a 'StringBuilder' object. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object generic, public :: Append => StringBuilder_Append, StringBuilder_AppendWPrefix Type-Bound Subroutine : Append Purpose :  To append the specified value at the end of the builder where the type\n      of value can be one of Fortran intrinsic types or the FvlStr type.  Optionally,\n      a prefix and/or a suffix can be specified.  Also, optionally, if the type of value\n      is a user-defined one, a ToString procedure must be specified. Usage : ! specify only the value --->    CALL StrBld%Append(Val) ! specify only the value and its ToString procedure --->    CALL StrBld%Append(Val, ToString) ! specify the value and its prefix --->    CALL StrBld%Append('The computed value is', Val) ! specify the value and its prefix and suffix --->    CALL StrBld%Append('The speed of light in vacuum =', 299792458, 'm/s.') private  subroutine StringBuilder_Append(StrBld, Value, ToString) To append the Value argument at the end of the stored characters (i.e. at Count+1).\n The Value argument is automatically converted to a string if its type is valid.\n Otherwise, an error is reported to a default log file. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object class(*), intent(in) :: Value value of any valid type procedure(Anytype2String), optional :: ToString procedure to convert value to string private  subroutine StringBuilder_AppendWPrefix(StrBld, Prefix, Value, Suffix, NoPreSpace, NoPostSpace, ToString) To append the Value argument with a prefix text.  Optionally, a suffix text can be\n specified.  This routine provides a convenient way to insert a value with a prefix\n (and a suffix). Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object character(kind=kChar, len=*), intent(in) :: Prefix prefix text class(*), intent(in) :: Value value of any valid type character(kind=kChar, len=*), intent(in), optional :: Suffix suffix text logical, intent(in), optional :: NoPreSpace true if there is no space between the prefix text and the value; default is false. logical, intent(in), optional :: NoPostSpace true if there is no space between the prefix text and the value; default is false. procedure(Anytype2String), optional :: ToString procedure to convert value to string procedure, public :: Insert => StringBuilder_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified value at the specified position where the type of\n      value can be one of Fortran intrinsic types or the FvlStr type.  Optionally, if the\n      type of value is a user-defined one, a ToString procedure must be specified. Usage : --->    CALL StrBld%Insert(Val, Pos) --->    CALL StrBld%Insert(Val, Pos, ToString) private  subroutine StringBuilder_Insert(StrBld, Value, StartID, ToString) To insert the Value argument at the specified position.  The position must be greater\n than 0 and less than or equal to Count .  Otherwise, this is the same as appending the\n value.  The Value argument is automatically converted to a string if its type is valid.\n Otherwise, an error is reported to a default log file. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object class(*), intent(in) :: Value value of any valid type integer(kind=kInt32), intent(in) :: StartID position to add the value; must be less than Count procedure(Anytype2String), optional :: ToString procedure to convert value to string procedure, public :: DelLastChar => StringBuilder_DeleteLastChar Type-Bound Subroutine : DelLastChar Purpose :  To remove the last character from the builder's string. Usage : --->    CALL StrBld%DelLastChar() private  subroutine StringBuilder_DeleteLastChar(StrBld) To delete the last character of the string being built. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object procedure, public :: ToCharAlloc => StringBuilder_ToCharAlloc Type-Bound Function : ToCharAlloc Purpose :  To return characters currently stored in the string builder as an\n      allocatable character string.  Optionally, a user can request to clear the\n      builder' buffer string. Usage : --->    cStr = StrBld%ToCharAlloc() --->    cStr = StrBld%ToCharAlloc(ClearBuffer=.TRUE.) private  function StringBuilder_ToCharAlloc(StrBld, ClearBuffer) result(cStr) To return characters currently stored in the string builder as\n an allocatable character string. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object logical, intent(in), optional :: ClearBuffer true if requesting to clear the builder's buffer after getting the string;\n default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE string procedure, public :: ToFvlStr => StringBuilder_ToFvlStr Type-Bound Function : ToFvlStr Purpose :  To return characters currently stored in the string builder as a\n      string of the FvlStr type.  Optionally, a user can request to clear the\n      builder' buffer string. Usage : --->    vStr = StrBld%ToFvlStr() --->    vStr = StrBld%ToFvlStr(ClearBuffer=.TRUE.) private  function StringBuilder_ToFvlStr(StrBld, ClearBuffer) result(vStr) To return characters currently stored in the string builder as\n a string of the FvlStr type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object logical, intent(in), optional :: ClearBuffer true if requesting to clear the builder's buffer after getting the string;\n default is false. Return Value type( FvlStr ) string procedure, public :: ToCharStar => StringBuilder_ToCharStar Type-Bound Subroutine : ToCharStar Purpose :  To return characters currently stored in the string builder as\n      a character string of assumed length.  Optionally, a user can request\n      to clear the builder' buffer string. Usage : --->    CALL StrBld%ToCharStar(cStr) --->    CALL StrBld%ToCharStar(cStr, ClearBuffer=.TRUE.) Note : In order to retrieve all the characters currently stored in the builder,\n      the length of the specified string must be at least equal to the current length\n      of the string being built, which can be inquired using the Length method. private  subroutine StringBuilder_ToCharStar(StrBld, cStr, ClearBuffer) To return characters currently stored in the string builder as\n a character string of assumed length. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object character(kind=kChar, len=*), intent(out) :: cStr character string logical, intent(in), optional :: ClearBuffer true if requesting to clear the builder's buffer after getting the string;\n default is false. procedure, public :: Length => StringBuilder_GetLength Type-Bound Function : Length Purpose :  To return the current length of the string being built. Usage : --->    Length = StrBld%Length() private  function StringBuilder_GetLength(StrBld) result(Length) To return the current length of the string being built (i.e. the number\n of characters currently stored in the builder). Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: StrBld 'StringBuilder' object Return Value integer(kind=kInt32) length of the string procedure, public :: Copy => StringBuilder_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine StringBuilder_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => StringBuilder_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function StringBuilder_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => StringBuilder_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine StringBuilder_MemFree(Obj) To free memory of the StringBuilder object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(inout) :: Obj procedure, public :: ToString => StringBuilder_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function StringBuilder_ToString(Obj) result(Str) To get the string representation of the StringBuilder type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => StringBuilder_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function StringBuilder_HashCode(Obj) result(Code) To get compute hash code for the given key.\n This is a deferred procedure inherited from the Hashable type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: CompareTo => StringBuilder_CompareTo Use a common logical expression to compare two Comparable objects. private  function StringBuilder_CompareTo(A, B) result(Flag) To compare a StringBuilder object with a Comparable object.\n This is a deferred procedure inherited from the Comparable type. Arguments Type Intent Optional Attributes Name class( StringBuilder ), intent(in) :: A StringBuilder object class(Comparable), intent(in) :: B Comparable object Return Value integer(kind=kInt32) output flag with value of -1 if A < B, 0 if A == B, or +1 if A > B. Source Code TYPE , EXTENDS ( Comparable ) :: StringBuilder PRIVATE tIndex :: Count = 0_kIndex !! the number of characters currently stored tIndex :: Capacity = 0_kIndex !! the maximum number of characters that currently can be stored tCharAlloc :: StrBuf !! string buffer CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: EnsureCapacity => StringBuilder_EnsureCapacity PROCEDURE , PRIVATE :: StringBuilder_Append PROCEDURE , PRIVATE :: StringBuilder_AppendWPrefix ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty string builder. <br> !  **Usage**: <br> !   ! use default initial capacity  <br> !   --->    CALL StrBld%CreateEmpty() <br> !   ! specify initial capacity <br> !   --->    CALL StrBld%CreateEmpty(InitCap=256) <br> PROCEDURE :: CreateEmpty => StringBuilder_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a string builder with the specified value.  This method !       provides a convenient way to create an empty string builder and then add the !       first value into the builder. <br> !  **Usage**: <br> !   --->    CALL StrBld%Construct(Value) <br> PROCEDURE :: Construct => StringBuilder_Construct !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To clear the buffer string of the string builder. <br> !  **Usage**: <br> !   --->    CALL StrBld%Clear() <br> PROCEDURE :: Clear => StringBuilder_Clear !> **Type-Bound Subroutine**: Append <br> !  **Purpose**:  To append the specified value at the end of the builder where the type !       of value can be one of Fortran intrinsic types or the *FvlStr* type.  Optionally, !       a prefix and/or a suffix can be specified.  Also, optionally, if the type of value !       is a user-defined one, a *ToString* procedure must be specified. <br> !  **Usage**: <br> !   ! specify only the value <br> !   --->    CALL StrBld%Append(Val) <br> !   ! specify only the value and its ToString procedure<br> !   --->    CALL StrBld%Append(Val, ToString) <br> !   ! specify the value and its prefix <br> !   --->    CALL StrBld%Append('The computed value is', Val) <br> !   ! specify the value and its prefix and suffix <br> !   --->    CALL StrBld%Append('The speed of light in vacuum =', 299792458, 'm/s.') <br> GENERIC :: Append => StringBuilder_Append , StringBuilder_AppendWPrefix !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified value at the specified position where the type of !       value can be one of Fortran intrinsic types or the *FvlStr* type.  Optionally, if the !       type of value is a user-defined one, a *ToString* procedure must be specified. <br> !  **Usage**: <br> !   --->    CALL StrBld%Insert(Val, Pos) <br> !   --->    CALL StrBld%Insert(Val, Pos, ToString) <br> PROCEDURE :: Insert => StringBuilder_Insert !> **Type-Bound Subroutine**: DelLastChar <br> !  **Purpose**:  To remove the last character from the builder's string. <br> !  **Usage**: <br> !   --->    CALL StrBld%DelLastChar() <br> PROCEDURE :: DelLastChar => StringBuilder_DeleteLastChar !> **Type-Bound Function**: ToCharAlloc <br> !  **Purpose**:  To return characters currently stored in the string builder as an !       allocatable character string.  Optionally, a user can request to clear the !       builder' buffer string. <br> !  **Usage**: <br> !   --->    cStr = StrBld%ToCharAlloc() <br> !   --->    cStr = StrBld%ToCharAlloc(ClearBuffer=.TRUE.) <br> PROCEDURE :: ToCharAlloc => StringBuilder_ToCharAlloc !> **Type-Bound Function**: ToFvlStr <br> !  **Purpose**:  To return characters currently stored in the string builder as a !       string of the *FvlStr* type.  Optionally, a user can request to clear the !       builder' buffer string. <br> !  **Usage**: <br> !   --->    vStr = StrBld%ToFvlStr() <br> !   --->    vStr = StrBld%ToFvlStr(ClearBuffer=.TRUE.) <br> PROCEDURE :: ToFvlStr => StringBuilder_ToFvlStr !> **Type-Bound Subroutine**: ToCharStar <br> !  **Purpose**:  To return characters currently stored in the string builder as !       a character string of assumed length.  Optionally, a user can request !       to clear the builder' buffer string. <br> !  **Usage**: <br> !   --->    CALL StrBld%ToCharStar(cStr) <br> !   --->    CALL StrBld%ToCharStar(cStr, ClearBuffer=.TRUE.) <br> !  **Note**: In order to retrieve all the characters currently stored in the builder, !       the length of the specified string must be at least equal to the current length !       of the string being built, which can be inquired using the *Length* method.<br> PROCEDURE :: ToCharStar => StringBuilder_ToCharStar !> **Type-Bound Function**: Length <br> !  **Purpose**:  To return the current length of the string being built. <br> !  **Usage**: <br> !   --->    Length = StrBld%Length() <br> PROCEDURE :: Length => StringBuilder_GetLength ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => StringBuilder_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => StringBuilder_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => StringBuilder_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StringBuilder_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => StringBuilder_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Comparable Type          ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => StringBuilder_CompareTo ! --------------------------------------------------------------------- ! -----                 Final Procedure                           ----- ! --------------------------------------------------------------------- !% To perform finalization of the *StringBuilder* object. FINAL :: StringBuilder_Finalize ! --------------------------------------------------------------------- END TYPE StringBuilder","tags":"","loc":"type\\stringbuilder.html"},{"title":"RealSP_ToString_DragonBox – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_ToString_DragonBox(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a single-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm.","tags":"","loc":"interface\\realsp_tostring_dragonbox.html"},{"title":"RealSP_ToString_Ryu – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_ToString_Ryu(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a single-precision floating-point value to a character\n (decimal) string using the Ryu algorithm.","tags":"","loc":"interface\\realsp_tostring_ryu.html"},{"title":"RealSP_ToString_Schubfach – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_ToString_Schubfach(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a single-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm.","tags":"","loc":"interface\\realsp_tostring_schubfach.html"},{"title":"RealSP_FromString_FastFloat – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number Description To convert a character (decimal) string to a single-precision\n floating-point value using the FastFloat algorithm.","tags":"","loc":"interface\\realsp_fromstring_fastfloat.html"},{"title":"RealSP_FromString_LibC – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number Description To convert a character (decimal) string to a single-precision\n floating-point value using the LibC algorithm.","tags":"","loc":"interface\\realsp_fromstring_libc.html"},{"title":"RealSP_FromString_YY – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number Description To convert a character (decimal) string to a single-precision\n floating-point value using the YY algorithm.","tags":"","loc":"interface\\realsp_fromstring_yy.html"},{"title":"RealSP_FromString_Lemire – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealSP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number Description To convert a character (decimal) string to a single-precision\n floating-point value using the Lemire algorithm.","tags":"","loc":"interface\\realsp_fromstring_lemire.html"},{"title":"RealDP_ToString_DragonBox – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_ToString_DragonBox(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a double-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm.","tags":"","loc":"interface\\realdp_tostring_dragonbox.html"},{"title":"RealDP_ToString_Ryu – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_ToString_Ryu(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a double-precision floating-point value to a character\n (decimal) string using the Ryu algorithm.","tags":"","loc":"interface\\realdp_tostring_ryu.html"},{"title":"RealDP_ToString_Schubfach – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_ToString_Schubfach(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a double-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm.","tags":"","loc":"interface\\realdp_tostring_schubfach.html"},{"title":"RealDP_FromString_FastFloat – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number Description To convert a character (decimal) string to a double-precision\n floating-point value using the FastFloat algorithm.","tags":"","loc":"interface\\realdp_fromstring_fastfloat.html"},{"title":"RealDP_FromString_LibC – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number Description To convert a character (decimal) string to a double-precision\n floating-point value using the LibC algorithm.","tags":"","loc":"interface\\realdp_fromstring_libc.html"},{"title":"RealDP_FromString_YY – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number Description To convert a character (decimal) string to a double-precision\n floating-point value using the YY algorithm.","tags":"","loc":"interface\\realdp_fromstring_yy.html"},{"title":"RealDP_FromString_Lemire – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealDP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number Description To convert a character (decimal) string to a double-precision\n floating-point value using the Lemire algorithm.","tags":"","loc":"interface\\realdp_fromstring_lemire.html"},{"title":"RealQP_ToString_DragonBox – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_ToString_DragonBox(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a quadruple-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm.","tags":"","loc":"interface\\realqp_tostring_dragonbox.html"},{"title":"RealQP_ToString_Ryu – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_ToString_Ryu(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a quadruple-precision floating-point value to a character\n (decimal) string using the Ryu algorithm.","tags":"","loc":"interface\\realqp_tostring_ryu.html"},{"title":"RealQP_ToString_Schubfach – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_ToString_Schubfach(Number, IsScientific) result(cStr) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a quadruple-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm.","tags":"","loc":"interface\\realqp_tostring_schubfach.html"},{"title":"RealQP_FromString_FastFloat – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number Description To convert a character (decimal) string to a quadruple-precision\n floating-point value using the FastFloat algorithm.","tags":"","loc":"interface\\realqp_fromstring_fastfloat.html"},{"title":"RealQP_FromString_LibC – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number Description To convert a character (decimal) string to a quadruple-precision\n floating-point value using the LibC algorithm.","tags":"","loc":"interface\\realqp_fromstring_libc.html"},{"title":"RealQP_FromString_YY – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number Description To convert a character (decimal) string to a quadruple-precision\n floating-point value using the YY algorithm.","tags":"","loc":"interface\\realqp_fromstring_yy.html"},{"title":"RealQP_FromString_Lemire – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function RealQP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number Description To convert a character (decimal) string to a quadruple-precision\n floating-point value using the Lemire algorithm.","tags":"","loc":"interface\\realqp_fromstring_lemire.html"},{"title":"I32_ToChar_Basic – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_ToChar_Basic(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 32-bit integer number to a character (decimal)\n string using the basic algorithm.","tags":"","loc":"interface\\i32_tochar_basic.html"},{"title":"I32_ToChar_CC – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_ToChar_CC(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 32-bit integer number to a character (decimal)\n string using the CC algorithm.","tags":"","loc":"interface\\i32_tochar_cc.html"},{"title":"I32_ToChar_YY – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_ToChar_YY(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 32-bit integer number to a character (decimal)\n string using the YY algorithm.","tags":"","loc":"interface\\i32_tochar_yy.html"},{"title":"I32_ToChar_YYLL – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_ToChar_YYLL(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 32-bit integer number to a character (decimal)\n string using the YY algorithm with large tables.","tags":"","loc":"interface\\i32_tochar_yyll.html"},{"title":"I32_ToChar_JEA – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_ToChar_JEA(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 32-bit integer number to a character (decimal)\n string using the JEA algorithm.","tags":"","loc":"interface\\i32_tochar_jea.html"},{"title":"I64_ToChar_Basic – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_ToChar_Basic(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 64-bit integer number to a character (decimal)\n string using the basic algorithm.","tags":"","loc":"interface\\i64_tochar_basic.html"},{"title":"I64_ToChar_CC – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_ToChar_CC(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 64-bit integer number to a character (decimal)\n string using the CC algorithm.","tags":"","loc":"interface\\i64_tochar_cc.html"},{"title":"I64_ToChar_YY – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_ToChar_YY(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 64-bit integer number to a character (decimal)\n string using the YY algorithm.","tags":"","loc":"interface\\i64_tochar_yy.html"},{"title":"I64_ToChar_YYLL – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_ToChar_YYLL(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 64-bit integer number to a character (decimal)\n string using the YY algorithm with large tables.","tags":"","loc":"interface\\i64_tochar_yyll.html"},{"title":"I64_ToChar_JEA – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_ToChar_JEA(Number) result(cStr) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar,len=:),ALLOCATABLE character string Description To convert a 64-bit integer number to a character (decimal)\n string using the JEA algorithm.","tags":"","loc":"interface\\i64_tochar_jea.html"},{"title":"I32_FromChar_CC_FortNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number Description To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a Fortran number.","tags":"","loc":"interface\\i32_fromchar_cc_fortnum.html"},{"title":"I32_FromChar_CC_FortPlus – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number Description To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a FPlus number.","tags":"","loc":"interface\\i32_fromchar_cc_fortplus.html"},{"title":"I32_FromChar_CC_JsonNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number Description To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a JSON number.","tags":"","loc":"interface\\i32_fromchar_cc_jsonnum.html"},{"title":"I32_FromChar_Lemire_FortPlus – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number Description To convert a decimal string to a 32-bit integer value using the\n Lemire algorithm where the string is interpreted as a FPlus number.","tags":"","loc":"interface\\i32_fromchar_lemire_fortplus.html"},{"title":"I32_FromChar_YY_JsonNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I32_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number Description To convert a decimal string to a 32-bit integer value using the\n YY algorithm where the string is interpreted as a JSON number.","tags":"","loc":"interface\\i32_fromchar_yy_jsonnum.html"},{"title":"I64_FromChar_CC_FortNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number Description To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a Fortran number.","tags":"","loc":"interface\\i64_fromchar_cc_fortnum.html"},{"title":"I64_FromChar_CC_FortPlus – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number Description To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a FPlus number.","tags":"","loc":"interface\\i64_fromchar_cc_fortplus.html"},{"title":"I64_FromChar_CC_JsonNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number Description To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a JSON number.","tags":"","loc":"interface\\i64_fromchar_cc_jsonnum.html"},{"title":"I64_FromChar_Lemire_FortPlus – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number Description To convert a decimal string to a 64-bit integer value using the\n Lemire algorithm where the string is interpreted as a FPlus number.","tags":"","loc":"interface\\i64_fromchar_lemire_fortplus.html"},{"title":"I64_FromChar_YY_JsonNum – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function I64_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number Description To convert a decimal string to a 64-bit integer value using the\n YY algorithm where the string is interpreted as a JSON number.","tags":"","loc":"interface\\i64_fromchar_yy_jsonnum.html"},{"title":"SyntaxNode_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine SyntaxNode_New(Node, NodeType) To allocate the node and specify its type. Arguments Type Intent Optional Attributes Name type( SyntaxNode ), intent(inout), POINTER :: Node integer(kind=kInt32), intent(in) :: NodeType Source Code SUBROUTINE SyntaxNode_New ( Node , NodeType ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its type. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SyntaxNode ), POINTER , INTENT ( INOUT ) :: Node tSInt32 , INTENT ( IN ) :: NodeType !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL SyntaxNode_Allocate ( Node ) ! check allocation status and report error if necessary Node % Type = NodeType Node % C = NULCHR SELECT CASE ( NodeType ) CASE ( BranchNode_Or ) Node % ID = 0 CASE ( BranchNode_Many ) Node % ID = 2 CASE ( BranchNode_Concat ) Node % ID = 1 CASE ( BranchNode_LBracket ) Node % ID = - 1 CASE ( BranchNode_RBracket ) Node % ID = 3 CASE DEFAULT Node % ID = - 2 END SELECT RETURN END SUBROUTINE SyntaxNode_New","tags":"","loc":"proc\\syntaxnode_new.html"},{"title":"SyntaxNode_Free – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine SyntaxNode_Free() To free all the nodes linked to the specified node. Arguments None Source Code SUBROUTINE SyntaxNode_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxNode ), POINTER :: Left , Right tIndex :: I ! FLOW IF ( ALLOCATED ( STNMemManger % Node )) THEN DO I = 1_kIndex , SIZE ( STNMemManger % Node , KIND = kIndex ) Left => STNMemManger % Node ( I )% GetLeft () IF ( ASSOCIATED ( Left )) NULLIFY ( Left ) Right => STNMemManger % Node ( I )% GetRight () IF ( ASSOCIATED ( Left )) NULLIFY ( Right ) END DO DEALLOCATE ( STNMemManger % Node ) END IF STNMemManger % ID = 0_kIndex RETURN END SUBROUTINE SyntaxNode_Free","tags":"","loc":"proc\\syntaxnode_free.html"},{"title":"ASSIGNMENT(=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a FvlStr object and an other (Fortran\n      intrinsic) type via an assignment expression. Usage : ! convert a 64-bit integer number to a FvlStr object --->    vStr = I64Num ! convert a FvlStr object to a quadruple-precision real number --->    RQPNum = vStr Important Note : The assignment and conversion operations are\n      functionally similar but have some subtle differences.  In particular\n      for those procedures that convert from a decimal string to a number,\n      the assignment procedures will silently convert to a proper value\n      (representation) if the input string is INVALID whereas the conversion procedures can optionally report the error occurred. Subroutines private module subroutine FvlStr_From_CharacterString(vStr, cStr) To assign a FvlStr object from a character string. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr character(kind=kChar, len=*), intent(in) :: cStr private module subroutine FvlStr_From_CharacterArray(vStr, cArr) To assign a FvlStr object from an array of characters. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr character(kind=kChar, len=1), intent(in) :: cArr (:) private module subroutine FvlStr_From_IByte(vStr, IntNum) To assign a FvlStr object from an 8-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt8), intent(in) :: IntNum private module subroutine FvlStr_From_IShort(vStr, IntNum) To assign a FvlStr object from a 16-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt16), intent(in) :: IntNum private module subroutine FvlStr_From_Integer(vStr, IntNum) To assign a FvlStr object from a 32-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt32), intent(in) :: IntNum private module subroutine FvlStr_From_ILong(vStr, IntNum) To assign a FvlStr object from a 64-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt64), intent(in) :: IntNum private module subroutine FvlStr_From_RSingle(vStr, RealNum) To assign a FvlStr object from a 32-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kSingle), intent(in) :: RealNum private module subroutine FvlStr_From_RDouble(vStr, RealNum) To assign a FvlStr object from a 64-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kDouble), intent(in) :: RealNum private module subroutine FvlStr_From_RQuad(vStr, RealNum) To assign a FvlStr object from a 128-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kQuad), intent(in) :: RealNum private module subroutine FvlStr_From_CSingle(vStr, CmpxNum) To assign a FvlStr object from a single-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kSingle), intent(in) :: CmpxNum private module subroutine FvlStr_From_CDouble(vStr, CmpxNum) To assign a FvlStr object from a double-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kDouble), intent(in) :: CmpxNum private module subroutine FvlStr_From_CQuad(vStr, CmpxNum) To assign a FvlStr object from a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kQuad), intent(in) :: CmpxNum private module subroutine FvlStr_From_Logical(vStr, Boolean) To assign a FvlStr object from a default logical value. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr logical, intent(in) :: Boolean private module subroutine FvlStr_To_CharAlloc(cStr, vStr) To convert a FvlStr object to an allocatable character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CharArray_Alloc(cArr, vStr) To convert a FvlStr object to an allocatable array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(out), ALLOCATABLE :: cArr (:) type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_IByte(IntNum, vStr) To convert a FvlStr object to an 8-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_IShort(IntNum, vStr) To convert a FvlStr object to a 16-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_Integer(IntNum, vStr) To convert a FvlStr object to a 32-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_ILong(IntNum, vStr) To convert a FvlStr object to a 64-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RSingle(RealNum, vStr) To convert a FvlStr object to a 32-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RDouble(RealNum, vStr) To convert a FvlStr object to a 64-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RQuad(RealNum, vStr) To convert a FvlStr object to a 128-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CSingle(CmpxNum, vStr) To convert a FvlStr object to a single-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CDouble(CmpxNum, vStr) To convert a FvlStr object to a double-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CQuad(CmpxNum, vStr) To convert a FvlStr object to a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_Logical(Boolean, vStr) To convert a FvlStr object to a default logical value. Arguments Type Intent Optional Attributes Name logical, intent(out) :: Boolean type( FvlStr ), intent(in) :: vStr private module subroutine FvlStrArray_From_ChrStrArray(vStr, cStr) To assign an array of FvlStr objects from an array of character strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(out) :: vStr (:) array of FvlStr objects character(kind=kChar, len=*), intent(in) :: cStr (SIZE(vStr)) array of character strings private module subroutine FvlStrArray_From_ChrStr(vStr, cStr) To assign an array of FvlStr objects from a character string. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(out) :: vStr (:) array of FvlStr objects character(kind=kChar, len=*), intent(in) :: cStr character string","tags":"","loc":"interface\\assignment(=).html"},{"title":"FvlStr – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FvlStr Function Interface : FvlStr Purpose :  To construct a FvlStr object based on specified input. Usage : ! construct a FvlStr object from an array of characters --->    vStr = FvlStr(cArray) ! construct a FvlStr object from double-precision real number --->    vStr = FvlStr(R64, IsScientific=.TRUE.) Functions private module function CharacterArray_To_FvlStr(cArr, IsCString) result(vStr) To convert an array of characters to a FvlStr object. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: cArr (:) array of characters logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array must contain a null character. Default is FALSE. Return Value type( FvlStr ) FvlStr object private module function IByte_To_FvlStr(IntNum) result(vStr) To convert an 8-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function IShort_To_FvlStr(IntNum) result(vStr) To convert a 16-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function Integer_To_FvlStr(IntNum) result(vStr) To convert a 32-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function ILong_To_FvlStr(IntNum) result(vStr) To convert a 64-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function RSingle_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a single-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RDouble_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a double-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RQuad_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a quadruple-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CSingle_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a single-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CDouble_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a double-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CQuad_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a quadruple-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function Logical_To_FvlStr(Boolean) result(vStr) To convert a logical value to a FvlStr object. Arguments Type Intent Optional Attributes Name logical, intent(in) :: Boolean logical value Return Value type( FvlStr ) FvlStr object","tags":"","loc":"interface\\fvlstr.html"},{"title":"OPERATOR(+) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To concatenate the first and second strings. Usage : --->    vStrOut = Str1st + Str2nd Functions private module function Concatenate_VLS_CHS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string character(kind=kChar, len=*), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_CHS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_VLS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object","tags":"","loc":"interface\\operator(+).html"},{"title":"OPERATOR( – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR( Operator Overload : OPERATOR('//') Purpose :  To concatenate the first and second strings. Usage : --->    vStrOut = Str1st '//' Str2nd Module Procedures private module function Concatenate_VLS_CHS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string character(kind=kChar, len=*), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_CHS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_VLS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object","tags":"","loc":"interface\\operator(.html"},{"title":"OPERATOR(==) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check whether two strings are equal or not. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Functions private module function VLS_EQ_CHS(lStr, rStr) result(Flag) To perform equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_EQ_VLS(lStr, rStr) result(Flag) To perform equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(==).html"},{"title":"OPERATOR(/=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check whether two strings are NOT equal or not. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Functions private module function VLS_NE_CHS(lStr, rStr) result(Flag) To perform not-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_NE_VLS(lStr, rStr) result(Flag) To perform not-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(SLASH=).html"},{"title":"OPERATOR(>) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check whether LHS string is greater than RHS string or not. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething Functions private module function VLS_GT_CHS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_GT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(gt).html"},{"title":"OPERATOR(>=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check whether LHS string is greater than or equal to\n      RHS string or not. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething Functions private module function VLS_GE_CHS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_GE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(gt=).html"},{"title":"OPERATOR(<) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check whether LHS string is less than RHS string or not. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething Functions private module function VLS_LT_CHS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(lt).html"},{"title":"OPERATOR(<=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check whether LHS string is less than or equal to\n      RHS string or not. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething Functions private module function VLS_LE_CHS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\operator(lt=).html"},{"title":"GETLEN – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface GETLEN Function Interface : GETLEN Purpose :  To return length of the character string of a FvlStr object. Usage : --->    Length = GETLEN(vStr) Functions private module function GetLength(vStr) result(Length) To return length of the character string of a FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr Return Value integer(kind=kInt32)","tags":"","loc":"interface\\getlen.html"},{"title":"LEN_TRIM – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LEN_TRIM Function Interface : LEN_TRIM Purpose :  To return length of the character string of a FvlStr object\n      without counting trailing blank characters. Usage : --->    Length = LEN_TRIM(vStr) Functions private module function GetLengthTrim(vStr) result(Length) To return length of the character string of a FvlStr object\n without counting trailing blank characters. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr Return Value integer(kind=kInt32)","tags":"","loc":"interface\\len_trim.html"},{"title":"INDEX – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface INDEX Function Interface : INDEX Purpose :  To return the starting position of a substring within the string\n      of a FvlStr object. Usage : --->    Indx = INDEX(vStr, sStr) --->    Indx = INDEX(vStr, sStr, Back=.TRUE.) Functions private module function FindIndex_CHS(vStr, sStr, Back) result(Indx) To return the starting position of a substring within the string of a FvlStr object. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: sStr substring logical, intent(in), optional :: Back If present and true, searching from the back; otherwise, searching from the front. Return Value integer(kind=kInt32) starting position of a substring private module function FindIndex_VLS(vStr, sStr, Back) result(Indx) See the \"FindIndex_CHS\" procedure, where the only difference\n between these two procedures is the type of the sStr argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: sStr logical, intent(in), optional :: Back Return Value integer(kind=kInt32)","tags":"","loc":"interface\\index.html"},{"title":"SCAN – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SCAN Function Interface : SCAN Purpose :  To scan the string of a FvlStr object for any character in a set\n      of characters and return the position of the first character found in the\n      string that is in the specified set depending on the scanning direction. Usage : --->    Pos = SCAN(vStr, ChrSet) --->    Pos = SCAN(vStr, ChrSet, Back=.TRUE.) Functions private module function ScanCharacters_CHS(vStr, ChrSet, Back) result(Pos) To scan the string of a FvlStr object for any character in a set of\n characters and return the position of the first character found in the\n string that is in the specified set depending on the scanning direction. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters logical, intent(in), optional :: Back If present and true, scanning from the back; otherwise, scanning from the front. Return Value integer(kind=kInt32) position of the first character found private module function ScanCharacters_VLS(vStr, ChrSet, Back) result(Pos) See the \"ScanCharacters_CHS\" procedure, where the only difference\n between these two procedures is the type of the ChrSet argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: ChrSet logical, intent(in), optional :: Back Return Value integer(kind=kInt32)","tags":"","loc":"interface\\scan.html"},{"title":"VERIFY – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface VERIFY Function Interface : VERIFY Purpose :  To verify that a set of characters contains all the characters\n      in the string of a FvlStr object by identifying the first character in\n      the string that is not in the set and to return the position of the\n      first character found in the string that is NOT in the specified set\n      depending on the scanning direction. Usage : --->    Pos = VERIFY(vStr, ChrSet) --->    Pos = VERIFY(vStr, ChrSet, Back=.TRUE.) Functions private module function VerifyCharacters_CHS(vStr, ChrSet, Back) result(Pos) To verify that a set of characters contains all the characters in\n the string of a FvlStr object by identifying the first character\n in the string that is not in the set and to return the position\n of the first character found in the string that is NOT in the\n specified set depending on the scanning direction.  If all characters\n of string are in the specified set or the length of string is zero,\n the returned value is zero. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters logical, intent(in), optional :: Back If present and true, scanning from the back; otherwise, scanning from the front. Return Value integer(kind=kInt32) position of the first character found private module function VerifyCharacters_VLS(vStr, ChrSet, Back) result(Pos) See the \"VerifyCharacters_CHS\" procedure, where the only difference\n between these two procedures is the type of the ChrSet argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: ChrSet logical, intent(in), optional :: Back Return Value integer(kind=kInt32)","tags":"","loc":"interface\\verify.html"},{"title":"ADJUSTL – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ADJUSTL Function Interface : ADJUSTL Purpose :  To adjust the string of FvlStr object to the left, removing\n      leading blanks and inserting trailing blanks. Usage : --->    vStrOut = ADJUSTL(vStrIn) Functions private module function AdjustToLeft(vStrIn) result(vStrOut) To adjust the string of FvlStr object to the left, removing leading\n blanks and inserting trailing blanks. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr )","tags":"","loc":"interface\\adjustl.html"},{"title":"ADJUSTR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ADJUSTR Function Interface : ADJUSTR Purpose :  To adjust the string of FvlStr object to the right, removing\n      trailing blanks and inserting leading blanks. Usage : --->    vStrOut = ADJUSTR(vStrIn) Functions private module function AdjustToRight(vStrIn) result(vStrOut) To adjust the string of FvlStr object to the right, removing trailing\n blanks and inserting leading blanks. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr )","tags":"","loc":"interface\\adjustr.html"},{"title":"TRIM – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TRIM Function Interface : TRIM Purpose :  To return the argument with trailing blanks removed. Usage : --->    vStrOut = TRIM(vStrIn) Functions private module function TrimFvlStr(vStrIn) result(vStrOut) To return the argument with trailing blanks removed. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr )","tags":"","loc":"interface\\trim.html"},{"title":"REPEAT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface REPEAT Function Interface : REPEAT Purpose :  To concatenate several copies of the string of the specified\n      FvlStr object. Usage : --->    vStrOut = REPEAT(vStrIn, nCopies) Functions private module function RepeatString(vStrIn, nCopies) result(vStrOut) To concatenate several copies of the specified string. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn input FvlStr object to be repeated integer(kind=kInt32), intent(in) :: nCopies number of copies Return Value type( FvlStr ) output FvlStr object","tags":"","loc":"interface\\repeat.html"},{"title":"LGT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LGT Function Interface : LGT Purpose :  To check whether LHS string is lexically greater than\n      RHS string or not, based on the ASCII collating sequence, even\n      if the compiler's default collating sequence is different. Usage : --->    Flag = LGT(LHS, RHS) --->    IF (.NOT.LGT(LHS, RHS)) DoSomething Functions private module function VLS_LGT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LGT_CHS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LGT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\lgt.html"},{"title":"LGE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LGE Function Interface : LGE Purpose :  To check whether LHS string is lexically greater than or equal\n      to RHS string or not, based on the ASCII collating sequence, even if the\n      compiler's default collating sequence is different. Usage : --->    Flag = LGE(LHS, RHS) --->    IF (.NOT.LGE(LHS, RHS)) DoSomething Functions private module function VLS_LGE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LGE_CHS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LGE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\lge.html"},{"title":"LLT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LLT Function Interface : LLT Purpose :  To check whether LHS string is lexically less than\n      RHS string or not, based on the ASCII collating sequence, even\n      if the compiler's default collating sequence is different. Usage : --->    Flag = LLT(LHS, RHS) --->    IF (.NOT.LLT(LHS, RHS)) DoSomething Functions private module function VLS_LLT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LLT_CHS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LLT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\llt.html"},{"title":"LLE – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LLE Function Interface : LLE Purpose :  To check whether LHS string is lexically less than or equal\n      to RHS string or not, based on the ASCII collating sequence, even if the\n      compiler's default collating sequence is different. Usage : --->    Flag = LLE(LHS, RHS) --->    IF (.NOT.LLE(LHS, RHS)) DoSomething Functions private module function VLS_LLE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LLE_CHS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LLE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical","tags":"","loc":"interface\\lle.html"},{"title":"ACHAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ACHAR Function Interface : ACHAR Purpose :  To return a FvlStr object with length of 1 representing the\n      character in the specified position of the ASCII character set. Usage : --->    Chr = ACHAR(I) Functions private module function Get_ACHAR(I) result(vStr) To get the character in the specified position of the ASCII character set. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I character code (position in the set) Return Value type( FvlStr ) FvlStr object with length of 1","tags":"","loc":"interface\\achar.html"},{"title":"CHAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CHAR Function Interface : CHAR Purpose :  To return a FvlStr object with length of 1 representing the\n      character in the specified position of the compiler's character set. Usage : --->    Chr = CHAR(I) Functions private module function Get_CHAR(I) result(vStr) To get the character in the specified position of the processor's character set. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I character code (position in the set) Return Value type( FvlStr ) FvlStr object with length of 1","tags":"","loc":"interface\\char.html"},{"title":"IACHAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IACHAR Function Interface : IACHAR Purpose :  To return the character code based on the ASCII character set\n      of the specified character of the FvlStr object. Usage : --->    I = IACHAR(vStr, Pos) Note : A character code is a position of the character in a character set. Functions private module function Get_IACHAR(vStr, Pos) result(I) To get the character code based on the ASCII character set of the specified\n character. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: Pos index specifying the FvlStr's character Return Value integer(kind=kInt32) the requested character code (position in the character set);\n I = -1 if invalid set of input is given.","tags":"","loc":"interface\\iachar.html"},{"title":"ICHAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ICHAR Function Interface : ICHAR Purpose :  To return the character code based on the compiler's character set\n      of the specified character of the FvlStr object. Usage : --->    I = ICHAR(vStr, Pos) Note : A character code is a position of the character in a character set. Functions private module function Get_ICHAR(vStr, Pos) result(I) To get the character code based on the processor's character set of the specified\n character. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: Pos index specifying the FvlStr's character Return Value integer(kind=kInt32) the requested character code (position in the character set);\n I = -1 if invalid set of input is given.","tags":"","loc":"interface\\ichar.html"},{"title":"WRITE(UNFORMATTED) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WRITE(UNFORMATTED) Subroutine Interface : WRITE(UNFORMATTED) Purpose :  To write a character string of the FvlStr object to a connected\n      unformatted unit. Usage : --->    WRITE(UNIT=IOUnit) vStr Subroutines private module subroutine Write_Unformatted(vStr, IOUnit, IOStat, IOMsg) To write a character string of the FvlStr object to a connected unformatted unit. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero","tags":"","loc":"interface\\write(unformatted).html"},{"title":"READ(UNFORMATTED) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface READ(UNFORMATTED) Subroutine Interface : READ(UNFORMATTED) Purpose :  To read a character sequence from a connected unformatted unit\n      into the FvlStr object. Usage : --->    READ(UNIT=IOUnit) vStr Subroutines private module subroutine Read_Unformatted(vStr, IOUnit, IOStat, IOMsg) To read a character sequence from a connected unformatted unit into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero","tags":"","loc":"interface\\read(unformatted).html"},{"title":"WRITE(FORMATTED) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WRITE(FORMATTED) Subroutine Interface : WRITE(FORMATTED) Purpose :  To write a character string of the FvlStr object to a connected\n      formatted unit. Usage : ! using the list-directed format output --->    WRITE(UNIT=IOUnit, FMT= ) vStr --->    WRITE(UNIT=IOUnit, FMT= , IOSTAT=IOStat, IOMSG=IOMsg) vStr ! using the DT edit descriptor --->    WRITE(UNIT=IOUnit, FMT='(DT)') vStr --->    WRITE(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr Subroutines private module subroutine Write_Formatted(vStr, IOUnit, IOType, VList, IOStat, IOMsg) To write a character string of the FvlStr object to a connected formatted unit. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number character(kind=kChar, len=*), intent(in) :: IOType type of io integer(kind=kInt32), intent(in) :: VList (:) list of integer array from part of the DT edit descriptor integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero","tags":"","loc":"interface\\write(formatted).html"},{"title":"READ(FORMATTED) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface READ(FORMATTED) Subroutine Interface : READ(FORMATTED) Purpose :  To read a character sequence from a connected formatted unit\n      into the FvlStr object. Usage : ! using the list-directed format input --->    READ(UNIT=IOUnit, FMT= ) vStr --->    READ(UNIT=IOUnit, FMT= , IOSTAT=IOStat, IOMSG=IOMsg) vStr ! using the DT edit descriptor --->    READ(UNIT=IOUnit, FMT='(DT)') vStr --->    READ(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr Subroutines private module subroutine Read_Formatted(vStr, IOUnit, IOType, VList, IOStat, IOMsg) To read a character sequence from a connected formatted unit into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number character(kind=kChar, len=*), intent(in) :: IOType type of io integer(kind=kInt32), intent(in) :: VList (:) list of integer array from part of the DT edit descriptor integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero","tags":"","loc":"interface\\read(formatted).html"},{"title":"Swap – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Swap Subroutine Interface : Swap Purpose :  To swap values of two FvlStr objects or two arrays\n      of FvlStr objects. Usage : --->    CALL Swap(vStrA, vStrB) --->    CALL Swap(vStrArrA, vStrArrB) Subroutines private module subroutine SwapFvlStr(AVal, BVal) To swap values of two FvlStr objects. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal value of A type( FvlStr ), intent(inout) :: BVal value of B private module subroutine SwapFvlStrArray(AVal, BVal) To swap values of two arrays of FvlStr objects. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array A of FvlStr objects type( FvlStr ), intent(inout) :: BVal (:) array B of FvlStr objects","tags":"","loc":"interface\\swap.html"},{"title":"ToCharStar – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToCharStar Subroutine Interface : ToCharStar Purpose :  To convert a FvlStr object to an assumed-length character string. Usage : --->    CALL ToCharStar(vStr, cStr) Important Note :  This procedure is intended to be used internally only. Module Procedures private  subroutine CharStar_From_FvlStr(vStr, cStr) To convert a FvlStr object to an assumed-length character string. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(out) :: cStr character string","tags":"","loc":"interface\\tocharstar.html"},{"title":"PtrToStr – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface PtrToStr Function Interface : PtrToStr Purpose :  To set a pointer to the string of the FvlStr object. Usage : --->    StrPtr => PtrToStr(vStr) --->    IF (.NOT.ASSOCIATED(PtrToStr(vStr))) DoSomething Important Note :  This procedure is intended to be used internally only. Module Procedures private  function Pointer_To_FvlStr(vStr) result(pStr) To set a pointer to the string of the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in), TARGET :: vStr FvlStr object Return Value character(kind=kChar, len=:), POINTER pointer to object's string","tags":"","loc":"interface\\ptrtostr.html"},{"title":"IsReady – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsReady Function Interface : IsReady Purpose :  To check whether the FvlStr object is ready to be used or not.\n      Return true if the object's string is allocated.  Otherwise, return false. Usage : --->    Flag = IsReady(vStr) --->    IF (.NOT.IsReady(vStr)) DoSomething Module Procedures private  function Is_FvlStr_Ready(vStr) result(Flag) To check whether the string of the FvlStr object is allocated or not.\n If allocated, return true.  Otherwise, return false. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object Return Value logical flag indicating whether the string is allocated or not.","tags":"","loc":"interface\\isready.html"},{"title":"IsCharacterInClass – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsCharacterInClass Function Interface : IsCharacterInClass Purpose :  To check whether a given character is in the specified class. Usage : --->    Flag = IsCharacterInClass('A', 'ASCII', FailIndex) --->    IF (.NOT.IsCharacterInClass('5', 'ALPHANUM')) DoSomething Functions private module function IsCharacterInClass(Chr, ClassType, FailIndex) result(ClassFlag) To check whether a given character is in the specified class where\n the following character classes are recognized. - 'ALPHABET': The given character is a valid letter [a-zA-Z]. - 'ALPHANUM': The given character is a valid letter or digit [a-zA-Z0-9]. - 'ASCII': The given character is a valid ASCII character. - 'BLANK': The given character is a valid blank character, that is blank\n      space or tab. - 'CONTROL': The given character is a valid control character where control\n      characters are in the ranges 00..1F and 7F..9F, that is from ASCII #0\n      to #31 and from #127 to #159. - 'DIGIT': The given character is a valid digit [0-9]. - 'GRAPHICAL': The given character is a valid graphical character not\n      including space that is from ASCII #33 to #126. - 'LOGICAL': The given character is a valid logical value, that is 't', 'T',\n      'f', and 'F'. - 'LOWERCASE': The given character is a valid lower-case letter, that is\n      [a-z]. - 'PUNCTUATION': The given character is a valid punctuation character, that\n      is _,;:.? {}@\"'. - 'PRINTABLE': The given character is a valid printable character including\n      space that is from ASCII #32 to #126. - 'UPPERCASE': The given character is a valid upper-case letter, that is\n      [A-Z]. - 'WHITESPACE': The given character is a valid white space, that is space,\n      tab, vertical tab, form-feed, newline or carriage return. - 'HEXDIGIT': The given character is a valid hexadecimal digit characters\n      that is [0-9A-Fa-f]. - 'OCTDIGIT': The given character is a valid octal digit characters\n      that is [0-9A-Fa-f]. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: Chr the specified character character(kind=kChar, len=*), intent(in) :: ClassType character class integer(kind=kInt32), intent(out), optional :: FailIndex return 1 if the character class is valid; otherwise, return 0. Return Value logical true if the character is in the specified class","tags":"","loc":"interface\\ischaracterinclass.html"},{"title":"ChangeCaseCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ChangeCaseCharacter Subroutine Interface : ChangeCaseCharacter Purpose :  To change case of the given character according to flag. Usage : ! if Char is an alphabet character, change it to its upper case --->    CALL ChangeCaseCharacter(Char, .TRUE.)\n  ! if Char is an alphabet character, change it to its lower case --->    CALL ChangeCaseCharacter(Char, .FALSE.)\n  ! if Char is NOT an alphabet character, nothing done --->    CALL ChangeCaseCharacter(Char, .TRUE.) Subroutines private elemental module subroutine ChangeCaseCharacter(Chr, ToUpper) To change case of the given character according to flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(inout) :: Chr the specified character logical, intent(in) :: ToUpper flag indicating whether to change the character to upper case - true if requesting an uppercase character - false if requesting a lowercase character","tags":"","loc":"interface\\changecasecharacter.html"},{"title":"CharacterDescription – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CharacterDescription Function Interface : CharacterDescription Purpose :  To provide a description of the given character. Usage : --->    Description = CharacterDescription('~') Functions private module function CharacterDescription(Chr) result(Description) To provide a description of the given character. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: Chr the specified character Return Value character(kind=kChar, len=:), ALLOCATABLE the character description","tags":"","loc":"interface\\characterdescription.html"},{"title":"ASSIGNMENT(=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a character string and an other\n               (Fortran intrinsic) type via an assignment expression. Usage : ! convert a 64-bit integer number to a character string --->    cStr = I64Num ! convert a character string to a quadruple-precision real number --->    RQPNum = cStr Important Note : The assignment and conversion operations are\n           functionally similar but have some subtle differences.  In\n           particular for those procedures that convert from a decimal\n           string to a number, the assignment procedures will silently\n           convert to a proper representation if the input string is INVALID whereas the conversion procedures can optionally\n           report the error occurred. Subroutines private module subroutine ChrStr_From_IByte(cStr, IntNum) To convert from a 8-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt8), intent(in) :: IntNum private module subroutine ChrStr_From_IShort(cStr, IntNum) To convert from a 16-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt16), intent(in) :: IntNum private module subroutine ChrStr_From_Integer(cStr, IntNum) To convert from a 32-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt32), intent(in) :: IntNum private module subroutine ChrStr_From_ILong(cStr, IntNum) To convert from a 64-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt64), intent(in) :: IntNum private module subroutine ChrStr_From_RSingle(cStr, RealNum) To convert from a single-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kSingle), intent(in) :: RealNum private module subroutine ChrStr_From_RDouble(cStr, RealNum) To convert from a double-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kDouble), intent(in) :: RealNum private module subroutine ChrStr_From_RQuad(cStr, RealNum) To convert from a quadruple-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kQuad), intent(in) :: RealNum private module subroutine ChrStr_From_CSingle(cStr, CmpxNum) To convert from a single-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kSingle), intent(in) :: CmpxNum private module subroutine ChrStr_From_CDouble(cStr, CmpxNum) To convert from a double-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kDouble), intent(in) :: CmpxNum private module subroutine ChrStr_From_CQuad(cStr, CmpxNum) To convert from a quadruple-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kQuad), intent(in) :: CmpxNum private module subroutine ChrStr_From_Logical(cStr, Boolean) To convert from a logical value to a character string\n via an assignment expression. Usage : cStr = Boolean Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr logical, intent(in) :: Boolean private module subroutine ChrStr_To_IByte(IntNum, cStr) To convert from a character string to a 8-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_IShort(IntNum, cStr) To convert from a character string to a 16-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_Integer(IntNum, cStr) To convert from a character string to a 32-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_ILong(IntNum, cStr) To convert from a character string to a 64-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RSingle(RealNum, cStr) To convert from a character string to a single-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RDouble(RealNum, cStr) To convert from a character string to a double-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RQuad(RealNum, cStr) To convert from a character string to a quadruple-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CSingle(CmpxNum, cStr) To convert from a character string to a single-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CDouble(CmpxNum, cStr) To convert from a character string to a double-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CQuad(CmpxNum, cStr) To convert from a character string to a quadruple-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_Logical(Boolean, cStr) To convert from a character string to a logical value\n via an assignment expression. Usage : Boolean = cStr Arguments Type Intent Optional Attributes Name logical, intent(out) :: Boolean character(kind=kChar, len=*), intent(in) :: cStr","tags":"","loc":"interface\\assignment(=)~2.html"},{"title":"CharString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CharString Function Interface : CharString Purpose :  To construct a character string based on specified input. Usage : ! construct a character string from an array of characters --->    cStr = CharString(cArray) ! construct a character string from double-precision real number --->    cStr = CharString(R64, IsScientific=.TRUE.) Functions private module function CharacterArray_To_ChrStr(cArr, IsCString) result(cStr) To convert a character array to a character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: cArr (:) array of characters logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array must contain a null character. Default is FALSE. Return Value character(kind=kChar, len=:), ALLOCATABLE character string private module function IByte_To_ChrStr(IntNum) result(cStr) To convert an 8-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function IShort_To_ChrStr(IntNum) result(cStr) To convert an 16-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function Integer_To_ChrStr(IntNum) result(cStr) To convert an 32-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function ILong_To_ChrStr(IntNum) result(cStr) To convert an 64-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RSingle_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a single-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RDouble_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a double-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RQuad_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a quadruple-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CSingle_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a single-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CDouble_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a double-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CQuad_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a quadruple-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function Logical_To_ChrStr(Boolean) result(cStr) To convert a logical value to a character string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: Boolean Return Value character(kind=kChar, len=:), ALLOCATABLE","tags":"","loc":"interface\\charstring.html"},{"title":"ToChrArrAlloc – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToChrArrAlloc Function Interface : ToChrArrAlloc Purpose :  To convert a character string to an allocatable array\n               of characters. Usage : ! convert a character string to a character array --->    cArray = ToChrArrAlloc(cStr) ! convert a character string to a character array with a null character --->    cArray = ToChrArrAlloc(cStr, IsCString=.TRUE.) Functions private module function CharArray_From_ChrStr_I(cStr, IsCString) result(cArr) To convert a character string to an allocatable array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array will contain a null character. Default is FALSE. Return Value character(kind=kChar, len=1), ALLOCATABLE, (:) an array of characters","tags":"","loc":"interface\\tochrarralloc.html"},{"title":"ToChrArrFixed – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToChrArrFixed Function Interface : ToChrArrFixed Purpose :  To convert a character string to an explicit-shape array\n               of characters. Usage : --->    cArray = ToChrArrFixed(cStr) Functions private module function CharArray_From_ChrStr_II(cStr) result(cArr) To convert a character string to an explicit-shape array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string Return Value character(kind=kChar, len=1), (LEN(cStr)) an array of characters","tags":"","loc":"interface\\tochrarrfixed.html"},{"title":"ToCString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToCString Function Interface : ToCString Purpose :  To convert a character string to a 'C' style string, which is an\n               explicit-shape array of characters with a null character added. Usage : --->    cArray = ToCString(cStr) Functions private module function CString_From_ChrStr(cStr) result(cArr) To convert a character string to a 'C' style string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string Return Value character(kind=kChar, len=1), (LEN(cStr)+1) a 'C' string","tags":"","loc":"interface\\tocstring.html"},{"title":"ParseByte – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseByte Function Interface : ParseByte Purpose :  To parse a character string as a 8-bit integer number. Usage : --->    IntNum = ParseByte(cStr) --->    IntNum = ParseByte(cStr, ErrFlag, ErrMsg) Functions private module function IByte_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 8-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt8) integer number","tags":"","loc":"interface\\parsebyte.html"},{"title":"ParseShort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseShort Function Interface : ParseShort Purpose :  To parse a character string as a 16-bit integer number. Usage : --->    IntNum = ParseShort(cStr) --->    IntNum = ParseShort(cStr, ErrFlag, ErrMsg) Functions private module function IShort_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 16-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt16) integer number","tags":"","loc":"interface\\parseshort.html"},{"title":"ParseInteger – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseInteger Function Interface : ParseInteger Purpose :  To parse a character string as a 32-bit integer number. Usage : --->    IntNum = ParseInteger(cStr) --->    IntNum = ParseInteger(cStr, ErrFlag, ErrMsg) Functions private module function Integer_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 32-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt32) integer number","tags":"","loc":"interface\\parseinteger.html"},{"title":"ParseLong – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseLong Function Interface : ParseLong Purpose :  To parse a character string as a 64-bit integer number. Usage : --->    IntNum = ParseLong(cStr) --->    IntNum = ParseLong(cStr, ErrFlag, ErrMsg) Functions private module function ILong_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 64-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt64) integer number","tags":"","loc":"interface\\parselong.html"},{"title":"ParseRSingle – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseRSingle Function Interface : ParseRSingle Purpose :  To parse a character string as a single-precision real number. Usage : --->    RealNum = ParseRSingle(cStr) --->    RealNum = ParseRSingle(cStr, ErrFlag, ErrMsg) Functions private module function RSingle_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a single-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) real number","tags":"","loc":"interface\\parsersingle.html"},{"title":"ParseRDouble – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseRDouble Function Interface : ParseRDouble Purpose :  To parse a character string as a double-precision real number. Usage : --->    RealNum = ParseRDouble(cStr) --->    RealNum = ParseRDouble(cStr, ErrFlag, ErrMsg) Functions private module function RDouble_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a double-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) real number","tags":"","loc":"interface\\parserdouble.html"},{"title":"ParseRQuad – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseRQuad Function Interface : ParseRQuad Purpose :  To parse a character string as a quadruple-precision real number. Usage : --->    RealNum = ParseRQuad(cStr) --->    RealNum = ParseRQuad(cStr, ErrFlag, ErrMsg) Functions private module function RQuad_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a quadruple-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) real number","tags":"","loc":"interface\\parserquad.html"},{"title":"ParseCSingle – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseCSingle Function Interface : ParseCSingle Purpose :  To parse a character string as a single-precision complex number. Usage : --->    CmpxNum = ParseCSingle(cStr) --->    CmpxNum = ParseCSingle(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. Functions private module function CSingle_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a single-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kSingle) complex number","tags":"","loc":"interface\\parsecsingle.html"},{"title":"ParseCDouble – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseCDouble Function Interface : ParseCDouble Purpose :  To parse a character string as a double-precision complex number. Usage : --->    CmpxNum = ParseCDouble(cStr) --->    CmpxNum = ParseCDouble(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. Functions private module function CDouble_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a double-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kDouble) complex number","tags":"","loc":"interface\\parsecdouble.html"},{"title":"ParseCQuad – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseCQuad Function Interface : ParseCQuad Purpose :  To parse a character string as a quadruple-precision complex number. Usage : --->    CmpxNum = ParseCQuad(cStr) --->    CmpxNum = ParseCQuad(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. Functions private module function CQuad_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kQuad) complex number","tags":"","loc":"interface\\parsecquad.html"},{"title":"ParseLogical – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ParseLogical Function Interface : ParseLogical Purpose :  To parse a character string as a logical value. Usage : --->    Boolean = ParseLogical(cStr) Functions private module function Logical_From_ChrStr(cStr) result(Boolean) To convert a character string to a logical value. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string Return Value logical logical value","tags":"","loc":"interface\\parselogical.html"},{"title":"IsStringNumber – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsStringNumber Function Interface : IsStringNumber Purpose :  To check whether a character string is a valid number and\n               return a flag indicating what kind of number the string is. Usage : --->    NumFlag = IsStringNumber('123a31')                        ! return -1 --->    NumFlag = IsStringNumber('123')                           ! return 0 --->    NumFlag = IsStringNumber('1.23')                          ! return 0 --->    NumFlag = IsStringNumber('123', Strict=.TRUE.)            ! return 1 --->    NumFlag = IsStringNumber('1.23', Strict=.TRUE.)           ! return 2 --->    NumFlag = IsStringNumber('(123, 456)')                    ! return 3 --->    NumFlag = IsStringNumber('(12.3, 4.56)', NumVal=CmplxNum) ! return 3 and also get number Technical Notes : A (strict) integer number is a whole number with no decimal point.\n  It can have a leading sign and is interpreted as a decimal number.\n  It takes a general form of [s]n[n...] where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A (strict) real number is a number with decimal point or an exponent part.\n  The general form of a real number with no exponent part is [s]n[n...] and\n  a real number with an exponent part has a general form of [s]n[n...]E[s]nn...\n  where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A decimal point must appear if\n    the real number has no exponent part. - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. A complex number is a pair of real or integer numbers, separated by a comma,\n  and enclosed in parentheses.  The first number represents the real part and\n  the second number represents the imaginary part. Functions private module function IsStringNumber(cStr, Strict, NumVal) result(NumFlag) To check whether a character string is a valid number and\n if so, what kind of number it is. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(in), optional :: Strict true if requesting strict integer/real number; default is false. class(*), intent(out), optional, ALLOCATABLE :: NumVal (optional) value of number if it is valid Return Value integer(kind=kInt32) flag indicating what kind of number the string represents. Return -1 if the string is NOT a number. Return  0 if the string is a valid integer or real number. Return  1 if the string is strictly an integer number. Return  2 if the string is strictly a real number. Return  3 if the string is a valid complex number.","tags":"","loc":"interface\\isstringnumber.html"},{"title":"IsStringLogical – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsStringLogical Function Interface : IsStringLogical Purpose : To check whether a character string is a logical value where\n              valid one include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true',\n              'false'. Usage : --->    Flag = IsStringLogical('a') --->    Flag = IsStringLogical('f', LogVal) Functions private module function IsStringLogical(cStr, Boolean) result(LogFlag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: Boolean (optional) logical value Return Value logical true if the string is a valid logical value","tags":"","loc":"interface\\isstringlogical.html"},{"title":"IsStringInClass – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsStringInClass Function Interface : IsStringInClass Purpose :  To check whether a given string is in the specified class. Usage : --->    Flag = IsStringInClass('AbCd', 'ASCII', FailIndex) --->    IF (.NOT.IsStringInClass('32.105e-32', 'REAL') DoSomething Functions private recursive module function IsStringInClass(cStr, ClassType, FailIndex) result(ClassFlag) To check whether the given character string is in the specified class.\n To be in the specified class, all characters in the string must be\n valid characters of that class. The recognized character string classes include those of character classes\n (see the IsCharacterInClass routine) and the following additional classes: - 'COMPLEX': The character string is a valid complex constant in Fortran,\n      with optional sign and surrounding white spaces. - 'FNAME': The character string is a valid FORTRAN name that can contain\n      letters, digits, and underscores. The first character must be a letter. - 'INTEGER': The character string is a valid integer constant in Fortran,\n      with optional surrounding white spaces. - 'LOGICAL': The character string is considered a valid logical value, that\n      is 't', 'T', 'true', 'TRUE', 'f', 'F', 'false' and 'FALSE', with\n      optional surrounding white spaces. - 'REAL': The character string is a valid real constant in Fortran, with\n      optional surrounding white spaces. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr specified character string character(kind=kChar, len=*), intent(in) :: ClassType character string class integer(kind=kInt32), intent(out), optional :: FailIndex flag indicating position of the failed character Return Value logical true if the string is in the specified class","tags":"","loc":"interface\\isstringinclass.html"},{"title":"IsStringInCharacterSet – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsStringInCharacterSet Function Interface : IsStringInCharacterSet Purpose :  To check whether all characters in the character string are\n               in the specified character set. Usage : --->    Flag = IsStringInCharacterSet('Ab23Cd', SET_ALPHANUM, FailIndex) --->    IF (.NOT.IsStringInCharacterSet('32.105Q-32', SET_NUMERICS) DoSomething Functions private module function IsStringInCharacterSet(cStr, ChrSet, FailID) result(Flag) To check whether all characters in the character string are\n in the given character set. Note: This routine is an alternative to the VERIFY intrinsic function. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set integer(kind=kInt32), intent(out) :: FailID index indicating position of invalid character Return Value logical true if all characters are in the set","tags":"","loc":"interface\\isstringincharacterset.html"},{"title":"CountSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CountSubstring Function Interface : CountSubstring Purpose :  To count the number of occurrences of the given\n               substring in the specified character string. Usage : --->    Count = CountSubstring(String, SubStr) --->    Count = CountSubstring(String, SubStr, Overlap=.TRUE.) Functions private module function CountSubstring(cStr, sStr, Overlap) result(nCount) To count the number of occurrences of the given substring in the\n specified character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring logical, intent(in), optional :: Overlap flag indicating whether overlapping occurrences of the substring\n are allowed or not. - If true, count the overlapping occurrences. - If false, count the non-overlapping occurrences . Default is false. Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\countsubstring.html"},{"title":"CountCharacters – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CountCharacters Function Interface : CountCharacters Purpose :  To count the number of occurrences of character(s) in the\n               specified character string for any character appearing in\n               the given character set. Usage : --->    Count = CountCharacters(String, CharSet) Functions private module function CountCharacters(cStr, ChrSet) result(nCount) To count the number of occurrences of character(s) in the specified\n character string for any character appearing in the given character set. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\countcharacters.html"},{"title":"CountCharactersProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CountCharactersProtect Function Interface : CountCharactersProtect Purpose :  To count the number of occurrences of delimiter(s) in the\n               unprotected region(s) of the specified character string\n               where a delimiter is any character appearing in the\n               given character set. Usage : --->    Count = CountCharactersProtect(String, CharSet) --->    Count = CountCharactersProtect(String, CharSet, ExclMrk=.FALSE.) Functions private module function CountCharactersProtect(cStr, ChrSet, ExclMrk) result(nCount) To count the number of occurrences of delimiter(s) in the unprotected\n region(s) of the specified character string where a delimiter is any\n character appearing in the given character set. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\countcharactersprotect.html"},{"title":"CountWords – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CountWords Function Interface : CountWords Purpose :  To count the number of words (separated by blanks) in the\n               specified character string where blanks are characters in\n               the SET_BLANKS character set. Usage : --->    Count = CountWords(String) Functions private module function CountWords(cStr) result(nCount) To count the number of words (separated by blanks) in the specified\n character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string Return Value integer(kind=kInt32) number of words","tags":"","loc":"interface\\countwords.html"},{"title":"FindProtectedRegions – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindProtectedRegions Function Interface : FindProtectedRegions Purpose :  To find the number of protected regions marked by two (single\n               or double) quotes and/or by an exclamation mark.  Also, return\n               positions of the first and last characters of each region. Usage : --->    nRegion = FindProtectedRegions(String, lPos, rPos) --->    nRegion = FindProtectedRegions(String, lPos, rPos, ExclMrk=.FALSE.) Functions private module function FindProtectedRegions(cStr, lPos, rPos, ExclMrk) result(nRegion) To look for quotes (and/or an exclamation mark) to find regions\n that must be protected from character string editing.  Return\n the number of protected regions as well as positions of the\n first and last characters of each region. Technical Notes : - Single quote, double quote and optionally exclamation mark are used as\n   delimiters to find protected regions. - Two single quotes or two double quotes are used to define a protected\n   region whereas an exclamation mark indicates that all characters\n   following it are all protected. - This routine is designed specifically for manipulating Fortran source code\n   where an exclamation mark is used for a comment and two (single or double)\n   quotes are used to specify a value to a character variable or literal. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(out), ALLOCATABLE :: lPos (:) positions of the first character of protected regions integer(kind=kInt32), intent(out), ALLOCATABLE :: rPos (:) positions of the last character of protected regions logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of protected regions","tags":"","loc":"interface\\findprotectedregions.html"},{"title":"FindSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindSubstring Function Interface : FindSubstring Purpose :  To count the number of non-overlapping occurrences of the given\n               substring in the specified character string and also return\n               position(s) of the first character of substring found. Usage : --->    Count = FindSubstring(String, SubStr, FirstPos) Functions private module function FindSubstring(cStr, sStr, sPos) result(nCount) To count the number of non-overlapping occurrences of the given\n substring in the specified character string and also return\n position(s) of the first character of substring found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) position(s) of the first character of substring found Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\findsubstring.html"},{"title":"FindSubstringProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindSubstringProtect Function Interface : FindSubstringProtect Purpose :  To count the number of non-overlapping occurrences of the given\n               substring in unprotected regions of the specified character\n               string and also return position(s) of the first character of\n               substring found. Usage : --->    Count = FindSubstringProtect(String, SubStr, FirstPos) --->    Count = FindSubstringProtect(String, SubStr, FirstPos, ExclMrk=.FALSE.) Functions private module function FindSubstringProtect(cStr, sStr, sPos, ExclMrk) result(nCount) To count the number of non-overlapping occurrences of the given substring\n in unprotected regions of the specified character string and also return\n position(s) of the first character of substring found. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) position(s) of the first character of substring found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\findsubstringprotect.html"},{"title":"FindDelimiters – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindDelimiters Function Interface : FindDelimiters Purpose :  To count the number of occurrences of delimiter(s) in the specified\n               character string and also return position(s) of the delimiter(s) found.\n               A delimiter is any character appearing in the given character set. Usage : --->    Count = FindDelimiters(String, CharSet, DPos) Functions private module function FindDelimiters(cStr, ChrSet, dPos) result(nCount) To count the number of occurrences of delimiter(s) in the specified\n character string and also return position(s) of the delimiter(s) found.\n A delimiter is any character appearing in the given character set. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters integer(kind=kInt32), intent(out), ALLOCATABLE :: dPos (:) position(s) of the delimiter(s) found Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\finddelimiters.html"},{"title":"FindDelimitersProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindDelimitersProtect Function Interface : FindDelimitersProtect Purpose :  To count the number of occurrences of delimiter(s) in unprotected\n               regions of the specified character string and also return position(s)\n               of the delimiter(s) found.  A delimiter is any character appearing\n               in the given character set. Usage : --->    Count = FindDelimitersProtect(String, CharSet, DPos) --->    Count = FindDelimitersProtect(String, CharSet, DPos, ExclMrk=.FALSE.) Functions private module function FindDelimitersProtect(cStr, ChrSet, dPos, ExclMrk) result(nCount) To count the number of occurrences of delimiter(s) in unprotected regions\n of the specified character string and also return position(s) of the\n delimiter(s) found.  A delimiter is any character appearing in the given\n character set. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters integer(kind=kInt32), intent(out), ALLOCATABLE :: dPos (:) position(s) of the delimiter(s) found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\finddelimitersprotect.html"},{"title":"FindSeparators – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindSeparators Function Interface : FindSeparators Purpose :  To count the number of occurrences of separator(s) in the\n               specified character string and also return (the first)\n               position(s) of the separator(s) found. Usage : ! a separator is any (single) character in the Separator argument --->    Count = FindSeparators(String, Separator, .TRUE., Pos) ! a separator is a character string specified by the Separator argument --->    Count = FindSeparators(String, Separator, .FALSE., Pos) Functions private module function FindSeparators(cStr, Separator, CharSet, sPos) result(nCount) To count the number of occurrences of separator(s) in the specified\n character string and also return (the first) position(s) of the\n separator(s) found. A separator can be a (single) character or a character string (multiple\n characters). The CharSet argument is a flag used to specify whether the separator\n is a character or a character string. If the CharSet argument is true, the Separator argument contains a\n set of characters where a separator is any character in the set. If the CharSet argument is false, the Separator argument specifies\n the character-string separator. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: Separator separator logical, intent(in) :: CharSet a flag indicating type of the separator integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) (first) position(s) of the separator(s) found Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\findseparators.html"},{"title":"FindSeparatorsProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FindSeparatorsProtect Function Interface : FindSeparatorsProtect Purpose :  To count the number of occurrences of separator(s) in the\n               specified character string and also return (the first)\n               position(s) of the separator(s) found. Usage : ! both quotes and an exclamation mark used to define protected regions. --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos)  ! separator is a single character --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos) ! separator is a character string ! only quotes used to define protected regions. --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos, ExclMrk=.FALSE.) --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos, ExclMrk=.FALSE.) Functions private module function FindSeparatorsProtect(cStr, Separator, CharSet, sPos, ExclMrk) result(nCount) To count the number of occurrences of separator(s) in unprotected\n regions of the specified character string and also return (the first)\n position(s) of the separator(s) found. See the FindSeparators routine for explanations regarding the separator and\n its types.\n See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: Separator separator logical, intent(in) :: CharSet a flag indicating type of the separator integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) (first) position(s) of the separator(s) found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences","tags":"","loc":"interface\\findseparatorsprotect.html"},{"title":"GetSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface GetSubstring Function Interface : GetSubstring Purpose :  To get a substring (specified by the leftmost and rightmost\n               indices) of the given character string. Usage : --->    Substring = GetSubstring(String, LeftIndx, RightIndx) Functions private module function GetSubstring(cStr, lPos, rPos) result(cSub) To return a substring specified by the lPos and rPos arguments\n of the given character string. If the lPos argument is less than 1, then 1 is used as a\n starting position of the substring. Similarly, if the rPos argument is greater than the length of\n the string, then the length is used as an ending position. Also, If the rPos argument is less than the lPos argument,\n a zero-length string is returned. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in) :: lPos leftmost index integer(kind=kInt32), intent(in) :: rPos rightmost index Return Value character(kind=kChar, len=:), ALLOCATABLE substring","tags":"","loc":"interface\\getsubstring.html"},{"title":"GetSlice – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface GetSlice Function Interface : GetSlice Purpose :  To extract characters from the region between the first and\n               last indices (both inclusive) of the given string by taking\n               strides of length Stride . Usage : --->    Slice = GetSlice(String, FirstIndx, LastIndx, Stride) Functions private module function GetSlice(cStr, First, Last, Stride) result(Slice) To extract characters from the region between the first and last indices\n (both inclusive) of the given string by taking strides of length Stride . Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: First the first index; can be greater than the last index if Stride is negative. integer(kind=kInt32), intent(in), optional :: Last the last index; can be less than the first index if Stride is negative. integer(kind=kInt32), intent(in), optional :: Stride a step (length) between characters extracted; can be negative. Return Value character(kind=kChar, len=:), ALLOCATABLE slice of the string","tags":"","loc":"interface\\getslice.html"},{"title":"StartWith – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface StartWith Function Interface : StartWith Purpose :  To check whether the given character string starts with the\n               specified substring or not.  Both the string and the substring\n               must not have a zero length. Usage : --->    Flag = StartWith(String, Substring) --->    IF (.NOT.StartWith(String, Substring)) DoSomething Functions private module function StartWithSubstring(cStr, sStr) result(Flag) To check whether the given character string starts with the specified\n substring or not.  Both the string and the substring must not have a\n zero length. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring Return Value logical true if the string starts with the substring","tags":"","loc":"interface\\startwith.html"},{"title":"EndWith – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface EndWith Function Interface : EndWith Purpose :  To check whether the given character string ends with the\n               specified substring or not.  Both the string and the substring\n               must not have a zero length. Usage : --->    Flag = EndWith(String, Substring) --->    IF (.NOT.EndWith(String, Substring)) DoSomething Functions private module function EndWithSubstring(cStr, sStr) result(Flag) To check whether the given character string ends with the specified\n substring or not.  Both the string and the substring must not have a\n zero length. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring Return Value logical true if the string ends with the substring","tags":"","loc":"interface\\endwith.html"},{"title":"CropBlanks – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CropBlanks Function Interface : CropBlanks Purpose :  To remove leading and trailing blanks from the character string. Usage : --->    OutStr = CropBlanks(InStr) --->    OutStr = CropBlanks(InStr, SpaceOnly=.TRUE.) Note : CropBlanks(InStr,.TRUE.) is the same as TRIM(ADJUSTL(InStr)). Functions private module function CropBlanks(cStrIn, SpaceOnly) result(cStrOut) To remove leading and trailing blanks from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string logical, intent(in), optional :: SpaceOnly flag indicating whether to only remove the space character or not. - True if requesting to remove only the space character. - False if requesting to remove both the tab and the space characters. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\cropblanks.html"},{"title":"CompactString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CompactString Function Interface : CompactString Purpose :  To convert multiple spaces and tabs into a single space,\n               delete control characters and removes initial (leading\n               and trailing) spaces. Usage : --->    OutStr = CompactString(InStr) Functions private module function CompactString(cStrIn) result(cStrOut) To convert multiple spaces and tabs into a single space, delete control\n characters and removes initial (leading and trailing) spaces. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\compactstring.html"},{"title":"CompressString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface CompressString Function Interface : CompressString Purpose :  To remove spaces, tabs and control characters from the\n               character string. Usage : --->    OutStr = CompressString(InStr) Note : Unlike the CompactString procedure, the output string\n           contains no space between its characters. Functions private module function CompressString(cStrIn) result(cStrOut) To remove spaces, tabs and control characters from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\compressstring.html"},{"title":"ChangeCase – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ChangeCase Subroutine Interface : ChangeCase Purpose :  To change case of all alphabet characters of the specified\n               character string according to the given flag.  If protected\n               regions are specified, only characters in unprotected regions\n               are changed. Usage : ! change all alphabet characters to upper cases --->    CALL ChangeCase(String, .TRUE.) ! change all alphabet characters only in unprotected regions to lower cases --->    CALL ChangeCase(String, nRegion, lPos, rPos, .FALSE.) Subroutines private elemental module subroutine ChangeCaseString(cStr, ToUpper) To change case of all alphabet characters of the specified character\n string according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: cStr character string logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. private module subroutine ChangeCaseProtect(cStr, nRegion, lPos, rPos, ToUpper) To change case of all alphabet characters of the specified character\n string in unprotected regions according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: cStr character string integer(kind=kInt32), intent(in) :: nRegion number of protected regions integer(kind=kInt32), intent(in) :: lPos (:) positions of the first character of protected regions integer(kind=kInt32), intent(in) :: rPos (:) positions of the last character of protected regions logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit.","tags":"","loc":"interface\\changecase.html"},{"title":"BlankCompressChangeCase – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BlankCompressChangeCase Function Interface : BlankCompressChangeCase Purpose :  To first remove all blank characters and then change case of all\n               alphabet characters of the specified character string according\n               to the given flag. Usage : --->    OutStr = BlankCompressChangeCase(InStr, .TRUE.) Functions private module function BlankCompressChangeCase(cStrIn, ToUpper) result(cStrOut) To first remove all blank characters and then change case of all alphabet\n characters of the specified character string according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\blankcompresschangecase.html"},{"title":"InsertSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface InsertSubstring Function Interface : InsertSubstring Purpose :  To insert a given substring into the character string at a\n               specified position. Usage : --->    OutStr = InsertSubstring(InStr, Pos, SubStr) Functions private module function InsertSubstring(cStrIn, Pos, sStr) result(cStrOut) To insert a given substring into the character string at a\n specified position. If the Pos argument is less than 1, then 1 is used as an insertion point. If the Pos argument is greater than length of the character string, then\n the substring is inserted at the end of the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: Pos the insertion point character(kind=kChar, len=*), intent(in) :: sStr substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\insertsubstring.html"},{"title":"RemoveCharacters – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RemoveCharacters Function Interface : RemoveCharacters Purpose :  To remove characters from the character string depending on\n               specified input. Usage : --->    OutStr = RemoveCharacters(InStr, CharSet) --->    OutStr = RemoveCharacters(InStr, CharSet, Option=2) Functions private module function RemoveCharacters(cStrIn, ChrSet, Option) result(cStrOut) To remove characters from the character string depending on\n the specified character set and optionally the option flag. The ChrSet argument is a required input that contains a set of\n characters to be removed whereas the Option argument is an\n optional input that indicates where characters in the character\n string to be removed are.  Available options include: - Option = -1 --> nothing to be removed. - Option =  0 --> leading (prefix) and trailing (suffix) character(s)\n                   to be removed. - Option =  1 --> leading (prefix) character(s) to be removed. - Option =  2 --> trailing (suffix) character(s) to be removed. - Option =  3 --> all characters in the ChrSet set to be removed. If the Option argument is not present, the default option is set to 0. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: ChrSet set of characters to be removed integer(kind=kInt32), intent(in), optional :: Option flag indicating how to remove characters Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\removecharacters.html"},{"title":"RemoveCharactersProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RemoveCharactersProtect Function Interface : RemoveCharactersProtect Purpose :  To remove characters from the character string depending on\n               specified input. Usage : --->    OutStr = RemoveCharactersProtect(InStr, CharSet) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, Option=2) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, ExclMrk=.FALSE.) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, 3, .FALSE.) Functions private module function RemoveCharactersProtect(cStrIn, ChrSet, Option, ExclMrk) result(cStrOut) To remove characters from the unprotected regions of the character string\n depending on the specified character set and optionally the option flag. See the RemoveCharacters routine for explanations regarding the ChrSet and Option arguments. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: ChrSet set of characters to be removed integer(kind=kInt32), intent(in), optional :: Option flag indicating how to remove characters logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\removecharactersprotect.html"},{"title":"RemoveSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RemoveSubstring Function Interface : RemoveSubstring Purpose :  To remove the substring from the character string based on\n               specified input. Usage : --->    OutStr = RemoveSubstring(InStr, SubStr) --->    OutStr = RemoveSubstring(InStr, SubStr, FirstOnly=.TRUE.) --->    OutStr = RemoveSubstring(InStr, sLen, sCount, sPos) --->    OutStr = RemoveSubstring(InStr, lPos, rPos) Functions private module function RemoveSubstring(cStrIn, sStr, FirstOnly) result(cStrOut) To remove the substring from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: sStr substring to be removed logical, intent(in), optional :: FirstOnly flag indicating whether to remove only the first substring found or to\n remove all occurrences found. If true, only remove the first substring found; otherwise, remove all\n (non-overlapping) occurrences found. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string private recursive module function RemoveSubstringKnownPos(cStrIn, sLen, sCount, sPos) result(cStrOut) To remove substring from the character string by providing length, number of\n occurrences and position(s) of first character of the substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: sLen length of the substring to be removed integer(kind=kInt32), intent(in) :: sCount number of occurrences of the substring integer(kind=kInt32), intent(in) :: sPos (sCount) position(s) of first character of the substring Return Value character(kind=kChar, len=:), ALLOCATABLE output character string private module function DeleteSubstring(cStrIn, lPos, rPos) result(cStrOut) To remove substring from the character string at specified positions. If the lPos argument is less than 1, then 1 is used as a starting point\n of the substring. Similarly, if the rPos argument is greater than length of the character\n string, then the length is used as a ending point. If the rPos argument is less than the lPos argument, the original\n character string is returned. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: lPos the leftmost character position of the substring integer(kind=kInt32), intent(in) :: rPos the rightmost character position of the substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\removesubstring.html"},{"title":"RemoveSubstringProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RemoveSubstringProtect Function Interface : RemoveSubstringProtect Purpose :  To remove the substring from the unprotected regions of the\n               character string based on specified input. Usage : --->    OutStr = RemoveSubstringProtect(InStr, SubStr) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, ExclMrk=.FALSE.) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, FirstOnly=.TRUE.) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, .FALSE., .TRUE.) Functions private recursive module function RemoveSubstringProtect(cStrIn, sStr, ExclMrk, FirstOnly) result(cStrOut) To remove the substring from the unprotected regions of the character\n string based on specified input. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: sStr substring to be removed logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. logical, intent(in), optional :: FirstOnly flag indicating whether to remove only the first substring found or to\n remove all occurrences found. If true, only remove the first substring found; otherwise, remove all\n (non-overlapping) occurrences found. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\removesubstringprotect.html"},{"title":"ReplaceSubstring – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ReplaceSubstring Function Interface : ReplaceSubstring Purpose :  To replace all occurrences of the original substring found\n               in the given character string with the new substring based\n               on specified input. Usage : --->    OutStr = ReplaceSubstring(InStr, OldSub, NewSub) --->    OutStr = ReplaceSubstring(InStr, NewSub, OldLen, OldCount, OldPos) Functions private module function ReplaceSubstring(cStrIn, oStr, nStr) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring Return Value character(kind=kChar, len=:), ALLOCATABLE output character string private recursive module function ReplaceSubstringKnownPos(cStrIn, nStr, oLen, oCount, oPos) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring by providing length, number of\n occurrences and position(s) of first character of original substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: nStr new substring integer(kind=kInt32), intent(in) :: oLen length of original substring integer(kind=kInt32), intent(in) :: oCount number of occurrences of original substring integer(kind=kInt32), intent(in) :: oPos (oCount) position(s) of first character of original substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\replacesubstring.html"},{"title":"ReplaceSubstringProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ReplaceSubstringProtect Function Interface : ReplaceSubstringProtect Purpose :  To replace all occurrences of the original substring found\n               in unprotected regions of the given character string with\n               the new substring. Usage : --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub) --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub, ExclMrk=.FALSE.) Functions private recursive module function ReplaceSubstringProtect(cStrIn, oStr, nStr, ExclMrk) result(cStrOut) To replace all occurrences of the original substring found in unprotected\n regions of the given character string with the new substring. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value character(kind=kChar, len=:), ALLOCATABLE output character string","tags":"","loc":"interface\\replacesubstringprotect.html"},{"title":"ReplaceSubstringRecursive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ReplaceSubstringRecursive Function Interface : ReplaceSubstringRecursive Purpose :  To replace all occurrences of the original substring found\n               in the given character string with the new substring in\n               a recursive way. Usage : --->    OutStr = ReplaceSubstringRecursive(InStr, OldSub, NewSub) Example : Input : cStrIn = 'abbbbb', oStr = 'ab', nStr = 'a' Output - non-recursive: cStrOut = 'abbbb' Output - recursive: cStrOut = 'ab' Functions private module function ReplaceSubstringRecursive(cStrIn, oStr, nStr) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring in a recursive way. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string","tags":"","loc":"interface\\replacesubstringrecursive.html"},{"title":"Partition – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Partition Subroutine Interface : Partition Purpose :  To partition a character string into two substrings by a\n               separator (single character or a multiple-character string).\n               The partition occurs at the first occurrence of the separator\n               found. Usage : ! SepSub is a multiple-character string separator. --->    CALL Partition(cStr, SepSub, bStr, aStr) ! SepSet is a set of characters where a character in the set is a valid ! separator.  Also, search the first separator from the back. --->    CALL Partition(cStr, SepSet, bStr, aStr, SepChr, Back=.TRUE.) Subroutines private module subroutine PartitionSepSub(cStr, SepSub, bStr, aStr, Back) To partition a character string into two substrings where the specified\n separator is a multiple-character string.  The partition occurs at the\n first occurrence of the separator found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator character(kind=kChar, len=:), intent(out), ALLOCATABLE :: bStr substring before the separator found character(kind=kChar, len=:), intent(out), ALLOCATABLE :: aStr substring after the separator found logical, intent(in), optional :: Back flag indicating whether to search the separator from the back or not. - True: search the separator from the back. - False: search the separator from the front. Default is false. private module subroutine PartitionSepChr(cStr, SepSet, bStr, aStr, SepChr, Back) To partition a character string into two substrings where the separator\n is a single character (any character in the specified set of characters).\n The partition occurs at the first occurrence of the separator found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators character(kind=kChar, len=:), intent(out), ALLOCATABLE :: bStr substring before the separator found character(kind=kChar, len=:), intent(out), ALLOCATABLE :: aStr substring after the separator found character(kind=kChar, len=1), intent(out) :: SepChr the separator found logical, intent(in), optional :: Back flag indicating whether to search the separator from the back or not. - True: search the separator from the back. - False: search the separator from the front. Default is false.","tags":"","loc":"interface\\partition.html"},{"title":"Split – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Split Subroutine Interface : Split Purpose :  To split a character string into multiple substrings by a\n               separator (single character or a multiple-character string). Usage : ! SepSub is a multiple-character string separator. --->    CALL Split(cStr, SepSub, qStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL Split(cStr, SepSet, qStr, SepChr) Subroutines private module subroutine SplitSepSub(cStr, SepSub, qStr) To split a character string into multiple substrings where the specified\n separator is a multiple-character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator type(QueueChar), intent(out) :: qStr queue of substrings private module subroutine SplitSepChr(cStr, SepSet, qStr, SepChr) To split a character string into multiple substrings where the separator\n is a single character (any character in the specified set of characters). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators type(QueueChar), intent(out) :: qStr queue of substrings character(kind=kChar, len=1), intent(out), ALLOCATABLE :: SepChr (:) separators found","tags":"","loc":"interface\\split.html"},{"title":"SplitProtect – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SplitProtect Subroutine Interface : SplitProtect Purpose :  To split a character string into multiple substrings by a\n               separator (single character or a multiple-character string)\n               found in unprotected region(s). Usage : ! SepSub is a multiple-character string separator. --->    CALL SplitProtect(cStr, SepSub, qStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL SplitProtect(cStr, SepSet, qStr, SepChr) ! The exclamation mark is NOT used to define the protected regions. --->    CALL SplitProtect(cStr, SepSub, qStr, ExclMrk=.FALSE.) Subroutines private module subroutine SplitSepSubProtect(cStr, SepSub, qStr, ExclMrk) To split a character string into multiple substrings where the specified\n separator is a multiple-character string found in unprotected region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator type(QueueChar), intent(out) :: qStr queue of substrings logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. private module subroutine SplitSepChrProtect(cStr, SepSet, qStr, SepChr, ExclMrk) To split a character string into multiple substrings where the separator\n is a single character (any character in the specified set of characters)\n found in unprotected region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators type(QueueChar), intent(out) :: qStr queue of substrings character(kind=kChar, len=1), intent(out), ALLOCATABLE :: SepChr (:) separators found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true.","tags":"","loc":"interface\\splitprotect.html"},{"title":"hashPOSIX_GetChar – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  function hashPOSIX_GetChar(Name) result(C) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=5), intent(in) :: Name To check whether the given character is in the given ASCII range\n  from ASCII_Min to ASCII_Max.\n** SUBROUTINE ARGUMENT DECLARATIONS: Return Value character(kind=kChar, len=1) Source Code FUNCTION hashPOSIX_GetChar ( Name ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !> To check whether the given character is in the given ASCII range !  from ASCII_Min to ASCII_Max. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharLen ( 5 ), INTENT ( IN ) :: Name ! class name tChar :: C ! character representing the class !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I !** FLOW: DO I = 1 , SIZE ( hashPOSIX ) IF ( Name == hashPOSIX ( I )% Name ) THEN C = hashPOSIX ( I )% C RETURN END IF END DO C = OP_STAR RETURN END FUNCTION hashPOSIX_GetChar","tags":"","loc":"proc\\hashposix_getchar.html"},{"title":"Rank_Insensitive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Rank_Insensitive Subroutine Interface : Rank_Insensitive Purpose :  To rank an array of strings in an ascending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! rank an array of Fortran intrinsic character strings --->    CALL Rank_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! rank an array of FvlStr objects --->    CALL Rank_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. Module Procedures private  subroutine ChrStr_RankInsensitive(AVal, AInd, RankArray) To perform data ranking for an array of character strings where\n the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) array values to be ranked integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) indices indicating the ranking procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_RankInsensitive(AVal, AInd, RankArray) To perform data ranking for an array of FvlStr objects where\n the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: AVal (:) array values to be ranked integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) indices indicating the ranking procedure(ComparableRank) :: RankArray procedure to perform ranking","tags":"","loc":"interface\\rank_insensitive.html"},{"title":"SortAscend_Insensitive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SortAscend_Insensitive Subroutine Interface : SortAscend_Insensitive Purpose :  To sort an array of strings in an ascending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! sort an array of Fortran intrinsic character strings --->    CALL SortAscend_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! sort an array of FvlStr objects --->    CALL SortAscend_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. Module Procedures private  subroutine ChrStr_SortInsensitive_Ascend(AVal, RankArray) To perform data sorting in ascending order for an array of\n character strings where the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: AVal (:) array values to be ranked procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_SortInsensitive_Ascend(AVal, RankArray) To perform data sorting in ascending order for an array of\n FvlStr objects where the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array values to be ranked procedure(ComparableRank) :: RankArray procedure to perform ranking","tags":"","loc":"interface\\sortascend_insensitive.html"},{"title":"SortDescend_Insensitive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SortDescend_Insensitive Subroutine Interface : SortDescend_Insensitive Purpose :  To sort an array of strings in a descending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! sort an array of Fortran intrinsic character strings --->    CALL SortDescend_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! sort an array of FvlStr objects --->    CALL SortDescend_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. Module Procedures private  subroutine ChrStr_SortInsensitive_Descend(AVal, RankArray) To perform data sorting in descending order for an array of\n character strings where the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: AVal (:) array values to be ranked procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_SortInsensitive_Descend(AVal, RankArray) To perform data sorting in descending order for an array of\n FvlStr objects where the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array values to be ranked procedure(ComparableRank) :: RankArray procedure to perform ranking","tags":"","loc":"interface\\sortdescend_insensitive.html"},{"title":"LSDSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LSDSort Subroutine Interface : LSDSort Purpose :  To sort an array of strings in an ascending order using the LSD\n      string sorting algorithm. Usage : --->    CALL LSDSort(cStrArr) Note : This procedure is only applicable for Fortran character strings. Module Procedures private  subroutine ChrStr_LSDSort(A) To sort an array of character strings in an ascending order using\n the least-significant-digit (LSD) string sorting algorithm, which\n is preferable for same-length strings. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted","tags":"","loc":"interface\\lsdsort.html"},{"title":"MSDSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MSDSort Subroutine Interface : MSDSort Purpose :  To sort an array of strings in an ascending order using the MSD\n      string sorting algorithm. Usage : --->    CALL MSDSort(Arr) Module Procedures private  subroutine ChrStr_MSDSort(A) To sort an array of character strings in an ascending order using\n the most-significant-digit (MSD) string sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_MSDSort(A) To sort an array of FvlStr objects in an ascending order using\n the most-significant-digit (MSD) string sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted","tags":"","loc":"interface\\msdsort.html"},{"title":"MSDInplaceSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MSDInplaceSort Subroutine Interface : MSDInplaceSort Purpose :  To sort an array of strings in an ascending order using the\n      in-place MSD string sorting algorithm.  Optionally, if all characters\n      of the strings are in a particular alphabet set, a user can specify an Alphabet data type of that particular alphabet set. Usage : --->    CALL MSDInplaceSort(Arr) --->    CALL MSDInplaceSort(Arr, Alphabet) Usage : See the Class_Alphabets module for various alphabet data types available to be used with the MSDInplaceSort procedure. Module Procedures private  subroutine ChrStr_MSDSort_Inplace(A) To sort an array of character strings in an ascending order using\n the in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_MSDSort_Inplace(A) To sort an array of FvlStr objects in an ascending order using\n the in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted private  subroutine ChrStr_MSDSort_Alphabet(A, Alpha) To sort an array of character strings (where all characters of the strings are\n in a particular alphabet set of characters) in an ascending order using the\n in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object private  subroutine FvlStr_MSDSort_Alphabet(A, Alpha) To sort an array of FvlStr objects (where all characters of their strings are\n in a particular alphabet set of characters) in an ascending order using the\n in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object","tags":"","loc":"interface\\msdinplacesort.html"},{"title":"QuickMultiKeySort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickMultiKeySort Subroutine Interface : QuickMultiKeySort Purpose :  To sort an array of strings in an ascending order using the\n      multi-key quicksort (or 3-way radix quicksort) algorithm. Usage : --->    CALL QuickMultiKeySort(Arr) Module Procedures private  subroutine ChrStr_QuickMultiKeySort(A) To sort an array of character strings in an ascending order using\n the three-way radix quicksort (or multi-key quicksort) algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_QuickMultiKeySort(A) To sort an array of FvlStr objects in an ascending order using\n the three-way radix quicksort (or multi-key quicksort) algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted","tags":"","loc":"interface\\quickmultikeysort.html"},{"title":"AmericanFlagSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface AmericanFlagSort Subroutine Interface : AmericanFlagSort Purpose :  To sort an array of strings in an ascending order using the\n      American-flag algorithm. Usage : --->    CALL AmericanFlagSort(Arr) Module Procedures private  subroutine ChrStr_AmericanFlagSort(A) To sort an array of character strings in an ascending order using the American\n flag algorithm. REFERENCES : [1] P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems,\n     Vol. 6, No. 1. [2] Java Code: Non-recursive Americal Flag Sort. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_AmericanFlagSort(A) To sort an array of character strings in an ascending order using the American\n flag algorithm. REFERENCES : [1] P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems,\n     Vol. 6, No. 1. [2] Java Code: Non-recursive Americal Flag Sort. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted","tags":"","loc":"interface\\americanflagsort.html"},{"title":"BitmapState_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine BitmapState_New(State, ID, Manager) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitmapState ), intent(inout), POINTER :: State integer(kind=kInt32), intent(in) :: ID type( BitmapStateManager ), intent(in) :: Manager Source Code SUBROUTINE BitmapState_New ( State , ID , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapState ), POINTER , INTENT ( INOUT ) :: State tSInt32 , INTENT ( IN ) :: ID TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMState )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMState ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % StateID = 0_kIndex CALL Handle_ErrAlloc ( 'BitmapState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % StateID = 1_kIndex ELSEIF ( BMSMemManger % StateID == SIZE ( BMSMemManger % BMState , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitmapState ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( BMSMemManger % BMState ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitmapState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( BMSMemManger % BMState )) = BMSMemManger % BMState CALL MOVE_ALLOC ( NewState , BMSMemManger % BMState ) BMSMemManger % StateID = BMSMemManger % StateID + 1 END BLOCK END IF ! set pointer to the storage State => BMSMemManger % BMState ( BMSMemManger % StateID ) CALL State % Construct ( ID , Manager ) RETURN END SUBROUTINE BitmapState_New","tags":"","loc":"proc\\bitmapstate_new.html"},{"title":"BitmapStatePack_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine BitmapStatePack_New(Pack, Manager) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitmapStatePack ), intent(inout), POINTER :: Pack type( BitmapStateManager ), intent(in) :: Manager Source Code SUBROUTINE BitmapStatePack_New ( Pack , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), POINTER , INTENT ( INOUT ) :: Pack TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMPack )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMPack ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % PackID = 0_kIndex CALL Handle_ErrAlloc ( 'BitmapStatePack_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % PackID = 1_kIndex ELSEIF ( BMSMemManger % PackID == SIZE ( BMSMemManger % BMPack , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitmapStatePack ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( BMSMemManger % BMPack ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitmapStatePack_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( BMSMemManger % BMPack )) = BMSMemManger % BMPack CALL MOVE_ALLOC ( NewState , BMSMemManger % BMPack ) BMSMemManger % PackID = BMSMemManger % PackID + 1 END BLOCK END IF ! set pointer to the storage Pack => BMSMemManger % BMPack ( BMSMemManger % PackID ) CALL Pack % Construct ( Manager ) RETURN END SUBROUTINE BitmapStatePack_New","tags":"","loc":"proc\\bitmapstatepack_new.html"},{"title":"BitMapNode_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine BitMapNode_New(Node, Chr, Manager, StatePack) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitMapNode ), intent(inout), POINTER :: Node character(kind=kChar, len=1), intent(in) :: Chr type( BitmapStateManager ), intent(in) :: Manager type( BitmapStatePack ), intent(in), optional, TARGET :: StatePack Source Code SUBROUTINE BitMapNode_New ( Node , Chr , Manager , StatePack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitMapNode ), POINTER , INTENT ( INOUT ) :: Node tChar , INTENT ( IN ) :: Chr TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager TYPE ( BitmapStatePack ), TARGET , OPTIONAL , INTENT ( IN ) :: StatePack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMNode )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % NodeID = 0_kIndex CALL Handle_ErrAlloc ( 'BitMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % NodeID = 1_kIndex ELSEIF ( BMSMemManger % NodeID == SIZE ( BMSMemManger % BMNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitMapNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( BMSMemManger % BMNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( BMSMemManger % BMNode )) = BMSMemManger % BMNode CALL MOVE_ALLOC ( NewNode , BMSMemManger % BMNode ) BMSMemManger % NodeID = BMSMemManger % NodeID + 1 END BLOCK END IF ! set pointer to the storage Node => BMSMemManger % BMNode ( BMSMemManger % NodeID ) CALL Node % Construct ( Chr , Manager , StatePack ) RETURN END SUBROUTINE BitMapNode_New","tags":"","loc":"proc\\bitmapnode_new.html"},{"title":"BitmapState_Free – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine BitmapState_Free() To free all the nodes linked to the specified node. Arguments None Source Code SUBROUTINE BitmapState_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( BMSMemManger % BMNode )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMNode , KIND = kIndex ) CALL BMSMemManger % BMNode ( I )% MemFree () END DO DEALLOCATE ( BMSMemManger % BMNode ) END IF IF ( ALLOCATED ( BMSMemManger % BMPack )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMPack , KIND = kIndex ) CALL BMSMemManger % BMPack ( I )% Destruct () END DO DEALLOCATE ( BMSMemManger % BMPack ) END IF IF ( ALLOCATED ( BMSMemManger % BMState )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMState , KIND = kIndex ) CALL BMSMemManger % BMState ( I )% Destruct () END DO DEALLOCATE ( BMSMemManger % BMState ) END IF BMSMemManger % PackID = 0_kIndex BMSMemManger % StateID = 0_kIndex BMSMemManger % NodeID = 0_kIndex RETURN END SUBROUTINE BitmapState_Free","tags":"","loc":"proc\\bitmapstate_free.html"},{"title":"NFAState_New – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine NFAState_New(State, ID) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( NFAState ), intent(inout), POINTER :: State integer(kind=kInt32), intent(in) :: ID Source Code SUBROUTINE NFAState_New ( State , ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( NFAState ), POINTER , INTENT ( INOUT ) :: State tSInt32 , INTENT ( IN ) :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( NFAMemManger % State )) THEN ! need allocation ALLOCATE ( NFAMemManger % State ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN NFAMemManger % StateID = 0_kIndex CALL Handle_ErrAlloc ( 'NFAState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NFAMemManger % StateID = 1_kIndex ELSEIF ( NFAMemManger % StateID == SIZE ( NFAMemManger % State , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( NFAState ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( NFAMemManger % State ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'NFAState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( NFAMemManger % State )) = NFAMemManger % State CALL MOVE_ALLOC ( NewState , NFAMemManger % State ) NFAMemManger % StateID = NFAMemManger % StateID + 1 END BLOCK END IF ! set pointer to the storage State => NFAMemManger % State ( NFAMemManger % StateID ) CALL State % Construct ( ID ) RETURN END SUBROUTINE NFAState_New","tags":"","loc":"proc\\nfastate_new.html"},{"title":"NFAState_Free – eXPerimental Fortran Library (XpfLib) Documentation","text":"public  subroutine NFAState_Free() To free all the nodes linked to the specified node. Arguments None Source Code SUBROUTINE NFAState_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( NFAMemManger % Node )) THEN DO I = 1_kIndex , SIZE ( NFAMemManger % Node , KIND = kIndex ) CALL NFAMemManger % Node ( I )% MemFree () END DO DEALLOCATE ( NFAMemManger % Node ) END IF IF ( ALLOCATED ( NFAMemManger % State )) THEN DO I = 1_kIndex , SIZE ( NFAMemManger % State , KIND = kIndex ) CALL NFAMemManger % State ( I )% MemFree () END DO DEALLOCATE ( NFAMemManger % State ) END IF NFAMemManger % StateID = 0_kIndex NFAMemManger % NodeID = 0_kIndex RETURN END SUBROUTINE NFAState_Free","tags":"","loc":"proc\\nfastate_free.html"},{"title":"MBase_CharConv – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains routines that perform a conversion between a number and a decimal\n  string.  The routines can be categorized into 4 groups: - real-to-string conversion routines, - real-from-string conversion routines, - integer-to-string conversion routines, and - integer-from-string conversion routines. For real-number conversions, routines for all three common (single, double and quadruple)\n  precisions are provided.  For integer-number conversions, only routines for 32-bit and\n  64-bit integers are provided. Technical Notes for Integer-From-String Conversions : When parsing a decimal string as an integer number, the string can be interpreted as a Fortran number, a FPlus number or a JSON number.  The following list provides a\n  description of these interpretations. 1. A Fortran number ( FortNum ) is strictly interpreted as an integer number that has\n     the form as: [S]N[N...] where - S is a sign indicator (required if negative '-', optional if positive '+'). - N is a decimal digit (0 through 9). Any leading zeros, leading and trailing\n          spaces are ignored. Unlike Fortran constants, the optional kind parameter (_k) is not allowed here. 2. A FPlus number ( FortPlus ) has a slightly more relaxed rule than that of a Fortran\n     number such that any invalid characters after characters that are valid are ignored.\n     For example, -3567e23 is treated as a valid number with a value of -3567. 3. A JSON number ( JsonNum ) has a slightly stricter rule than that of a Fortran number\n     such that a plus sign and leading zeroes are not allowed. Technical Notes for Real-From-String Conversions : Similarly, when parsing a decimal string as a real number, the string can also be interpreted\n  as a Fortran number, a FPlus number or a JSON number.  The following list provides a\n  description of these interpretations. 1. A Fortran number ( FortNum ) is strictly interpreted as a real number that has one of the\n     two following forms: <1> A number without exponent part -> [S]N[N...], and <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] where - [ ] indicates an optional field. - S is a sign indicator (required if negative '-', optional if positive '+'). - N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere\n              after the sign (but before the exponent). - E is an exponent indicator (either 'e' or 'E'). The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. - The optional kind parameter (e.g. 1.23_DP) is not allowed here. Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered\n     valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\"\n     is considered NOT valid. Therefore, this routine is not totally compatible with Fortran READ statement where spaces inside the valid number are allowed. However, this can easily be done by\n     adding an optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or\n     'ignored'.  Then, the input will be pre-processed according to the flag.  Nonetheless, this routine\n     neglects this optional input because it will make the routine much less efficient due to the fact\n     that we will need to scan the whole string twice and we will also need to copy the input string\n     into a buffer string and working with the buffer instead of directly handling the input string. 2. A FPlus number ( FortPlus ) is interpreted as a real number with more relaxed rules than\n     a Fortran number.  The relaxed rules consider the following numbers as valid: - A number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' in place of 'e' or\n       'E'. - A number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to be a valid number\n       expressed in the scientific format where an exponent indicator is omitted. - Digits before any invalid character encountered are treated as a valid number and any characters\n       after the first encounter (including the first invalid one) are neglected.  Therefore, for example,\n       a '12.56ax-300' string is considered to be a valid number with a value of 12.56. 3. A JSON number ( JsonNum ) has a slightly stricter rule than that of a Fortran number where its\n     differences from Fortran number are as follows: - Leading and trailing spaces are not allowed. - A plus sign as the first character is not allowed. - Leading zero(s) is not allowed (if 0 is the first character, the second one must either be a\n       period or an exponent indicator.) - A period must be followed by at least one digit. Uses MBase_Common Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: FortNum = 1 integer(kind=kInt32), public, parameter :: FPlusNum = 2 integer(kind=kInt32), public, parameter :: JsonNum = 3 Interfaces interface public module function RealSP_ToString_DragonBox(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealSP_ToString_Ryu(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character\n (decimal) string using the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealSP_ToString_Schubfach(Number, IsScientific) result(cStr) To convert a single-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealSP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision\n floating-point value using the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number interface public module function RealSP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision\n floating-point value using the LibC algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number interface public module function RealSP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision\n floating-point value using the YY algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number interface public module function RealSP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a single-precision\n floating-point value using the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) floating-point number interface public module function RealDP_ToString_DragonBox(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealDP_ToString_Ryu(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character\n (decimal) string using the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealDP_ToString_Schubfach(Number, IsScientific) result(cStr) To convert a double-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealDP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision\n floating-point value using the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number interface public module function RealDP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision\n floating-point value using the LibC algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number interface public module function RealDP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision\n floating-point value using the YY algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number interface public module function RealDP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a double-precision\n floating-point value using the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) floating-point number interface public module function RealQP_ToString_DragonBox(Number, IsScientific) result(cStr) To convert a quadruple-precision floating-point value to a character\n (decimal) string using the DragonBox algorithm. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealQP_ToString_Ryu(Number, IsScientific) result(cStr) To convert a quadruple-precision floating-point value to a character\n (decimal) string using the Ryu algorithm. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealQP_ToString_Schubfach(Number, IsScientific) result(cStr) To convert a quadruple-precision floating-point value to a character\n (decimal) string using the Schubfach algorithm. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: Number number logical, intent(in), optional :: IsScientific format flag - true  if to write the given number in scientific format. - false if to write the given number in general format. - default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function RealQP_FromString_FastFloat(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a quadruple-precision\n floating-point value using the FastFloat algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number interface public module function RealQP_FromString_LibC(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a quadruple-precision\n floating-point value using the LibC algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number interface public module function RealQP_FromString_YY(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a quadruple-precision\n floating-point value using the YY algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number interface public module function RealQP_FromString_Lemire(cStr, ParseOpt, ErrFlag, ErrMsg) result(Number) To convert a character (decimal) string to a quadruple-precision\n floating-point value using the Lemire algorithm. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: ParseOpt flag indicating how to interpret the input string - FortNum (or 1): interpreted as a strict Fortran number, - FPlusNum (or 2): interpreted as a relaxed Fortran number, or - JsonNum (or 3): interpreted as a JSON number. logical, intent(out), optional :: ErrFlag true if error occurred character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) floating-point number interface public module function I32_ToChar_Basic(Number) result(cStr) To convert a 32-bit integer number to a character (decimal)\n string using the basic algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I32_ToChar_CC(Number) result(cStr) To convert a 32-bit integer number to a character (decimal)\n string using the CC algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I32_ToChar_YY(Number) result(cStr) To convert a 32-bit integer number to a character (decimal)\n string using the YY algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I32_ToChar_YYLL(Number) result(cStr) To convert a 32-bit integer number to a character (decimal)\n string using the YY algorithm with large tables. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I32_ToChar_JEA(Number) result(cStr) To convert a 32-bit integer number to a character (decimal)\n string using the JEA algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I64_ToChar_Basic(Number) result(cStr) To convert a 64-bit integer number to a character (decimal)\n string using the basic algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I64_ToChar_CC(Number) result(cStr) To convert a 64-bit integer number to a character (decimal)\n string using the CC algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I64_ToChar_YY(Number) result(cStr) To convert a 64-bit integer number to a character (decimal)\n string using the YY algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I64_ToChar_YYLL(Number) result(cStr) To convert a 64-bit integer number to a character (decimal)\n string using the YY algorithm with large tables. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I64_ToChar_JEA(Number) result(cStr) To convert a 64-bit integer number to a character (decimal)\n string using the JEA algorithm. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: Number number Return Value character(kind=kChar, len=:), ALLOCATABLE character string interface public module function I32_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a Fortran number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number interface public module function I32_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a FPlus number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number interface public module function I32_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer value using the\n CC algorithm where the string is interpreted as a JSON number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number interface public module function I32_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer value using the\n Lemire algorithm where the string is interpreted as a FPlus number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number interface public module function I32_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 32-bit integer value using the\n YY algorithm where the string is interpreted as a JSON number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt32) number interface public module function I64_FromChar_CC_FortNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a Fortran number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number interface public module function I64_FromChar_CC_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a FPlus number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number interface public module function I64_FromChar_CC_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer value using the\n CC algorithm where the string is interpreted as a JSON number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number interface public module function I64_FromChar_Lemire_FortPlus(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer value using the\n Lemire algorithm where the string is interpreted as a FPlus number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number interface public module function I64_FromChar_YY_JsonNum(cStr, ErrFlag, ErrMsg) result(Number) To convert a decimal string to a 64-bit integer value using the\n YY algorithm where the string is interpreted as a JSON number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value integer(kind=kInt64) number","tags":"","loc":"module\\mbase_charconv.html"},{"title":"MClass_SyntaxNode – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SyntaxNode type and its related routines.\n  The SyntaxNode type is a derived type representing a ... Uses MClass_Object MBase_Common MBase_ErrHandlers MClass_IntrusiveLinkedLists MBase_SIntUtil Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: Node_Undefined = 0 integer(kind=kInt32), public, parameter :: LeafNode_Null = 1 integer(kind=kInt32), public, parameter :: LeafNode_Char = 2 integer(kind=kInt32), public, parameter :: LeafNode_Closure = 3 integer(kind=kInt32), public, parameter :: BranchNode_Or = 4 integer(kind=kInt32), public, parameter :: BranchNode_Many = 5 integer(kind=kInt32), public, parameter :: BranchNode_Concat = 6 integer(kind=kInt32), public, parameter :: BranchNode_LBracket = 7 integer(kind=kInt32), public, parameter :: BranchNode_RBracket = 8 Derived Types type, public, extends(DoublyLinkedNode) :: SyntaxNode The SyntaxNode type is a node type... Components Type Visibility Attributes Name Initial integer(kind=kInt32), public :: Type = Node_Undefined node type integer(kind=kInt32), public :: ID = 0 node identification (only used for branch nodes) character(kind=kChar, len=1), public :: C = NULCHR character used only for LeafNode_Char Type-Bound Procedures procedure, public :: Copy => SyntaxNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => SyntaxNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => SyntaxNode_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). procedure, public :: ToString => SyntaxNode_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: GetRight => SyntaxNode_GetRightNode Type-Bound Function : GetRight Purpose :  To get a pointer to the right node of the current node. Usage : --->    RightNode => CurrNode%GetRight() procedure, public :: GetLeft => SyntaxNode_GetLeftNode Type-Bound Function : GetLeft Purpose :  To get a pointer to the left node of the current node. Usage : --->    LeftNode => CurrNode%GetLeft() procedure, public :: SetRight => SyntaxNode_SetRightNode Type-Bound Subroutine : SetRight Purpose :  To set a pointer to the right node of the current node. Usage : --->    CALL CurrNode%SetRight(RightNode) procedure, public :: SetLeft => SyntaxNode_SetLeftNode Type-Bound Subroutine : SetLeft Purpose :  To set a pointer to the left node of the current node. Usage : --->    CALL CurrNode%SetLeft(LeftNode) procedure, public :: HasRight => SyntaxNode_HasRightNode Type-Bound Function : HasRight Purpose :  To check whether the right node of the specified node is associated or not. Usage : --->    Flag = CurrNode%HasRight() --->    IF (.NOT.CurrNode%HasRight()) DoSomething procedure, public :: HasLeft => SyntaxNode_HasLeftNode Type-Bound Function : HasLeft Purpose :  To check whether the left node of the specified node is associated or not. Usage : --->    Flag = CurrNode%HasLeft() --->    IF (.NOT.CurrNode%HasLeft()) DoSomething procedure, public :: Operate => SyntaxNode_Operate Type-Bound Subroutine : Operate Purpose :  To set a pointer to both the left and right nodes of the current node.\n               This operation is applicable only for the \"BranchNode_Or\", \"BranchNode_Many\",\n               or \"BranchNode_Concat\" node type. Usage : --->    CALL CurrNode%Operate(LeftNode, RightNode) procedure, public :: SetChar => SyntaxNode_SetCharacter Type-Bound Subroutine : SetChar Purpose :  To set the specified character to the current node.  This operation is\n               only applicable for the \"LeafNode_Char\" node type. Usage : --->    CALL CurrNode%SetChar(C) Subroutines public  subroutine SyntaxNode_New (Node, NodeType) To allocate the node and specify its type. Arguments Type Intent Optional Attributes Name type( SyntaxNode ), intent(inout), POINTER :: Node integer(kind=kInt32), intent(in) :: NodeType public  subroutine SyntaxNode_Free () To free all the nodes linked to the specified node. Arguments None","tags":"","loc":"module\\mclass_syntaxnode.html"},{"title":"MClass_FvlStr – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the FvlStr type and its related routines.  The FvlStr type represents a variable-length string class that provides routines to handle\n  and manipulate strings.  Functionally, it is similar to the Fortran's CHARACTER type.  However, when declared as an array, elements of the array of the FvlStr type do not have to have the same length whereas those of the Fortran intrinsic\n  type must. The procedures provided by the FvlStr type are similar to those provided in\n  the MBase_ChrStr module.  However,\n  the FvlStr type employs an object-oriented interface instead of a procedural\n  interface; thus, these procedures are type-bound.  In addition, procedures\n  similar to the Fortran intrinsic procedures (for the CHARACTER type) are also\n  provided in a procedural interface (i.e. the same as the intrinsic ones). It should be noted that the FvlStr type is a subtype of the Hashable type.\n  Therefore, all operations provided for the Object , the Comparable or\n  the Hashable types, such as sorting and containers, are also applicable to\n  the FvlStr type. Uses iso_c_binding MBase_OptimalHash32 MClass_Object MBase_Common MBase_ErrHandlers MClass_Comparable Interfaces public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a FvlStr object and an other (Fortran\n      intrinsic) type via an assignment expression. Usage : ! convert a 64-bit integer number to a FvlStr object --->    vStr = I64Num ! convert a FvlStr object to a quadruple-precision real number --->    RQPNum = vStr Important Note : The assignment and conversion operations are\n      functionally similar but have some subtle differences.  In particular\n      for those procedures that convert from a decimal string to a number,\n      the assignment procedures will silently convert to a proper value\n      (representation) if the input string is INVALID whereas the conversion procedures can optionally report the error occurred. private module subroutine FvlStr_From_CharacterString(vStr, cStr) To assign a FvlStr object from a character string. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr character(kind=kChar, len=*), intent(in) :: cStr private module subroutine FvlStr_From_CharacterArray(vStr, cArr) To assign a FvlStr object from an array of characters. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr character(kind=kChar, len=1), intent(in) :: cArr (:) private module subroutine FvlStr_From_IByte(vStr, IntNum) To assign a FvlStr object from an 8-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt8), intent(in) :: IntNum private module subroutine FvlStr_From_IShort(vStr, IntNum) To assign a FvlStr object from a 16-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt16), intent(in) :: IntNum private module subroutine FvlStr_From_Integer(vStr, IntNum) To assign a FvlStr object from a 32-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt32), intent(in) :: IntNum private module subroutine FvlStr_From_ILong(vStr, IntNum) To assign a FvlStr object from a 64-bit integer number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr integer(kind=kInt64), intent(in) :: IntNum private module subroutine FvlStr_From_RSingle(vStr, RealNum) To assign a FvlStr object from a 32-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kSingle), intent(in) :: RealNum private module subroutine FvlStr_From_RDouble(vStr, RealNum) To assign a FvlStr object from a 64-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kDouble), intent(in) :: RealNum private module subroutine FvlStr_From_RQuad(vStr, RealNum) To assign a FvlStr object from a 128-bit real number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr real(kind=kQuad), intent(in) :: RealNum private module subroutine FvlStr_From_CSingle(vStr, CmpxNum) To assign a FvlStr object from a single-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kSingle), intent(in) :: CmpxNum private module subroutine FvlStr_From_CDouble(vStr, CmpxNum) To assign a FvlStr object from a double-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kDouble), intent(in) :: CmpxNum private module subroutine FvlStr_From_CQuad(vStr, CmpxNum) To assign a FvlStr object from a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr complex(kind=kQuad), intent(in) :: CmpxNum private module subroutine FvlStr_From_Logical(vStr, Boolean) To assign a FvlStr object from a default logical value. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(out) :: vStr logical, intent(in) :: Boolean private module subroutine FvlStr_To_CharAlloc(cStr, vStr) To convert a FvlStr object to an allocatable character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CharArray_Alloc(cArr, vStr) To convert a FvlStr object to an allocatable array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(out), ALLOCATABLE :: cArr (:) type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_IByte(IntNum, vStr) To convert a FvlStr object to an 8-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_IShort(IntNum, vStr) To convert a FvlStr object to a 16-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_Integer(IntNum, vStr) To convert a FvlStr object to a 32-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_ILong(IntNum, vStr) To convert a FvlStr object to a 64-bit integer number. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: IntNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RSingle(RealNum, vStr) To convert a FvlStr object to a 32-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RDouble(RealNum, vStr) To convert a FvlStr object to a 64-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_RQuad(RealNum, vStr) To convert a FvlStr object to a 128-bit real number. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(out) :: RealNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CSingle(CmpxNum, vStr) To convert a FvlStr object to a single-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CDouble(CmpxNum, vStr) To convert a FvlStr object to a double-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_CQuad(CmpxNum, vStr) To convert a FvlStr object to a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(out) :: CmpxNum type( FvlStr ), intent(in) :: vStr private module subroutine FvlStr_To_Logical(Boolean, vStr) To convert a FvlStr object to a default logical value. Arguments Type Intent Optional Attributes Name logical, intent(out) :: Boolean type( FvlStr ), intent(in) :: vStr private module subroutine FvlStrArray_From_ChrStrArray(vStr, cStr) To assign an array of FvlStr objects from an array of character strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(out) :: vStr (:) array of FvlStr objects character(kind=kChar, len=*), intent(in) :: cStr (SIZE(vStr)) array of character strings private module subroutine FvlStrArray_From_ChrStr(vStr, cStr) To assign an array of FvlStr objects from a character string. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(out) :: vStr (:) array of FvlStr objects character(kind=kChar, len=*), intent(in) :: cStr character string public        interface FvlStr Function Interface : FvlStr Purpose :  To construct a FvlStr object based on specified input. Usage : ! construct a FvlStr object from an array of characters --->    vStr = FvlStr(cArray) ! construct a FvlStr object from double-precision real number --->    vStr = FvlStr(R64, IsScientific=.TRUE.) private module function CharacterArray_To_FvlStr(cArr, IsCString) result(vStr) To convert an array of characters to a FvlStr object. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: cArr (:) array of characters logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array must contain a null character. Default is FALSE. Return Value type( FvlStr ) FvlStr object private module function IByte_To_FvlStr(IntNum) result(vStr) To convert an 8-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function IShort_To_FvlStr(IntNum) result(vStr) To convert a 16-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function Integer_To_FvlStr(IntNum) result(vStr) To convert a 32-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function ILong_To_FvlStr(IntNum) result(vStr) To convert a 64-bit integer number to a FvlStr object. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: IntNum integer number Return Value type( FvlStr ) FvlStr object private module function RSingle_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a single-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RDouble_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a double-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function RQuad_To_FvlStr(RealNum, IsScientific) result(vStr) To convert a quadruple-precision real number to a FvlStr object. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: RealNum real number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CSingle_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a single-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CDouble_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a double-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function CQuad_To_FvlStr(CmpxNum, IsScientific) result(vStr) To convert a quadruple-precision complex number to a FvlStr object. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(in) :: CmpxNum complex number logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is false where the string is expressed in the general format. Return Value type( FvlStr ) FvlStr object private module function Logical_To_FvlStr(Boolean) result(vStr) To convert a logical value to a FvlStr object. Arguments Type Intent Optional Attributes Name logical, intent(in) :: Boolean logical value Return Value type( FvlStr ) FvlStr object public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To concatenate the first and second strings. Usage : --->    vStrOut = Str1st + Str2nd private module function Concatenate_VLS_CHS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string character(kind=kChar, len=*), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_CHS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_VLS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object public        interface OPERATOR( Operator Overload : OPERATOR('//') Purpose :  To concatenate the first and second strings. Usage : --->    vStrOut = Str1st '//' Str2nd private module function Concatenate_VLS_CHS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string character(kind=kChar, len=*), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_CHS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object private module function Concatenate_VLS_VLS(Str1st, Str2nd) result(vStrOut) To concatenate the first and second strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: Str1st the first string type( FvlStr ), intent(in) :: Str2nd the second string Return Value type( FvlStr ) output FvlStr object public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check whether two strings are equal or not. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private module function VLS_EQ_CHS(lStr, rStr) result(Flag) To perform equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_EQ_VLS(lStr, rStr) result(Flag) To perform equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check whether two strings are NOT equal or not. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private module function VLS_NE_CHS(lStr, rStr) result(Flag) To perform not-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_NE_VLS(lStr, rStr) result(Flag) To perform not-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check whether LHS string is greater than RHS string or not. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething private module function VLS_GT_CHS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_GT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check whether LHS string is greater than or equal to\n      RHS string or not. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething private module function VLS_GE_CHS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_GE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check whether LHS string is less than RHS string or not. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething private module function VLS_LT_CHS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check whether LHS string is less than or equal to\n      RHS string or not. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething private module function VLS_LE_CHS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface GETLEN Function Interface : GETLEN Purpose :  To return length of the character string of a FvlStr object. Usage : --->    Length = GETLEN(vStr) private module function GetLength(vStr) result(Length) To return length of the character string of a FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr Return Value integer(kind=kInt32) public        interface LEN_TRIM Function Interface : LEN_TRIM Purpose :  To return length of the character string of a FvlStr object\n      without counting trailing blank characters. Usage : --->    Length = LEN_TRIM(vStr) private module function GetLengthTrim(vStr) result(Length) To return length of the character string of a FvlStr object\n without counting trailing blank characters. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr Return Value integer(kind=kInt32) public        interface INDEX Function Interface : INDEX Purpose :  To return the starting position of a substring within the string\n      of a FvlStr object. Usage : --->    Indx = INDEX(vStr, sStr) --->    Indx = INDEX(vStr, sStr, Back=.TRUE.) private module function FindIndex_CHS(vStr, sStr, Back) result(Indx) To return the starting position of a substring within the string of a FvlStr object. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: sStr substring logical, intent(in), optional :: Back If present and true, searching from the back; otherwise, searching from the front. Return Value integer(kind=kInt32) starting position of a substring private module function FindIndex_VLS(vStr, sStr, Back) result(Indx) See the \"FindIndex_CHS\" procedure, where the only difference\n between these two procedures is the type of the sStr argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: sStr logical, intent(in), optional :: Back Return Value integer(kind=kInt32) public        interface SCAN Function Interface : SCAN Purpose :  To scan the string of a FvlStr object for any character in a set\n      of characters and return the position of the first character found in the\n      string that is in the specified set depending on the scanning direction. Usage : --->    Pos = SCAN(vStr, ChrSet) --->    Pos = SCAN(vStr, ChrSet, Back=.TRUE.) private module function ScanCharacters_CHS(vStr, ChrSet, Back) result(Pos) To scan the string of a FvlStr object for any character in a set of\n characters and return the position of the first character found in the\n string that is in the specified set depending on the scanning direction. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters logical, intent(in), optional :: Back If present and true, scanning from the back; otherwise, scanning from the front. Return Value integer(kind=kInt32) position of the first character found private module function ScanCharacters_VLS(vStr, ChrSet, Back) result(Pos) See the \"ScanCharacters_CHS\" procedure, where the only difference\n between these two procedures is the type of the ChrSet argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: ChrSet logical, intent(in), optional :: Back Return Value integer(kind=kInt32) public        interface VERIFY Function Interface : VERIFY Purpose :  To verify that a set of characters contains all the characters\n      in the string of a FvlStr object by identifying the first character in\n      the string that is not in the set and to return the position of the\n      first character found in the string that is NOT in the specified set\n      depending on the scanning direction. Usage : --->    Pos = VERIFY(vStr, ChrSet) --->    Pos = VERIFY(vStr, ChrSet, Back=.TRUE.) private module function VerifyCharacters_CHS(vStr, ChrSet, Back) result(Pos) To verify that a set of characters contains all the characters in\n the string of a FvlStr object by identifying the first character\n in the string that is not in the set and to return the position\n of the first character found in the string that is NOT in the\n specified set depending on the scanning direction.  If all characters\n of string are in the specified set or the length of string is zero,\n the returned value is zero. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters logical, intent(in), optional :: Back If present and true, scanning from the back; otherwise, scanning from the front. Return Value integer(kind=kInt32) position of the first character found private module function VerifyCharacters_VLS(vStr, ChrSet, Back) result(Pos) See the \"VerifyCharacters_CHS\" procedure, where the only difference\n between these two procedures is the type of the ChrSet argument. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr type( FvlStr ), intent(in) :: ChrSet logical, intent(in), optional :: Back Return Value integer(kind=kInt32) public        interface ADJUSTL Function Interface : ADJUSTL Purpose :  To adjust the string of FvlStr object to the left, removing\n      leading blanks and inserting trailing blanks. Usage : --->    vStrOut = ADJUSTL(vStrIn) private module function AdjustToLeft(vStrIn) result(vStrOut) To adjust the string of FvlStr object to the left, removing leading\n blanks and inserting trailing blanks. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr ) public        interface ADJUSTR Function Interface : ADJUSTR Purpose :  To adjust the string of FvlStr object to the right, removing\n      trailing blanks and inserting leading blanks. Usage : --->    vStrOut = ADJUSTR(vStrIn) private module function AdjustToRight(vStrIn) result(vStrOut) To adjust the string of FvlStr object to the right, removing trailing\n blanks and inserting leading blanks. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr ) public        interface TRIM Function Interface : TRIM Purpose :  To return the argument with trailing blanks removed. Usage : --->    vStrOut = TRIM(vStrIn) private module function TrimFvlStr(vStrIn) result(vStrOut) To return the argument with trailing blanks removed. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn Return Value type( FvlStr ) public        interface REPEAT Function Interface : REPEAT Purpose :  To concatenate several copies of the string of the specified\n      FvlStr object. Usage : --->    vStrOut = REPEAT(vStrIn, nCopies) private module function RepeatString(vStrIn, nCopies) result(vStrOut) To concatenate several copies of the specified string. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStrIn input FvlStr object to be repeated integer(kind=kInt32), intent(in) :: nCopies number of copies Return Value type( FvlStr ) output FvlStr object public        interface LGT Function Interface : LGT Purpose :  To check whether LHS string is lexically greater than\n      RHS string or not, based on the ASCII collating sequence, even\n      if the compiler's default collating sequence is different. Usage : --->    Flag = LGT(LHS, RHS) --->    IF (.NOT.LGT(LHS, RHS)) DoSomething private module function VLS_LGT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LGT_CHS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LGT_VLS(lStr, rStr) result(Flag) To perform greater-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface LGE Function Interface : LGE Purpose :  To check whether LHS string is lexically greater than or equal\n      to RHS string or not, based on the ASCII collating sequence, even if the\n      compiler's default collating sequence is different. Usage : --->    Flag = LGE(LHS, RHS) --->    IF (.NOT.LGE(LHS, RHS)) DoSomething private module function VLS_LGE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LGE_CHS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LGE_VLS(lStr, rStr) result(Flag) To perform greater-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface LLT Function Interface : LLT Purpose :  To check whether LHS string is lexically less than\n      RHS string or not, based on the ASCII collating sequence, even\n      if the compiler's default collating sequence is different. Usage : --->    Flag = LLT(LHS, RHS) --->    IF (.NOT.LLT(LHS, RHS)) DoSomething private module function VLS_LLT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LLT_CHS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LLT_VLS(lStr, rStr) result(Flag) To perform less-than operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface LLE Function Interface : LLE Purpose :  To check whether LHS string is lexically less than or equal\n      to RHS string or not, based on the ASCII collating sequence, even if the\n      compiler's default collating sequence is different. Usage : --->    Flag = LLE(LHS, RHS) --->    IF (.NOT.LLE(LHS, RHS)) DoSomething private module function VLS_LLE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical private module function VLS_LLE_CHS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: lStr character(kind=kChar, len=*), intent(in) :: rStr Return Value logical private module function CHS_LLE_VLS(lStr, rStr) result(Flag) To perform less-than-or-equal-to operation of two strings. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: lStr type( FvlStr ), intent(in) :: rStr Return Value logical public        interface ACHAR Function Interface : ACHAR Purpose :  To return a FvlStr object with length of 1 representing the\n      character in the specified position of the ASCII character set. Usage : --->    Chr = ACHAR(I) private module function Get_ACHAR(I) result(vStr) To get the character in the specified position of the ASCII character set. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I character code (position in the set) Return Value type( FvlStr ) FvlStr object with length of 1 public        interface CHAR Function Interface : CHAR Purpose :  To return a FvlStr object with length of 1 representing the\n      character in the specified position of the compiler's character set. Usage : --->    Chr = CHAR(I) private module function Get_CHAR(I) result(vStr) To get the character in the specified position of the processor's character set. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I character code (position in the set) Return Value type( FvlStr ) FvlStr object with length of 1 public        interface IACHAR Function Interface : IACHAR Purpose :  To return the character code based on the ASCII character set\n      of the specified character of the FvlStr object. Usage : --->    I = IACHAR(vStr, Pos) Note : A character code is a position of the character in a character set. private module function Get_IACHAR(vStr, Pos) result(I) To get the character code based on the ASCII character set of the specified\n character. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: Pos index specifying the FvlStr's character Return Value integer(kind=kInt32) the requested character code (position in the character set);\n I = -1 if invalid set of input is given. public        interface ICHAR Function Interface : ICHAR Purpose :  To return the character code based on the compiler's character set\n      of the specified character of the FvlStr object. Usage : --->    I = ICHAR(vStr, Pos) Note : A character code is a position of the character in a character set. private module function Get_ICHAR(vStr, Pos) result(I) To get the character code based on the processor's character set of the specified\n character. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: Pos index specifying the FvlStr's character Return Value integer(kind=kInt32) the requested character code (position in the character set);\n I = -1 if invalid set of input is given. public        interface WRITE(UNFORMATTED) Subroutine Interface : WRITE(UNFORMATTED) Purpose :  To write a character string of the FvlStr object to a connected\n      unformatted unit. Usage : --->    WRITE(UNIT=IOUnit) vStr private module subroutine Write_Unformatted(vStr, IOUnit, IOStat, IOMsg) To write a character string of the FvlStr object to a connected unformatted unit. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero public        interface READ(UNFORMATTED) Subroutine Interface : READ(UNFORMATTED) Purpose :  To read a character sequence from a connected unformatted unit\n      into the FvlStr object. Usage : --->    READ(UNIT=IOUnit) vStr private module subroutine Read_Unformatted(vStr, IOUnit, IOStat, IOMsg) To read a character sequence from a connected unformatted unit into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero public        interface WRITE(FORMATTED) Subroutine Interface : WRITE(FORMATTED) Purpose :  To write a character string of the FvlStr object to a connected\n      formatted unit. Usage : ! using the list-directed format output --->    WRITE(UNIT=IOUnit, FMT= ) vStr --->    WRITE(UNIT=IOUnit, FMT= , IOSTAT=IOStat, IOMSG=IOMsg) vStr ! using the DT edit descriptor --->    WRITE(UNIT=IOUnit, FMT='(DT)') vStr --->    WRITE(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr private module subroutine Write_Formatted(vStr, IOUnit, IOType, VList, IOStat, IOMsg) To write a character string of the FvlStr object to a connected formatted unit. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number character(kind=kChar, len=*), intent(in) :: IOType type of io integer(kind=kInt32), intent(in) :: VList (:) list of integer array from part of the DT edit descriptor integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero public        interface READ(FORMATTED) Subroutine Interface : READ(FORMATTED) Purpose :  To read a character sequence from a connected formatted unit\n      into the FvlStr object. Usage : ! using the list-directed format input --->    READ(UNIT=IOUnit, FMT= ) vStr --->    READ(UNIT=IOUnit, FMT= , IOSTAT=IOStat, IOMSG=IOMsg) vStr ! using the DT edit descriptor --->    READ(UNIT=IOUnit, FMT='(DT)') vStr --->    READ(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr private module subroutine Read_Formatted(vStr, IOUnit, IOType, VList, IOStat, IOMsg) To read a character sequence from a connected formatted unit into the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(inout) :: vStr FvlStr object integer(kind=kInt32), intent(in) :: IOUnit connected io unit number character(kind=kChar, len=*), intent(in) :: IOType type of io integer(kind=kInt32), intent(in) :: VList (:) list of integer array from part of the DT edit descriptor integer(kind=kInt32), intent(out) :: IOStat status of io operation character(kind=kChar, len=*), intent(inout) :: IOMsg an io message if is IOStat is non-zero public        interface Swap Subroutine Interface : Swap Purpose :  To swap values of two FvlStr objects or two arrays\n      of FvlStr objects. Usage : --->    CALL Swap(vStrA, vStrB) --->    CALL Swap(vStrArrA, vStrArrB) private module subroutine SwapFvlStr(AVal, BVal) To swap values of two FvlStr objects. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal value of A type( FvlStr ), intent(inout) :: BVal value of B private module subroutine SwapFvlStrArray(AVal, BVal) To swap values of two arrays of FvlStr objects. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array A of FvlStr objects type( FvlStr ), intent(inout) :: BVal (:) array B of FvlStr objects public        interface ToCharStar Subroutine Interface : ToCharStar Purpose :  To convert a FvlStr object to an assumed-length character string. Usage : --->    CALL ToCharStar(vStr, cStr) Important Note :  This procedure is intended to be used internally only. private  subroutine CharStar_From_FvlStr(vStr, cStr) To convert a FvlStr object to an assumed-length character string. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object character(kind=kChar, len=*), intent(out) :: cStr character string public        interface PtrToStr Function Interface : PtrToStr Purpose :  To set a pointer to the string of the FvlStr object. Usage : --->    StrPtr => PtrToStr(vStr) --->    IF (.NOT.ASSOCIATED(PtrToStr(vStr))) DoSomething Important Note :  This procedure is intended to be used internally only. private  function Pointer_To_FvlStr(vStr) result(pStr) To set a pointer to the string of the FvlStr object. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in), TARGET :: vStr FvlStr object Return Value character(kind=kChar, len=:), POINTER pointer to object's string public        interface IsReady Function Interface : IsReady Purpose :  To check whether the FvlStr object is ready to be used or not.\n      Return true if the object's string is allocated.  Otherwise, return false. Usage : --->    Flag = IsReady(vStr) --->    IF (.NOT.IsReady(vStr)) DoSomething private  function Is_FvlStr_Ready(vStr) result(Flag) To check whether the string of the FvlStr object is allocated or not.\n If allocated, return true.  Otherwise, return false. Arguments Type Intent Optional Attributes Name class( FvlStr ), intent(in) :: vStr FvlStr object Return Value logical flag indicating whether the string is allocated or not. Derived Types type, public, extends(Comparable) :: FvlStr FvlStr is a string type that represents a variable-length string class.\n It provides various methods/procedures to handle and manipulate strings. Constructor Function Interface : FvlStr Purpose :  To construct a FvlStr object based on specified input. Usage : ! construct a FvlStr object from an array of characters --->    vStr = FvlStr(cArray) ! construct a FvlStr object from double-precision real number --->    vStr = FvlStr(R64, IsScientific=.TRUE.) private\n\n                    module\n                    function CharacterArray_To_FvlStr (cArr, IsCString) To convert an array of characters to a FvlStr object. private\n\n                    module\n                    function IByte_To_FvlStr (IntNum) To convert an 8-bit integer number to a FvlStr object. private\n\n                    module\n                    function IShort_To_FvlStr (IntNum) To convert a 16-bit integer number to a FvlStr object. private\n\n                    module\n                    function Integer_To_FvlStr (IntNum) To convert a 32-bit integer number to a FvlStr object. private\n\n                    module\n                    function ILong_To_FvlStr (IntNum) To convert a 64-bit integer number to a FvlStr object. private\n\n                    module\n                    function RSingle_To_FvlStr (RealNum, IsScientific) To convert a single-precision real number to a FvlStr object. private\n\n                    module\n                    function RDouble_To_FvlStr (RealNum, IsScientific) To convert a double-precision real number to a FvlStr object. private\n\n                    module\n                    function RQuad_To_FvlStr (RealNum, IsScientific) To convert a quadruple-precision real number to a FvlStr object. private\n\n                    module\n                    function CSingle_To_FvlStr (CmpxNum, IsScientific) To convert a single-precision complex number to a FvlStr object. private\n\n                    module\n                    function CDouble_To_FvlStr (CmpxNum, IsScientific) To convert a double-precision complex number to a FvlStr object. private\n\n                    module\n                    function CQuad_To_FvlStr (CmpxNum, IsScientific) To convert a quadruple-precision complex number to a FvlStr object. private\n\n                    module\n                    function Logical_To_FvlStr (Boolean) To convert a logical value to a FvlStr object. Finalizations Procedures final :: FinalizeFvlStr Type-Bound Procedures procedure, public :: ToCharString => CharAlloc_From_FvlStr Type-Bound Function : ToCharString Purpose :  To convert a FvlStr object to an allocatable character\n      string. Usage : --->    cStr = vStr%ToCharString() procedure, public :: ToChrArrAlloc => CharArray_From_FvlStr Type-Bound Function : ToChrArrAlloc Purpose :  To convert a FvlStr object to an allocatable array\n      of characters. Usage : ! convert a FvlStr object to a character array --->    cArray = vStr%ToChrArrAlloc() ! convert a FvlStr object to a character array with a null character --->    cArray = vStr%ToChrArrAlloc(IsCString=.TRUE.) procedure, public :: ParseByte => IByte_From_FvlStr Type-Bound Function : ParseByte Purpose :  To parse the string of a FvlStr object as an 8-bit integer number. Usage : --->    NumVal = vStr%ParseByte() --->    NumVal = vStr%ParseByte(ErrFlag, ErrMsg) procedure, public :: ParseShort => IShort_From_FvlStr Type-Bound Function : ParseShort Purpose :  To parse the string of a FvlStr object as a 16-bit integer number. Usage : --->    NumVal = vStr%ParseShort() --->    NumVal = vStr%ParseShort(ErrFlag, ErrMsg) procedure, public :: ParseInteger => Integer_From_FvlStr Type-Bound Function : ParseInteger Purpose :  To parse the string of a FvlStr object as a 32-bit integer number. Usage : --->    NumVal = vStr%ParseInteger() --->    NumVal = vStr%ParseInteger(ErrFlag, ErrMsg) procedure, public :: ParseLong => ILong_From_FvlStr Type-Bound Function : ParseLong Purpose :  To parse the string of a FvlStr object as a 8-bit integer number. Usage : --->    NumVal = vStr%ParseLong() --->    NumVal = vStr%ParseLong(ErrFlag, ErrMsg) procedure, public :: ParseRSingle => RSingle_From_FvlStr Type-Bound Function : ParseRSingle Purpose :  To parse the string of a FvlStr object as a single-precision real number. Usage : --->    NumVal = vStr%ParseRSingle() --->    NumVal = vStr%ParseRSingle(ErrFlag, ErrMsg) procedure, public :: ParseRDouble => RDouble_From_FvlStr Type-Bound Function : ParseRDouble Purpose :  To parse the string of a FvlStr object as a double-precision real number. Usage : --->    NumVal = vStr%ParseRDouble() --->    NumVal = vStr%ParseRDouble(ErrFlag, ErrMsg) procedure, public :: ParseRQuad => RQuad_From_FvlStr Type-Bound Function : ParseRQuad Purpose :  To parse the string of a FvlStr object as a quadruple-precision real number. Usage : --->    NumVal = vStr%ParseRQuad() --->    NumVal = vStr%ParseRQuad(ErrFlag, ErrMsg) procedure, public :: ParseCSingle => CSingle_From_FvlStr Type-Bound Function : ParseCSingle Purpose :  To parse the string of a FvlStr object as a single-precision complex number. Usage : --->    NumVal = vStr%ParseCSingle() --->    NumVal = vStr%ParseCSingle(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. procedure, public :: ParseCDouble => CDouble_From_FvlStr Type-Bound Function : ParseCDouble Purpose :  To parse the string of a FvlStr object as a double-precision complex number. Usage : --->    NumVal = vStr%ParseCDouble() --->    NumVal = vStr%ParseCDouble(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. procedure, public :: ParseCQuad => CQuad_From_FvlStr Type-Bound Function : ParseCQuad Purpose :  To parse the string of a FvlStr object as a quadruple-precision complex number. Usage : --->    NumVal = vStr%ParseCQuad() --->    NumVal = vStr%ParseCQuad(ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. procedure, public :: ParseLogical => Logical_From_FvlStr Type-Bound Function : ParseLogical Purpose :  To parse the string of a FvlStr object as a logical value. Usage : --->    LogVal = vStr%ParseLogical() procedure, public :: Length => GetLength Type-Bound Function : Length Purpose :  To return the length of the character string of a FvlStr object. Usage : --->    StrLen = vStr%Length() procedure, public :: cSubStr => GetSubstring_CHS Type-Bound Function : cSubStr Purpose :  To return a substring from FvlStr object based on the specified lPos\n      and rPos where the returned substring is an allocatable character string. Usage : --->    SubStr = vStr%cSubStr(lPos, rPos) Note: the above example is functionally equivalent to the following Fortran\n        intrinsic statement: SubStr = cStr(lPos:rPos) procedure, public :: vSubStr => GetSubstring_VLS Type-Bound Function : vSubStr Purpose :  To return a substring from FvlStr object based on the specified lPos\n      and rPos where the returned substring is another FvlStr object. Usage : --->    SubStr = vStr%vSubStr(lPos, rPos) procedure, public :: cSlice => GetSlice_CHS Type-Bound Function : cSlice Purpose :  To extract the characters from the region between first and last indices (both inclusive) of a FvlStr object by taking strides of length stride .\n      The returned character slice is an allocatable character string. Usage : --->    Slice = vStr%cSlice(first, last, stride) Note: the above example is functionally equivalent to the following Fortran\n        intrinsic statement: Slice = cStr(first:last:stride) procedure, public :: vSlice => GetSlice_VLS Type-Bound Function : vSlice Purpose :  To extract the characters from the region between First and Last indices (both inclusive) of a FvlStr object by taking strides of length Stride .\n      The returned character slice is another FvlStr object. Usage : --->    Slice = vStr%vSlice(First, Last, Stride) procedure, public :: Char => GetCharacter Type-Bound Function : Char Purpose :  To return a (single) character from a FvlStr object based on\n      the specified position. Usage : --->    Chr = vStr%Char(Pos) procedure, public :: IsNumber => Is_FvlStr_Number Type-Bound Function : IsNumber Purpose :  To return a flag indicating whether the string of a FvlStr object\n      is a valid number and if so, what kind of number it is. If the returned flag is -1, the string is NOT a number. If the returned flag is  0, the string is a valid integer or real number. If the returned flag is  1, the string is strictly an integer number. If the returned flag is  2, the string is strictly a real number. If the returned flag is  3, the string is a valid complex number. Usage : ! return -1, 0 or 3 --->    Flag = vStr%IsNumber() ! return -1, 1, 2 or 3 --->    Flag = vStr%IsNumber(Strict=.TRUE.) ! return a flag (-1, 0 or 3) and value of the string if it is a number --->    Flag = vStr%IsNumber(NumVal=Value) Technical Notes : A (strict) integer number is a whole number with no decimal point.\n  It can have a leading sign and is interpreted as a decimal number.\n  It takes a general form of [s]n[n...] where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A (strict) real number is a number with decimal point or an exponent part.\n  The general form of a real number with no exponent part is [s]n[n...] and\n  a real number with an exponent part has a general form of [s]n[n...]E[s]nn...\n  where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A decimal point must appear if\n    the real number has no exponent part. - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. A complex number is a pair of real or integer numbers, separated by a comma,\n  and enclosed in parentheses.  The first number represents the real part and\n  the second number represents the imaginary part. procedure, public :: IsLogical => Is_FvlStr_Logical Type-Bound Function : IsLogical Purpose :  To return true value if the string of a FvlStr object is a logical\n      value where valid logical values include 'T', 'F', 't', 'f', 'TRUE', 'FALSE',\n      'true', 'false'.  Otherwise, return false value. Usage : ! only return the flag --->    Flag = vStr%IsLogical() ! return the flag and also get logical value if the returned flag is true --->    Flag = vStr%IsLogical(LogVal) procedure, public :: IsInClass => Is_FvlStr_InClass Type-Bound Function : IsInClass Purpose :  To check whether a FvlStr object is in the specified class where\n      the recognized classes include ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX,\n      CONTROL, DIGIT, FNAME, GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION,\n      PRINTABLE, REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. Usage : --->    Flag = vStr%IsInClass('ALPHANUM') --->    Flag = vStr%IsInClass('GRAPHICAL', FailIndex) --->    IF (.NOT.vStr%IsInClass('FNAME')) DoSomething Technical Notes :  See explanations of various recognized classes in the IsCharacterInClass function interface and the IsStringInClass function interface of the MBase_ChrStr module. generic, public :: CountSubstring => CountSubstring_CHS, CountSubstring_VLS Function Interface : CountSubstring Purpose :  To count the number of occurrences of the given substring\n      in the specified FvlStr object. Usage : --->    Count = vStr%CountSubstring(SubStr) --->    Count = vStr%CountSubstring(SubStr, Overlap=.TRUE.) generic, public :: CountCharacters => CountCharacters_CHS, CountCharacters_VLS Function Interface : CountCharacters Purpose :  To count the number of occurrences of character(s) in the\n      specified FvlStr object for any character appearing in the given\n      character set.  Optionally, a user can specify flags indicating\n      whether protected regions exist or not and whether the exclamation\n      mark is used to protect regions. Usage : --->    Count = vStr%CountCharacters(CharSet) --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE.) --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) procedure, public :: CountWords => CountWords_VLS Function Interface : CountWords Purpose :  To count the number of words (separated by blanks) in the\n      specified FvlStr object where blanks are characters in the SET_BLANKS character set. Usage : --->    Count = vStr%CountWords() procedure, public :: FindProtectedRegions => FindProtectedRegions_VLS Function Interface : FindProtectedRegions Purpose :  To find the number of protected regions marked by two (single\n      or double) quotes and/or by an exclamation mark.  Also, return positions\n      of the first and last characters of each region. Usage : --->    nRegion = vStr%FindProtectedRegions(lPos, rPos) --->    nRegion = vStr%FindProtectedRegions(lPos, rPos, ExclMrk=.FALSE.) generic, public :: FindSubstring => FindSubstring_CHS, FindSubstring_VLS Function Interface : FindSubstring Purpose :  To count the number of non-overlapping occurrences of the given\n      substring in the specified FvlStr object and also return position(s) of\n      the first character of substring found.  Optionally, a user can specify\n      flags indicating whether protected regions exist or not and whether the\n      exclamation mark is used to protect regions. Usage : --->    Count = vStr%FindSubstring(SubStr, FirstPos) --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE.) --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE., ExclMrk=.FALSE.) generic, public :: FindDelimiters => FindDelimiters_CHS, FindDelimiters_VLS Function Interface : FindDelimiters Purpose :  To count the number of occurrences of delimiter(s) in the\n      specified FvlStr object and also return position(s) of the delimiter(s)\n      found.  A delimiter is any character appearing in the given character\n      set.  Optionally, a user can specify flags indicating whether protected\n      regions exist or not and whether the exclamation mark is used to protect\n      regions. Usage : --->    Count = vStr%FindDelimiters(CharSet, DPos) --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE.) --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE., ExclMrk=.FALSE.) generic, public :: FindSeparators => FindSeparators_CHS, FindSeparators_VLS Function Interface : FindSeparators Purpose :  To count the number of occurrences of separator(s) in the\n      specified FvlStr object and also return (the first) position(s) of the\n      separator(s) found.  Optionally, a user can specify flags indicating\n      whether protected regions exist or not and whether the exclamation\n      mark is used to protect regions. Usage : ! a separator is any (single) character in the Separator argument --->    Count = vStr%FindSeparators(Separator, .TRUE., Pos) ! a separator is a character string specified by the Separator argument --->    Count = vStr%FindSeparators(Separator, .FALSE., Pos) ! both quotes and an exclamation mark used to define protected regions. --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE.)  ! separator is a single character --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE.) ! separator is a character string ! only quotes used to define protected regions. --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) generic, public :: StartWith => StartWith_CHS, StartWith_VLS Function Interface : StartWith Purpose :  To check whether the string of a FvlStr object starts with the\n      specified substring or not.  Both the string and the substring must not\n      have a zero length. Usage : --->    Flag = vStr%StartWith(SubStr) --->    IF (.NOT.vStr%StartWith(SubStr)) DoSomething generic, public :: EndWith => EndWith_CHS, EndWith_VLS Function Interface : EndWith Purpose :  To check whether the string of a FvlStr object ends with the\n      specified substring or not.  Both the string and the substring must not\n      have a zero length. Usage : --->    Flag = vStr%EndWith(SubStr) --->    IF (.NOT.vStr%EndWith(SubStr)) DoSomething generic, public :: ChangeCase => AlterCase, AlterCaseProtect Subroutine Interface : ChangeCase Purpose :  To change case of all alphabet characters of the string of the\n      specified FvlStr object according to the given flag.  If protected regions\n      are specified, only characters in unprotected regions are changed. Usage : ! change all alphabet characters to upper cases --->    CALL vStr%ChangeCase(.TRUE.) ! change all alphabet characters only in unprotected regions to lower cases --->    CALL vStr%ChangeCase(nRegion, lPos, rPos, .FALSE.) procedure, public :: ChangeCaseBC => BlankCompressAlterCase Subroutine Interface : ChangeCaseBC Purpose :  To first remove all blank characters and then change case of all\n      alphabet characters of the string of the specified FvlStr object according\n      to the given flag. Usage : --->    CALL vStr%ChangeCaseBC(.TRUE.) procedure, public :: CropBlanks => CropBlanks_VLS Subroutine Interface : CropBlanks Purpose :  To remove leading and trailing blanks from the string of the\n      specified FvlStr object. Usage : --->    CALL vStr%CropBlanks() --->    CALL vStr%CropBlanks(SpaceOnly=.TRUE.) procedure, public :: Compact => CompactString_VLS Subroutine Interface : Compact Purpose :  To convert multiple spaces and tabs into a single space, delete\n      control characters and removes initial (leading and trailing) spaces. Usage : --->    CALL vStr%Compact() procedure, public :: Compress => CompressString_VLS Subroutine Interface : Compress Purpose :  To remove spaces, tabs and control characters from the string\n      of the specified FvlStr object. Usage : --->    CALL vStr%Compress() Note : Unlike the Compact method, the returned string contains no space\n           between its characters. generic, public :: InsertSubstring => InsertSubstring_CHS, InsertSubstring_VLS Subroutine Interface : InsertSubstring Purpose :  To insert a given substring into the string of the given\n      FvlStr object at a specified position. Usage : --->    CALL vStr%InsertSubstring(Pos, SubStr) generic, public :: RemoveCharacters => RemoveCharacters_CHS, RemoveCharacters_VLS Subroutine Interface : RemoveCharacters Purpose :  To remove characters from the string of the given FvlStr\n      object depending on specified input. Usage : --->    CALL vStr%RemoveCharacters(CharSet) --->    CALL vStr%RemoveCharacters(CharSet, Option=2) --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE.) --->    CALL vStr%RemoveCharacters(CharSet, 2, Protect=.TRUE.) --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%RemoveCharacters(CharSet, 3, .TRUE., .FALSE.) generic, public :: RemoveSubstring => RemoveSubstring_CHS, RemoveSubstring_VLS, Delete_Substring Subroutine Interface : RemoveSubstring Purpose :  To remove the substring from the string of the given FvlStr\n      object based on specified input. Usage : --->    CALL vStr%RemoveSubstring(SubStr) --->    CALL vStr%RemoveSubstring(lPos, rPos) --->    CALL vStr%RemoveSubstring(SubStr, FirstOnly=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., FirstOnly=.TRUE.) --->    CALL vStr%RemoveSubstring(SubStr, .TRUE., .FALSE., .TRUE.) generic, public :: ReplaceSubstring => ReplaceSubstring_CHS_CHS, ReplaceSubstring_VLS_CHS, ReplaceSubstring_CHS_VLS, ReplaceSubstring_VLS_VLS Subroutine Interface : ReplaceSubstring Purpose :  To replace all occurrences of the original substring found\n      in the string of the given FvlStr object with the new substring based\n      on specified input. Usage : --->    CALL vStr%ReplaceSubstring(OldSub, NewSub) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., Recur=.TRUE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., ExclMrk=.FALSE.) --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, .TRUE., .TRUE., .FALSE.) generic, public :: Partition => PartitionSepSub_CHS, PartitionSepSub_VLS, PartitionSepChr_CHS, PartitionSepChr_VLS Subroutine Interface : Partition Purpose :  To partition the string of the given FvlStr object into two\n      substrings by a separator (single character or a multiple-character\n      string).  The partition occurs at the first occurrence of the separator\n      found. Usage : ! SepSub is a multiple-character string separator. --->    CALL vStr%Partition(SepSub, SubStr) ! SepSet is a set of characters where a character in the set is a valid ! separator.  Also, search the first separator from the back. --->    CALL vStr%Partition(SepSet, SubStr, SepChr, Back=.TRUE.) generic, public :: Split => SplitSepSub_CHS, SplitSepSub_VLS, SplitSepChr_CHS, SplitSepChr_VLS Subroutine Interface : Split Purpose :  To split the string of the given FvlStr object into multiple\n       substrings by a separator (single character or a multiple-character string). Usage : ! SepSub is a multiple-character string separator. --->    CALL vStr%Split(SepSub, SubStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL vStr%Split(SepSet, SubStr, SepChr) ! only find a separator in the unprotected regions. --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE.) ! only find separators in the unprotected regions. --->    CALL vStr%Split(SepSet, SubStr, SepChr, Protect=.TRUE.) ! The exclamation mark is NOT used to define the protected regions. --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE., ExclMrk=.FALSE.) procedure, public :: WriteOutput Subroutine Interface : WriteOutput Purpose :  To write the string of a FvlStr object to a connected\n      formatted unit. Usage : --->    CALL vStr%WriteOutput(IOUnit) --->    CALL vStr%WriteOutput(IOUnit,IOStat,IOMsg) procedure, public :: ReadComnandLine Subroutine Interface : ReadComnandLine Purpose :  To read a character sequence from a command line into the\n      FvlStr object. Usage : --->    CALL vStr%ReadComnandLine() procedure, public :: ReadInput Subroutine Interface : ReadInput Purpose :  To read a character sequence from a connected formatted unit\n      into the FvlStr object. Usage : --->    CALL vStr%ReadInput(IOUnit) --->    CALL vStr%ReadInput(IOUnit,IOStat,IOMsg) procedure, public :: Copy => FvlStr_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => FvlStr_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => FvlStr_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => FvlStr_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => FvlStr_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: CompareTo => FvlStr_CompareTo Use a common logical expression to compare two Comparable objects.","tags":"","loc":"module\\mclass_fvlstr.html"},{"title":"MBase_ChrStr – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains routines that handle and manipulate character strings.\n  These routines supplement the Fortran intrinsic procedures provided for\n  the Fortran's CHARACTER type.  The routines provided in this module\n  can be categorized into 5 groups as follows. (1) Character procedures are routines for a single character.  The following\n      list shows available (i.e. public) character procedures. - IsCharacterInClass, - ChangeCaseCharacter, and - CharacterDescription. (2) Assignment procedures are conversion routines between a character string\n      and an other (Fortran intrinsic) type.  These conversion routines are intended\n      to be used in an assignment expression. (3) Conversion procedures are conversion routines between a character string\n      and an other (Fortran intrinsic) type.  These conversion routines are NOT\n      intended to be used in an assignment expression; therefore, they have\n      different interfaces from those intended for an assignment expression.\n      The following list shows available (i.e. public) conversion procedures. - CharString, - ToChrArrFixed, - ToChrArrAlloc, - ToCString, - ParseByte, - ParseShort, - ParseInteger, - ParseLong, - ParseRSingle, - ParseRDouble, - ParseRQuad, - ParseCSingle, - ParseCDouble, - ParseCQuad, and - ParseLogical. (4) Inquiry procedures are routines that inquire information relating to\n      a character string.  The following list shows available (i.e. public)\n      inquiry procedures. - IsStringNumber, - IsStringLogical, - IsStringInClass, - IsStringInCharacterSet, - CountSubString, - CountCharacters, - CountCharactersProtect, - CountWords, - FindProtectedRegions, - FindSubstring, - FindDelimiters, - FindSeparators, - FindSubstringProtect, - FindDelimitersProtect, - FindSeparatorsProtect, - StartWith, - EndWith, - GetSubstring, and - GetSlice. (5) Manipulation procedures are routines that perform a manipulation on\n      a character string.  The following list shows available (i.e. public)\n      manipulation procedures. - ChangeCase, - BlankCompressChangeCase, - CropBlanks, - CompactString, - CompressString, - InsertSubstring, - RemoveCharacters, - RemoveCharactersProtect, - RemoveSubstring, - RemoveSubstringProtect, - ReplaceSubstring, - ReplaceSubstringProtect, - ReplaceSubstringRecursive - Partition, - Split, and - SplitProtect. Uses MBase_CharUtil MBase_DoublyLinkedLists MBase_Common Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: ID_UNKNOWN_INDEX = -5 unknown index integer(kind=kInt32), public, parameter :: ID_NOT_ALLOCATED = -4 character string not yet allocated integer(kind=kInt32), public, parameter :: ID_ZERO_LENGTH = -3 character string with zero length integer(kind=kInt32), public, parameter :: ID_MISSING_CHARACTER = -2 missing character integer(kind=kInt32), public, parameter :: ID_EMPTY_STRING = -1 empty string integer(kind=kInt32), public, parameter :: ID_NO_FAILINDEX = 0 fail index not applicable Interfaces public        interface IsCharacterInClass Function Interface : IsCharacterInClass Purpose :  To check whether a given character is in the specified class. Usage : --->    Flag = IsCharacterInClass('A', 'ASCII', FailIndex) --->    IF (.NOT.IsCharacterInClass('5', 'ALPHANUM')) DoSomething private module function IsCharacterInClass(Chr, ClassType, FailIndex) result(ClassFlag) To check whether a given character is in the specified class where\n the following character classes are recognized. - 'ALPHABET': The given character is a valid letter [a-zA-Z]. - 'ALPHANUM': The given character is a valid letter or digit [a-zA-Z0-9]. - 'ASCII': The given character is a valid ASCII character. - 'BLANK': The given character is a valid blank character, that is blank\n      space or tab. - 'CONTROL': The given character is a valid control character where control\n      characters are in the ranges 00..1F and 7F..9F, that is from ASCII #0\n      to #31 and from #127 to #159. - 'DIGIT': The given character is a valid digit [0-9]. - 'GRAPHICAL': The given character is a valid graphical character not\n      including space that is from ASCII #33 to #126. - 'LOGICAL': The given character is a valid logical value, that is 't', 'T',\n      'f', and 'F'. - 'LOWERCASE': The given character is a valid lower-case letter, that is\n      [a-z]. - 'PUNCTUATION': The given character is a valid punctuation character, that\n      is _,;:.? {}@\"'. - 'PRINTABLE': The given character is a valid printable character including\n      space that is from ASCII #32 to #126. - 'UPPERCASE': The given character is a valid upper-case letter, that is\n      [A-Z]. - 'WHITESPACE': The given character is a valid white space, that is space,\n      tab, vertical tab, form-feed, newline or carriage return. - 'HEXDIGIT': The given character is a valid hexadecimal digit characters\n      that is [0-9A-Fa-f]. - 'OCTDIGIT': The given character is a valid octal digit characters\n      that is [0-9A-Fa-f]. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: Chr the specified character character(kind=kChar, len=*), intent(in) :: ClassType character class integer(kind=kInt32), intent(out), optional :: FailIndex return 1 if the character class is valid; otherwise, return 0. Return Value logical true if the character is in the specified class public        interface ChangeCaseCharacter Subroutine Interface : ChangeCaseCharacter Purpose :  To change case of the given character according to flag. Usage : ! if Char is an alphabet character, change it to its upper case --->    CALL ChangeCaseCharacter(Char, .TRUE.)\n  ! if Char is an alphabet character, change it to its lower case --->    CALL ChangeCaseCharacter(Char, .FALSE.)\n  ! if Char is NOT an alphabet character, nothing done --->    CALL ChangeCaseCharacter(Char, .TRUE.) private elemental module subroutine ChangeCaseCharacter(Chr, ToUpper) To change case of the given character according to flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(inout) :: Chr the specified character logical, intent(in) :: ToUpper flag indicating whether to change the character to upper case - true if requesting an uppercase character - false if requesting a lowercase character public        interface CharacterDescription Function Interface : CharacterDescription Purpose :  To provide a description of the given character. Usage : --->    Description = CharacterDescription('~') private module function CharacterDescription(Chr) result(Description) To provide a description of the given character. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: Chr the specified character Return Value character(kind=kChar, len=:), ALLOCATABLE the character description public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a character string and an other\n               (Fortran intrinsic) type via an assignment expression. Usage : ! convert a 64-bit integer number to a character string --->    cStr = I64Num ! convert a character string to a quadruple-precision real number --->    RQPNum = cStr Important Note : The assignment and conversion operations are\n           functionally similar but have some subtle differences.  In\n           particular for those procedures that convert from a decimal\n           string to a number, the assignment procedures will silently\n           convert to a proper representation if the input string is INVALID whereas the conversion procedures can optionally\n           report the error occurred. private module subroutine ChrStr_From_IByte(cStr, IntNum) To convert from a 8-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt8), intent(in) :: IntNum private module subroutine ChrStr_From_IShort(cStr, IntNum) To convert from a 16-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt16), intent(in) :: IntNum private module subroutine ChrStr_From_Integer(cStr, IntNum) To convert from a 32-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt32), intent(in) :: IntNum private module subroutine ChrStr_From_ILong(cStr, IntNum) To convert from a 64-bit integer number to a character string\n via an assignment expression. Usage : cStr = IntNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr integer(kind=kInt64), intent(in) :: IntNum private module subroutine ChrStr_From_RSingle(cStr, RealNum) To convert from a single-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kSingle), intent(in) :: RealNum private module subroutine ChrStr_From_RDouble(cStr, RealNum) To convert from a double-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kDouble), intent(in) :: RealNum private module subroutine ChrStr_From_RQuad(cStr, RealNum) To convert from a quadruple-precision real number to a character string\n via an assignment expression. Usage : cStr = RealNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr real(kind=kQuad), intent(in) :: RealNum private module subroutine ChrStr_From_CSingle(cStr, CmpxNum) To convert from a single-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kSingle), intent(in) :: CmpxNum private module subroutine ChrStr_From_CDouble(cStr, CmpxNum) To convert from a double-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kDouble), intent(in) :: CmpxNum private module subroutine ChrStr_From_CQuad(cStr, CmpxNum) To convert from a quadruple-precision complex number to a character string\n via an assignment expression. Usage : cStr = CmpxNum Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr complex(kind=kQuad), intent(in) :: CmpxNum private module subroutine ChrStr_From_Logical(cStr, Boolean) To convert from a logical value to a character string\n via an assignment expression. Usage : cStr = Boolean Arguments Type Intent Optional Attributes Name character(kind=kChar, len=:), intent(out), ALLOCATABLE :: cStr logical, intent(in) :: Boolean private module subroutine ChrStr_To_IByte(IntNum, cStr) To convert from a character string to a 8-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_IShort(IntNum, cStr) To convert from a character string to a 16-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_Integer(IntNum, cStr) To convert from a character string to a 32-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_ILong(IntNum, cStr) To convert from a character string to a 64-bit integer number\n via an assignment expression. Usage : IntNum = cStr Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: IntNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RSingle(RealNum, cStr) To convert from a character string to a single-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RDouble(RealNum, cStr) To convert from a character string to a double-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_RQuad(RealNum, cStr) To convert from a character string to a quadruple-precision real number\n via an assignment expression. Usage : RealNum = cStr Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(out) :: RealNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CSingle(CmpxNum, cStr) To convert from a character string to a single-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CDouble(CmpxNum, cStr) To convert from a character string to a double-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_CQuad(CmpxNum, cStr) To convert from a character string to a quadruple-precision complex number\n via an assignment expression. Usage : CmpxNum = cStr Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(out) :: CmpxNum character(kind=kChar, len=*), intent(in) :: cStr private module subroutine ChrStr_To_Logical(Boolean, cStr) To convert from a character string to a logical value\n via an assignment expression. Usage : Boolean = cStr Arguments Type Intent Optional Attributes Name logical, intent(out) :: Boolean character(kind=kChar, len=*), intent(in) :: cStr public        interface CharString Function Interface : CharString Purpose :  To construct a character string based on specified input. Usage : ! construct a character string from an array of characters --->    cStr = CharString(cArray) ! construct a character string from double-precision real number --->    cStr = CharString(R64, IsScientific=.TRUE.) private module function CharacterArray_To_ChrStr(cArr, IsCString) result(cStr) To convert a character array to a character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=1), intent(in) :: cArr (:) array of characters logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array must contain a null character. Default is FALSE. Return Value character(kind=kChar, len=:), ALLOCATABLE character string private module function IByte_To_ChrStr(IntNum) result(cStr) To convert an 8-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function IShort_To_ChrStr(IntNum) result(cStr) To convert an 16-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function Integer_To_ChrStr(IntNum) result(cStr) To convert an 32-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function ILong_To_ChrStr(IntNum) result(cStr) To convert an 64-bit integer value to a character string. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: IntNum Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RSingle_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a single-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RDouble_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a double-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function RQuad_To_ChrStr(RealNum, IsScientific) result(cStr) To convert a quadruple-precision real value to a character string. Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: RealNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CSingle_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a single-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kSingle), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CDouble_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a double-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kDouble), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function CQuad_To_ChrStr(CmpxNum, IsScientific) result(cStr) To convert a quadruple-precision complex value to a character string. Arguments Type Intent Optional Attributes Name complex(kind=kQuad), intent(in) :: CmpxNum logical, intent(in), optional :: IsScientific flag indicating whether the string is expressed in the scientific format. Default is FALSE where the string is expressed in the general format. Return Value character(kind=kChar, len=:), ALLOCATABLE private module function Logical_To_ChrStr(Boolean) result(cStr) To convert a logical value to a character string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: Boolean Return Value character(kind=kChar, len=:), ALLOCATABLE public        interface ToChrArrAlloc Function Interface : ToChrArrAlloc Purpose :  To convert a character string to an allocatable array\n               of characters. Usage : ! convert a character string to a character array --->    cArray = ToChrArrAlloc(cStr) ! convert a character string to a character array with a null character --->    cArray = ToChrArrAlloc(cStr, IsCString=.TRUE.) private module function CharArray_From_ChrStr_I(cStr, IsCString) result(cArr) To convert a character string to an allocatable array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string logical, intent(in), optional :: IsCString flag indicating whether the array is a 'C' string or not. If true, the array will contain a null character. Default is FALSE. Return Value character(kind=kChar, len=1), ALLOCATABLE, (:) an array of characters public        interface ToChrArrFixed Function Interface : ToChrArrFixed Purpose :  To convert a character string to an explicit-shape array\n               of characters. Usage : --->    cArray = ToChrArrFixed(cStr) private module function CharArray_From_ChrStr_II(cStr) result(cArr) To convert a character string to an explicit-shape array of characters. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string Return Value character(kind=kChar, len=1), (LEN(cStr)) an array of characters public        interface ToCString Function Interface : ToCString Purpose :  To convert a character string to a 'C' style string, which is an\n               explicit-shape array of characters with a null character added. Usage : --->    cArray = ToCString(cStr) private module function CString_From_ChrStr(cStr) result(cArr) To convert a character string to a 'C' style string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr a character string Return Value character(kind=kChar, len=1), (LEN(cStr)+1) a 'C' string public        interface ParseByte Function Interface : ParseByte Purpose :  To parse a character string as a 8-bit integer number. Usage : --->    IntNum = ParseByte(cStr) --->    IntNum = ParseByte(cStr, ErrFlag, ErrMsg) private module function IByte_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 8-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt8) integer number public        interface ParseShort Function Interface : ParseShort Purpose :  To parse a character string as a 16-bit integer number. Usage : --->    IntNum = ParseShort(cStr) --->    IntNum = ParseShort(cStr, ErrFlag, ErrMsg) private module function IShort_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 16-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt16) integer number public        interface ParseInteger Function Interface : ParseInteger Purpose :  To parse a character string as a 32-bit integer number. Usage : --->    IntNum = ParseInteger(cStr) --->    IntNum = ParseInteger(cStr, ErrFlag, ErrMsg) private module function Integer_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 32-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt32) integer number public        interface ParseLong Function Interface : ParseLong Purpose :  To parse a character string as a 64-bit integer number. Usage : --->    IntNum = ParseLong(cStr) --->    IntNum = ParseLong(cStr, ErrFlag, ErrMsg) private module function ILong_From_ChrStr(cStr, ErrFlag, ErrMsg) result(IntNum) To convert a character string to a 64-bit integer number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value integer(kind=kInt64) integer number public        interface ParseRSingle Function Interface : ParseRSingle Purpose :  To parse a character string as a single-precision real number. Usage : --->    RealNum = ParseRSingle(cStr) --->    RealNum = ParseRSingle(cStr, ErrFlag, ErrMsg) private module function RSingle_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a single-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kSingle) real number public        interface ParseRDouble Function Interface : ParseRDouble Purpose :  To parse a character string as a double-precision real number. Usage : --->    RealNum = ParseRDouble(cStr) --->    RealNum = ParseRDouble(cStr, ErrFlag, ErrMsg) private module function RDouble_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a double-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kDouble) real number public        interface ParseRQuad Function Interface : ParseRQuad Purpose :  To parse a character string as a quadruple-precision real number. Usage : --->    RealNum = ParseRQuad(cStr) --->    RealNum = ParseRQuad(cStr, ErrFlag, ErrMsg) private module function RQuad_From_ChrStr(cStr, ErrFlag, ErrMsg) result(RealNum) To convert a character string to a quadruple-precision real number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value real(kind=kQuad) real number public        interface ParseCSingle Function Interface : ParseCSingle Purpose :  To parse a character string as a single-precision complex number. Usage : --->    CmpxNum = ParseCSingle(cStr) --->    CmpxNum = ParseCSingle(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. private module function CSingle_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a single-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kSingle) complex number public        interface ParseCDouble Function Interface : ParseCDouble Purpose :  To parse a character string as a double-precision complex number. Usage : --->    CmpxNum = ParseCDouble(cStr) --->    CmpxNum = ParseCDouble(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. private module function CDouble_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a double-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kDouble) complex number public        interface ParseCQuad Function Interface : ParseCQuad Purpose :  To parse a character string as a quadruple-precision complex number. Usage : --->    CmpxNum = ParseCQuad(cStr) --->    CmpxNum = ParseCQuad(cStr, ErrFlag, ErrMsg) Note : A valid string representing a complex number consists of a pair of\n           real-number (or integer-number) strings, separated by a comma, and\n           enclosed in parentheses. private module function CQuad_From_ChrStr(cStr, ErrFlag, ErrMsg) result(CmpxNum) To convert a character string to a quadruple-precision complex number. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: ErrFlag true if input is invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg error message Return Value complex(kind=kQuad) complex number public        interface ParseLogical Function Interface : ParseLogical Purpose :  To parse a character string as a logical value. Usage : --->    Boolean = ParseLogical(cStr) private module function Logical_From_ChrStr(cStr) result(Boolean) To convert a character string to a logical value. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string Return Value logical logical value public        interface IsStringNumber Function Interface : IsStringNumber Purpose :  To check whether a character string is a valid number and\n               return a flag indicating what kind of number the string is. Usage : --->    NumFlag = IsStringNumber('123a31')                        ! return -1 --->    NumFlag = IsStringNumber('123')                           ! return 0 --->    NumFlag = IsStringNumber('1.23')                          ! return 0 --->    NumFlag = IsStringNumber('123', Strict=.TRUE.)            ! return 1 --->    NumFlag = IsStringNumber('1.23', Strict=.TRUE.)           ! return 2 --->    NumFlag = IsStringNumber('(123, 456)')                    ! return 3 --->    NumFlag = IsStringNumber('(12.3, 4.56)', NumVal=CmplxNum) ! return 3 and also get number Technical Notes : A (strict) integer number is a whole number with no decimal point.\n  It can have a leading sign and is interpreted as a decimal number.\n  It takes a general form of [s]n[n...] where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A (strict) real number is a number with decimal point or an exponent part.\n  The general form of a real number with no exponent part is [s]n[n...] and\n  a real number with an exponent part has a general form of [s]n[n...]E[s]nn...\n  where - s is a sign; required if negative (-), optional if positive (+). - n is a decimal digit (0 through 9). A decimal point must appear if\n    the real number has no exponent part. - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. A complex number is a pair of real or integer numbers, separated by a comma,\n  and enclosed in parentheses.  The first number represents the real part and\n  the second number represents the imaginary part. private module function IsStringNumber(cStr, Strict, NumVal) result(NumFlag) To check whether a character string is a valid number and\n if so, what kind of number it is. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(in), optional :: Strict true if requesting strict integer/real number; default is false. class(*), intent(out), optional, ALLOCATABLE :: NumVal (optional) value of number if it is valid Return Value integer(kind=kInt32) flag indicating what kind of number the string represents. Return -1 if the string is NOT a number. Return  0 if the string is a valid integer or real number. Return  1 if the string is strictly an integer number. Return  2 if the string is strictly a real number. Return  3 if the string is a valid complex number. public        interface IsStringLogical Function Interface : IsStringLogical Purpose : To check whether a character string is a logical value where\n              valid one include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true',\n              'false'. Usage : --->    Flag = IsStringLogical('a') --->    Flag = IsStringLogical('f', LogVal) private module function IsStringLogical(cStr, Boolean) result(LogFlag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string logical, intent(out), optional :: Boolean (optional) logical value Return Value logical true if the string is a valid logical value public        interface IsStringInClass Function Interface : IsStringInClass Purpose :  To check whether a given string is in the specified class. Usage : --->    Flag = IsStringInClass('AbCd', 'ASCII', FailIndex) --->    IF (.NOT.IsStringInClass('32.105e-32', 'REAL') DoSomething private recursive module function IsStringInClass(cStr, ClassType, FailIndex) result(ClassFlag) To check whether the given character string is in the specified class.\n To be in the specified class, all characters in the string must be\n valid characters of that class. The recognized character string classes include those of character classes\n (see the IsCharacterInClass routine) and the following additional classes: - 'COMPLEX': The character string is a valid complex constant in Fortran,\n      with optional sign and surrounding white spaces. - 'FNAME': The character string is a valid FORTRAN name that can contain\n      letters, digits, and underscores. The first character must be a letter. - 'INTEGER': The character string is a valid integer constant in Fortran,\n      with optional surrounding white spaces. - 'LOGICAL': The character string is considered a valid logical value, that\n      is 't', 'T', 'true', 'TRUE', 'f', 'F', 'false' and 'FALSE', with\n      optional surrounding white spaces. - 'REAL': The character string is a valid real constant in Fortran, with\n      optional surrounding white spaces. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr specified character string character(kind=kChar, len=*), intent(in) :: ClassType character string class integer(kind=kInt32), intent(out), optional :: FailIndex flag indicating position of the failed character Return Value logical true if the string is in the specified class public        interface IsStringInCharacterSet Function Interface : IsStringInCharacterSet Purpose :  To check whether all characters in the character string are\n               in the specified character set. Usage : --->    Flag = IsStringInCharacterSet('Ab23Cd', SET_ALPHANUM, FailIndex) --->    IF (.NOT.IsStringInCharacterSet('32.105Q-32', SET_NUMERICS) DoSomething private module function IsStringInCharacterSet(cStr, ChrSet, FailID) result(Flag) To check whether all characters in the character string are\n in the given character set. Note: This routine is an alternative to the VERIFY intrinsic function. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set integer(kind=kInt32), intent(out) :: FailID index indicating position of invalid character Return Value logical true if all characters are in the set public        interface CountSubstring Function Interface : CountSubstring Purpose :  To count the number of occurrences of the given\n               substring in the specified character string. Usage : --->    Count = CountSubstring(String, SubStr) --->    Count = CountSubstring(String, SubStr, Overlap=.TRUE.) private module function CountSubstring(cStr, sStr, Overlap) result(nCount) To count the number of occurrences of the given substring in the\n specified character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring logical, intent(in), optional :: Overlap flag indicating whether overlapping occurrences of the substring\n are allowed or not. - If true, count the overlapping occurrences. - If false, count the non-overlapping occurrences . Default is false. Return Value integer(kind=kInt32) number of occurrences public        interface CountCharacters Function Interface : CountCharacters Purpose :  To count the number of occurrences of character(s) in the\n               specified character string for any character appearing in\n               the given character set. Usage : --->    Count = CountCharacters(String, CharSet) private module function CountCharacters(cStr, ChrSet) result(nCount) To count the number of occurrences of character(s) in the specified\n character string for any character appearing in the given character set. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set Return Value integer(kind=kInt32) number of occurrences public        interface CountCharactersProtect Function Interface : CountCharactersProtect Purpose :  To count the number of occurrences of delimiter(s) in the\n               unprotected region(s) of the specified character string\n               where a delimiter is any character appearing in the\n               given character set. Usage : --->    Count = CountCharactersProtect(String, CharSet) --->    Count = CountCharactersProtect(String, CharSet, ExclMrk=.FALSE.) private module function CountCharactersProtect(cStr, ChrSet, ExclMrk) result(nCount) To count the number of occurrences of delimiter(s) in the unprotected\n region(s) of the specified character string where a delimiter is any\n character appearing in the given character set. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet character set logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences public        interface CountWords Function Interface : CountWords Purpose :  To count the number of words (separated by blanks) in the\n               specified character string where blanks are characters in\n               the SET_BLANKS character set. Usage : --->    Count = CountWords(String) private module function CountWords(cStr) result(nCount) To count the number of words (separated by blanks) in the specified\n character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string Return Value integer(kind=kInt32) number of words public        interface FindProtectedRegions Function Interface : FindProtectedRegions Purpose :  To find the number of protected regions marked by two (single\n               or double) quotes and/or by an exclamation mark.  Also, return\n               positions of the first and last characters of each region. Usage : --->    nRegion = FindProtectedRegions(String, lPos, rPos) --->    nRegion = FindProtectedRegions(String, lPos, rPos, ExclMrk=.FALSE.) private module function FindProtectedRegions(cStr, lPos, rPos, ExclMrk) result(nRegion) To look for quotes (and/or an exclamation mark) to find regions\n that must be protected from character string editing.  Return\n the number of protected regions as well as positions of the\n first and last characters of each region. Technical Notes : - Single quote, double quote and optionally exclamation mark are used as\n   delimiters to find protected regions. - Two single quotes or two double quotes are used to define a protected\n   region whereas an exclamation mark indicates that all characters\n   following it are all protected. - This routine is designed specifically for manipulating Fortran source code\n   where an exclamation mark is used for a comment and two (single or double)\n   quotes are used to specify a value to a character variable or literal. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(out), ALLOCATABLE :: lPos (:) positions of the first character of protected regions integer(kind=kInt32), intent(out), ALLOCATABLE :: rPos (:) positions of the last character of protected regions logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of protected regions public        interface FindSubstring Function Interface : FindSubstring Purpose :  To count the number of non-overlapping occurrences of the given\n               substring in the specified character string and also return\n               position(s) of the first character of substring found. Usage : --->    Count = FindSubstring(String, SubStr, FirstPos) private module function FindSubstring(cStr, sStr, sPos) result(nCount) To count the number of non-overlapping occurrences of the given\n substring in the specified character string and also return\n position(s) of the first character of substring found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) position(s) of the first character of substring found Return Value integer(kind=kInt32) number of occurrences public        interface FindSubstringProtect Function Interface : FindSubstringProtect Purpose :  To count the number of non-overlapping occurrences of the given\n               substring in unprotected regions of the specified character\n               string and also return position(s) of the first character of\n               substring found. Usage : --->    Count = FindSubstringProtect(String, SubStr, FirstPos) --->    Count = FindSubstringProtect(String, SubStr, FirstPos, ExclMrk=.FALSE.) private module function FindSubstringProtect(cStr, sStr, sPos, ExclMrk) result(nCount) To count the number of non-overlapping occurrences of the given substring\n in unprotected regions of the specified character string and also return\n position(s) of the first character of substring found. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) position(s) of the first character of substring found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences public        interface FindDelimiters Function Interface : FindDelimiters Purpose :  To count the number of occurrences of delimiter(s) in the specified\n               character string and also return position(s) of the delimiter(s) found.\n               A delimiter is any character appearing in the given character set. Usage : --->    Count = FindDelimiters(String, CharSet, DPos) private module function FindDelimiters(cStr, ChrSet, dPos) result(nCount) To count the number of occurrences of delimiter(s) in the specified\n character string and also return position(s) of the delimiter(s) found.\n A delimiter is any character appearing in the given character set. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters integer(kind=kInt32), intent(out), ALLOCATABLE :: dPos (:) position(s) of the delimiter(s) found Return Value integer(kind=kInt32) number of occurrences public        interface FindDelimitersProtect Function Interface : FindDelimitersProtect Purpose :  To count the number of occurrences of delimiter(s) in unprotected\n               regions of the specified character string and also return position(s)\n               of the delimiter(s) found.  A delimiter is any character appearing\n               in the given character set. Usage : --->    Count = FindDelimitersProtect(String, CharSet, DPos) --->    Count = FindDelimitersProtect(String, CharSet, DPos, ExclMrk=.FALSE.) private module function FindDelimitersProtect(cStr, ChrSet, dPos, ExclMrk) result(nCount) To count the number of occurrences of delimiter(s) in unprotected regions\n of the specified character string and also return position(s) of the\n delimiter(s) found.  A delimiter is any character appearing in the given\n character set. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: ChrSet a set of characters integer(kind=kInt32), intent(out), ALLOCATABLE :: dPos (:) position(s) of the delimiter(s) found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences public        interface FindSeparators Function Interface : FindSeparators Purpose :  To count the number of occurrences of separator(s) in the\n               specified character string and also return (the first)\n               position(s) of the separator(s) found. Usage : ! a separator is any (single) character in the Separator argument --->    Count = FindSeparators(String, Separator, .TRUE., Pos) ! a separator is a character string specified by the Separator argument --->    Count = FindSeparators(String, Separator, .FALSE., Pos) private module function FindSeparators(cStr, Separator, CharSet, sPos) result(nCount) To count the number of occurrences of separator(s) in the specified\n character string and also return (the first) position(s) of the\n separator(s) found. A separator can be a (single) character or a character string (multiple\n characters). The CharSet argument is a flag used to specify whether the separator\n is a character or a character string. If the CharSet argument is true, the Separator argument contains a\n set of characters where a separator is any character in the set. If the CharSet argument is false, the Separator argument specifies\n the character-string separator. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: Separator separator logical, intent(in) :: CharSet a flag indicating type of the separator integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) (first) position(s) of the separator(s) found Return Value integer(kind=kInt32) number of occurrences public        interface FindSeparatorsProtect Function Interface : FindSeparatorsProtect Purpose :  To count the number of occurrences of separator(s) in the\n               specified character string and also return (the first)\n               position(s) of the separator(s) found. Usage : ! both quotes and an exclamation mark used to define protected regions. --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos)  ! separator is a single character --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos) ! separator is a character string ! only quotes used to define protected regions. --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos, ExclMrk=.FALSE.) --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos, ExclMrk=.FALSE.) private module function FindSeparatorsProtect(cStr, Separator, CharSet, sPos, ExclMrk) result(nCount) To count the number of occurrences of separator(s) in unprotected\n regions of the specified character string and also return (the first)\n position(s) of the separator(s) found. See the FindSeparators routine for explanations regarding the separator and\n its types.\n See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: Separator separator logical, intent(in) :: CharSet a flag indicating type of the separator integer(kind=kInt32), intent(out), ALLOCATABLE :: sPos (:) (first) position(s) of the separator(s) found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value integer(kind=kInt32) number of occurrences public        interface GetSubstring Function Interface : GetSubstring Purpose :  To get a substring (specified by the leftmost and rightmost\n               indices) of the given character string. Usage : --->    Substring = GetSubstring(String, LeftIndx, RightIndx) private module function GetSubstring(cStr, lPos, rPos) result(cSub) To return a substring specified by the lPos and rPos arguments\n of the given character string. If the lPos argument is less than 1, then 1 is used as a\n starting position of the substring. Similarly, if the rPos argument is greater than the length of\n the string, then the length is used as an ending position. Also, If the rPos argument is less than the lPos argument,\n a zero-length string is returned. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in) :: lPos leftmost index integer(kind=kInt32), intent(in) :: rPos rightmost index Return Value character(kind=kChar, len=:), ALLOCATABLE substring public        interface GetSlice Function Interface : GetSlice Purpose :  To extract characters from the region between the first and\n               last indices (both inclusive) of the given string by taking\n               strides of length Stride . Usage : --->    Slice = GetSlice(String, FirstIndx, LastIndx, Stride) private module function GetSlice(cStr, First, Last, Stride) result(Slice) To extract characters from the region between the first and last indices\n (both inclusive) of the given string by taking strides of length Stride . Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string integer(kind=kInt32), intent(in), optional :: First the first index; can be greater than the last index if Stride is negative. integer(kind=kInt32), intent(in), optional :: Last the last index; can be less than the first index if Stride is negative. integer(kind=kInt32), intent(in), optional :: Stride a step (length) between characters extracted; can be negative. Return Value character(kind=kChar, len=:), ALLOCATABLE slice of the string public        interface StartWith Function Interface : StartWith Purpose :  To check whether the given character string starts with the\n               specified substring or not.  Both the string and the substring\n               must not have a zero length. Usage : --->    Flag = StartWith(String, Substring) --->    IF (.NOT.StartWith(String, Substring)) DoSomething private module function StartWithSubstring(cStr, sStr) result(Flag) To check whether the given character string starts with the specified\n substring or not.  Both the string and the substring must not have a\n zero length. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring Return Value logical true if the string starts with the substring public        interface EndWith Function Interface : EndWith Purpose :  To check whether the given character string ends with the\n               specified substring or not.  Both the string and the substring\n               must not have a zero length. Usage : --->    Flag = EndWith(String, Substring) --->    IF (.NOT.EndWith(String, Substring)) DoSomething private module function EndWithSubstring(cStr, sStr) result(Flag) To check whether the given character string ends with the specified\n substring or not.  Both the string and the substring must not have a\n zero length. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: sStr substring Return Value logical true if the string ends with the substring public        interface CropBlanks Function Interface : CropBlanks Purpose :  To remove leading and trailing blanks from the character string. Usage : --->    OutStr = CropBlanks(InStr) --->    OutStr = CropBlanks(InStr, SpaceOnly=.TRUE.) Note : CropBlanks(InStr,.TRUE.) is the same as TRIM(ADJUSTL(InStr)). private module function CropBlanks(cStrIn, SpaceOnly) result(cStrOut) To remove leading and trailing blanks from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string logical, intent(in), optional :: SpaceOnly flag indicating whether to only remove the space character or not. - True if requesting to remove only the space character. - False if requesting to remove both the tab and the space characters. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface CompactString Function Interface : CompactString Purpose :  To convert multiple spaces and tabs into a single space,\n               delete control characters and removes initial (leading\n               and trailing) spaces. Usage : --->    OutStr = CompactString(InStr) private module function CompactString(cStrIn) result(cStrOut) To convert multiple spaces and tabs into a single space, delete control\n characters and removes initial (leading and trailing) spaces. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface CompressString Function Interface : CompressString Purpose :  To remove spaces, tabs and control characters from the\n               character string. Usage : --->    OutStr = CompressString(InStr) Note : Unlike the CompactString procedure, the output string\n           contains no space between its characters. private module function CompressString(cStrIn) result(cStrOut) To remove spaces, tabs and control characters from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface ChangeCase Subroutine Interface : ChangeCase Purpose :  To change case of all alphabet characters of the specified\n               character string according to the given flag.  If protected\n               regions are specified, only characters in unprotected regions\n               are changed. Usage : ! change all alphabet characters to upper cases --->    CALL ChangeCase(String, .TRUE.) ! change all alphabet characters only in unprotected regions to lower cases --->    CALL ChangeCase(String, nRegion, lPos, rPos, .FALSE.) private elemental module subroutine ChangeCaseString(cStr, ToUpper) To change case of all alphabet characters of the specified character\n string according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: cStr character string logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. private module subroutine ChangeCaseProtect(cStr, nRegion, lPos, rPos, ToUpper) To change case of all alphabet characters of the specified character\n string in unprotected regions according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: cStr character string integer(kind=kInt32), intent(in) :: nRegion number of protected regions integer(kind=kInt32), intent(in) :: lPos (:) positions of the first character of protected regions integer(kind=kInt32), intent(in) :: rPos (:) positions of the last character of protected regions logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. public        interface BlankCompressChangeCase Function Interface : BlankCompressChangeCase Purpose :  To first remove all blank characters and then change case of all\n               alphabet characters of the specified character string according\n               to the given flag. Usage : --->    OutStr = BlankCompressChangeCase(InStr, .TRUE.) private module function BlankCompressChangeCase(cStrIn, ToUpper) result(cStrOut) To first remove all blank characters and then change case of all alphabet\n characters of the specified character string according to the given flag. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string logical, intent(in) :: ToUpper flag indicating whether to change the string's characters to\n upper-case characters or not. - If true, the string contains upper-case characters on exit. - If false, the string contains lower-case characters on exit. Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface InsertSubstring Function Interface : InsertSubstring Purpose :  To insert a given substring into the character string at a\n               specified position. Usage : --->    OutStr = InsertSubstring(InStr, Pos, SubStr) private module function InsertSubstring(cStrIn, Pos, sStr) result(cStrOut) To insert a given substring into the character string at a\n specified position. If the Pos argument is less than 1, then 1 is used as an insertion point. If the Pos argument is greater than length of the character string, then\n the substring is inserted at the end of the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: Pos the insertion point character(kind=kChar, len=*), intent(in) :: sStr substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface RemoveCharacters Function Interface : RemoveCharacters Purpose :  To remove characters from the character string depending on\n               specified input. Usage : --->    OutStr = RemoveCharacters(InStr, CharSet) --->    OutStr = RemoveCharacters(InStr, CharSet, Option=2) private module function RemoveCharacters(cStrIn, ChrSet, Option) result(cStrOut) To remove characters from the character string depending on\n the specified character set and optionally the option flag. The ChrSet argument is a required input that contains a set of\n characters to be removed whereas the Option argument is an\n optional input that indicates where characters in the character\n string to be removed are.  Available options include: - Option = -1 --> nothing to be removed. - Option =  0 --> leading (prefix) and trailing (suffix) character(s)\n                   to be removed. - Option =  1 --> leading (prefix) character(s) to be removed. - Option =  2 --> trailing (suffix) character(s) to be removed. - Option =  3 --> all characters in the ChrSet set to be removed. If the Option argument is not present, the default option is set to 0. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: ChrSet set of characters to be removed integer(kind=kInt32), intent(in), optional :: Option flag indicating how to remove characters Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface RemoveCharactersProtect Function Interface : RemoveCharactersProtect Purpose :  To remove characters from the character string depending on\n               specified input. Usage : --->    OutStr = RemoveCharactersProtect(InStr, CharSet) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, Option=2) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, ExclMrk=.FALSE.) --->    OutStr = RemoveCharactersProtect(InStr, CharSet, 3, .FALSE.) private module function RemoveCharactersProtect(cStrIn, ChrSet, Option, ExclMrk) result(cStrOut) To remove characters from the unprotected regions of the character string\n depending on the specified character set and optionally the option flag. See the RemoveCharacters routine for explanations regarding the ChrSet and Option arguments. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: ChrSet set of characters to be removed integer(kind=kInt32), intent(in), optional :: Option flag indicating how to remove characters logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface RemoveSubstring Function Interface : RemoveSubstring Purpose :  To remove the substring from the character string based on\n               specified input. Usage : --->    OutStr = RemoveSubstring(InStr, SubStr) --->    OutStr = RemoveSubstring(InStr, SubStr, FirstOnly=.TRUE.) --->    OutStr = RemoveSubstring(InStr, sLen, sCount, sPos) --->    OutStr = RemoveSubstring(InStr, lPos, rPos) private module function RemoveSubstring(cStrIn, sStr, FirstOnly) result(cStrOut) To remove the substring from the character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: sStr substring to be removed logical, intent(in), optional :: FirstOnly flag indicating whether to remove only the first substring found or to\n remove all occurrences found. If true, only remove the first substring found; otherwise, remove all\n (non-overlapping) occurrences found. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string private recursive module function RemoveSubstringKnownPos(cStrIn, sLen, sCount, sPos) result(cStrOut) To remove substring from the character string by providing length, number of\n occurrences and position(s) of first character of the substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: sLen length of the substring to be removed integer(kind=kInt32), intent(in) :: sCount number of occurrences of the substring integer(kind=kInt32), intent(in) :: sPos (sCount) position(s) of first character of the substring Return Value character(kind=kChar, len=:), ALLOCATABLE output character string private module function DeleteSubstring(cStrIn, lPos, rPos) result(cStrOut) To remove substring from the character string at specified positions. If the lPos argument is less than 1, then 1 is used as a starting point\n of the substring. Similarly, if the rPos argument is greater than length of the character\n string, then the length is used as a ending point. If the rPos argument is less than the lPos argument, the original\n character string is returned. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string integer(kind=kInt32), intent(in) :: lPos the leftmost character position of the substring integer(kind=kInt32), intent(in) :: rPos the rightmost character position of the substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface RemoveSubstringProtect Function Interface : RemoveSubstringProtect Purpose :  To remove the substring from the unprotected regions of the\n               character string based on specified input. Usage : --->    OutStr = RemoveSubstringProtect(InStr, SubStr) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, ExclMrk=.FALSE.) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, FirstOnly=.TRUE.) --->    OutStr = RemoveSubstringProtect(InStr, SubStr, .FALSE., .TRUE.) private recursive module function RemoveSubstringProtect(cStrIn, sStr, ExclMrk, FirstOnly) result(cStrOut) To remove the substring from the unprotected regions of the character\n string based on specified input. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: sStr substring to be removed logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. logical, intent(in), optional :: FirstOnly flag indicating whether to remove only the first substring found or to\n remove all occurrences found. If true, only remove the first substring found; otherwise, remove all\n (non-overlapping) occurrences found. Default is false. Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface ReplaceSubstring Function Interface : ReplaceSubstring Purpose :  To replace all occurrences of the original substring found\n               in the given character string with the new substring based\n               on specified input. Usage : --->    OutStr = ReplaceSubstring(InStr, OldSub, NewSub) --->    OutStr = ReplaceSubstring(InStr, NewSub, OldLen, OldCount, OldPos) private module function ReplaceSubstring(cStrIn, oStr, nStr) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring Return Value character(kind=kChar, len=:), ALLOCATABLE output character string private recursive module function ReplaceSubstringKnownPos(cStrIn, nStr, oLen, oCount, oPos) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring by providing length, number of\n occurrences and position(s) of first character of original substring. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: nStr new substring integer(kind=kInt32), intent(in) :: oLen length of original substring integer(kind=kInt32), intent(in) :: oCount number of occurrences of original substring integer(kind=kInt32), intent(in) :: oPos (oCount) position(s) of first character of original substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface ReplaceSubstringProtect Function Interface : ReplaceSubstringProtect Purpose :  To replace all occurrences of the original substring found\n               in unprotected regions of the given character string with\n               the new substring. Usage : --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub) --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub, ExclMrk=.FALSE.) private recursive module function ReplaceSubstringProtect(cStrIn, oStr, nStr, ExclMrk) result(cStrOut) To replace all occurrences of the original substring found in unprotected\n regions of the given character string with the new substring. See the FindProtectedRegions routine for explanations regarding the protected\n region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. Return Value character(kind=kChar, len=:), ALLOCATABLE output character string public        interface ReplaceSubstringRecursive Function Interface : ReplaceSubstringRecursive Purpose :  To replace all occurrences of the original substring found\n               in the given character string with the new substring in\n               a recursive way. Usage : --->    OutStr = ReplaceSubstringRecursive(InStr, OldSub, NewSub) Example : Input : cStrIn = 'abbbbb', oStr = 'ab', nStr = 'a' Output - non-recursive: cStrOut = 'abbbb' Output - recursive: cStrOut = 'ab' private module function ReplaceSubstringRecursive(cStrIn, oStr, nStr) result(cStrOut) To replace all occurrences of the original substring found in the given\n character string with the new substring in a recursive way. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStrIn input string character(kind=kChar, len=*), intent(in) :: oStr original (old) substring character(kind=kChar, len=*), intent(in) :: nStr new substring Return Value character(kind=kChar, len=:), ALLOCATABLE output string public        interface Partition Subroutine Interface : Partition Purpose :  To partition a character string into two substrings by a\n               separator (single character or a multiple-character string).\n               The partition occurs at the first occurrence of the separator\n               found. Usage : ! SepSub is a multiple-character string separator. --->    CALL Partition(cStr, SepSub, bStr, aStr) ! SepSet is a set of characters where a character in the set is a valid ! separator.  Also, search the first separator from the back. --->    CALL Partition(cStr, SepSet, bStr, aStr, SepChr, Back=.TRUE.) private module subroutine PartitionSepSub(cStr, SepSub, bStr, aStr, Back) To partition a character string into two substrings where the specified\n separator is a multiple-character string.  The partition occurs at the\n first occurrence of the separator found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator character(kind=kChar, len=:), intent(out), ALLOCATABLE :: bStr substring before the separator found character(kind=kChar, len=:), intent(out), ALLOCATABLE :: aStr substring after the separator found logical, intent(in), optional :: Back flag indicating whether to search the separator from the back or not. - True: search the separator from the back. - False: search the separator from the front. Default is false. private module subroutine PartitionSepChr(cStr, SepSet, bStr, aStr, SepChr, Back) To partition a character string into two substrings where the separator\n is a single character (any character in the specified set of characters).\n The partition occurs at the first occurrence of the separator found. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators character(kind=kChar, len=:), intent(out), ALLOCATABLE :: bStr substring before the separator found character(kind=kChar, len=:), intent(out), ALLOCATABLE :: aStr substring after the separator found character(kind=kChar, len=1), intent(out) :: SepChr the separator found logical, intent(in), optional :: Back flag indicating whether to search the separator from the back or not. - True: search the separator from the back. - False: search the separator from the front. Default is false. public        interface Split Subroutine Interface : Split Purpose :  To split a character string into multiple substrings by a\n               separator (single character or a multiple-character string). Usage : ! SepSub is a multiple-character string separator. --->    CALL Split(cStr, SepSub, qStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL Split(cStr, SepSet, qStr, SepChr) private module subroutine SplitSepSub(cStr, SepSub, qStr) To split a character string into multiple substrings where the specified\n separator is a multiple-character string. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator type(QueueChar), intent(out) :: qStr queue of substrings private module subroutine SplitSepChr(cStr, SepSet, qStr, SepChr) To split a character string into multiple substrings where the separator\n is a single character (any character in the specified set of characters). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators type(QueueChar), intent(out) :: qStr queue of substrings character(kind=kChar, len=1), intent(out), ALLOCATABLE :: SepChr (:) separators found public        interface SplitProtect Subroutine Interface : SplitProtect Purpose :  To split a character string into multiple substrings by a\n               separator (single character or a multiple-character string)\n               found in unprotected region(s). Usage : ! SepSub is a multiple-character string separator. --->    CALL SplitProtect(cStr, SepSub, qStr) ! SepSet is a set of characters where a character in the set is a valid separator. --->    CALL SplitProtect(cStr, SepSet, qStr, SepChr) ! The exclamation mark is NOT used to define the protected regions. --->    CALL SplitProtect(cStr, SepSub, qStr, ExclMrk=.FALSE.) private module subroutine SplitSepSubProtect(cStr, SepSub, qStr, ExclMrk) To split a character string into multiple substrings where the specified\n separator is a multiple-character string found in unprotected region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSub multiple-character separator type(QueueChar), intent(out) :: qStr queue of substrings logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true. private module subroutine SplitSepChrProtect(cStr, SepSet, qStr, SepChr, ExclMrk) To split a character string into multiple substrings where the separator\n is a single character (any character in the specified set of characters)\n found in unprotected region(s). Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: cStr character string character(kind=kChar, len=*), intent(in) :: SepSet set of characters representing valid separators type(QueueChar), intent(out) :: qStr queue of substrings character(kind=kChar, len=1), intent(out), ALLOCATABLE :: SepChr (:) separators found logical, intent(in), optional :: ExclMrk flag indicating whether the exclamation is used to define a protected\n region or not. - If true, both the exclamation mark and quotes are used. - If false, only quotes are used. Default is true.","tags":"","loc":"module\\mbase_chrstr.html"},{"title":"MClass_PatternFinder – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PatternFinder type and its related helper types and routines.\n  The PatternFinder type is a string type that provides various efficient algorithms for\n  a substring searching operation.  The substring searching is a fundamental string\n  operation where given a text string of length N and a pattern string of length M,\n  find an occurrence of the pattern within the text . Available searching algorithms include: - BruteForce : a simple basic searching algorithm [1, 6], - BoyerMoore : a searching algorithm by Boyer and Mooore [1, 6], - KMP : a searching algorithm by Knuth, Morris and Pratt [1, 6], - KMPlus : an optimized version of KMP algorithm [1, 6], - RabinKarp : a searching algorithm by Rabin and Karp [1, 6], - Horspool : an improved version of BoyerMoore algorithm by Horspool [2, 7], - Raita : an improved version of Horspool algorithm by Raita [3, 7], - Sunday : an improved version of BoyerMoore algorithm by Sunday [4], and - BNDM : a Backwards Non-deterministic DAWG (Directed acyclic word graph)\n     Matching algorithm by Gonzalo Navarro and Mathieu Raffinot [5, 7]. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. [2] R.N. Horspool. 1980. Practical Fast Searching in Strings. Software-Practice and\n      Experience, vol. 10, pp. 501-506. [3] T. Raita. 1992. Tuning the Boyer-Moore-Horspool string searching algorithm.\n      Software-Practice and Experience, vol. 22(10), pp. 879-884. [4] D.M. Sunday. 1990.  A very fast\n      substring search algorithm.  Communications of the ACM, vol. 33(8), pp. 132-142. [5] G. Navarro and M. Raffinot. 1998. A Bit-Parallel Approach to Suffix Automata:\n      Fast Extended String Matching. Combinatorial Pattern Matching, pp. 14-33. [6] R. Sedgewick and K. Wayne.\n      Algorithms, 4th Edition, Online version. [7] StringSearch:\n      High-performance pattern matching algorithms in Java. Uses MBase_SInt128 MBase_CharUtil MBase_Common MBase_ErrHandlers MClass_Sfc64RNG MBase_SIntUtil MBase_MathUtil iso_c_binding Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: BruteForce = 0 integer(kind=kInt32), public, parameter :: BoyerMoore = 1 integer(kind=kInt32), public, parameter :: KMPlus = 2 integer(kind=kInt32), public, parameter :: KMP = 3 integer(kind=kInt32), public, parameter :: RabinKarp = 4 integer(kind=kInt32), public, parameter :: Horspool = 5 integer(kind=kInt32), public, parameter :: Raita = 6 integer(kind=kInt32), public, parameter :: Sunday = 7 integer(kind=kInt32), public, parameter :: BNDM = 8 Derived Types type, public :: PatternFinder The PatternFinder type is a string type that provides various efficient\n algorithms for a substring searching operation. Finalizations Procedures final :: PatternFinder_Finalize To perform finalization of the PatternFinder object. Type-Bound Procedures procedure, public :: SetPattern => PatternFinder_SetPattern Type-Bound Subroutine : SetPattern Purpose :  To process the specified pattern based on the specified searching algorithm. Usage : --->    CALL Finder%SetPattern(Pattern, SearchAlgo) --->    CALL Finder%SetPattern(Pattern, BNDM, WildCard='.') --->    CALL Finder%SetPattern(Pattern, BNDM, Insensitive=.TRUE.) --->    CALL Finder%SetPattern(Pattern, BNDM, .TRUE., ' ') Note : 1. If the length of the pattern is zero, the method just returns without doing anything. 2. The optional Insensitive and WildCard* arguments are applicable for the BNDM method only. procedure, public :: FindIndex => PatternFinder_FindIndex Type-Bound Function : FindIndex Purpose :  To find the first occurrence of the (previously specified) pattern within the\n      specified text .  Return an (one-based) index representing the position of the first\n      character of the occurrence found.  Return zero if there is no such pattern found.  If the\n      pattern has not yet been set, return one. Usage : ! start searching from the beginning of the text --->    Index = Finder%FindIndex(Text) ! start searching from the specified position (one-based) of the text --->    Index = Finder%FindIndex(Text, StartPos) procedure, public :: FindNext => PatternFinder_FindNext Type-Bound Function : FindNext Purpose :  To find the next occurrence of the (previously specified) pattern within the\n       (previously specified) text . Usage : --->    Index = Finder%FindNext() Note : Must call the SetPattern and FindIndex methods before calling this method. procedure, public :: Clear => PatternFinder_Clear Type-Bound Subroutine : Clear Purpose :  To reset/clear all components of the PatternFinder object. Usage : --->    CALL Finder%Clear() Note : If the length of the pattern is zero, the method just returns without doing anything.","tags":"","loc":"module\\mclass_patternfinder.html"},{"title":"MClass_AlphabetTrie – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the AlphabetTrie type and its related routines.\n  The AlphabetTrie type is a derived type representing a symbol table\n  of key-value pairs, with string keys and generic values. The AlphabetTrie type supports common operations of the symbol table\n  including the Insert , Remove , Contain , GetSize , IsEmpty and GetValue methods.  It also provides character-based methods for finding\n  the string in the symbol table that is the longest prefix of a given prefix,\n  finding all strings in the symbol table that start with a given prefix, and\n  finding all strings in the symbol table that match a given pattern. For all operations provided, the AlphabetTrie type supports two types of\n  character strings: the Fortran intrinsic CHARACTER type and the FvlStr derived type.  A user can choose to work with one of these two types.  Like\n  other symbol tables, the AlphabetTrie type does not allow duplicated keys.\n  Therefore, if an inserted key is equal to a key stored in the table, an\n  associated value of the stored key is replaced by an associated value of\n  the inserted key. Similar to the MultiwayTrie type, the AlphabetTrie type technically employs a multi-way\n  (R-way) trie implementation.  However, unlike the MultiwayTrie type with its\n  fixed R (= 256), the AlphabetTrie type can be used with any R, which is the\n  number of characters (i.e. the radix) in an alphabet set of characters.  Also,\n  unlike the MultiwayTrie type, an explicit construction is required via either\n  the CreateEmpty or the Construct method where a user must specify a specific\n  set of characters via an alphabet data type. See the Class_Alphabets module for\n  various alphabet data types available to be used with the AlphabetTrie type.\n  Most of these data types commonly have a much smaller radix than 256; therefore,\n  the AlphabetTrie type is likely more efficient than the MultiwayTrie type\n  when working with those alphabet data types with small radix. It is important to note that all provided concrete alphabet data types also\n  require an explicit construction via their Construct method.  Therefore, a\n  user must construct an alphabet data type before supplying it to one of the AlphabetTrie type's construction methods.  It is also worth mentioning that\n  the given alphabet data type must contain all characters (with the exception of\n  the wild-card characters) of all strings that the user will specify as input\n  arguments.  This means that the user must know in advance what kind of characters\n  to be used so that he/she can properly select a particular alphabet data type. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Uses MClass_StringBuilder MBase_Common MBase_ErrHandlers MBase_DoublyLinkedLists MClass_Alphabets MClass_FvlStr Derived Types type, public :: AlphabetTrie The AlphabetTrie type is a container type that utilizes a multi-way trie\n implementation to provide common operations for a symbol table where its\n keys are character strings and its values can be of any type. Finalizations Procedures final :: AlphabetTrie_Finalizer To perform finalization of the symbol table. Type-Bound Procedures procedure, public :: CreateEmpty => AlphabetTrie_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty symbol table. Usage : --->    CALL Table%CreateEmpty(Alphabet) generic, public :: Construct => AlphabetTrie_ConstructByArray_ChrStr, AlphabetTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(Alphabet, 10, KeyArr, ValArr) procedure, public :: Clear => AlphabetTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() generic, public :: Destruct => AlphabetTrie_Destructor_ChrStr, AlphabetTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: Insert => AlphabetTrie_Insert_ChrStr, AlphabetTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) generic, public :: Remove => AlphabetTrie_Remove_ChrStr, AlphabetTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) generic, public :: Contain => AlphabetTrie_Contain_ChrStr, AlphabetTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetSize => AlphabetTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() procedure, public :: IsEmpty => AlphabetTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing generic, public :: StartWith => AlphabetTrie_StartWith_ChrStr, AlphabetTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing generic, public :: GetValue => AlphabetTrie_GetValue_ChrStr, AlphabetTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) generic, public :: GetAllKeys => AlphabetTrie_AllKeys_ChrStr, AlphabetTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysWithPrefix => AlphabetTrie_KeysWithPrefix_CHCH, AlphabetTrie_KeysWithPrefix_CHVL, AlphabetTrie_KeysWithPrefix_VLCH, AlphabetTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysThatMatch => AlphabetTrie_KeysThatMatch_CHCH, AlphabetTrie_KeysThatMatch_CHVL, AlphabetTrie_KeysThatMatch_VLCH, AlphabetTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetWildcardKeys => AlphabetTrie_WildcardKeys_CHCH, AlphabetTrie_WildcardKeys_CHVL, AlphabetTrie_WildcardKeys_VLCH, AlphabetTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. generic, public :: GetLongestPrefixOf => AlphabetTrie_LongestPrefixOf_ChrStr, AlphabetTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix)","tags":"","loc":"module\\mclass_alphabettrie.html"},{"title":"MClass_MultiwayTrie – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the MultiwayTrie type and its related routines.\n  The MultiwayTrie type is a derived type representing a symbol table\n  of key-value pairs, with string keys and generic values. The MultiwayTrie type supports common operations of the symbol table\n  including the Insert , Remove , Contain , GetSize , IsEmpty and GetValue methods.  It also provides character-based methods for finding\n  the string in the symbol table that is the longest prefix of a given prefix,\n  finding all strings in the symbol table that start with a given prefix, and\n  finding all strings in the symbol table that match a given pattern. For all operations provided, the MultiwayTrie type supports two types of\n  character strings: the Fortran intrinsic CHARACTER type and the FvlStr derived type.  A user can choose to work with one of these two types.  Like\n  other symbol tables, the MultiwayTrie type does not allow duplicated keys.\n  Therefore, if an inserted key is equal to a key stored in the table, an\n  associated value of the stored key is replaced by an associated value of\n  the inserted key.  Technically, the MultiwayTrie type employs a R-way\n  (multi-way) trie implementation where R is 256.  This implies that the\n  characters are encoded according to the 8-bit Extended ASCII codes. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Uses MClass_StringBuilder MBase_Common MBase_ErrHandlers MBase_DoublyLinkedLists MClass_FvlStr Derived Types type, public :: MultiwayTrie The MultiwayTrie type is a container type that utilizes a multi-way trie\n implementation to provide common operations for a symbol table where its\n keys are character strings and its values can be of any type. Finalizations Procedures final :: MultiwayTrie_Finalizer To perform finalization of the symbol table. Type-Bound Procedures generic, public :: Construct => MultiwayTrie_ConstructByArray_ChrStr, MultiwayTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(10, KeyArr, ValArr) procedure, public :: Clear => MultiwayTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() generic, public :: Destruct => MultiwayTrie_Destructor_ChrStr, MultiwayTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: Insert => MultiwayTrie_Insert_ChrStr, MultiwayTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) generic, public :: Remove => MultiwayTrie_Remove_ChrStr, MultiwayTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) generic, public :: Contain => MultiwayTrie_Contain_ChrStr, MultiwayTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetSize => MultiwayTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() procedure, public :: IsEmpty => MultiwayTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing generic, public :: StartWith => MultiwayTrie_StartWith_ChrStr, MultiwayTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing generic, public :: GetValue => MultiwayTrie_GetValue_ChrStr, MultiwayTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) generic, public :: GetAllKeys => MultiwayTrie_AllKeys_ChrStr, MultiwayTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysWithPrefix => MultiwayTrie_KeysWithPrefix_CHCH, MultiwayTrie_KeysWithPrefix_CHVL, MultiwayTrie_KeysWithPrefix_VLCH, MultiwayTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysThatMatch => MultiwayTrie_KeysThatMatch_CHCH, MultiwayTrie_KeysThatMatch_CHVL, MultiwayTrie_KeysThatMatch_VLCH, MultiwayTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetWildcardKeys => MultiwayTrie_WildcardKeys_CHCH, MultiwayTrie_WildcardKeys_CHVL, MultiwayTrie_WildcardKeys_VLCH, MultiwayTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. generic, public :: GetLongestPrefixOf => MultiwayTrie_LongestPrefixOf_ChrStr, MultiwayTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix)","tags":"","loc":"module\\mclass_multiwaytrie.html"},{"title":"MClass_RECompiler – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the RECompiler type and its related routines. REFERENCES : [1] The Apache Jakarta Project. Uses MClass_StringBuilder MBase_CharUtil MBase_Common MClass_REProgram MBase_ErrHandlers MBase_ChrStr MBase_MemHandlers MBase_SIntUtil MBase_REParameters Derived Types type, public :: RECompiler The RECompiler type is a ... Type-Bound Procedures procedure, public :: Compile => RECompiler_Compile","tags":"","loc":"module\\mclass_recompiler.html"},{"title":"MClass_Alphabets – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains various alphabet data types and its related routines.\n  An alphabet data type is a data type for a given alphabet, which is a set\n  of characters.  It is intended to be used with string-processing code that\n  must convert between an alphabet of size Radix and the integers (i.e. indices)\n  through 1 through Radix. The following concrete alphabet data types are provided. - The GenericAlphabet type for any alphabet (i.e. any set of characters). - The BinaryAlphabet type for binary alphabet {0, 1}. - The OctalAlphabet type for octal alphabet {0, 1, 2, 3, 4, 5, 6, 7}. - The DecimalAlphabet type for decimal alphabet {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. - The HexadecimalAlphabet type for hexadecimal alphabet\n    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F}. - The DnaAlphabet type for DNA alphabet {A, C, T, G}. - The ProteinAlphabet type for protein alphabet\n    {A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y}. - The LowercaseAlphabet type for lowercase alphabet {a, b, c, ..., z}. - The UppercaseAlphabet type for uppercase alphabet {A, B, C, ..., Z}. - The Base64Alphabet type for base-64 alphabet {64 characters}. - The Code39Alphabet type for binary alphabet {43+1 characters}. - The AsciiAlphabet type for ASCII alphabet {128 characters}. - The ExtendedAsciiAlphabet type for extended ASCII alphabet {256 characters}. All alphabet data types provide common operations including: - the Construct method to create the instance of the alphabet data type, - the Contain method to check whether the specified character is in the alphabet's\n    set of characters, - the Verify method to check whether all characters of the specified word are in\n    the alphabet's set of characters, - the GetRadix method to get the number of characters in the alphabet's set, - the GetIndex method to get the index corresponding to the specified character, and - the GetChar method to get the character corresponding to the specified index. All concrete alphabet data types provided require an explicit construction before\n  other operations can be used.  The GenericAlphabet type can be constructed from\n  either a given set of characters or a specified radix (which represents a number of\n  characters in the set where the characters's code ranges from 0 to radix-1).  Other\n  types requires no argument (besides the object itself) for their construction method. Uses MBase_SimpleHash32 MClass_Object MClass_IntrusiveHashTree MBase_Common MBase_ErrHandlers iso_fortran_env MClass_IntrusiveBSTrees MClass_FvlStr MBase_SIntUtil MClass_Comparable Derived Types type, public :: BaseAlphabet The BaseAlphabet type is an abstract data type for alphabets intended to\n be used with string-processing code that must convert between an alphabet\n of size R and the integers through 1 through R. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() type, public, extends( BaseAlphabet ) :: GenericAlphabet The GenericAlphabet type is a generic data type that can represent any alphabets.\n An instance of the GenericAlphabet type can be created via the Construct method\n from either a given set of characters or a radix (representing a number of characters\n in the set where the characters' code are from 0 to radix-1). Finalizations Procedures final :: GenericAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() generic, public :: Construct => GenericAlphabet_FromCharSet, GenericAlphabet_FromRadix Type-Bound Subroutine : Construct Purpose : To create this Alphabet object either from a specified set of characters\n              or from the radix (which is the number of characters in the set where\n              characters' code ranges from 0 to radix-1). Usage : --->    CALL Alphabet%Construct(CharSet) --->    CALL Alphabet%Construct(Radix) type, public, extends( BaseAlphabet ) :: BinaryAlphabet The BinaryAlphabet type is a data type representing the binary alphabet { 0, 1 }. Finalizations Procedures final :: BinaryAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => BinaryAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: OctalAlphabet The OctalAlphabet type is a data type representing the octal alphabet { 0, 1, 2, 3, 4, 5, 6, 7 }. Finalizations Procedures final :: OctalAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => OctalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: DecimalAlphabet The DecimalAlphabet type is a data type representing the decimal alphabet\n { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }. Finalizations Procedures final :: DecimalAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => DecimalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: HexadecimalAlphabet The HexadecimalAlphabet type is a data type representing the hexadecimal alphabet\n { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F }. Finalizations Procedures final :: HexadecimalAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => HexadecimalAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: DnaAlphabet The DnaAlphabet type is a data type representing the DNA alphabet { A, C, T, G }. Finalizations Procedures final :: DnaAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => DnaAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: ProteinAlphabet The ProteinAlphabet type is a data type representing the protein alphabet\n { A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y }. Finalizations Procedures final :: ProteinAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => ProteinAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: LowercaseAlphabet The LowercaseAlphabet type is a data type representing the lowercase alphabet\n { a, b, c, ..., z }. Finalizations Procedures final :: LowercaseAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => LowercaseAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: UppercaseAlphabet The UppercaseAlphabet type is a data type representing the uppercase alphabet\n { A, B, C, ..., Z }. Finalizations Procedures final :: UppercaseAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => UppercaseAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: Base64Alphabet The Base64Alphabet type is a data type representing the base-64 alphabet { 64 characters }. Finalizations Procedures final :: Base64Alphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => Base64Alphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: Code39Alphabet The Code39Alphabet type is a data type representing the Code-39 alphabet { 43+1 characters }. Finalizations Procedures final :: Code39Alphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => Code39Alphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: AsciiAlphabet The AsciiAlphabet type is a data type representing the ASCII alphabet { 0-127 characters' code }. Finalizations Procedures final :: AsciiAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => AsciiAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct() type, public, extends( BaseAlphabet ) :: ExtendedAsciiAlphabet The ExtendedAsciiAlphabet type is a data type representing the extended ASCII alphabet\n { 0-255 characters' code }. Finalizations Procedures final :: ExtendedAsciiAlphabet_Finalize To perform finalization of this object. Type-Bound Procedures procedure, public :: IsReady => Alphabet_IsReady Type-Bound Function : IsReady Purpose : To check whether the Alphabet object is ready to be used. Usage : --->    Flag = Alphabet%IsReady() --->    IF (.NOT.Alphabet%IsReady()) DoSomething procedure, public :: Contain => Alphabet_Contain Type-Bound Function : Contain Purpose : To check whether the Alphabet object contains the specified character or not. Usage : --->    Flag = Alphabet%Contain(Chr) --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething generic, public :: Verify => Alphabet_Verify_ChrStr, Alphabet_Verify_FvlStr Type-Bound Function : Verify Purpose : To verify that all characters in the specified word are in the set of\n              characters of this alphabet.  Return 0 if they are.  Otherwise, return\n              a number indicating the first position (index) of the character that\n              is not in the set. Usage : --->    Flag = Alphabet%Verify(Word) --->    IF (Alphabet%Verify(Word) /= 0) DoSomething procedure, public :: GetRadix => Alphabet_Radix Type-Bound Function : GetRadix Purpose : To return the number of characters in the Alphabet object. Usage : --->    Radix = Alphabet%GetRadix() procedure, public :: GetIndex => Alphabet_ToIndex Type-Bound Function : GetIndex Purpose : To return the index corresponding to the specified character.  If the\n              character is not in the Alphabet object, return -1. Usage : --->    Index = Alphabet%GetIndex() procedure, public :: GetChar => Alphabet_ToChar Type-Bound Function : GetChar Purpose : To return the character corresponding to the specified index.  If the\n              index is not in the valid range (1 to Radix), return an empty character. Usage : --->    Chr = Alphabet%GetChar() procedure, public :: Construct => ExtendedAsciiAlphabet_Construct Type-Bound Subroutine : Construct Purpose : To create this Alphabet object. Usage : --->    CALL Alphabet%Construct()","tags":"","loc":"module\\mclass_alphabets.html"},{"title":"MBase_REParameters – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the REProgram type and its related helper types and routines.\n  The REProgram type is a string type that provides various efficient algorithms for\n  a substring searching operation.  The substring searching is a fundamental string\n  operation where given a text string of length N and a pattern string of length M,\n  find an occurrence of the pattern within the text . REFERENCES : [1] The Apache Jakarta Project. Uses MBase_Common Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: OPT_HASBACKREFS = 1 integer(kind=kInt32), public, parameter :: OPT_HASBOL = 2 integer(kind=kInt32), public, parameter :: NODE_NORMAL = 0 integer(kind=kInt32), public, parameter :: NODE_NULLABLE = 1 integer(kind=kInt32), public, parameter :: NODE_TOPLEVEL = 2 integer(kind=kInt32), public, parameter :: ESC_MASK = INT(Z'000FFFF0', KIND=kInt32) integer(kind=kInt32), public, parameter :: ESC_BACKREF = INT(Z'000FFFFF', KIND=kInt32) integer(kind=kInt32), public, parameter :: ESC_COMPLEX = INT(Z'000FFFFE', KIND=kInt32) integer(kind=kInt32), public, parameter :: ESC_CLASS = INT(Z'000FFFFD', KIND=kInt32) integer(kind=kInt32), public, parameter :: bracketUnbounded = -1 integer(kind=kInt32), public, parameter :: MATCH_NORMAL = INT(Z'00000000', KIND=kInt32) integer(kind=kInt32), public, parameter :: MATCH_CASEINDEPENDENT = INT(Z'00000001', KIND=kInt32) integer(kind=kInt32), public, parameter :: MATCH_MULTILINE = INT(Z'00000002', KIND=kInt32) integer(kind=kInt32), public, parameter :: MATCH_SINGLELINE = INT(Z'00000004', KIND=kInt32) character(kind=kChar, len=1), public, parameter :: OP_END = 'E' character(kind=kChar, len=1), public, parameter :: OP_BOL = '&#94;' character(kind=kChar, len=1), public, parameter :: OP_EOL = '$' character(kind=kChar, len=1), public, parameter :: OP_ANY = '.' character(kind=kChar, len=1), public, parameter :: OP_ANYOF = '[' character(kind=kChar, len=1), public, parameter :: OP_BRANCH = '|' character(kind=kChar, len=1), public, parameter :: OP_ATOM = 'A' character(kind=kChar, len=1), public, parameter :: OP_STAR = '*' character(kind=kChar, len=1), public, parameter :: OP_PLUS = '+' character(kind=kChar, len=1), public, parameter :: OP_MAYBE = '?' character(kind=kChar, len=1), public, parameter :: OP_ESCAPE = '\\' character(kind=kChar, len=1), public, parameter :: OP_OPEN = '(' character(kind=kChar, len=1), public, parameter :: OP_OPEN_CLUSTER = '<' character(kind=kChar, len=1), public, parameter :: OP_CLOSE = ')' character(kind=kChar, len=1), public, parameter :: OP_CLOSE_CLUSTER = '>' character(kind=kChar, len=1), public, parameter :: OP_BACKREF = '#' character(kind=kChar, len=1), public, parameter :: OP_GOTO = 'G' character(kind=kChar, len=1), public, parameter :: OP_NOTHING = 'N' character(kind=kChar, len=1), public, parameter :: OP_CONTINUE = 'C' character(kind=kChar, len=1), public, parameter :: OP_RELUCTANTSTAR = '8' character(kind=kChar, len=1), public, parameter :: OP_RELUCTANTPLUS = '=' character(kind=kChar, len=1), public, parameter :: OP_RELUCTANTMAYBE = '/' character(kind=kChar, len=1), public, parameter :: OP_POSIXCLASS = 'P' character(kind=kChar, len=1), public, parameter :: E_ALNUM = 'w' character(kind=kChar, len=1), public, parameter :: E_NALNUM = 'W' character(kind=kChar, len=1), public, parameter :: E_BOUND = 'b' character(kind=kChar, len=1), public, parameter :: E_NBOUND = 'B' character(kind=kChar, len=1), public, parameter :: E_SPACE = 's' character(kind=kChar, len=1), public, parameter :: E_NSPACE = 'S' character(kind=kChar, len=1), public, parameter :: E_DIGIT = 'd' character(kind=kChar, len=1), public, parameter :: E_NDIGIT = 'D' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_ALNUM = 'w' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_ALPHA = 'a' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_BLANK = 'b' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_CNTRL = 'c' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_DIGIT = 'd' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_GRAPH = 'g' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_LOWER = 'l' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_PRINT = 'p' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_PUNCT = '!' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_SPACE = 's' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_UPPER = 'u' character(kind=kChar, len=1), public, parameter :: POSIX_CLASS_HEXDG = 'x' integer(kind=kInt32), public, parameter :: maxNode = 65536 integer(kind=kInt32), public, parameter :: MAX_PAREN = 16 integer(kind=kInt32), public, parameter :: offsetOpcode = 0 integer(kind=kInt32), public, parameter :: offsetOpdata = 1 integer(kind=kInt32), public, parameter :: offsetNext = 2 integer(kind=kInt32), public, parameter :: nodeSize = 3 type(PosixPair), public, parameter :: hashPOSIX (*) = [PosixPair(\"alnum\", POSIX_CLASS_ALNUM), PosixPair(\"alpha\", POSIX_CLASS_ALPHA), PosixPair(\"blank\", POSIX_CLASS_BLANK), PosixPair(\"cntrl\", POSIX_CLASS_CNTRL), PosixPair(\"digit\", POSIX_CLASS_DIGIT), PosixPair(\"graph\", POSIX_CLASS_GRAPH), PosixPair(\"lower\", POSIX_CLASS_LOWER), PosixPair(\"print\", POSIX_CLASS_PRINT), PosixPair(\"punct\", POSIX_CLASS_PUNCT), PosixPair(\"space\", POSIX_CLASS_SPACE), PosixPair(\"upper\", POSIX_CLASS_UPPER), PosixPair(\"hexdg\", POSIX_CLASS_HEXDG)] Functions public  function hashPOSIX_GetChar (Name) result(C) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=5), intent(in) :: Name To check whether the given character is in the given ASCII range\n  from ASCII_Min to ASCII_Max.\n** SUBROUTINE ARGUMENT DECLARATIONS: Return Value character(kind=kChar, len=1)","tags":"","loc":"module\\mbase_reparameters.html"},{"title":"MClass_RegexFinder – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the RegexFinder type and its related helper types and routines.\n  The RegexFinder type is a string type that provides various efficient algorithms for\n  a substring searching operation.  The substring searching is a fundamental string\n  operation where given a text string of length N and a pattern string of length M,\n  find an occurrence of the pattern within the text . REFERENCES : [1] DFA-Regex: A DFA regex engine in java. Uses MClass_DFAutomaton MBase_Common MClass_NFAutomaton MClass_SyntaxTree MClass_BitmapState MClass_SyntaxNode Derived Types type, public :: RegexFinder The RegexFinder type is a string type that provides various efficient\n algorithms for a substring searching operation. Type-Bound Procedures procedure, public :: SetPattern => RegexFinder_SetPattern Type-Bound Subroutine : SetPattern Purpose :  To set and compile the specified pattern. Usage : --->    CALL Finder%SetPattern(Pattern) procedure, public :: IsMatch => RegexFinder_IsMatch Type-Bound Function : IsMatch Purpose :  To check whether the specified text matches the previously compiled pattern\n               (or the optionally specified pattern). Usage : --->    Flag = Finder%IsMatch(Text) --->    IF (.NOT.Finder%IsMatch(Text, Pattern)) DoSomething procedure, public :: FindSubstring => RegexFinder_FindSubstring Type-Bound Function : FindSubstring Purpose :  To find a substring within the specified text that matches the previously\n               compiled pattern (or the optionally specified pattern).  If the 'StartPos'\n               argument is present and greater than 0 and less than the text length, the\n               search starts at the 'StartPos' position.  Otherwise, the search start at\n               the first position of the text.  The routine returns indices indicating\n               the starting and ending positions of the substring if found.  If the\n               substring is not found, both indices are set to zeros. Usage : ! find a substring within the text starting at 1 where the pattern has already been set. --->    Indices = Finder%FindSubstring(Text) ! find a substring within the text starting at StartPos. --->    Indices = Finder%FindSubstring(Text, StartPos=StartPos) ! find a substring within the text where the pattern has not yet been set. --->    Indices = Finder%FindSubstring(Text, Pattern=Pattern) ! find a substring within the text starting at StartPos where the pattern has not yet been set. --->    Indices = Finder%FindSubstring(Text, StartPos, Pattern)","tags":"","loc":"module\\mclass_regexfinder.html"},{"title":"MClass_DFAutomaton – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DFAutomaton type and its related routines.\n  The DFAutomaton type is a derived type representing a ... Uses MBase_OptimalHash32 MClass_IntrusiveHashList MClass_TreeInteger4B MClass_PQInteger4B MClass_Object MBase_Common MBase_ErrHandlers MClass_SyntaxTree MClass_IntrusiveLinkedLists MBase_MemHandlers MBase_SIntUtil MClass_BitmapState iso_c_binding Derived Types type, public :: CompiledRegex Components Type Visibility Attributes Name Initial integer(kind=kInt32), public, ALLOCATABLE :: TransitionTable (:,:) integer(kind=kInt32), public :: IS = -1 integer(kind=kInt32), public :: RS = -1 logical, public, ALLOCATABLE :: FS (:) type, public :: DFAutomaton The DFAutomaton type is a node type... Components Type Visibility Attributes Name Initial type( BitmapStateManager ), public, POINTER :: Manager => NULL() type( BitmapState ), public, POINTER :: States (:) => NULL() Type-Bound Procedures procedure, public :: Construct => DFAutomaton_Construct procedure, public :: Destruct => DFAutomaton_Destruct procedure, public :: Initialize => DFAutomaton_Initialize procedure, public :: NFATransMap => DFAutomaton_NFATransMap procedure, public :: OriginalDFA => DFAutomaton_OriginalDFA procedure, public :: CalculateClosure => DFAutomaton_CalculateClosure procedure, public :: DfsClosure => DFAutomaton_DfsClosure procedure, public :: TraceReachable => DFAutomaton_TraceReachable procedure, public :: Minimize => DFAutomaton_Minimize","tags":"","loc":"module\\mclass_dfautomaton.html"},{"title":"MBase_StringSorts – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains sorting and ranking routines specialized for strings.\n  The specified array can be of a CHARACTER or a FvlStr type. Uses MBase_Common MClass_Alphabets MBase_DoublyLinkedLists MBase_ChrStr MClass_FvlStr MClass_Comparable Interfaces public        interface Rank_Insensitive Subroutine Interface : Rank_Insensitive Purpose :  To rank an array of strings in an ascending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! rank an array of Fortran intrinsic character strings --->    CALL Rank_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! rank an array of FvlStr objects --->    CALL Rank_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. private  subroutine ChrStr_RankInsensitive(AVal, AInd, RankArray) To perform data ranking for an array of character strings where\n the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) array values to be ranked integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) indices indicating the ranking procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_RankInsensitive(AVal, AInd, RankArray) To perform data ranking for an array of FvlStr objects where\n the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(in) :: AVal (:) array values to be ranked integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) indices indicating the ranking procedure(ComparableRank) :: RankArray procedure to perform ranking public        interface SortAscend_Insensitive Subroutine Interface : SortAscend_Insensitive Purpose :  To sort an array of strings in an ascending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! sort an array of Fortran intrinsic character strings --->    CALL SortAscend_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! sort an array of FvlStr objects --->    CALL SortAscend_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. private  subroutine ChrStr_SortInsensitive_Ascend(AVal, RankArray) To perform data sorting in ascending order for an array of\n character strings where the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: AVal (:) array values to be ranked procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_SortInsensitive_Ascend(AVal, RankArray) To perform data sorting in ascending order for an array of\n FvlStr objects where the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array values to be ranked procedure(ComparableRank) :: RankArray procedure to perform ranking public        interface SortDescend_Insensitive Subroutine Interface : SortDescend_Insensitive Purpose :  To sort an array of strings in a descending order using the specified\n      ranking procedure where the strings are treated as case-insensitive strings.\n      An applicable user-supplied procedure or any applicable ranking procedure (e.g.\n      Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in\n      the MBase_Ranking module can be\n      used as an argument. Usage : ! sort an array of Fortran intrinsic character strings --->    CALL SortDescend_Insensitive(cStrArr, cStrInd, Wise_RankChar) ! sort an array of FvlStr objects --->    CALL SortDescend_Insensitive(vStrArr, vStrInd, Wise_RankComp) Note : The Wise_RankChar and Wise_RankComp are examples of applicable ranking procedures\n  for Fortran intrinsic character strings and FvlStr objects, respectively. private  subroutine ChrStr_SortInsensitive_Descend(AVal, RankArray) To perform data sorting in descending order for an array of\n character strings where the character case is ignored. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: AVal (:) array values to be ranked procedure(ChrStrRank) :: RankArray procedure to perform ranking private  subroutine FvlStr_SortInsensitive_Descend(AVal, RankArray) To perform data sorting in descending order for an array of\n FvlStr objects where the character case is ignored. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: AVal (:) array values to be ranked procedure(ComparableRank) :: RankArray procedure to perform ranking public        interface LSDSort Subroutine Interface : LSDSort Purpose :  To sort an array of strings in an ascending order using the LSD\n      string sorting algorithm. Usage : --->    CALL LSDSort(cStrArr) Note : This procedure is only applicable for Fortran character strings. private  subroutine ChrStr_LSDSort(A) To sort an array of character strings in an ascending order using\n the least-significant-digit (LSD) string sorting algorithm, which\n is preferable for same-length strings. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted public        interface MSDSort Subroutine Interface : MSDSort Purpose :  To sort an array of strings in an ascending order using the MSD\n      string sorting algorithm. Usage : --->    CALL MSDSort(Arr) private  subroutine ChrStr_MSDSort(A) To sort an array of character strings in an ascending order using\n the most-significant-digit (MSD) string sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_MSDSort(A) To sort an array of FvlStr objects in an ascending order using\n the most-significant-digit (MSD) string sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted public        interface MSDInplaceSort Subroutine Interface : MSDInplaceSort Purpose :  To sort an array of strings in an ascending order using the\n      in-place MSD string sorting algorithm.  Optionally, if all characters\n      of the strings are in a particular alphabet set, a user can specify an Alphabet data type of that particular alphabet set. Usage : --->    CALL MSDInplaceSort(Arr) --->    CALL MSDInplaceSort(Arr, Alphabet) Usage : See the Class_Alphabets module for various alphabet data types available to be used with the MSDInplaceSort procedure. private  subroutine ChrStr_MSDSort_Inplace(A) To sort an array of character strings in an ascending order using\n the in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_MSDSort_Inplace(A) To sort an array of FvlStr objects in an ascending order using\n the in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted private  subroutine ChrStr_MSDSort_Alphabet(A, Alpha) To sort an array of character strings (where all characters of the strings are\n in a particular alphabet set of characters) in an ascending order using the\n in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object private  subroutine FvlStr_MSDSort_Alphabet(A, Alpha) To sort an array of FvlStr objects (where all characters of their strings are\n in a particular alphabet set of characters) in an ascending order using the\n in-place MSD radix sorting algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted class( BaseAlphabet ), intent(inout) :: Alpha Alphabet object public        interface QuickMultiKeySort Subroutine Interface : QuickMultiKeySort Purpose :  To sort an array of strings in an ascending order using the\n      multi-key quicksort (or 3-way radix quicksort) algorithm. Usage : --->    CALL QuickMultiKeySort(Arr) private  subroutine ChrStr_QuickMultiKeySort(A) To sort an array of character strings in an ascending order using\n the three-way radix quicksort (or multi-key quicksort) algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_QuickMultiKeySort(A) To sort an array of FvlStr objects in an ascending order using\n the three-way radix quicksort (or multi-key quicksort) algorithm. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted public        interface AmericanFlagSort Subroutine Interface : AmericanFlagSort Purpose :  To sort an array of strings in an ascending order using the\n      American-flag algorithm. Usage : --->    CALL AmericanFlagSort(Arr) private  subroutine ChrStr_AmericanFlagSort(A) To sort an array of character strings in an ascending order using the American\n flag algorithm. REFERENCES : [1] P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems,\n     Vol. 6, No. 1. [2] Java Code: Non-recursive Americal Flag Sort. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) the array to be sorted private  subroutine FvlStr_AmericanFlagSort(A) To sort an array of character strings in an ascending order using the American\n flag algorithm. REFERENCES : [1] P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems,\n     Vol. 6, No. 1. [2] Java Code: Non-recursive Americal Flag Sort. Arguments Type Intent Optional Attributes Name type( FvlStr ), intent(inout) :: A (:) the array to be sorted","tags":"","loc":"module\\mbase_stringsorts.html"},{"title":"MClass_NFAutomaton – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the NFAutomaton type and its related routines.\n  The NFAutomaton type is a derived type representing a ... Uses MClass_IntrusiveHashList MBase_Common MBase_ErrHandlers MClass_IntrusiveLinkedLists MClass_NFAState MClass_BitmapState MClass_SyntaxNode iso_c_binding Derived Types type, public :: NFAutomaton The NFAutomaton type is a node type... Components Type Visibility Attributes Name Initial type(IntrusiveLinearList), public :: List type(IntrusiveLinearList), public :: Stack integer(kind=kInt32), public :: NextID = 0 Type-Bound Procedures procedure, public :: Construct => NFAutomaton_Construct procedure, public :: Destruct => NFAutomaton_Destruct procedure, public :: NewState => NFAutomaton_NewState procedure, public :: DepthFirstSearch => NFAutomaton_DepthFirstSearch procedure, public :: Visit => NFAutomaton_Visit procedure, public :: AsBitmapStateManager => NFAutomaton_AsBitmapStateManager","tags":"","loc":"module\\mclass_nfautomaton.html"},{"title":"MClass_BitmapState – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BitmapState type and its related routines.\n  The BitmapState type is a derived type representing a ... Uses MBase_OptimalHash32 MClass_IntrusiveHashList MClass_Object MBase_Common MBase_ErrHandlers MClass_NFAState MClass_IntrusiveLinkedLists MBase_MemHandlers MBase_SIntUtil iso_c_binding Derived Types type, public, extends(DoublyLinkedNode) :: BitmapStatePack The BitmapStatePack type is a node type... Type-Bound Procedures procedure, public :: Copy => BitmapStatePack_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => BitmapStatePack_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => BitmapStatePack_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). procedure, public :: ToString => BitmapStatePack_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: HashCode => BitmapStatePack_HashCode HashCode is a deferred procedure to compute hash code of this object. procedure, public :: Construct => BitmapStatePack_Construct procedure, public :: Destruct => BitmapStatePack_Destruct procedure, public :: AddState => BitmapStatePack_AddState procedure, public :: AddAll => BitmapStatePack_AddAll procedure, public :: Contain => BitmapStatePack_Contain procedure, public :: IsEmpty => BitmapStatePack_IsEmpty procedure, public :: Size => BitmapStatePack_Size procedure, public :: AsList => BitmapStatePack_AsList procedure, public :: Freeze => BitmapStatePack_Freeze procedure, public :: EnsureWritable => BitmapStatePack_EnsureWritable procedure, public :: IsEqual => BitmapStatePack_IsEqual type, public, extends(DoublyLinkedNode) :: BitmapState The BitmapState type is a node type... Type-Bound Procedures procedure, public :: Copy => BitmapState_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => BitmapState_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => BitmapState_MemFree FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). procedure, public :: ToString => BitmapState_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: HashCode => BitmapState_HashCode HashCode is a deferred procedure to compute hash code of this object. procedure, public :: Construct => BitmapState_Construct procedure, public :: Destruct => BitmapState_Destruct procedure, public :: TransitionRule => BitmapState_TransitionRule procedure, public :: DirectRule => BitmapState_DirectRule procedure, public :: GetTransitionMap => BitmapState_GetTransitionMap procedure, public :: GetDirectTable => BitmapState_GetDirectTable procedure, public :: GetID => BitmapState_GetID procedure, public :: Freeze => BitmapState_Freeze procedure, public :: EnsureWritable => BitmapState_EnsureWritable procedure, public :: IsEqual => BitmapState_IsEqual type, public :: BitmapStateManager The BitmapStateManager type is a node type... Type-Bound Procedures procedure, public :: Construct => BitmapStateManager_Construct procedure, public :: Destruct => BitmapStateManager_Destruct procedure, public :: GetState => BitmapStateManager_GetState procedure, public :: GetStates => BitmapStateManager_GetStates procedure, public :: StateCount => BitmapStateManager_StateCount procedure, public :: NewEmptyPack => BitmapStateManager_NewEmptyPack type, public, extends(HashListNode) :: BitMapNode The BitMapNode type is a node type... Components Type Visibility Attributes Name Initial character(kind=kChar, len=1), public :: Chr type( BitmapStatePack ), public, POINTER :: State => NULL() Type-Bound Procedures procedure, public :: Copy => BitmapNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => BitmapNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => BitMapNode_FreeMemory FreeMemory is a procedure deferred by the Object type. Use the MemFree method in place of the FreeMemory method to free\n memory the Object object if the object contains allocatable and/or\n pointer component(s). procedure, public :: ToString => BitmapNode_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: HashCode => BitMapNode_HashCode HashCode is a deferred procedure to compute hash code of this object. procedure, public :: IsKeyEqual => BitMapNode_IsKeyEqual procedure, public :: Construct => BitMapNode_Construct Subroutines public  subroutine BitmapState_New (State, ID, Manager) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitmapState ), intent(inout), POINTER :: State integer(kind=kInt32), intent(in) :: ID type( BitmapStateManager ), intent(in) :: Manager public  subroutine BitmapStatePack_New (Pack, Manager) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitmapStatePack ), intent(inout), POINTER :: Pack type( BitmapStateManager ), intent(in) :: Manager public  subroutine BitMapNode_New (Node, Chr, Manager, StatePack) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( BitMapNode ), intent(inout), POINTER :: Node character(kind=kChar, len=1), intent(in) :: Chr type( BitmapStateManager ), intent(in) :: Manager type( BitmapStatePack ), intent(in), optional, TARGET :: StatePack public  subroutine BitmapState_Free () To free all the nodes linked to the specified node. Arguments None","tags":"","loc":"module\\mclass_bitmapstate.html"},{"title":"MClass_TernaryTrie – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TernaryTrie type and its related routines.\n  The TernaryTrie type is a derived type representing a symbol table\n  of key-value pairs, with string keys and generic values. Technically, the TernaryTrie type employs a ternary-search tree\n  implementation to provide common operations of the symbol table.\n  These operations include the Insert , Remove , Contain , GetSize , IsEmpty and GetValue methods.  It also provides character-based\n  methods for finding the string in the symbol table that is the longest\n  prefix of a given prefix, finding all strings in the symbol table that\n  start with a given prefix, and finding all strings in the symbol table\n  that match a given pattern. For all operations provided, the TernaryTrie type supports two types\n  of character strings: the Fortran intrinsic CHARACTER type and the FvlStr derived type.  A user can choose to work with one of these two\n  types.  Like other symbol tables, the TernaryTrie type does not allow\n  duplicated keys.  Therefore, if an inserted key is equal to a key stored\n  in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. REFERENCES : [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. Uses MClass_StringBuilder MBase_Common MBase_ErrHandlers MBase_DoublyLinkedLists MClass_FvlStr Derived Types type, public :: TernaryTrie The TernaryTrie type is a container type that utilizes a ternary search\n tree implementation to provide common operations for a symbol table where\n its keys are character strings and its values can be of any type. Finalizations Procedures final :: TernaryTrie_Finalizer To perform finalization of the symbol table. Type-Bound Procedures generic, public :: Construct => TernaryTrie_ConstructByArray_ChrStr, TernaryTrie_ConstructByArray_FvlStr Type-Bound Subroutine : Construct Purpose :  To construct a symbol table from arrays of keys and values. Usage : --->    CALL Table%Construct(10, KeyArr, ValArr) procedure, public :: Clear => TernaryTrie_Clear Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Clear() generic, public :: Destruct => TernaryTrie_Destructor_ChrStr, TernaryTrie_Destructor_FvlStr Type-Bound Subroutine : Destruct Purpose :  To first retrieve stored keys (and optionally their associated values)\n               and then remove all key-value pairs from the symbol table. Usage : --->    CALL Table%Destruct(KeyQ) --->    CALL Table%Destruct(KeyArr) --->    CALL Table%Destruct(KeyQ, ValQ) --->    CALL Table%Destruct(KeyArr, ValQ) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: Insert => TernaryTrie_Insert_ChrStr, TernaryTrie_Insert_FvlStr Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) generic, public :: Remove => TernaryTrie_Remove_ChrStr, TernaryTrie_Remove_FvlStr Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the table (if the key found).  Optionally, the associated\n               value can be retrieved. Usage : --->    CALL Table%Remove(Key) --->    CALL Table%Remove(Key, Value) generic, public :: Contain => TernaryTrie_Contain_ChrStr, TernaryTrie_Contain_FvlStr Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetSize => TernaryTrie_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (the number of key-value pairs stored)\n               of the table. Usage : --->    Size = Table%GetSize() procedure, public :: IsEmpty => TernaryTrie_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing generic, public :: StartWith => TernaryTrie_StartWith_ChrStr, TernaryTrie_StartWith_FvlStr Type-Bound Function : StartWith Purpose :  To return a flag indicating whether the symbol table contains\n               a key starting with the specified prefix. Usage : --->    Flag = Table%StartWith(Prefix) --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing generic, public :: GetValue => TernaryTrie_GetValue_ChrStr, TernaryTrie_GetValue_FvlStr Type-Bound Subroutine : GetValue Purpose :  To get a value associated with the specified key in the table.\n               If the key is not found, return an unallocated value. Usage : --->    CALL Table%GetValue(Key, Value) generic, public :: GetAllKeys => TernaryTrie_AllKeys_ChrStr, TernaryTrie_AllKeys_FvlStr Type-Bound Subroutine : GetAllKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table. Usage : --->    CALL Table%GetAllKeys(KeyQ) --->    CALL Table%GetAllKeys(KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysWithPrefix => TernaryTrie_KeysWithPrefix_CHCH, TernaryTrie_KeysWithPrefix_CHVL, TernaryTrie_KeysWithPrefix_VLCH, TernaryTrie_KeysWithPrefix_VLVL Type-Bound Subroutine : GetKeysWithPrefix Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               start with the specified prefix.  Return an empty queue (or an unallocated\n               array) if no such key(s) found. Usage : --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetKeysThatMatch => TernaryTrie_KeysThatMatch_CHCH, TernaryTrie_KeysThatMatch_CHVL, TernaryTrie_KeysThatMatch_VLCH, TernaryTrie_KeysThatMatch_VLVL Type-Bound Subroutine : GetKeysThatMatch Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern where the question-mark character is interpreted\n               as a wild-card character.  Return an empty queue (or an unallocated array)\n               if no such key(s) found. Usage : --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) Important Note : A user must choose which type of keys to be returned.  The method\n      returns a queue of keys where their type is the Fortran intrinsic CHARACTER type\n      or it returns an array of keys where their type is the FvlStr type. generic, public :: GetWildcardKeys => TernaryTrie_WildcardKeys_CHCH, TernaryTrie_WildcardKeys_CHVL, TernaryTrie_WildcardKeys_VLCH, TernaryTrie_WildcardKeys_VLVL Type-Bound Subroutine : GetWildcardKeys Purpose :  To return a queue (or an array) of all the keys in the symbol table that\n               match the given pattern with wild-card characters.  Return an empty queue\n               (or an unallocated array) if no such key(s) found. Usage : --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) Important Note : The GetWildcardKeys method is mostly the same as the GetKeysThatMatch method, except that it recognizes two wild-card characters instead of one.  Similar to\n      the GetKeysThatMatch method, the question-mark character ('?') is interpreted as a\n      wild-card character for a single character.  Additionally, the GetWildcardKeys method\n      interprets the asterisk character ('*') as a wild-card character for a sequence of\n      characters. generic, public :: GetLongestPrefixOf => TernaryTrie_LongestPrefixOf_ChrStr, TernaryTrie_LongestPrefixOf_FvlStr Type-Bound Subroutine : GetLongestPrefixOf Purpose :  To return the string in the symbol table that is the longest prefix of the\n               specified query.  Return an unallocated string if no such string found. Usage : --->    CALL Table%GetLongestPrefixOf(Query, Prefix)","tags":"","loc":"module\\mclass_ternarytrie.html"},{"title":"MClass_NFAState – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the NFAState type and its related routines.\n  The NFAState type is a derived type representing a ... Uses MBase_OptimalHash32 MClass_IntrusiveHashList MClass_Object MBase_Common MBase_ErrHandlers MBase_SIntUtil iso_c_binding Derived Types type, public, extends(HashListNode) :: HashMapNode Type-Bound Procedures procedure, public :: Copy => HashMapNode_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => HashMapNode_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: ToString => HashMapNode_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: IsKeyEqual => HashMapNode_IsKeyEqual procedure, public :: MemFree => HashMapNode_FreeMemory procedure, public :: HashCode => HashMapNode_HashCode procedure, public :: Construct => HashMapNode_Construct procedure, public :: GetSet => HashMapNode_GetSet procedure, public :: GetChar => HashMapNode_GetChar type, public, extends(HashListNode) :: NFAState The NFAState type is a node type... Type-Bound Procedures procedure, public :: Copy => NFAState_Copy CopyAssign is a procedure deferred by the Object type. Use the assignment expression in place of the CopyAssign method\n to make a copy of an Object object. procedure, public :: IsEqualTo => NFAState_IsEqualTo IsEqualTo is a procedure deferred by the Object type. Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: ToString => NFAState_ToString ToString is a deferred procedure to get the string representation of this object. procedure, public :: IsKeyEqual => NFAState_IsKeyEqual procedure, public :: MemFree => NFAState_FreeMemory procedure, public :: HashCode => NFAState_HashCode procedure, public :: Construct => NFAState_Construct procedure, public :: TransitionRule => NFAState_TransitionRule procedure, public :: DirectRule => NFAState_DirectRule procedure, public :: GetTransitionMap => NFAState_GetTransitionMap procedure, public :: GetDirectTable => NFAState_GetDirectTable procedure, public :: GetID => NFAState_GetID Subroutines public  subroutine NFAState_New (State, ID) To allocate the state and specify its ID. Arguments Type Intent Optional Attributes Name type( NFAState ), intent(inout), POINTER :: State integer(kind=kInt32), intent(in) :: ID public  subroutine NFAState_Free () To free all the nodes linked to the specified node. Arguments None","tags":"","loc":"module\\mclass_nfastate.html"},{"title":"MClass_SyntaxTree – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the SyntaxTree type and its related routines.\n  The SyntaxTree type is a derived type representing a ... Uses MClass_StringBuilder MBase_CharUtil MBase_Common MBase_ErrHandlers MBase_DoublyLinkedLists MBase_ChrStr MClass_IntrusiveLinkedLists MBase_MemHandlers MClass_SyntaxNode Variables Type Visibility Attributes Name Initial integer(kind=kInt32), public, parameter :: EncodingLen = 128 Derived Types type, public :: SyntaxTree The SyntaxTree type is a tree type... Type-Bound Procedures procedure, public :: Construct => SyntaxTree_Construct procedure, public :: Destruct => SyntaxTree_Destruct procedure, public :: GetRoot => SyntaxTree_GetRoot","tags":"","loc":"module\\mclass_syntaxtree.html"},{"title":"MClass_REProgram – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the REProgram type and its related routines. REFERENCES : [1) The Apache Jakarta Project. Uses MBase_REParameters MBase_Common Derived Types type, public :: REProgram The REProgram type is a derive type that holds compiled regular expressions. Type-Bound Procedures procedure, public :: Construct => REProgram_Construct procedure, public :: Destruct => REProgram_Destruct procedure, public :: GetInstructions => REProgram_GetInstructions procedure, public :: GetPrefix => REProgram_GetPrefix procedure, public :: GetMaxParen => REProgram_GetMaxParen procedure, public :: GetFlag => REProgram_GetFlag","tags":"","loc":"module\\mclass_reprogram.html"},{"title":"MClass_StringBuilder – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the StringBuilder type and its related routines.  The StringBuilder type\n  is a string type that provides a convenient and efficient mechanism for concatenating multiple\n  strings (i.e. building a string from several strings). The StringBuilder type provides several methods that can be grouped\n  into the following categories. (1) Construction and Destruction.  Methods for these operations include: - CreateEmpty method - method to construct an empty builder, - Construct method - method to construct the builder from its first specified value, and - Clear method - method to remove all inserted values from the builder. (2) Insertion and Removal.  Methods for these operations include: - Append method - method to insert a value into the end of the builder's string, - Insert method - method to insert a value at a specified position of the builder's string, and - DelLastChar method - method to remove the last character of the builder's string. (3) Conversion-To-String.  Methods for these operations include: - ToCharAlloc method - method to return the builder's string as an allocatable character string, - ToFvlStr method - method to return the builder's string as a string of the FvlStr type, and - ToCharStar method - method to return the builder's string as a character string of assumed length. (4) Inquiry.  A method for this operation is: - Length method - method to inquire the current length of the builder's string. (5) Miscellaneous.  There are several other methods that the StringBuilder type are inherited from\n    its parent types ( Object and Comparable ). It is worth noting that values inserted into the string builder do not need to be strings.  If the type\n  of values is one of Fortran intrinsic types or the FvlStr type, the values are automatically converted\n  into strings.  However, if the type of values is a user-defined one, the user can supply a procedure to\n  convert values into strings. Uses MBase_CharUtil MClass_Object MBase_Common MBase_ErrHandlers MBase_ByteUtil MBase_ChrStr MClass_FvlStr MBase_OptimalHash64 MClass_Comparable Derived Types type, public, extends(Comparable) :: StringBuilder The StringBuilder type is string type that provides a convenient way\n to build a string from multiple strings. Finalizations Procedures final :: StringBuilder_Finalize To perform finalization of the StringBuilder object. Type-Bound Procedures procedure, public :: CreateEmpty => StringBuilder_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty string builder. Usage : ! use default initial capacity --->    CALL StrBld%CreateEmpty() ! specify initial capacity --->    CALL StrBld%CreateEmpty(InitCap=256) procedure, public :: Construct => StringBuilder_Construct Type-Bound Subroutine : Construct Purpose :  To construct a string builder with the specified value.  This method\n      provides a convenient way to create an empty string builder and then add the\n      first value into the builder. Usage : --->    CALL StrBld%Construct(Value) procedure, public :: Clear => StringBuilder_Clear Type-Bound Subroutine : Clear Purpose :  To clear the buffer string of the string builder. Usage : --->    CALL StrBld%Clear() generic, public :: Append => StringBuilder_Append, StringBuilder_AppendWPrefix Type-Bound Subroutine : Append Purpose :  To append the specified value at the end of the builder where the type\n      of value can be one of Fortran intrinsic types or the FvlStr type.  Optionally,\n      a prefix and/or a suffix can be specified.  Also, optionally, if the type of value\n      is a user-defined one, a ToString procedure must be specified. Usage : ! specify only the value --->    CALL StrBld%Append(Val) ! specify only the value and its ToString procedure --->    CALL StrBld%Append(Val, ToString) ! specify the value and its prefix --->    CALL StrBld%Append('The computed value is', Val) ! specify the value and its prefix and suffix --->    CALL StrBld%Append('The speed of light in vacuum =', 299792458, 'm/s.') procedure, public :: Insert => StringBuilder_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified value at the specified position where the type of\n      value can be one of Fortran intrinsic types or the FvlStr type.  Optionally, if the\n      type of value is a user-defined one, a ToString procedure must be specified. Usage : --->    CALL StrBld%Insert(Val, Pos) --->    CALL StrBld%Insert(Val, Pos, ToString) procedure, public :: DelLastChar => StringBuilder_DeleteLastChar Type-Bound Subroutine : DelLastChar Purpose :  To remove the last character from the builder's string. Usage : --->    CALL StrBld%DelLastChar() procedure, public :: ToCharAlloc => StringBuilder_ToCharAlloc Type-Bound Function : ToCharAlloc Purpose :  To return characters currently stored in the string builder as an\n      allocatable character string.  Optionally, a user can request to clear the\n      builder' buffer string. Usage : --->    cStr = StrBld%ToCharAlloc() --->    cStr = StrBld%ToCharAlloc(ClearBuffer=.TRUE.) procedure, public :: ToFvlStr => StringBuilder_ToFvlStr Type-Bound Function : ToFvlStr Purpose :  To return characters currently stored in the string builder as a\n      string of the FvlStr type.  Optionally, a user can request to clear the\n      builder' buffer string. Usage : --->    vStr = StrBld%ToFvlStr() --->    vStr = StrBld%ToFvlStr(ClearBuffer=.TRUE.) procedure, public :: ToCharStar => StringBuilder_ToCharStar Type-Bound Subroutine : ToCharStar Purpose :  To return characters currently stored in the string builder as\n      a character string of assumed length.  Optionally, a user can request\n      to clear the builder' buffer string. Usage : --->    CALL StrBld%ToCharStar(cStr) --->    CALL StrBld%ToCharStar(cStr, ClearBuffer=.TRUE.) Note : In order to retrieve all the characters currently stored in the builder,\n      the length of the specified string must be at least equal to the current length\n      of the string being built, which can be inquired using the Length method. procedure, public :: Length => StringBuilder_GetLength Type-Bound Function : Length Purpose :  To return the current length of the string being built. Usage : --->    Length = StrBld%Length() procedure, public :: Copy => StringBuilder_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => StringBuilder_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => StringBuilder_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => StringBuilder_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => StringBuilder_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: CompareTo => StringBuilder_CompareTo Use a common logical expression to compare two Comparable objects.","tags":"","loc":"module\\mclass_stringbuilder.html"},{"title":"MBase_CharConv.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_CharConv !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains routines that perform a conversion between a number and a decimal !   string.  The routines can be categorized into 4 groups: <br> !   - real-to-string conversion routines, <br> !   - real-from-string conversion routines, <br> !   - integer-to-string conversion routines, and <br> !   - integer-from-string conversion routines. <br> !   For real-number conversions, routines for all three common (single, double and quadruple) !   precisions are provided.  For integer-number conversions, only routines for 32-bit and !   64-bit integers are provided. <br> !   <br> ! **Technical Notes for Integer-From-String Conversions**: <br> !   When parsing a decimal string as an integer number, the string can be interpreted as a !   *Fortran* number, a *FPlus* number or a *JSON* number.  The following list provides a !   description of these interpretations. <br> !   1. A *Fortran* number (*FortNum*) is strictly interpreted as an integer number that has !      the form as: [S]N[N...] where <br> !       - S is a sign indicator (required if negative '-', optional if positive '+'). <br> !       - N is a decimal digit (0 through 9). Any leading zeros, leading and trailing !           spaces are ignored. <br> !    Unlike Fortran constants, the optional kind parameter (_k) is not allowed here. <br> !   2. A *FPlus* number (*FortPlus*) has a slightly more relaxed rule than that of a Fortran !      number such that any invalid characters after characters that are valid are ignored. !      For example, -3567e23 is treated as a valid number with a value of -3567. <br> !   3. A *JSON* number (*JsonNum*) has a slightly stricter rule than that of a Fortran number !      such that a plus sign and leading zeroes are not allowed. <br> !   <br> !   <br> ! **Technical Notes for Real-From-String Conversions**: <br> !   Similarly, when parsing a decimal string as a real number, the string can also be interpreted !   as a *Fortran* number, a *FPlus* number or a *JSON* number.  The following list provides a !   description of these interpretations. <br> !   1. A *Fortran* number (*FortNum*) is strictly interpreted as a real number that has one of the !      two following forms: <br> !      <1> A number without exponent part -> [S]N[N...], and <br> !      <2> A number with exponent part    -> [S]N[N...]E[S]N[N...] <br> !          where <br> !          - [ ] indicates an optional field. <br> !          - S is a sign indicator (required if negative '-', optional if positive '+'). <br> !          - N is a decimal digit (0 through 9). A decimal point (a period) may appear anywhere !               after the sign (but before the exponent). <br> !          - E is an exponent indicator (either 'e' or 'E'). <br> !      The valid number is similar to \"Real\" Fortran constant (literal) with some small differences. <br> !       - A whole number without a decimal point (i.e. \"Integer\" constant) is considered valid. <br> !       - The optional kind parameter (e.g. 1.23_DP) is not allowed here. <br> !      Leading and/or trailing space(s) are allowed.  For example, \"  1.23\" and \"1.23   \" are considered !      valid.  However, no space is allowed inside the supposedly valid number.  For instance, \"1 .2 3\" !      is considered NOT valid. Therefore, this routine is not totally compatible with Fortran *READ* !      statement where spaces inside the valid number are allowed. However, this can easily be done by !      adding an optional 'Inside Space' flag that provide an interpretation of the spaces as 'zero' or !      'ignored'.  Then, the input will be pre-processed according to the flag.  Nonetheless, this routine !      neglects this optional input because it will make the routine much less efficient due to the fact !      that we will need to scan the whole string twice and we will also need to copy the input string !      into a buffer string and working with the buffer instead of directly handling the input string. <br> !   2. A *FPlus* number (*FortPlus*) is interpreted as a real number with more relaxed rules than !      a *Fortran* number.  The relaxed rules consider the following numbers as valid: <br> !      - A number expressed in the scientific format can use 'd', 'D', 'q' and 'Q' in place of 'e' or !        'E'. <br> !      - A number with '+' or '-' after digits (e.g. 1.23-20 or 123+50) is considered to be a valid number !        expressed in the scientific format where an exponent indicator is omitted. <br> !      - Digits before any invalid character encountered are treated as a valid number and any characters !        after the first encounter (including the first invalid one) are neglected.  Therefore, for example, !        a '12.56ax-300' string is considered to be a valid number with a value of 12.56. <br> !   3. A *JSON* number (*JsonNum*) has a slightly stricter rule than that of a Fortran number where its !      differences from Fortran number are as follows: <br> !      - Leading and trailing spaces are not allowed. <br> !      - A plus sign as the first character is not allowed. <br> !      - Leading zero(s) is not allowed (if 0 is the first character, the second one must either be a !        period or an exponent indicator.) <br> !      - A period must be followed by at least one digit. <br> !   <br> !** USE STATEMENTS: USE MBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS !-------------------------------------------------- !   Single-Precision Real-Character Conversions !-------------------------------------------------- ! Real-To-String PUBLIC :: RealSP_ToString_DragonBox , RealSP_ToString_Ryu PUBLIC :: RealSP_ToString_Schubfach ! Real-From-String PUBLIC :: RealSP_FromString_FastFloat , RealSP_FromString_LibC PUBLIC :: RealSP_FromString_YY , RealSP_FromString_Lemire !-------------------------------------------------- !   Double-Precision Real-Character Conversions !-------------------------------------------------- ! Real-To-String PUBLIC :: RealDP_ToString_DragonBox , RealDP_ToString_Ryu PUBLIC :: RealDP_ToString_Schubfach ! Real-From-String PUBLIC :: RealDP_FromString_FastFloat , RealDP_FromString_LibC PUBLIC :: RealDP_FromString_YY , RealDP_FromString_Lemire !-------------------------------------------------- !   Quad-Precision Real-Character Conversions !-------------------------------------------------- ! Real-To-String PUBLIC :: RealQP_ToString_DragonBox , RealQP_ToString_Ryu PUBLIC :: RealQP_ToString_Schubfach ! Real-From-String PUBLIC :: RealQP_FromString_FastFloat , RealQP_FromString_LibC PUBLIC :: RealQP_FromString_YY , RealQP_FromString_Lemire !-------------------------------------------------- !   32-Bit Integer ToChar Procedures !-------------------------------------------------- PUBLIC :: I32_ToChar_Basic , I32_ToChar_CC PUBLIC :: I32_ToChar_YY , I32_ToChar_YYLL PUBLIC :: I32_ToChar_JEA !-------------------------------------------------- !   64-Bit Integer ToChar Procedures !-------------------------------------------------- PUBLIC :: I64_ToChar_Basic , I64_ToChar_CC PUBLIC :: I64_ToChar_YY , I64_ToChar_YYLL PUBLIC :: I64_ToChar_JEA !-------------------------------------------------- !   32-Bit Integer FromChar Procedures !-------------------------------------------------- PUBLIC :: I32_FromChar_CC_FortNum , I32_FromChar_CC_FortPlus PUBLIC :: I32_FromChar_CC_JsonNum , I32_FromChar_Lemire_FortPlus PUBLIC :: I32_FromChar_YY_JsonNum !-------------------------------------------------- !   64-Bit Integer FromChar Procedures !-------------------------------------------------- PUBLIC :: I64_FromChar_CC_FortNum , I64_FromChar_CC_FortPlus PUBLIC :: I64_FromChar_CC_JsonNum , I64_FromChar_Lemire_FortPlus PUBLIC :: I64_FromChar_YY_JsonNum PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! ----------------------------------------------------------------- ! -----     options for type of number to be parsed           ----- ! ----------------------------------------------------------------- tSInt32 , PARAMETER , PUBLIC :: FortNum = 1 ! strict Fortran number tSInt32 , PARAMETER , PUBLIC :: FPlusNum = 2 ! relaxed Fortran number tSInt32 , PARAMETER , PUBLIC :: JsonNum = 3 ! JSON number !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE/GENERIC DEFINITIONS: !-------------------------------------------------- !   Single-Precision Real-Character Conversions !-------------------------------------------------- INTERFACE MODULE FUNCTION RealSP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a single-precision floating-point value to a character !  (decimal) string using the DragonBox algorithm. tRealSP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealSP_ToString_DragonBox !---------------------------------------------------------------------- MODULE FUNCTION RealSP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a single-precision floating-point value to a character !  (decimal) string using the Ryu algorithm. tRealSP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealSP_ToString_Ryu !---------------------------------------------------------------------- MODULE FUNCTION RealSP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a single-precision floating-point value to a character !  (decimal) string using the Schubfach algorithm. tRealSP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealSP_ToString_Schubfach !---------------------------------------------------------------------- MODULE FUNCTION RealSP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a single-precision !  floating-point value using the FastFloat algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealSP :: Number !! floating-point number END FUNCTION RealSP_FromString_FastFloat !---------------------------------------------------------------------- MODULE FUNCTION RealSP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a single-precision !  floating-point value using the LibC algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealSP :: Number !! floating-point number END FUNCTION RealSP_FromString_LibC !---------------------------------------------------------------------- MODULE FUNCTION RealSP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a single-precision !  floating-point value using the YY algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealSP :: Number !! floating-point number END FUNCTION RealSP_FromString_YY !---------------------------------------------------------------------- MODULE FUNCTION RealSP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a single-precision !  floating-point value using the Lemire algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealSP :: Number !! floating-point number END FUNCTION RealSP_FromString_Lemire !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   Double-Precision Real-Character Conversions !-------------------------------------------------- INTERFACE MODULE FUNCTION RealDP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a double-precision floating-point value to a character !  (decimal) string using the DragonBox algorithm. tRealDP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealDP_ToString_DragonBox !---------------------------------------------------------------------- MODULE FUNCTION RealDP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a double-precision floating-point value to a character !  (decimal) string using the Ryu algorithm. tRealDP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealDP_ToString_Ryu !---------------------------------------------------------------------- MODULE FUNCTION RealDP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a double-precision floating-point value to a character !  (decimal) string using the Schubfach algorithm. tRealDP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealDP_ToString_Schubfach !---------------------------------------------------------------------- MODULE FUNCTION RealDP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a double-precision !  floating-point value using the FastFloat algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealDP :: Number !! floating-point number END FUNCTION RealDP_FromString_FastFloat !---------------------------------------------------------------------- MODULE FUNCTION RealDP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a double-precision !  floating-point value using the LibC algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealDP :: Number !! floating-point number END FUNCTION RealDP_FromString_LibC !---------------------------------------------------------------------- MODULE FUNCTION RealDP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a double-precision !  floating-point value using the YY algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealDP :: Number !! floating-point number END FUNCTION RealDP_FromString_YY !---------------------------------------------------------------------- MODULE FUNCTION RealDP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a double-precision !  floating-point value using the Lemire algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealDP :: Number !! floating-point number END FUNCTION RealDP_FromString_Lemire !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   Quad-Precision Real-Character Conversions !-------------------------------------------------- INTERFACE MODULE FUNCTION RealQP_ToString_DragonBox ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a quadruple-precision floating-point value to a character !  (decimal) string using the DragonBox algorithm. tRealQP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealQP_ToString_DragonBox !---------------------------------------------------------------------- MODULE FUNCTION RealQP_ToString_Ryu ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a quadruple-precision floating-point value to a character !  (decimal) string using the Ryu algorithm. tRealQP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealQP_ToString_Ryu !---------------------------------------------------------------------- MODULE FUNCTION RealQP_ToString_Schubfach ( Number , IsScientific ) RESULT ( cStr ) !&#94; To convert a quadruple-precision floating-point value to a character !  (decimal) string using the Schubfach algorithm. tRealQP , INTENT ( IN ) :: Number !! number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; format flag <br> ! - true  if to write the given number in scientific format. <br> ! - false if to write the given number in general format. <br> ! - default is false. tCharAlloc :: cStr !! character string END FUNCTION RealQP_ToString_Schubfach !---------------------------------------------------------------------- MODULE FUNCTION RealQP_FromString_FastFloat ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a quadruple-precision !  floating-point value using the FastFloat algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealQP :: Number !! floating-point number END FUNCTION RealQP_FromString_FastFloat !---------------------------------------------------------------------- MODULE FUNCTION RealQP_FromString_LibC ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a quadruple-precision !  floating-point value using the LibC algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealQP :: Number !! floating-point number END FUNCTION RealQP_FromString_LibC !---------------------------------------------------------------------- MODULE FUNCTION RealQP_FromString_YY ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a quadruple-precision !  floating-point value using the YY algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealQP :: Number !! floating-point number END FUNCTION RealQP_FromString_YY !---------------------------------------------------------------------- MODULE FUNCTION RealQP_FromString_Lemire ( cStr , ParseOpt , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a character (decimal) string to a quadruple-precision !  floating-point value using the Lemire algorithm. tCharStar , INTENT ( IN ) :: cStr !! character string tSInt32 , OPTIONAL , INTENT ( IN ) :: ParseOpt !&#94; flag indicating how to interpret the input string <br> !   - *FortNum* (or 1): interpreted as a strict Fortran number, <br> !   - *FPlusNum* (or 2): interpreted as a relaxed Fortran number, or <br> !   - *JsonNum* (or 3): interpreted as a JSON number. tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if error occurred tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealQP :: Number !! floating-point number END FUNCTION RealQP_FromString_Lemire !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   32-Bit Integer ToChar Procedures !-------------------------------------------------- INTERFACE MODULE FUNCTION I32_ToChar_Basic ( Number ) RESULT ( cStr ) !&#94; To convert a 32-bit integer number to a character (decimal) !  string using the basic algorithm. tSInt32 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I32_ToChar_Basic !---------------------------------------------------------------------- MODULE FUNCTION I32_ToChar_CC ( Number ) RESULT ( cStr ) !&#94; To convert a 32-bit integer number to a character (decimal) !  string using the CC algorithm. tSInt32 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I32_ToChar_CC !---------------------------------------------------------------------- MODULE FUNCTION I32_ToChar_YY ( Number ) RESULT ( cStr ) !&#94; To convert a 32-bit integer number to a character (decimal) !  string using the YY algorithm. tSInt32 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I32_ToChar_YY !---------------------------------------------------------------------- MODULE FUNCTION I32_ToChar_YYLL ( Number ) RESULT ( cStr ) !&#94; To convert a 32-bit integer number to a character (decimal) !  string using the YY algorithm with large tables. tSInt32 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I32_ToChar_YYLL !---------------------------------------------------------------------- MODULE FUNCTION I32_ToChar_JEA ( Number ) RESULT ( cStr ) !&#94; To convert a 32-bit integer number to a character (decimal) !  string using the JEA algorithm. tSInt32 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I32_ToChar_JEA !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   64-Bit Integer ToChar Procedures !-------------------------------------------------- INTERFACE MODULE FUNCTION I64_ToChar_Basic ( Number ) RESULT ( cStr ) !&#94; To convert a 64-bit integer number to a character (decimal) !  string using the basic algorithm. tSInt64 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I64_ToChar_Basic !---------------------------------------------------------------------- MODULE FUNCTION I64_ToChar_CC ( Number ) RESULT ( cStr ) !&#94; To convert a 64-bit integer number to a character (decimal) !  string using the CC algorithm. tSInt64 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I64_ToChar_CC !---------------------------------------------------------------------- MODULE FUNCTION I64_ToChar_YY ( Number ) RESULT ( cStr ) !&#94; To convert a 64-bit integer number to a character (decimal) !  string using the YY algorithm. tSInt64 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I64_ToChar_YY !---------------------------------------------------------------------- MODULE FUNCTION I64_ToChar_YYLL ( Number ) RESULT ( cStr ) !&#94; To convert a 64-bit integer number to a character (decimal) !  string using the YY algorithm with large tables. tSInt64 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I64_ToChar_YYLL !---------------------------------------------------------------------- MODULE FUNCTION I64_ToChar_JEA ( Number ) RESULT ( cStr ) !&#94; To convert a 64-bit integer number to a character (decimal) !  string using the JEA algorithm. tSInt64 , INTENT ( IN ) :: Number !! number tCharAlloc :: cStr !! character string END FUNCTION I64_ToChar_JEA !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   32-Bit Integer FromChar Procedures !-------------------------------------------------- INTERFACE MODULE FUNCTION I32_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 32-bit integer value using the !  CC algorithm where the string is interpreted as a Fortran number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: Number !! number END FUNCTION I32_FromChar_CC_FortNum !---------------------------------------------------------------------- MODULE FUNCTION I32_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 32-bit integer value using the !  CC algorithm where the string is interpreted as a FPlus number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: Number !! number END FUNCTION I32_FromChar_CC_FortPlus !---------------------------------------------------------------------- MODULE FUNCTION I32_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 32-bit integer value using the !  CC algorithm where the string is interpreted as a JSON number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: Number !! number END FUNCTION I32_FromChar_CC_JsonNum !---------------------------------------------------------------------- MODULE FUNCTION I32_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 32-bit integer value using the !  Lemire algorithm where the string is interpreted as a FPlus number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: Number !! number END FUNCTION I32_FromChar_Lemire_FortPlus !---------------------------------------------------------------------- MODULE FUNCTION I32_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 32-bit integer value using the !  YY algorithm where the string is interpreted as a JSON number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: Number !! number END FUNCTION I32_FromChar_YY_JsonNum !---------------------------------------------------------------------- END INTERFACE !-------------------------------------------------- !   64-Bit Integer FromChar Procedures !-------------------------------------------------- INTERFACE MODULE FUNCTION I64_FromChar_CC_FortNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 64-bit integer value using the !  CC algorithm where the string is interpreted as a Fortran number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: Number !! number END FUNCTION I64_FromChar_CC_FortNum !---------------------------------------------------------------------- MODULE FUNCTION I64_FromChar_CC_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 64-bit integer value using the !  CC algorithm where the string is interpreted as a FPlus number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: Number !! number END FUNCTION I64_FromChar_CC_FortPlus !---------------------------------------------------------------------- MODULE FUNCTION I64_FromChar_CC_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 64-bit integer value using the !  CC algorithm where the string is interpreted as a JSON number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: Number !! number END FUNCTION I64_FromChar_CC_JsonNum !---------------------------------------------------------------------- MODULE FUNCTION I64_FromChar_Lemire_FortPlus ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 64-bit integer value using the !  Lemire algorithm where the string is interpreted as a FPlus number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: Number !! number END FUNCTION I64_FromChar_Lemire_FortPlus !---------------------------------------------------------------------- MODULE FUNCTION I64_FromChar_YY_JsonNum ( cStr , ErrFlag , ErrMsg ) RESULT ( Number ) !&#94; To convert a decimal string to a 64-bit integer value using the !  YY algorithm where the string is interpreted as a JSON number. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: Number !! number END FUNCTION I64_FromChar_YY_JsonNum !---------------------------------------------------------------------- END INTERFACE CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** END MODULE MBase_CharConv !******************************************************************************","tags":"","loc":"sourcefile\\mbase_charconv.f90.html"},{"title":"MClass_SyntaxNode.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SyntaxNode !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SyntaxNode* type and its related routines. !   The *SyntaxNode* type is a derived type representing a ... <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MClass_IntrusiveLinkedLists , ONLY : DoublyLinkedNode USE MClass_Object , ONLY : Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SyntaxNode PUBLIC :: SyntaxNode_New PUBLIC :: SyntaxNode_Free PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_SyntaxNode' tSInt32 , PARAMETER :: MsgLen = 128 tSInt32 , PARAMETER , PUBLIC :: Node_Undefined = 0 tSInt32 , PARAMETER , PUBLIC :: LeafNode_Null = 1 tSInt32 , PARAMETER , PUBLIC :: LeafNode_Char = 2 tSInt32 , PARAMETER , PUBLIC :: LeafNode_Closure = 3 tSInt32 , PARAMETER , PUBLIC :: BranchNode_Or = 4 tSInt32 , PARAMETER , PUBLIC :: BranchNode_Many = 5 tSInt32 , PARAMETER , PUBLIC :: BranchNode_Concat = 6 tSInt32 , PARAMETER , PUBLIC :: BranchNode_LBracket = 7 tSInt32 , PARAMETER , PUBLIC :: BranchNode_RBracket = 8 tCharStar , PARAMETER :: NULCHR = ACHAR ( 0 ) !** DERIVED TYPE DEFINITIONS !> The *SyntaxNode* type is a node type... TYPE , EXTENDS ( DoublyLinkedNode ) :: SyntaxNode tSInt32 :: Type = Node_Undefined !! node type tSInt32 :: ID = 0 !! node identification (only used for branch nodes) tChar :: C = NULCHR !! character used only for LeafNode_Char CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => SyntaxNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => SyntaxNode_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => SyntaxNode_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => SyntaxNode_ToString ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetRight <br> !  **Purpose**:  To get a pointer to the right node of the current node. <br> !  **Usage**: <br> !   --->    RightNode => CurrNode%GetRight() PROCEDURE :: GetRight => SyntaxNode_GetRightNode !> **Type-Bound Function**: GetLeft <br> !  **Purpose**:  To get a pointer to the left node of the current node. <br> !  **Usage**: <br> !   --->    LeftNode => CurrNode%GetLeft() PROCEDURE :: GetLeft => SyntaxNode_GetLeftNode !> **Type-Bound Subroutine**: SetRight <br> !  **Purpose**:  To set a pointer to the right node of the current node. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetRight(RightNode) PROCEDURE :: SetRight => SyntaxNode_SetRightNode !> **Type-Bound Subroutine**: SetLeft <br> !  **Purpose**:  To set a pointer to the left node of the current node. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetLeft(LeftNode) PROCEDURE :: SetLeft => SyntaxNode_SetLeftNode !> **Type-Bound Function**: HasRight <br> !  **Purpose**:  To check whether the right node of the specified node is associated or not. <br> !  **Usage**: <br> !   --->    Flag = CurrNode%HasRight() <br> !   --->    IF (.NOT.CurrNode%HasRight()) DoSomething <br> PROCEDURE :: HasRight => SyntaxNode_HasRightNode !> **Type-Bound Function**: HasLeft <br> !  **Purpose**:  To check whether the left node of the specified node is associated or not. <br> !  **Usage**: <br> !   --->    Flag = CurrNode%HasLeft() <br> !   --->    IF (.NOT.CurrNode%HasLeft()) DoSomething <br> PROCEDURE :: HasLeft => SyntaxNode_HasLeftNode !> **Type-Bound Subroutine**: Operate <br> !  **Purpose**:  To set a pointer to both the left and right nodes of the current node. !                This operation is applicable only for the \"BranchNode_Or\", \"BranchNode_Many\", !                or \"BranchNode_Concat\" node type. <br> !  **Usage**: <br> !   --->    CALL CurrNode%Operate(LeftNode, RightNode) PROCEDURE :: Operate => SyntaxNode_Operate !> **Type-Bound Subroutine**: SetChar <br> !  **Purpose**:  To set the specified character to the current node.  This operation is !                only applicable for the \"LeafNode_Char\" node type. <br> !  **Usage**: <br> !   --->    CALL CurrNode%SetChar(C) PROCEDURE :: SetChar => SyntaxNode_SetCharacter END TYPE SyntaxNode TYPE SyntaxNodeMemHandler tIndex :: ID = 0_kIndex TYPE ( SyntaxNode ), ALLOCATABLE :: Node (:) END TYPE SyntaxNodeMemHandler !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: TYPE ( SyntaxNodeMemHandler ), TARGET :: STNMemManger CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! ----------------------------------------------------------------------------- ! -----                     SyntaxNode Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE SyntaxNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the SyntaxNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( SyntaxNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'SyntaxNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE SyntaxNode_Copy !****************************************************************************** FUNCTION SyntaxNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( SyntaxNode ) Flag = FalseVal IF ( LhsObj % Type /= RhsObj % Type ) RETURN IF ( LhsObj % ID /= RhsObj % ID ) RETURN Flag = ( LhsObj % C /= RhsObj % C ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION SyntaxNode_IsEqualTo !****************************************************************************** SUBROUTINE SyntaxNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the SyntaxNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END SUBROUTINE SyntaxNode_MemFree !****************************************************************************** FUNCTION SyntaxNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = 'SyntaxNode: {Type: ' // ToChar ( Obj % Type ) // ', ID: ' // ToChar ( Obj % ID ) // ', C: ' // Obj % C // '}' RETURN END FUNCTION SyntaxNode_ToString ! ----------------------------------------------------------------------------- ! -----                     Specific Procedures                           ----- ! ----------------------------------------------------------------------------- SUBROUTINE SyntaxNode_New ( Node , NodeType ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its type. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SyntaxNode ), POINTER , INTENT ( INOUT ) :: Node tSInt32 , INTENT ( IN ) :: NodeType !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL SyntaxNode_Allocate ( Node ) ! check allocation status and report error if necessary Node % Type = NodeType Node % C = NULCHR SELECT CASE ( NodeType ) CASE ( BranchNode_Or ) Node % ID = 0 CASE ( BranchNode_Many ) Node % ID = 2 CASE ( BranchNode_Concat ) Node % ID = 1 CASE ( BranchNode_LBracket ) Node % ID = - 1 CASE ( BranchNode_RBracket ) Node % ID = 3 CASE DEFAULT Node % ID = - 2 END SELECT RETURN END SUBROUTINE SyntaxNode_New !****************************************************************************** SUBROUTINE SyntaxNode_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxNode ), POINTER :: Left , Right tIndex :: I ! FLOW IF ( ALLOCATED ( STNMemManger % Node )) THEN DO I = 1_kIndex , SIZE ( STNMemManger % Node , KIND = kIndex ) Left => STNMemManger % Node ( I )% GetLeft () IF ( ASSOCIATED ( Left )) NULLIFY ( Left ) Right => STNMemManger % Node ( I )% GetRight () IF ( ASSOCIATED ( Left )) NULLIFY ( Right ) END DO DEALLOCATE ( STNMemManger % Node ) END IF STNMemManger % ID = 0_kIndex RETURN END SUBROUTINE SyntaxNode_Free !****************************************************************************** SUBROUTINE SyntaxNode_Allocate ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a storage of the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( SyntaxNode ), POINTER , INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( STNMemManger % Node )) THEN ! need allocation ALLOCATE ( STNMemManger % Node ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN STNMemManger % ID = 0_kIndex CALL Handle_ErrAlloc ( 'SyntaxNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF STNMemManger % ID = 1_kIndex ELSEIF ( STNMemManger % ID == SIZE ( STNMemManger % Node , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( SyntaxNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( STNMemManger % Node ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'SyntaxNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( STNMemManger % Node )) = STNMemManger % Node CALL MOVE_ALLOC ( NewNode , STNMemManger % Node ) STNMemManger % ID = STNMemManger % ID + 1 END BLOCK END IF ! set pointer to the storage Node => STNMemManger % Node ( STNMemManger % ID ) RETURN END SUBROUTINE SyntaxNode_Allocate !****************************************************************************** FUNCTION SyntaxNode_GetRightNode ( CurrNode ) RESULT ( RightNode ) !** PURPOSE OF THIS SUBROUTINE: !! To get the right node of the current node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: CurrNode !! current node TYPE ( SyntaxNode ), POINTER :: RightNode !! right node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: NextNode ! FLOW NextNode => CurrNode % GetNext () SELECT TYPE ( NextNode ) TYPE IS ( SyntaxNode ) RightNode => NextNode END SELECT NULLIFY ( NextNode ) RETURN END FUNCTION SyntaxNode_GetRightNode !****************************************************************************** FUNCTION SyntaxNode_GetLeftNode ( CurrNode ) RESULT ( LeftNode ) !** PURPOSE OF THIS SUBROUTINE: !! To get the left node of the current node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: CurrNode !! current node TYPE ( SyntaxNode ), POINTER :: LeftNode !! left node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: PrevNode ! FLOW PrevNode => CurrNode % GetPrevious () SELECT TYPE ( PrevNode ) TYPE IS ( SyntaxNode ) LeftNode => PrevNode END SELECT NULLIFY ( PrevNode ) RETURN END FUNCTION SyntaxNode_GetLeftNode !****************************************************************************** SUBROUTINE SyntaxNode_SetRightNode ( CurrNode , RightNode ) !** PURPOSE OF THIS SUBROUTINE: !! To set the right node of the current node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( INOUT ) :: CurrNode !! current node TYPE ( SyntaxNode ), TARGET , INTENT ( IN ) :: RightNode !! right node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL CurrNode % SetNext ( RightNode ) RETURN END SUBROUTINE SyntaxNode_SetRightNode !****************************************************************************** SUBROUTINE SyntaxNode_SetLeftNode ( CurrNode , LeftNode ) !** PURPOSE OF THIS SUBROUTINE: !! To set the left node of the current node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( INOUT ) :: CurrNode !! current node TYPE ( SyntaxNode ), TARGET , INTENT ( IN ) :: LeftNode !! left node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL CurrNode % SetPrevious ( LeftNode ) RETURN END SUBROUTINE SyntaxNode_SetLeftNode !****************************************************************************** FUNCTION SyntaxNode_HasRightNode ( CurrNode ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the right node of the specified node is associated or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: CurrNode !! current node tLogical :: Flag !! true if right node is associated !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ASSOCIATED ( CurrNode % GetNext ()) RETURN END FUNCTION SyntaxNode_HasRightNode !****************************************************************************** FUNCTION SyntaxNode_HasLeftNode ( CurrNode ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the left node of the specified node is associated or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( IN ) :: CurrNode !! current node tLogical :: Flag !! true if right node is associated !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ASSOCIATED ( CurrNode % GetPrevious ()) RETURN END FUNCTION SyntaxNode_HasLeftNode !****************************************************************************** SUBROUTINE SyntaxNode_Operate ( CurrNode , LeftNode , RightNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set both the left and right nodes of the current node.  This operation is applicable !  only for the \"BranchNode_Or\", \"BranchNode_Many\", or \"BranchNode_Concat\" node type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( INOUT ) :: CurrNode !! current node CLASS ( DoublyLinkedNode ), INTENT ( IN ) :: LeftNode !! left node CLASS ( DoublyLinkedNode ), INTENT ( IN ) :: RightNode !! right node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( CurrNode % Type ) CASE ( BranchNode_Or , BranchNode_Many , BranchNode_Concat ) CALL CurrNode % SetPrevious ( LeftNode ) CALL CurrNode % SetNext ( RightNode ) END SELECT RETURN END SUBROUTINE SyntaxNode_Operate !****************************************************************************** SUBROUTINE SyntaxNode_SetCharacter ( CurrNode , C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the specified character to the current node.  This operation is !  only applicable for the \"LeafNode_Char\" node type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxNode ), INTENT ( INOUT ) :: CurrNode !! current node tChar , INTENT ( IN ) :: C !! character to be set !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( CurrNode % Type == LeafNode_Char ) THEN CurrNode % C = C END IF RETURN END SUBROUTINE SyntaxNode_SetCharacter !****************************************************************************** END MODULE MClass_SyntaxNode !******************************************************************************","tags":"","loc":"sourcefile\\mclass_syntaxnode.f90.html"},{"title":"MClass_FvlStr.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_FvlStr !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *FvlStr* type and its related routines.  The *FvlStr* !   type represents a variable-length string class that provides routines to handle !   and manipulate strings.  Functionally, it is similar to the Fortran's *CHARACTER* !   type.  However, when declared as an array, elements of the array of the *FvlStr* !   type do not have to have the same length whereas those of the Fortran intrinsic !   type must. <br> !   The procedures provided by the *FvlStr* type are similar to those provided in !   the <a href=\"../module/mbase_chrstr.html\">MBase_ChrStr</a> module.  However, !   the *FvlStr* type employs an object-oriented interface instead of a procedural !   interface; thus, these procedures are type-bound.  In addition, procedures !   similar to the Fortran intrinsic procedures (for the *CHARACTER* type) are also !   provided in a procedural interface (i.e. the same as the intrinsic ones). <br> !   It should be noted that the *FvlStr* type is a subtype of the *Hashable* type. !   Therefore, all operations provided for the *Object*, the *Comparable* or !   the *Hashable* types, such as sorting and containers, are also applicable to !   the *FvlStr* type. <br> !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !** USE STATEMENTS: USE ISO_C_BINDING USE MBase_Common USE MBase_ErrHandlers USE MClass_Object , ONLY : Object USE MClass_Comparable , ONLY : Comparable #ifdef Indx32Bits USE MBase_OptimalHash32 , ONLY : ComputeHash => Murmur3_Hash32_Opt #else USE MBase_OptimalHash64 , ONLY : ComputeHash => XX_Hash64_Opt #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type PUBLIC :: FvlStr ! assignment and operators PUBLIC :: ASSIGNMENT ( = ), OPERATOR ( + ), OPERATOR ( // ) PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ), OPERATOR ( > ) PUBLIC :: OPERATOR ( >= ), OPERATOR ( < ), OPERATOR ( <= ) PUBLIC :: GETLEN , LEN_TRIM , ACHAR , CHAR ! string intrinsics PUBLIC :: IACHAR , ICHAR , ADJUSTL , ADJUSTR PUBLIC :: INDEX , REPEAT , SCAN , TRIM PUBLIC :: VERIFY , LGT , LGE , LLT , LLE ! user-defined input/output statements PUBLIC :: WRITE ( UNFORMATTED ), READ ( UNFORMATTED ) PUBLIC :: WRITE ( FORMATTED ), READ ( FORMATTED ) ! miscellaneous procedures PUBLIC :: Swap , ToCharStar , PtrToStr , IsReady PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'Class_FvlStr' ! seed for computation of hash code #ifdef Indx32Bits tSInt32 , PARAMETER :: HashSeed = 313131_kInt32 #else tSInt64 , PARAMETER :: HashSeed = 313131_kInt64 #endif !** DERIVED TYPE DEFINITIONS !> *FvlStr* is a string type that represents a variable-length string class. !  It provides various methods/procedures to handle and manipulate strings. TYPE , EXTENDS ( Comparable ) :: FvlStr PRIVATE tCharAlloc :: cStr ! character string CONTAINS ! --------------------------------------------------------------------- ! -----                 Conversion Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToCharString <br> !  **Purpose**:  To convert a FvlStr object to an allocatable character !       string. <br> !  **Usage**: <br> !   --->    cStr = vStr%ToCharString() <br> PROCEDURE :: ToCharString => CharAlloc_From_FvlStr !> **Type-Bound Function**: ToChrArrAlloc <br> !  **Purpose**:  To convert a FvlStr object to an allocatable array !       of characters. <br> !  **Usage**: <br> !   ! convert a FvlStr object to a character array <br> !   --->    cArray = vStr%ToChrArrAlloc() <br> !   ! convert a FvlStr object to a character array with a null character <br> !   --->    cArray = vStr%ToChrArrAlloc(IsCString=.TRUE.) <br> PROCEDURE :: ToChrArrAlloc => CharArray_From_FvlStr !> **Type-Bound Function**: ParseByte <br> !  **Purpose**:  To parse the string of a FvlStr object as an 8-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseByte() <br> !   --->    NumVal = vStr%ParseByte(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseByte => IByte_From_FvlStr !> **Type-Bound Function**: ParseShort <br> !  **Purpose**:  To parse the string of a FvlStr object as a 16-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseShort() <br> !   --->    NumVal = vStr%ParseShort(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseShort => IShort_From_FvlStr !> **Type-Bound Function**: ParseInteger <br> !  **Purpose**:  To parse the string of a FvlStr object as a 32-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseInteger() <br> !   --->    NumVal = vStr%ParseInteger(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseInteger => Integer_From_FvlStr !> **Type-Bound Function**: ParseLong <br> !  **Purpose**:  To parse the string of a FvlStr object as a 8-bit integer number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseLong() <br> !   --->    NumVal = vStr%ParseLong(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseLong => ILong_From_FvlStr !> **Type-Bound Function**: ParseRSingle <br> !  **Purpose**:  To parse the string of a FvlStr object as a single-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRSingle() <br> !   --->    NumVal = vStr%ParseRSingle(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRSingle => RSingle_From_FvlStr !> **Type-Bound Function**: ParseRDouble <br> !  **Purpose**:  To parse the string of a FvlStr object as a double-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRDouble() <br> !   --->    NumVal = vStr%ParseRDouble(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRDouble => RDouble_From_FvlStr !> **Type-Bound Function**: ParseRQuad <br> !  **Purpose**:  To parse the string of a FvlStr object as a quadruple-precision real number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseRQuad() <br> !   --->    NumVal = vStr%ParseRQuad(ErrFlag, ErrMsg) <br> PROCEDURE :: ParseRQuad => RQuad_From_FvlStr !> **Type-Bound Function**: ParseCSingle <br> !  **Purpose**:  To parse the string of a FvlStr object as a single-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCSingle() <br> !   --->    NumVal = vStr%ParseCSingle(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCSingle => CSingle_From_FvlStr !> **Type-Bound Function**: ParseCDouble <br> !  **Purpose**:  To parse the string of a FvlStr object as a double-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCDouble() <br> !   --->    NumVal = vStr%ParseCDouble(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCDouble => CDouble_From_FvlStr !> **Type-Bound Function**: ParseCQuad <br> !  **Purpose**:  To parse the string of a FvlStr object as a quadruple-precision complex number. <br> !  **Usage**: <br> !   --->    NumVal = vStr%ParseCQuad() <br> !   --->    NumVal = vStr%ParseCQuad(ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. PROCEDURE :: ParseCQuad => CQuad_From_FvlStr !> **Type-Bound Function**: ParseLogical<br> !  **Purpose**:  To parse the string of a FvlStr object as a logical value. <br> !  **Usage**: <br> !   --->    LogVal = vStr%ParseLogical() <br> PROCEDURE :: ParseLogical => Logical_From_FvlStr ! --------------------------------------------------------------------- ! -----                 Getter Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: Length <br> !  **Purpose**:  To return the length of the character string of a FvlStr object. <br> !  **Usage**: <br> !   --->    StrLen = vStr%Length() <br> PROCEDURE :: Length => GetLength !> **Type-Bound Function**: cSubStr <br> !  **Purpose**:  To return a substring from FvlStr object based on the specified lPos !       and rPos where the returned substring is an allocatable character string. <br> !  **Usage**: <br> !   --->    SubStr = vStr%cSubStr(lPos, rPos) <br> !   Note: the above example is functionally equivalent to the following Fortran !         intrinsic statement: <br> !           SubStr = cStr(lPos:rPos) PROCEDURE :: cSubStr => GetSubstring_CHS !> **Type-Bound Function**: vSubStr <br> !  **Purpose**:  To return a substring from FvlStr object based on the specified lPos !       and rPos where the returned substring is another FvlStr object. <br> !  **Usage**: <br> !   --->    SubStr = vStr%vSubStr(lPos, rPos) <br> PROCEDURE :: vSubStr => GetSubstring_VLS !> **Type-Bound Function**: cSlice <br> !  **Purpose**:  To extract the characters from the region between *first* and *last* !       indices (both inclusive) of a FvlStr object by taking strides of length *stride*. !       The returned character slice is an allocatable character string. <br> !  **Usage**: <br> !   --->    Slice = vStr%cSlice(first, last, stride) <br> !   Note: the above example is functionally equivalent to the following Fortran !         intrinsic statement: <br> !           Slice = cStr(first:last:stride) PROCEDURE :: cSlice => GetSlice_CHS !> **Type-Bound Function**: vSlice <br> !  **Purpose**:  To extract the characters from the region between *First* and *Last* !       indices (both inclusive) of a FvlStr object by taking strides of length *Stride*. !       The returned character slice is another FvlStr object. <br> !  **Usage**: <br> !   --->    Slice = vStr%vSlice(First, Last, Stride) <br> PROCEDURE :: vSlice => GetSlice_VLS !> **Type-Bound Function**: Char <br> !  **Purpose**:  To return a (single) character from a FvlStr object based on !       the specified position. <br> !  **Usage**: <br> !   --->    Chr = vStr%Char(Pos) <br> PROCEDURE :: Char => GetCharacter ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: CountSubstring_CHS PROCEDURE , PRIVATE :: CountSubstring_VLS PROCEDURE , PRIVATE :: CountCharacters_CHS PROCEDURE , PRIVATE :: CountCharacters_VLS PROCEDURE , PRIVATE :: FindSubstring_CHS PROCEDURE , PRIVATE :: FindSubstring_VLS PROCEDURE , PRIVATE :: FindDelimiters_CHS PROCEDURE , PRIVATE :: FindDelimiters_VLS PROCEDURE , PRIVATE :: FindSeparators_CHS PROCEDURE , PRIVATE :: FindSeparators_VLS PROCEDURE , PRIVATE :: StartWith_CHS PROCEDURE , PRIVATE :: StartWith_VLS PROCEDURE , PRIVATE :: EndWith_CHS PROCEDURE , PRIVATE :: EndWith_VLS !> **Type-Bound Function**: IsNumber <br> !  **Purpose**:  To return a flag indicating whether the string of a FvlStr object !       is a valid number and if so, what kind of number it is. <br> !       If the returned flag is -1, the string is NOT a number. <br> !       If the returned flag is  0, the string is a valid integer or real number. <br> !       If the returned flag is  1, the string is strictly an integer number. <br> !       If the returned flag is  2, the string is strictly a real number. <br> !       If the returned flag is  3, the string is a valid complex number. <br> !  **Usage**: <br> !   ! return -1, 0 or 3 <br> !   --->    Flag = vStr%IsNumber() <br> !   ! return -1, 1, 2 or 3 <br> !   --->    Flag = vStr%IsNumber(Strict=.TRUE.) <br> !   ! return a flag (-1, 0 or 3) and value of the string if it is a number <br> !   --->    Flag = vStr%IsNumber(NumVal=Value) <br> !  **Technical Notes**: <br> !   A (strict) integer number is a whole number with no decimal point. !   It can have a leading sign and is interpreted as a decimal number. !   It takes a general form of [s]n[n...] where <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). <br> !   A (strict) real number is a number with decimal point or an exponent part. !   The general form of a real number with no exponent part is [s]n[n...] and !   a real number with an exponent part has a general form of [s]n[n...]E[s]nn... !   where  <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). A decimal point must appear if !     the real number has no exponent part. <br> !   - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. <br> !   A complex number is a pair of real or integer numbers, separated by a comma, !   and enclosed in parentheses.  The first number represents the real part and !   the second number represents the imaginary part. PROCEDURE :: IsNumber => Is_FvlStr_Number !> **Type-Bound Function**: IsLogical <br> !  **Purpose**:  To return true value if the string of a FvlStr object is a logical !       value where valid logical values include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', !       'true', 'false'.  Otherwise, return false value. <br> !  **Usage**: <br> !   ! only return the flag <br> !   --->    Flag = vStr%IsLogical() <br> !   ! return the flag and also get logical value if the returned flag is true <br> !   --->    Flag = vStr%IsLogical(LogVal) <br> PROCEDURE :: IsLogical => Is_FvlStr_Logical !> **Type-Bound Function**: IsInClass <br> !  **Purpose**:  To check whether a FvlStr object is in the specified class where !       the recognized classes include ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX, !       CONTROL, DIGIT, FNAME, GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION, !       PRINTABLE, REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. <br> !  **Usage**: <br> !   --->    Flag = vStr%IsInClass('ALPHANUM') <br> !   --->    Flag = vStr%IsInClass('GRAPHICAL', FailIndex) <br> !   --->    IF (.NOT.vStr%IsInClass('FNAME')) DoSomething <br> !  **Technical Notes**:  See explanations of various recognized classes in the !       <a href=\"../module/mbase_chrstr.html#interface-ischaracterinclass\"> !       IsCharacterInClass</a> function interface and the !       <a href=\"../module/mbase_chrstr.html#interface-isstringinclass\"> !       IsStringInClass</a> function interface of the !       <a href=\"../module/mbase_chrstr.html\">MBase_ChrStr</a> module. <br> PROCEDURE :: IsInClass => Is_FvlStr_InClass !> **Function Interface**: CountSubstring <br> !  **Purpose**:  To count the number of occurrences of the given substring !       in the specified FvlStr object. <br> !  **Usage**: <br> !   --->    Count = vStr%CountSubstring(SubStr) <br> !   --->    Count = vStr%CountSubstring(SubStr, Overlap=.TRUE.) <br> GENERIC :: CountSubstring => CountSubstring_CHS , CountSubstring_VLS !> **Function Interface**: CountCharacters <br> !  **Purpose**:  To count the number of occurrences of character(s) in the !       specified FvlStr object for any character appearing in the given !       character set.  Optionally, a user can specify flags indicating !       whether protected regions exist or not and whether the exclamation !       mark is used to protect regions. <br> !  **Usage**: <br> !   --->    Count = vStr%CountCharacters(CharSet) <br> !   --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE.) <br> !   --->    Count = vStr%CountCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: CountCharacters => CountCharacters_CHS , CountCharacters_VLS !> **Function Interface**: CountWords <br> !  **Purpose**:  To count the number of words (separated by blanks) in the !       specified FvlStr object where blanks are characters in the !       <a href=\"../module/mbase_chrstr.html#variable-set_blanks\"> !       SET_BLANKS</a> character set. <br> !  **Usage**: <br> !   --->    Count = vStr%CountWords() <br> PROCEDURE :: CountWords => CountWords_VLS !> **Function Interface**: FindProtectedRegions <br> !  **Purpose**:  To find the number of protected regions marked by two (single !       or double) quotes and/or by an exclamation mark.  Also, return positions !       of the first and last characters of each region. <br> !  **Usage**: <br> !   --->    nRegion = vStr%FindProtectedRegions(lPos, rPos) <br> !   --->    nRegion = vStr%FindProtectedRegions(lPos, rPos, ExclMrk=.FALSE.) <br> PROCEDURE :: FindProtectedRegions => FindProtectedRegions_VLS !> **Function Interface**: FindSubstring <br> !  **Purpose**:  To count the number of non-overlapping occurrences of the given !       substring in the specified FvlStr object and also return position(s) of !       the first character of substring found.  Optionally, a user can specify !       flags indicating whether protected regions exist or not and whether the !       exclamation mark is used to protect regions. <br> !  **Usage**: <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos) <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE.) <br> !   --->    Count = vStr%FindSubstring(SubStr, FirstPos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindSubstring => FindSubstring_CHS , FindSubstring_VLS !> **Function Interface**: FindDelimiters <br> !  **Purpose**:  To count the number of occurrences of delimiter(s) in the !       specified FvlStr object and also return position(s) of the delimiter(s) !       found.  A delimiter is any character appearing in the given character !       set.  Optionally, a user can specify flags indicating whether protected !       regions exist or not and whether the exclamation mark is used to protect !       regions. <br> !  **Usage**: <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos) <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE.) <br> !   --->    Count = vStr%FindDelimiters(CharSet, DPos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindDelimiters => FindDelimiters_CHS , FindDelimiters_VLS !> **Function Interface**: FindSeparators <br> !  **Purpose**:  To count the number of occurrences of separator(s) in the !       specified FvlStr object and also return (the first) position(s) of the !       separator(s) found.  Optionally, a user can specify flags indicating !       whether protected regions exist or not and whether the exclamation !       mark is used to protect regions. <br> !  **Usage**: <br> !   ! a separator is any (single) character in the *Separator* argument <br> !   --->    Count = vStr%FindSeparators(Separator, .TRUE., Pos) <br> !   ! a separator is a character string specified by the *Separator* argument <br> !   --->    Count = vStr%FindSeparators(Separator, .FALSE., Pos) <br> !   ! both quotes and an exclamation mark used to define protected regions. <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE.)  ! separator is a single character <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE.) ! separator is a character string <br> !   ! only quotes used to define protected regions.  <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .TRUE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    Count = vStr%FindSeparatorsProtect(Separator, .FALSE., Pos, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: FindSeparators => FindSeparators_CHS , FindSeparators_VLS !> **Function Interface**: StartWith <br> !  **Purpose**:  To check whether the string of a FvlStr object starts with the !       specified substring or not.  Both the string and the substring must not !       have a zero length. <br> !  **Usage**: <br> !   --->    Flag = vStr%StartWith(SubStr) <br> !   --->    IF (.NOT.vStr%StartWith(SubStr)) DoSomething GENERIC :: StartWith => StartWith_CHS , StartWith_VLS !> **Function Interface**: EndWith <br> !  **Purpose**:  To check whether the string of a FvlStr object ends with the !       specified substring or not.  Both the string and the substring must not !       have a zero length. <br> !  **Usage**: <br> !   --->    Flag = vStr%EndWith(SubStr) <br> !   --->    IF (.NOT.vStr%EndWith(SubStr)) DoSomething GENERIC :: EndWith => EndWith_CHS , EndWith_VLS ! --------------------------------------------------------------------- ! -----             Manipulation Procedures                       ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: AlterCase PROCEDURE , PRIVATE :: AlterCaseProtect PROCEDURE , PRIVATE :: InsertSubstring_CHS PROCEDURE , PRIVATE :: InsertSubstring_VLS PROCEDURE , PRIVATE :: RemoveCharacters_CHS PROCEDURE , PRIVATE :: RemoveCharacters_VLS PROCEDURE , PRIVATE :: RemoveSubstring_CHS PROCEDURE , PRIVATE :: RemoveSubstring_VLS PROCEDURE , PRIVATE :: Delete_Substring PROCEDURE , PRIVATE :: ReplaceSubstring_CHS_CHS PROCEDURE , PRIVATE :: ReplaceSubstring_VLS_CHS PROCEDURE , PRIVATE :: ReplaceSubstring_CHS_VLS PROCEDURE , PRIVATE :: ReplaceSubstring_VLS_VLS PROCEDURE , PRIVATE :: PartitionSepSub_CHS PROCEDURE , PRIVATE :: PartitionSepSub_VLS PROCEDURE , PRIVATE :: PartitionSepChr_CHS PROCEDURE , PRIVATE :: PartitionSepChr_VLS PROCEDURE , PRIVATE :: SplitSepSub_CHS PROCEDURE , PRIVATE :: SplitSepSub_VLS PROCEDURE , PRIVATE :: SplitSepChr_CHS PROCEDURE , PRIVATE :: SplitSepChr_VLS !> **Subroutine Interface**: ChangeCase <br> !  **Purpose**:  To change case of all alphabet characters of the string of the !       specified FvlStr object according to the given flag.  If protected regions !       are specified, only characters in unprotected regions are changed. <br> !  **Usage**: <br> !   ! change all alphabet characters to upper cases <br> !   --->    CALL vStr%ChangeCase(.TRUE.) <br> !   ! change all alphabet characters only in unprotected regions to lower cases <br> !   --->    CALL vStr%ChangeCase(nRegion, lPos, rPos, .FALSE.) GENERIC :: ChangeCase => AlterCase , AlterCaseProtect !> **Subroutine Interface**: ChangeCaseBC <br> !  **Purpose**:  To first remove all blank characters and then change case of all !       alphabet characters of the string of the specified FvlStr object according !       to the given flag. <br> !  **Usage**: <br> !   --->    CALL vStr%ChangeCaseBC(.TRUE.) PROCEDURE :: ChangeCaseBC => BlankCompressAlterCase !> **Subroutine Interface**: CropBlanks <br> !  **Purpose**:  To remove leading and trailing blanks from the string of the !       specified FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%CropBlanks() <br> !   --->    CALL vStr%CropBlanks(SpaceOnly=.TRUE.) <br> PROCEDURE :: CropBlanks => CropBlanks_VLS !> **Subroutine Interface**: Compact <br> !  **Purpose**:  To convert multiple spaces and tabs into a single space, delete !       control characters and removes initial (leading and trailing) spaces. <br> !  **Usage**: <br> !   --->    CALL vStr%Compact() <br> PROCEDURE :: Compact => CompactString_VLS !> **Subroutine Interface**: Compress <br> !  **Purpose**:  To remove spaces, tabs and control characters from the string !       of the specified FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%Compress() <br> !  **Note**: Unlike the *Compact* method, the returned string contains no space !            between its characters. PROCEDURE :: Compress => CompressString_VLS !> **Subroutine Interface**: InsertSubstring <br> !  **Purpose**:  To insert a given substring into the string of the given !       FvlStr object at a specified position. <br> !  **Usage**: <br> !   --->    CALL vStr%InsertSubstring(Pos, SubStr) GENERIC :: InsertSubstring => InsertSubstring_CHS , InsertSubstring_VLS !> **Subroutine Interface**: RemoveCharacters <br> !  **Purpose**:  To remove characters from the string of the given FvlStr !       object depending on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%RemoveCharacters(CharSet) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Option=2) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, 2, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%RemoveCharacters(CharSet, 3, .TRUE., .FALSE.) <br> GENERIC :: RemoveCharacters => RemoveCharacters_CHS , RemoveCharacters_VLS !> **Subroutine Interface**: RemoveSubstring <br> !  **Purpose**:  To remove the substring from the string of the given FvlStr !       object based on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%RemoveSubstring(SubStr) <br> !   --->    CALL vStr%RemoveSubstring(lPos, rPos) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, FirstOnly=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, Protect=.TRUE., FirstOnly=.TRUE.) <br> !   --->    CALL vStr%RemoveSubstring(SubStr, .TRUE., .FALSE., .TRUE.) <br> GENERIC :: RemoveSubstring => RemoveSubstring_CHS , RemoveSubstring_VLS , & Delete_Substring !> **Subroutine Interface**: ReplaceSubstring <br> !  **Purpose**:  To replace all occurrences of the original substring found !       in the string of the given FvlStr object with the new substring based !       on specified input. <br> !  **Usage**: <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., Recur=.TRUE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, Protect=.TRUE., ExclMrk=.FALSE.) <br> !   --->    CALL vStr%ReplaceSubstring(OldSub, NewSub, .TRUE., .TRUE., .FALSE.) <br> GENERIC :: ReplaceSubstring => ReplaceSubstring_CHS_CHS , ReplaceSubstring_VLS_CHS , & ReplaceSubstring_CHS_VLS , ReplaceSubstring_VLS_VLS !> **Subroutine Interface**: Partition <br> !  **Purpose**:  To partition the string of the given FvlStr object into two !       substrings by a separator (single character or a multiple-character !       string).  The partition occurs at the first occurrence of the separator !       found. <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL vStr%Partition(SepSub, SubStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid <br> !   ! separator.  Also, search the first separator from the back. <br> !   --->    CALL vStr%Partition(SepSet, SubStr, SepChr, Back=.TRUE.) <br> GENERIC :: Partition => PartitionSepSub_CHS , PartitionSepSub_VLS , & PartitionSepChr_CHS , PartitionSepChr_VLS !> **Subroutine Interface**: Split <br> !  **Purpose**:  To split the string of the given FvlStr object into multiple !        substrings by a separator (single character or a multiple-character string). <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL vStr%Split(SepSub, SubStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid separator. <br> !   --->    CALL vStr%Split(SepSet, SubStr, SepChr) <br> !   ! only find a separator in the unprotected regions. <br> !   --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE.) <br> !   ! only find separators in the unprotected regions. <br> !   --->    CALL vStr%Split(SepSet, SubStr, SepChr, Protect=.TRUE.) <br> !   ! The exclamation mark is NOT used to define the protected regions. <br> !   --->    CALL vStr%Split(SepSub, SubStr, Protect=.TRUE., ExclMrk=.FALSE.) <br> GENERIC :: Split => SplitSepSub_CHS , SplitSepSub_VLS , & SplitSepChr_CHS , SplitSepChr_VLS ! --------------------------------------------------------------------- ! -----         Reading and Writing Procedures                    ----- ! --------------------------------------------------------------------- !> **Subroutine Interface**: WriteOutput <br> !  **Purpose**:  To write the string of a FvlStr object to a connected !       formatted unit. <br> !  **Usage**: <br> !   --->    CALL vStr%WriteOutput(IOUnit) <br> !   --->    CALL vStr%WriteOutput(IOUnit,IOStat,IOMsg) <br> PROCEDURE :: WriteOutput !> **Subroutine Interface**: ReadComnandLine <br> !  **Purpose**:  To read a character sequence from a command line into the !       FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%ReadComnandLine() <br> PROCEDURE :: ReadComnandLine !> **Subroutine Interface**: ReadInput <br> !  **Purpose**:  To read a character sequence from a connected formatted unit !       into the FvlStr object. <br> !  **Usage**: <br> !   --->    CALL vStr%ReadInput(IOUnit) <br> !   --->    CALL vStr%ReadInput(IOUnit,IOStat,IOMsg) <br> PROCEDURE :: ReadInput ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => FvlStr_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => FvlStr_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => FvlStr_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => FvlStr_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => FvlStr_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Comparable Type          ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => FvlStr_CompareTo ! --------------------------------------------------------------------- ! -----                 Final Procedure                           ----- ! --------------------------------------------------------------------- FINAL :: FinalizeFvlStr ! --------------------------------------------------------------------- END TYPE FvlStr !** INTERFACE DEFINITIONS: !------------------------------------------------------------------ !-----      Interfaces for 'Type-Bound' Procedures            ----- !------------------------------------------------------------------ ! interfaces for 'SClass_FvlStr_Conversion' INTERFACE ! --------------------------------------------------------------------- MODULE FUNCTION IByte_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a FvlStr object to an 8-bit integer number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt8 :: IntNum !! integer number END FUNCTION IByte_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION IShort_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a FvlStr object to a 16-bit integer number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt16 :: IntNum !! integer number END FUNCTION IShort_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION Integer_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a FvlStr object to a 32-bit integer number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt32 :: IntNum !! integer number END FUNCTION Integer_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION ILong_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a FvlStr object to a 64-bit integer number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tSInt64 :: IntNum !! integer number END FUNCTION ILong_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RSingle_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a FvlStr object to a single-precision real number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tRealSP :: RealNum !! real number END FUNCTION RSingle_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RDouble_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a FvlStr object to a double-precision real number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tRealDP :: RealNum !! real number END FUNCTION RDouble_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RQuad_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a FvlStr object to a quadruple-precision real number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tRealQP :: RealNum !! real number END FUNCTION RQuad_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CSingle_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a FvlStr object to a single-precision complex number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tCmpxSP :: CmpxNum !! complex number END FUNCTION CSingle_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CDouble_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a FvlStr object to a double-precision complex number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tCmpxDP :: CmpxNum !! complex number END FUNCTION CDouble_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CQuad_From_FvlStr ( vStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a FvlStr object to a quadruple-precision complex number. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid tCmpxQP :: CmpxNum !! complex number END FUNCTION CQuad_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION Logical_From_FvlStr ( vStr ) RESULT ( Boolean ) !&#94; To convert a FvlStr object to a logical value. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical :: Boolean !! logical value END FUNCTION Logical_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CharArray_From_FvlStr ( vStr , IsCString ) RESULT ( cArr ) !&#94; To convert a FvlStr object to an allocatable array of characters. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( IN ) :: IsCString !&#94; flag indicating whether the array is a 'C' string or not. <br> !  If true, the array will contain a null character. <br> !  Default is FALSE. tChar , ALLOCATABLE :: cArr (:) !! character array END FUNCTION CharArray_From_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CharAlloc_From_FvlStr ( vStr ) RESULT ( cStr ) !&#94; To convert a FvlStr object to an allocatable character string. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharAlloc :: cStr !! character string END FUNCTION CharAlloc_From_FvlStr ! --------------------------------------------------------------------- END INTERFACE ! interfaces for 'SClass_FvlStr_Inquiry' INTERFACE ! --------------------------------------------------------------------- MODULE FUNCTION Is_FvlStr_Number ( vStr , Strict , NumVal ) RESULT ( NumFlag ) !&#94; To check whether a FvlStr object represents a valid number and !  if so, what kind of number it is. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , INTENT ( IN ) :: Strict !&#94; Flag requesting for strict integer/real number. <br> ! If true, NumFlag is 1 or 2 if the FvlStr object is a valid integer or real number. <br> ! Otherwise, NumFlag is 0 if the FvlStr object is a valid integer or real number. <br> ! Default is false. <br> CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: NumVal !! Value of number if it is valid. OPTIONAL :: Strict , NumVal tSInt32 :: NumFlag !&#94; Flag indicating what kind of number the FvlStr object represents. <br> ! NumFlag = -1, the string is NOT a number. <br> ! NumFlag =  0, the string is a valid integer or real number. <br> ! NumFlag =  1, the string is strictly an integer number. <br> ! NumFlag =  2, the string is strictly a real number. <br> ! NumFlag =  3, the string is a valid complex number. <br> END FUNCTION Is_FvlStr_Number ! --------------------------------------------------------------------- MODULE FUNCTION Is_FvlStr_Logical ( vStr , Boolean ) RESULT ( LogFlag ) !&#94; To check whether a FvlStr object represents a logical value where valid !  string include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true', and 'false'. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( OUT ) :: Boolean !! logical value if flag is true; otherwise, set to FalseVal tLogical :: LogFlag !! true if FvlStr object is a logical value END FUNCTION Is_FvlStr_Logical ! --------------------------------------------------------------------- MODULE FUNCTION Is_FvlStr_InClass ( vStr , ClassType , FailIndex ) RESULT ( ClassFlag ) !&#94; To check whether a FvlStr object is in the specified class. <br> ! The following FvlStr classes are recognized: <br> !   ALPHABET, ALPHANUM, ASCII, BLANK, COMPLEX, CONTROL, DIGIT, FNAME, !   GRAPHICAL, INTEGER, LOGICAL, LOWERCASE, PUNCTUATION, PRINTABLE, !   REAL, UPPERCASE, WHITESPACE, HEXDIGIT, OCTDIGIT. <br> ! See explanations of classes in the \"IsStringInClass\" and !   \"IsCharacterInClass\" routines in the \"MBase_ChrStr\" module. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ClassType !! FvlStr class tIndex , OPTIONAL , INTENT ( OUT ) :: FailIndex !! flag indicating position of the failed character tLogical :: ClassFlag !! true if FvlStr object is in the specified class END FUNCTION Is_FvlStr_InClass ! --------------------------------------------------------------------- MODULE FUNCTION CountSubstring_CHS ( vStr , sStr , Overlap ) RESULT ( nCount ) !&#94; To count the number of occurrences of the specified substring in !  the given FvlStr object. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring tLogical , OPTIONAL , INTENT ( IN ) :: Overlap !&#94; flag indicating whether overlapping occurrences of the substring !  are allowed or not. <br> !  - If true, count the overlapping occurrences. <br> !  - If false, count the non-overlapping occurrences . <br> !  Default is false. tIndex :: nCount !! number of occurrences END FUNCTION CountSubstring_CHS ! --------------------------------------------------------------------- MODULE FUNCTION CountSubstring_VLS ( vStr , sStr , Overlap ) RESULT ( nCount ) !&#94; See the \"CountSubstring_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tLogical , OPTIONAL , INTENT ( IN ) :: Overlap tIndex :: nCount END FUNCTION CountSubstring_VLS ! --------------------------------------------------------------------- MODULE FUNCTION CountCharacters_CHS ( vStr , ChrSet , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of character(s) in the FvlStr object !  for any character appearing in the given character set.  Optionally, a !  user can specify flags indicating whether protected regions exist or not !  and whether the exclamation mark is used to protect regions.  If protected !  regions exist, only characters in unprotected regions are counted. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ChrSet !! Set of characters tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; Protect region flag. <br> ! - True if protected regions exists. <br> ! - False if protected regions do not exist. <br> ! Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; Exclamation mark flag. <br> ! - True if exclamation mark is also used to protect regions. <br> ! - False if only (single and/or double) quotes are used to protect regions. <br> ! Default is true. tIndex :: nCount !! number of occurrences END FUNCTION CountCharacters_CHS ! --------------------------------------------------------------------- MODULE FUNCTION CountCharacters_VLS ( vStr , ChrSet , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"CountCharacters_CHS\" procedure, where the only difference !  between these two procedures is the type of the *ChrSet* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: ChrSet tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION CountCharacters_VLS ! --------------------------------------------------------------------- MODULE FUNCTION CountWords_VLS ( vStr ) RESULT ( nCount ) !&#94; To count the number of words (separated by blanks) in the FvlStr object. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tIndex :: nCount !! number of words END FUNCTION CountWords_VLS ! --------------------------------------------------------------------- MODULE FUNCTION FindProtectedRegions_VLS ( vStr , lPos , rPos , ExclMrk ) RESULT ( nRegion ) !&#94; To look for quotes (and/or an exclamation mark) to find regions !  that must be protected from string editing.  Return the number !  of protected regions as well as positions of the first and last !  characters of each region. <br> !  **Technical Notes**: <br> !  - Single quote, double quote and optionally exclamation mark are used as !    delimiters to find protected regions. <br> !  - Two single quotes or two double quotes are used to define a protected !    region whereas an exclamation mark indicates that all characters !    following it are all protected. <br> !  - This routine is designed specifically for manipulating Fortran source code !    where an exclamation mark is used for a comment and two (single or double) !    quotes are used to specify a value to a character variable or literal. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tIndex , ALLOCATABLE , INTENT ( OUT ) :: lPos (:) !&#94; positions of the first character of protected regions tIndex , ALLOCATABLE , INTENT ( OUT ) :: rPos (:) !&#94; positions of the last character of protected regions tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nRegion !! number of protected regions END FUNCTION FindProtectedRegions_VLS ! --------------------------------------------------------------------- MODULE FUNCTION FindSubstring_CHS ( vStr , sStr , sPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of non-overlapping occurrences of substring in the FvlStr object !  and also return position(s) of the first character of substring found. <br> !  If *Protect* is present and its value is true, only those occurrences found in the !  unprotected region(s) are counted. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" procedure. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !&#94; position(s) of the first character of substring found tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindSubstring_CHS ! --------------------------------------------------------------------- MODULE FUNCTION FindSubstring_VLS ( vStr , sStr , sPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"FindSubstring_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION FindSubstring_VLS ! --------------------------------------------------------------------- MODULE FUNCTION FindDelimiters_CHS ( vStr , ChrSet , dPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of delimiter(s) in the FvlStr object !  and also return position(s) of the delimiter(s) found. <br> !  A delimiter is any character appearing in the given character set. <br> !  If Protect is present and its value is true, only those occurrences found in the !  unprotected region(s) are counted. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" procedure. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ChrSet !! a set of characters tIndex , ALLOCATABLE , INTENT ( OUT ) :: dPos (:) !! position(s) of the delimiter(s) found tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindDelimiters_CHS ! --------------------------------------------------------------------- MODULE FUNCTION FindDelimiters_VLS ( vStr , ChrSet , dPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"FindDelimiters_CHS\" procedure, where the only difference !  between these two procedures is the type of the *ChrSet* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: ChrSet tIndex , ALLOCATABLE , INTENT ( OUT ) :: dPos (:) tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION FindDelimiters_VLS ! --------------------------------------------------------------------- MODULE FUNCTION FindSeparators_CHS ( vStr , Separator , CharSet , sPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of separator(s) in the FvlStr object !  and also return position(s) of the separator(s) found. <br> !  A separator can be a (single) character or a character string (multiple characters). <br> !  The argument \"CharSet\" is a flag used to specify whether the separator is a character !  or a character string. If it is true, the argument \"Separator\" contains a set of !  characters where a separator is any character in the set.  If it is false, !  the argument \"Separator\" specifies the character-string separator. <br> !  If Protect is present and its value is true, only those occurrences found in the !  unprotected region(s) are counted. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" procedure. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: Separator !! separator tLogical , INTENT ( IN ) :: CharSet !! a flag indicating type of the separator tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !! position(s) of the delimiter(s) found tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindSeparators_CHS ! --------------------------------------------------------------------- MODULE FUNCTION FindSeparators_VLS ( vStr , Separator , CharSet , sPos , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"FindSeparators_CHS\" procedure, where the only difference !  between these two procedures is the type of the *Separator* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: Separator tLogical , INTENT ( IN ) :: CharSet tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION FindSeparators_VLS ! --------------------------------------------------------------------- MODULE FUNCTION GetCharacter ( vStr , Pos ) RESULT ( Chr ) !&#94; To get a character from FvlStr object based on the specified position. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tIndex , INTENT ( IN ) :: Pos !! the position of the desired character tChar :: Chr !! the character desired END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION GetSubstring_CHS ( vStr , lPos , rPos ) RESULT ( cSub ) !&#94; To get a specified substring from FvlStr object based on lPos and rPos. <br> !  If lPos is less than 1, then 1 is used as a starting point of the substring. <br> !  Similarly, if rPos is greater than the length of the FvlStr's string, then !  the length is used as an ending point. <br> !  If rPos is less than lPos, a zero-length string is returned. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tIndex , INTENT ( IN ) :: lPos !! the leftmost character position of the substring tIndex , INTENT ( IN ) :: rPos !! the rightmost character position of the substring tCharAlloc :: cSub !! substring END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION GetSubstring_VLS ( vStr , lPos , rPos ) RESULT ( vSub ) !&#94; See the \"GetSubstring_CHS\" procedure, where the only difference !  between these two procedures is the type of the returned argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr tIndex , INTENT ( IN ) :: lPos tIndex , INTENT ( IN ) :: rPos TYPE ( FvlStr ) :: vSub END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION GetSlice_CHS ( vStr , First , Last , Stride ) RESULT ( Slice ) !&#94; To extract the characters from the region between *First* and *Last* indices ! (both inclusive) of the given string by taking strides of length *Stride*. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tIndex , OPTIONAL , INTENT ( IN ) :: First !! the first index tIndex , OPTIONAL , INTENT ( IN ) :: Last !! the last index tIndex , OPTIONAL , INTENT ( IN ) :: Stride !! the stride tCharAlloc :: Slice !! character slice END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION GetSlice_VLS ( vStr , First , Last , Stride ) RESULT ( Slice ) !&#94; See the \"GetSlice_CHS\" procedure, where the only difference !  between these two procedures is the type of the returned argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr tIndex , OPTIONAL , INTENT ( IN ) :: First tIndex , OPTIONAL , INTENT ( IN ) :: Last tIndex , OPTIONAL , INTENT ( IN ) :: Stride TYPE ( FvlStr ) :: Slice END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StartWith_CHS ( vStr , sStr ) RESULT ( Flag ) !&#94; To check whether the string of the given FvlStr object starts with !  the specified substring or not. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring tLogical :: Flag !! true if the string starts with the substring END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StartWith_VLS ( vStr , sStr ) RESULT ( Flag ) !&#94; See the \"StartWith_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION EndWith_CHS ( vStr , sStr ) RESULT ( Flag ) !&#94; To check whether the string of the given FvlStr object ends with !  the specified substring or not. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring tLogical :: Flag !! true if the string ends with the substring END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION EndWith_VLS ( vStr , sStr ) RESULT ( Flag ) !&#94; See the \"EndWith_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for 'SClass_FvlStr_Manipulation' INTERFACE ! --------------------------------------------------------------------- MODULE ELEMENTAL SUBROUTINE AlterCase ( vStr , ToUpper ) !&#94; To change case of the character string of the FvlStr object according to flag. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> END SUBROUTINE AlterCase ! --------------------------------------------------------------------- MODULE SUBROUTINE BlankCompressAlterCase ( vStr , ToUpper ) !&#94; To first remove all blanks and then change case of the character string !  of the FvlStr object according to flag. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> END SUBROUTINE BlankCompressAlterCase ! --------------------------------------------------------------------- MODULE SUBROUTINE AlterCaseProtect ( vStr , nRegion , lPos , rPos , ToUpper ) !&#94; To change case of the character string of the FvlStr object according !  to flag where only unprotected region(s) are allowed to be changed. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tIndex , INTENT ( IN ) :: nRegion !! number of protected regions tIndex , INTENT ( IN ) :: lPos (:) !! positions of the first character of protected regions tIndex , INTENT ( IN ) :: rPos (:) !! positions of the last character of protected regions tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> END SUBROUTINE AlterCaseProtect ! --------------------------------------------------------------------- MODULE SUBROUTINE InsertSubstring_CHS ( vStr , Pos , sStr ) !&#94; To insert substring into the FvlStr object at a specified position. <br> !  If Pos is less than 1, then 1 is used as an insertion point. <br> !  If Pos is greater than length of the character string, then !  the substring is inserted at the end of the character string. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tIndex , INTENT ( IN ) :: Pos !! the insertion point tCharStar , INTENT ( IN ) :: sStr !! substring END SUBROUTINE InsertSubstring_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE InsertSubstring_VLS ( vStr , Pos , sStr ) !&#94; See the \"InsertSubstring_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr tIndex , INTENT ( IN ) :: Pos TYPE ( FvlStr ), INTENT ( IN ) :: sStr END SUBROUTINE InsertSubstring_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE RemoveCharacters_CHS ( vStr , ChrSet , Option , Protect , ExclMrk ) !&#94; To remove characters from the FvlStr object depending on the specified !  Option and ChrSet. <br> !  If Protect is present and its value is true, only those occurrences found in the !  unprotected region(s) are removed. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" !  procedure in the \"SClass_FvlStr_Inquiry\" submodule. <br> !  See explanations of the *ChrSet* and *Option* arguments in the \"RemoveCharacters\" !  procedure in the \"SBase_ChrStr_Manipulation\" submodule of the \"MBase_ChrStr\" !  module. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ChrSet !! set of characters to be removed tSInt32 , OPTIONAL , INTENT ( IN ) :: Option !! flag indicating how to remove characters tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. END SUBROUTINE RemoveCharacters_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE RemoveCharacters_VLS ( vStr , ChrSet , Option , Protect , ExclMrk ) !&#94; See the \"RemoveCharacters_CHS\" procedure, where the only difference !  between these two procedures is the type of the *ChrSet* argument. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: ChrSet tSInt32 , OPTIONAL , INTENT ( IN ) :: Option tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk END SUBROUTINE RemoveCharacters_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE RemoveSubstring_CHS ( vStr , sStr , Protect , ExclMrk , FirstOnly ) !&#94; To remove substring from the FvlStr object. <br> !  If Protect is present and its value is true, only those occurrences found in the !  unprotected region(s) are removed. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" !  procedure in the \"SClass_FvlStr_Inquiry\" submodule. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring to be removed tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tLogical , OPTIONAL , INTENT ( IN ) :: FirstOnly !&#94; flag indicating whether only the first occurrence is removed. <br> !  - If true, only the first occurrence is removed. <br> !  - If false, all occurrences are removed. <br> !  Default is false. END SUBROUTINE RemoveSubstring_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE RemoveSubstring_VLS ( vStr , sStr , Protect , ExclMrk , FirstOnly ) !&#94; See the \"RemoveSubstring_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tLogical , OPTIONAL , INTENT ( IN ) :: FirstOnly END SUBROUTINE RemoveSubstring_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE Delete_Substring ( vStr , lPos , rPos ) !&#94; To remove substring from the FvlStr object at specified positions. <br> !  If lPos is less than 1, then 1 is used as a starting point of the substring. <br> !  Similarly, if rPos is greater than length of the FvlStr's string, then !  the length is used as a starting point. <br> !  If rPos is less than lPos, the same FvlStr object is returned. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tIndex , INTENT ( IN ) :: lPos !! the leftmost character position of the substring tIndex , INTENT ( IN ) :: rPos !! the rightmost character position of the substring END SUBROUTINE Delete_Substring ! --------------------------------------------------------------------- MODULE SUBROUTINE CropBlanks_VLS ( vStr , SpaceOnly ) !&#94; To remove leading and trailing blanks from the FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tLogical , OPTIONAL , INTENT ( IN ) :: SpaceOnly !&#94; flag indicating whether to only remove the space character or not. <br> ! - True if requesting to remove only the space character. <br> ! - False if requesting to remove both the tab and the space characters. <br> ! Default is false. END SUBROUTINE CropBlanks_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE CompactString_VLS ( vStr ) !&#94; To convert multiple spaces and tabs into a single space, delete !  control characters and removes initial (leading and trailing) spaces !  of the string of the specified FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr END SUBROUTINE CompactString_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE CompressString_VLS ( vStr ) !&#94; To remove spaces, tabs and control characters from the string !  of the specified FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr END SUBROUTINE CompressString_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE ReplaceSubstring_CHS_CHS ( vStr , oStr , nStr , Protect , Recur , ExclMrk ) !&#94; To replace (all) occurrences of the original substring found in the FvlStr !  object with the new substring. <br> !  Optional inputs (Protect, Recur and ExclMrk) can change how the substring !  are replaced. <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: oStr !! original (old) substring tCharStar , INTENT ( IN ) :: nStr !! new substring tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: Recur !&#94; flag indicating how to replace substring(s). <br> !  - If true, to replace in a recursive way. <br> !  - If true, to replace in a non-recursive way. <br> !  Default is false. <br> !  For example: set vStr = 'abbbbb', oStr = 'ab', and nStr = 'a' <br> !  if Recur = TrueVal,  the returning vStr = 'ab' <br> !  if Recur = FalseVal, the returning vStr = 'abbbb' <br> !  *Important Note*: If *Protect* is present and set to true, !       the substring will be replaced in a non-recursive way !       regardless of the present and value of Recur. <br> tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. END SUBROUTINE ReplaceSubstring_CHS_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE ReplaceSubstring_VLS_CHS ( vStr , oStr , nStr , Protect , Recur , ExclMrk ) !&#94; See the \"ReplaceSubstring_CHS_CHS\" procedure, where the only differences !  between these two procedures are the types of the *oStr* and/or *nStr* !  argument(s). <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: oStr tCharStar , INTENT ( IN ) :: nStr tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: Recur tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk END SUBROUTINE ReplaceSubstring_VLS_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE ReplaceSubstring_CHS_VLS ( vStr , oStr , nStr , Protect , Recur , ExclMrk ) !&#94; See the \"ReplaceSubstring_CHS_CHS\" procedure, where the only differences !  between these two procedures are the types of the *oStr* and/or *nStr* !  argument(s). <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr tCharStar , INTENT ( IN ) :: oStr TYPE ( FvlStr ), INTENT ( IN ) :: nStr tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: Recur tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk END SUBROUTINE ReplaceSubstring_CHS_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE ReplaceSubstring_VLS_VLS ( vStr , oStr , nStr , Protect , Recur , ExclMrk ) !&#94; See the \"ReplaceSubstring_CHS_CHS\" procedure, where the only differences !  between these two procedures are the types of the *oStr* and/or *nStr* !  argument(s). <br> CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: oStr TYPE ( FvlStr ), INTENT ( IN ) :: nStr tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: Recur tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk END SUBROUTINE ReplaceSubstring_VLS_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE PartitionSepSub_CHS ( vStr , SepSub , sStr , Back ) !&#94; To partition a string into two substrings where the specified separator !  is a multiple-character string.  The partition occurs at the first !  occurrence of the separator found. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: SepSub !! multiple-character separator TYPE ( FvlStr ), INTENT ( OUT ) :: sStr ( 2 ) !&#94; substrings where sStr(1) is a substring before !  the separator found and sStr(2) is the one after. tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; If present and true, searching from the back; ! otherwise, searching from the front. END SUBROUTINE PartitionSepSub_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE PartitionSepSub_VLS ( vStr , SepSub , sStr , Back ) !&#94; See the \"PartitionSepSub_CHS\" procedure, where the only difference !  between these two procedures is the type of the *SepSub* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: SepSub TYPE ( FvlStr ), INTENT ( OUT ) :: sStr ( 2 ) tLogical , OPTIONAL , INTENT ( IN ) :: Back END SUBROUTINE PartitionSepSub_VLS ! --------------------------------------------------------------------- MODULE SUBROUTINE PartitionSepChr_CHS ( vStr , SepSet , sStr , SepChr , Back ) !&#94; To partition a string into two substrings where the separator is a single !  character (any character in the specified set of characters).  The partition !  occurs at the first occurrence of the separator found. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: SepSet !&#94; set of characters representing valid separators TYPE ( FvlStr ), INTENT ( OUT ) :: sStr ( 2 ) !&#94; substrings where sStr(1) is a substring before ! the separator found and sStr(2) is the one after. tChar , INTENT ( OUT ) :: SepChr !! the separator found tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; If present and true, searching from the back; ! otherwise, searching from the front. END SUBROUTINE PartitionSepChr_CHS ! --------------------------------------------------------------------- MODULE SUBROUTINE PartitionSepChr_VLS ( vStr , SepSet , sStr , SepChr , Back ) !&#94; See the \"PartitionSepChr_CHS\" procedure, where the only difference !  between these two procedures is the type of the *SepSet* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: SepSet TYPE ( FvlStr ), INTENT ( OUT ) :: sStr ( 2 ) tChar , INTENT ( OUT ) :: SepChr tLogical , OPTIONAL , INTENT ( IN ) :: Back END SUBROUTINE PartitionSepChr_VLS ! --------------------------------------------------------------------- MODULE FUNCTION SplitSepSub_CHS ( vStr , SepSub , sStr , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To split a string of the FvlStr object into multiple substrings where the !  specified separator is a multiple-character string.  The number of substrings !  is equal to the number of occurrences of the separator found plus one.  The !  substrings may be a zero-length string if the separator is found at the !  beginning or at the end of the given string. <br> !  If Protect is present and its value is true, only those occurrences found in !  the unprotected region(s) are counted. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" !  procedure in the \"SClass_FvlStr_Inquiry\" submodule. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: SepSub !! multiple-character separator TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: sStr (:) !! output substrings tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences of separator found END FUNCTION SplitSepSub_CHS ! --------------------------------------------------------------------- MODULE FUNCTION SplitSepSub_VLS ( vStr , SepSub , sStr , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"SplitSepSub_CHS\" procedure, where the only difference !  between these two procedures is the type of the *SepSub* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: SepSub TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: sStr (:) tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION SplitSepSub_VLS ! --------------------------------------------------------------------- MODULE FUNCTION SplitSepChr_CHS ( vStr , SepSet , sStr , SepChr , Protect , ExclMrk ) RESULT ( nCount ) !&#94; To split a string of the FvlStr object into multiple substrings where a !  separator is a single character (any character in the specified set of !  characters).  The number of substrings is equal to the number of occurrences !  of the separator found plus one.  The substrings may be a zero-length string !  if the separator is found at the beginning or at the end of the given string. <br> !  If Protect is present and its value is true, only those occurrences found in !  the unprotected region(s) are counted. <br> !  See explanations about the protected region(s) in the \"FindProtectedRegions\" !  procedure in the \"SClass_FvlStr_Inquiry\" submodule. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: SepSet !! set of characters representing valid separators TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: sStr (:) !! output substrings tChar , ALLOCATABLE , INTENT ( OUT ) :: SepChr (:) !! the separators found tLogical , OPTIONAL , INTENT ( IN ) :: Protect !&#94; flag indicating whether protected regions exist or not. <br> ! -> If true, protected regions exist. <br> ! -> If false, protected regions do not exist. <br> !  Default is false. tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences of separators found END FUNCTION SplitSepChr_CHS ! --------------------------------------------------------------------- MODULE FUNCTION SplitSepChr_VLS ( vStr , SepSet , sStr , SepChr , Protect , ExclMrk ) RESULT ( nCount ) !&#94; See the \"SplitSepChr_CHS\" procedure, where the only difference !  between these two procedures is the type of the *SepSet* argument. <br> CLASS ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: SepSet TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: sStr (:) tChar , ALLOCATABLE , INTENT ( OUT ) :: SepChr (:) tLogical , OPTIONAL , INTENT ( IN ) :: Protect tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk tIndex :: nCount END FUNCTION SplitSepChr_VLS ! --------------------------------------------------------------------- END INTERFACE ! interfaces for 'SClass_FvlStr_Miscellaneous' INTERFACE ! --------------------------------------------------------------------- MODULE SUBROUTINE WriteOutput ( vStr , IOUnit , IOStat , IOMsg ) !&#94; To write a character string of the FvlStr object to a connected formatted unit. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tSInt32 , OPTIONAL , INTENT ( OUT ) :: IOStat !! status of io operation tCharStar , OPTIONAL , INTENT ( INOUT ) :: IOMsg !! an io message if is IOStat is non-zero END SUBROUTINE WriteOutput ! --------------------------------------------------------------------- MODULE SUBROUTINE ReadInput ( vStr , IOUnit , IOStat , IOMsg ) !&#94; To read a character sequence from a connected formatted unit into the FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tSInt32 , OPTIONAL , INTENT ( OUT ) :: IOStat !! status of io operation tCharAlloc , OPTIONAL , INTENT ( OUT ) :: IOMsg !! an io message END SUBROUTINE ReadInput ! --------------------------------------------------------------------- MODULE SUBROUTINE ReadComnandLine ( vStr ) !&#94; To read a character sequence from a command line into the FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object END SUBROUTINE ReadComnandLine ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Assignment' Procedures            ----- !------------------------------------------------------------------ INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) <br> !  **Purpose**:  To convert between a FvlStr object and an other (Fortran !       intrinsic) type via an assignment expression. <br> !  **Usage**: <br> !   ! convert a 64-bit integer number to a FvlStr object <br> !   --->    vStr = I64Num <br> !   ! convert a FvlStr object to a quadruple-precision real number <br> !   --->    RQPNum = vStr <br> !  **Important Note**: The *assignment* and *conversion* operations are !       functionally similar but have some subtle differences.  In particular !       for those procedures that convert from a decimal string to a number, !       the *assignment* procedures will silently convert to a proper value !       (representation) if the input string is *INVALID* whereas the *conversion* !       procedures can optionally report the error occurred. <br> ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_CharacterString ( vStr , cStr ) !&#94; To assign a FvlStr object from a character string. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tCharStar , INTENT ( IN ) :: cStr END SUBROUTINE FvlStr_From_CharacterString ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_CharacterArray ( vStr , cArr ) !&#94; To assign a FvlStr object from an array of characters. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tChar , INTENT ( IN ) :: cArr (:) END SUBROUTINE FvlStr_From_CharacterArray ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_IByte ( vStr , IntNum ) !&#94; To assign a FvlStr object from an 8-bit integer number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tSInt8 , INTENT ( IN ) :: IntNum END SUBROUTINE FvlStr_From_IByte ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_IShort ( vStr , IntNum ) !&#94; To assign a FvlStr object from a 16-bit integer number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tSInt16 , INTENT ( IN ) :: IntNum END SUBROUTINE FvlStr_From_IShort ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_Integer ( vStr , IntNum ) !&#94; To assign a FvlStr object from a 32-bit integer number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tSInt32 , INTENT ( IN ) :: IntNum END SUBROUTINE FvlStr_From_Integer ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_ILong ( vStr , IntNum ) !&#94; To assign a FvlStr object from a 64-bit integer number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tSInt64 , INTENT ( IN ) :: IntNum END SUBROUTINE FvlStr_From_ILong ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_RSingle ( vStr , RealNum ) !&#94; To assign a FvlStr object from a 32-bit real number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tRealSP , INTENT ( IN ) :: RealNum END SUBROUTINE FvlStr_From_RSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_RDouble ( vStr , RealNum ) !&#94; To assign a FvlStr object from a 64-bit real number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tRealDP , INTENT ( IN ) :: RealNum END SUBROUTINE FvlStr_From_RDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_RQuad ( vStr , RealNum ) !&#94; To assign a FvlStr object from a 128-bit real number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tRealQP , INTENT ( IN ) :: RealNum END SUBROUTINE FvlStr_From_RQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_CSingle ( vStr , CmpxNum ) !&#94; To assign a FvlStr object from a single-precision complex number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tCmpxSP , INTENT ( IN ) :: CmpxNum END SUBROUTINE FvlStr_From_CSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_CDouble ( vStr , CmpxNum ) !&#94; To assign a FvlStr object from a double-precision complex number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tCmpxDP , INTENT ( IN ) :: CmpxNum END SUBROUTINE FvlStr_From_CDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_CQuad ( vStr , CmpxNum ) !&#94; To assign a FvlStr object from a quadruple-precision complex number. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tCmpxQP , INTENT ( IN ) :: CmpxNum END SUBROUTINE FvlStr_From_CQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_From_Logical ( vStr , Boolean ) !&#94; To assign a FvlStr object from a default logical value. CLASS ( FvlStr ), INTENT ( OUT ) :: vStr tLogical , INTENT ( IN ) :: Boolean END SUBROUTINE FvlStr_From_Logical ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_CharAlloc ( cStr , vStr ) !&#94; To convert a FvlStr object to an allocatable character string. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tCharAlloc , INTENT ( OUT ) :: cStr END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_CharArray_Alloc ( cArr , vStr ) !&#94; To convert a FvlStr object to an allocatable array of characters. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tChar , ALLOCATABLE , INTENT ( OUT ) :: cArr (:) END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_IByte ( IntNum , vStr ) !&#94; To convert a FvlStr object to an 8-bit integer number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tSInt8 , INTENT ( OUT ) :: IntNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_IShort ( IntNum , vStr ) !&#94; To convert a FvlStr object to a 16-bit integer number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tSInt16 , INTENT ( OUT ) :: IntNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_Integer ( IntNum , vStr ) !&#94; To convert a FvlStr object to a 32-bit integer number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tSInt32 , INTENT ( OUT ) :: IntNum END SUBROUTINE FvlStr_To_Integer ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_ILong ( IntNum , vStr ) !&#94; To convert a FvlStr object to a 64-bit integer number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tSInt64 , INTENT ( OUT ) :: IntNum END SUBROUTINE FvlStr_To_ILong ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_RSingle ( RealNum , vStr ) !&#94; To convert a FvlStr object to a 32-bit real number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tRealSP , INTENT ( OUT ) :: RealNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_RDouble ( RealNum , vStr ) !&#94; To convert a FvlStr object to a 64-bit real number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tRealDP , INTENT ( OUT ) :: RealNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_RQuad ( RealNum , vStr ) !&#94; To convert a FvlStr object to a 128-bit real number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tRealQP , INTENT ( OUT ) :: RealNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_CSingle ( CmpxNum , vStr ) !&#94; To convert a FvlStr object to a single-precision complex number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tCmpxSP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_CDouble ( CmpxNum , vStr ) !&#94; To convert a FvlStr object to a double-precision complex number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tCmpxDP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_CQuad ( CmpxNum , vStr ) !&#94; To convert a FvlStr object to a quadruple-precision complex number. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tCmpxQP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStr_To_Logical ( Boolean , vStr ) !&#94; To convert a FvlStr object to a default logical value. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tLogical , INTENT ( OUT ) :: Boolean END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStrArray_From_ChrStrArray ( vStr , cStr ) !&#94; To assign an array of FvlStr objects from an array of character strings. <br> TYPE ( FvlStr ), INTENT ( OUT ) :: vStr (:) !! array of FvlStr objects tCharStar , INTENT ( IN ) :: cStr ( SIZE ( vStr )) !! array of character strings END SUBROUTINE FvlStrArray_From_ChrStrArray ! --------------------------------------------------------------------- MODULE SUBROUTINE FvlStrArray_From_ChrStr ( vStr , cStr ) !&#94; To assign an array of FvlStr objects from a character string. <br> TYPE ( FvlStr ), INTENT ( OUT ) :: vStr (:) !! array of FvlStr objects tCharStar , INTENT ( IN ) :: cStr !! character string END SUBROUTINE FvlStrArray_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----  Interfaces for 'Conversion/Constructor' Procedures    ----- !------------------------------------------------------------------ INTERFACE FvlStr !&#94; **Function Interface**: FvlStr <br> !  **Purpose**:  To construct a FvlStr object based on specified input. <br> !  **Usage**: <br> !   ! construct a FvlStr object from an array of characters <br> !   --->    vStr = FvlStr(cArray) <br> !   ! construct a FvlStr object from double-precision real number <br> !   --->    vStr = FvlStr(R64, IsScientific=.TRUE.) <br> MODULE FUNCTION CharacterArray_To_FvlStr ( cArr , IsCString ) RESULT ( vStr ) !&#94; To convert an array of characters to a FvlStr object. tChar , INTENT ( IN ) :: cArr (:) !! array of characters tLogical , OPTIONAL , INTENT ( IN ) :: IsCString !&#94; flag indicating whether the array is a 'C' string or not. <br> !  If true, the array must contain a null character. <br> !  Default is FALSE. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION CharacterArray_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION IByte_To_FvlStr ( IntNum ) RESULT ( vStr ) !&#94; To convert an 8-bit integer number to a FvlStr object. tSInt8 , INTENT ( IN ) :: IntNum !! integer number TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION IByte_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION IShort_To_FvlStr ( IntNum ) RESULT ( vStr ) !&#94; To convert a 16-bit integer number to a FvlStr object. tSInt16 , INTENT ( IN ) :: IntNum !! integer number TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION IShort_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION Integer_To_FvlStr ( IntNum ) RESULT ( vStr ) !&#94; To convert a 32-bit integer number to a FvlStr object. tSInt32 , INTENT ( IN ) :: IntNum !! integer number TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION Integer_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION ILong_To_FvlStr ( IntNum ) RESULT ( vStr ) !&#94; To convert a 64-bit integer number to a FvlStr object. tSInt64 , INTENT ( IN ) :: IntNum !! integer number TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION ILong_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RSingle_To_FvlStr ( RealNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a single-precision real number to a FvlStr object. tRealSP , INTENT ( IN ) :: RealNum !! real number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION RSingle_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RDouble_To_FvlStr ( RealNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a double-precision real number to a FvlStr object. tRealDP , INTENT ( IN ) :: RealNum !! real number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION RDouble_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION RQuad_To_FvlStr ( RealNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a quadruple-precision real number to a FvlStr object. tRealQP , INTENT ( IN ) :: RealNum !! real number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION RQuad_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CSingle_To_FvlStr ( CmpxNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a single-precision complex number to a FvlStr object. tCmpxSP , INTENT ( IN ) :: CmpxNum !! complex number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION CSingle_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CDouble_To_FvlStr ( CmpxNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a double-precision complex number to a FvlStr object. tCmpxDP , INTENT ( IN ) :: CmpxNum !! complex number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION CDouble_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION CQuad_To_FvlStr ( CmpxNum , IsScientific ) RESULT ( vStr ) !&#94; To convert a quadruple-precision complex number to a FvlStr object. tCmpxQP , INTENT ( IN ) :: CmpxNum !! complex number tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> !  Default is false where the string is expressed in the general format. TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION CQuad_To_FvlStr ! --------------------------------------------------------------------- MODULE FUNCTION Logical_To_FvlStr ( Boolean ) RESULT ( vStr ) !&#94; To convert a logical value to a FvlStr object. tLogical , INTENT ( IN ) :: Boolean !! logical value TYPE ( FvlStr ) :: vStr !! FvlStr object END FUNCTION Logical_To_FvlStr ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Operator Overload' Procedures     ----- !------------------------------------------------------------------ INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) <br> !  **Purpose**:  To concatenate the first and second strings. <br> !  **Usage**: <br> !   --->    vStrOut = Str1st + Str2nd <br> MODULE FUNCTION Concatenate_VLS_CHS ( Str1st , Str2nd ) RESULT ( vStrOut ) !&#94; To concatenate the first and second strings. TYPE ( FvlStr ), INTENT ( IN ) :: Str1st !! the first string tCharStar , INTENT ( IN ) :: Str2nd !! the second string TYPE ( FvlStr ) :: vStrOut !! output FvlStr object END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION Concatenate_CHS_VLS ( Str1st , Str2nd ) RESULT ( vStrOut ) !&#94; To concatenate the first and second strings. tCharStar , INTENT ( IN ) :: Str1st !! the first string TYPE ( FvlStr ), INTENT ( IN ) :: Str2nd !! the second string TYPE ( FvlStr ) :: vStrOut !! output FvlStr object END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION Concatenate_VLS_VLS ( Str1st , Str2nd ) RESULT ( vStrOut ) !&#94; To concatenate the first and second strings. TYPE ( FvlStr ), INTENT ( IN ) :: Str1st !! the first string TYPE ( FvlStr ), INTENT ( IN ) :: Str2nd !! the second string TYPE ( FvlStr ) :: vStrOut !! output FvlStr object END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( // ) !&#94; **Operator Overload**: OPERATOR('//') <br> !  **Purpose**:  To concatenate the first and second strings. <br> !  **Usage**: <br> !   --->    vStrOut = Str1st '//' Str2nd <br> MODULE PROCEDURE Concatenate_VLS_CHS MODULE PROCEDURE Concatenate_CHS_VLS MODULE PROCEDURE Concatenate_VLS_VLS END INTERFACE INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) <br> !  **Purpose**:  To check whether two strings are equal or not. <br> !  **Usage**: <br> !   --->    Flag = LHS == RHS <br> !   --->    IF (LHS .EQ. RHS) DoSomething MODULE FUNCTION VLS_EQ_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_EQ_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) <br> !  **Purpose**:  To check whether two strings are NOT equal or not. <br> !  **Usage**: <br> !   --->    Flag = LHS /= RHS <br> !   --->    IF (LHS .NE. RHS) DoSomething MODULE FUNCTION VLS_NE_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform not-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_NE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform not-equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( > ) !&#94; **Operator Overload**: OPERATOR(>) <br> !  **Purpose**:  To check whether LHS string is greater than RHS string or not. <br> !  **Usage**: <br> !   --->    Flag = LHS > RHS <br> !   --->    IF (LHS .GT. RHS) DoSomething MODULE FUNCTION VLS_GT_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_GT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( >= ) !&#94; **Operator Overload**: OPERATOR(>=) <br> !  **Purpose**:  To check whether LHS string is greater than or equal to !       RHS string or not. <br> !  **Usage**: <br> !   --->    Flag = LHS >= RHS <br> !   --->    IF (LHS .GE. RHS) DoSomething MODULE FUNCTION VLS_GE_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_GE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than-or-equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( < ) !&#94; **Operator Overload**: OPERATOR(<) <br> !  **Purpose**:  To check whether LHS string is less than RHS string or not. <br> !  **Usage**: <br> !   --->    Flag = LHS < RHS <br> !   --->    IF (LHS .LT. RHS) DoSomething MODULE FUNCTION VLS_LT_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE OPERATOR ( <= ) !&#94; **Operator Overload**: OPERATOR(<=) <br> !  **Purpose**:  To check whether LHS string is less than or equal to !       RHS string or not. <br> !  **Usage**: <br> !   --->    Flag = LHS <= RHS <br> !   --->    IF (LHS .LE. RHS) DoSomething MODULE FUNCTION VLS_LE_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than-or-equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for Fortran 'Intrinsic' Procedures     ----- !------------------------------------------------------------------ INTERFACE GETLEN !&#94; **Function Interface**: GETLEN <br> !  **Purpose**:  To return length of the character string of a FvlStr object. <br> !  **Usage**: <br> !   --->    Length = GETLEN(vStr) <br> MODULE FUNCTION GetLength ( vStr ) RESULT ( Length ) !&#94; To return length of the character string of a FvlStr object. CLASS ( FvlStr ), INTENT ( IN ) :: vStr tIndex :: Length END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE LEN_TRIM !&#94; **Function Interface**: LEN_TRIM <br> !  **Purpose**:  To return length of the character string of a FvlStr object !       without counting trailing blank characters. <br> !  **Usage**: <br> !   --->    Length = LEN_TRIM(vStr) <br> MODULE FUNCTION GetLengthTrim ( vStr ) RESULT ( Length ) !&#94; To return length of the character string of a FvlStr object !  without counting trailing blank characters. TYPE ( FvlStr ), INTENT ( IN ) :: vStr tIndex :: Length END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE INDEX !&#94; **Function Interface**: INDEX <br> !  **Purpose**:  To return the starting position of a substring within the string !       of a FvlStr object. <br> !  **Usage**: <br> !   --->    Indx = INDEX(vStr, sStr) <br> !   --->    Indx = INDEX(vStr, sStr, Back=.TRUE.) <br> MODULE FUNCTION FindIndex_CHS ( vStr , sStr , Back ) RESULT ( Indx ) !&#94; To return the starting position of a substring within the string of a FvlStr object. TYPE ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: sStr !! substring tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; If present and true, searching from the back; otherwise, searching from the front. tIndex :: Indx !! starting position of a substring END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION FindIndex_VLS ( vStr , sStr , Back ) RESULT ( Indx ) !&#94; See the \"FindIndex_CHS\" procedure, where the only difference !  between these two procedures is the type of the *sStr* argument. <br> TYPE ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: sStr tLogical , OPTIONAL , INTENT ( IN ) :: Back tIndex :: Indx END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE SCAN !&#94; **Function Interface**: SCAN <br> !  **Purpose**:  To scan the string of a FvlStr object for any character in a set !       of characters and return the position of the first character found in the !       string that is in the specified set depending on the scanning direction. <br> !  **Usage**: <br> !   --->    Pos = SCAN(vStr, ChrSet) <br> !   --->    Pos = SCAN(vStr, ChrSet, Back=.TRUE.) <br> MODULE FUNCTION ScanCharacters_CHS ( vStr , ChrSet , Back ) RESULT ( Pos ) !&#94; To scan the string of a FvlStr object for any character in a set of !  characters and return the position of the first character found in the !  string that is in the specified set depending on the scanning direction. TYPE ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ChrSet !! a set of characters tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; If present and true, scanning from the back; otherwise, scanning from the front. tIndex :: Pos !! position of the first character found END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION ScanCharacters_VLS ( vStr , ChrSet , Back ) RESULT ( Pos ) !&#94; See the \"ScanCharacters_CHS\" procedure, where the only difference !  between these two procedures is the type of the *ChrSet* argument. <br> TYPE ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: ChrSet tLogical , OPTIONAL , INTENT ( IN ) :: Back tIndex :: Pos END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE VERIFY !&#94; **Function Interface**: VERIFY <br> !  **Purpose**:  To verify that a set of characters contains all the characters !       in the string of a FvlStr object by identifying the first character in !       the string that is not in the set and to return the position of the !       first character found in the string that is NOT in the specified set !       depending on the scanning direction. <br> !  **Usage**: <br> !   --->    Pos = VERIFY(vStr, ChrSet) <br> !   --->    Pos = VERIFY(vStr, ChrSet, Back=.TRUE.) <br> MODULE FUNCTION VerifyCharacters_CHS ( vStr , ChrSet , Back ) RESULT ( Pos ) !&#94; To verify that a set of characters contains all the characters in !  the string of a FvlStr object by identifying the first character !  in the string that is not in the set and to return the position !  of the first character found in the string that is NOT in the !  specified set depending on the scanning direction.  If all characters !  of string are in the specified set or the length of string is zero, !  the returned value is zero. TYPE ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( IN ) :: ChrSet !! a set of characters tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; If present and true, scanning from the back; otherwise, scanning from the front. tIndex :: Pos !! position of the first character found END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION VerifyCharacters_VLS ( vStr , ChrSet , Back ) RESULT ( Pos ) !&#94; See the \"VerifyCharacters_CHS\" procedure, where the only difference !  between these two procedures is the type of the *ChrSet* argument. <br> TYPE ( FvlStr ), INTENT ( IN ) :: vStr TYPE ( FvlStr ), INTENT ( IN ) :: ChrSet tLogical , OPTIONAL , INTENT ( IN ) :: Back tIndex :: Pos END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE ADJUSTL !&#94; **Function Interface**: ADJUSTL <br> !  **Purpose**:  To adjust the string of FvlStr object to the left, removing !       leading blanks and inserting trailing blanks. <br> !  **Usage**: <br> !   --->    vStrOut = ADJUSTL(vStrIn) <br> MODULE FUNCTION AdjustToLeft ( vStrIn ) RESULT ( vStrOut ) !&#94; To adjust the string of FvlStr object to the left, removing leading !  blanks and inserting trailing blanks. TYPE ( FvlStr ), INTENT ( IN ) :: vStrIn TYPE ( FvlStr ) :: vStrOut END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE ADJUSTR !&#94; **Function Interface**: ADJUSTR <br> !  **Purpose**:  To adjust the string of FvlStr object to the right, removing !       trailing blanks and inserting leading blanks. <br> !  **Usage**: <br> !   --->    vStrOut = ADJUSTR(vStrIn) <br> MODULE FUNCTION AdjustToRight ( vStrIn ) RESULT ( vStrOut ) !&#94; To adjust the string of FvlStr object to the right, removing trailing !  blanks and inserting leading blanks. TYPE ( FvlStr ), INTENT ( IN ) :: vStrIn TYPE ( FvlStr ) :: vStrOut END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE TRIM !&#94; **Function Interface**: TRIM <br> !  **Purpose**:  To return the argument with trailing blanks removed. <br> !  **Usage**: <br> !   --->    vStrOut = TRIM(vStrIn) <br> MODULE FUNCTION TrimFvlStr ( vStrIn ) RESULT ( vStrOut ) !&#94; To return the argument with trailing blanks removed. TYPE ( FvlStr ), INTENT ( IN ) :: vStrIn TYPE ( FvlStr ) :: vStrOut END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE REPEAT !&#94; **Function Interface**: REPEAT <br> !  **Purpose**:  To concatenate several copies of the string of the specified !       FvlStr object. <br> !  **Usage**: <br> !   --->    vStrOut = REPEAT(vStrIn, nCopies) <br> MODULE FUNCTION RepeatString ( vStrIn , nCopies ) RESULT ( vStrOut ) !&#94; To concatenate several copies of the specified string. TYPE ( FvlStr ), INTENT ( IN ) :: vStrIn !! input FvlStr object to be repeated tIndex , INTENT ( IN ) :: nCopies !! number of copies TYPE ( FvlStr ) :: vStrOut !! output FvlStr object END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE LGT !&#94; **Function Interface**: LGT <br> !  **Purpose**:  To check whether LHS string is lexically greater than !       RHS string or not, based on the ASCII collating sequence, even !       if the compiler's default collating sequence is different. <br> !  **Usage**: <br> !   --->    Flag = LGT(LHS, RHS) <br> !   --->    IF (.NOT.LGT(LHS, RHS)) DoSomething MODULE FUNCTION VLS_LGT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION VLS_LGT_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LGT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE LGE !&#94; **Function Interface**: LGE <br> !  **Purpose**:  To check whether LHS string is lexically greater than or equal !       to RHS string or not, based on the ASCII collating sequence, even if the !       compiler's default collating sequence is different. <br> !  **Usage**: <br> !   --->    Flag = LGE(LHS, RHS) <br> !   --->    IF (.NOT.LGE(LHS, RHS)) DoSomething MODULE FUNCTION VLS_LGE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION VLS_LGE_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LGE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform greater-than-or-equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE LLT !&#94; **Function Interface**: LLT <br> !  **Purpose**:  To check whether LHS string is lexically less than !       RHS string or not, based on the ASCII collating sequence, even !       if the compiler's default collating sequence is different. <br> !  **Usage**: <br> !   --->    Flag = LLT(LHS, RHS) <br> !   --->    IF (.NOT.LLT(LHS, RHS)) DoSomething MODULE FUNCTION VLS_LLT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION VLS_LLT_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LLT_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE LLE !&#94; **Function Interface**: LLE <br> !  **Purpose**:  To check whether LHS string is lexically less than or equal !       to RHS string or not, based on the ASCII collating sequence, even if the !       compiler's default collating sequence is different. <br> !  **Usage**: <br> !   --->    Flag = LLE(LHS, RHS) <br> !   --->    IF (.NOT.LLE(LHS, RHS)) DoSomething MODULE FUNCTION VLS_LLE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION VLS_LLE_CHS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than-or-equal-to operation of two strings. TYPE ( FvlStr ), INTENT ( IN ) :: lStr tCharStar , INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION CHS_LLE_VLS ( lStr , rStr ) RESULT ( Flag ) !&#94; To perform less-than-or-equal-to operation of two strings. tCharStar , INTENT ( IN ) :: lStr TYPE ( FvlStr ), INTENT ( IN ) :: rStr tLogical :: Flag END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE ACHAR !&#94; **Function Interface**: ACHAR <br> !  **Purpose**:  To return a FvlStr object with length of 1 representing the !       character in the specified position of the ASCII character set. <br> !  **Usage**: <br> !   --->    Chr = ACHAR(I) <br> MODULE FUNCTION Get_ACHAR ( I ) RESULT ( vStr ) !&#94; To get the character in the specified position of the ASCII character set. tSInt32 , INTENT ( IN ) :: I !! character code (position in the set) TYPE ( FvlStr ) :: vStr !! FvlStr object with length of 1 END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE CHAR !&#94; **Function Interface**: CHAR <br> !  **Purpose**:  To return a FvlStr object with length of 1 representing the !       character in the specified position of the compiler's character set. <br> !  **Usage**: <br> !   --->    Chr = CHAR(I) <br> MODULE FUNCTION Get_CHAR ( I ) RESULT ( vStr ) !&#94; To get the character in the specified position of the processor's character set. tSInt32 , INTENT ( IN ) :: I !! character code (position in the set) TYPE ( FvlStr ) :: vStr !! FvlStr object with length of 1 END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE IACHAR !&#94; **Function Interface**: IACHAR <br> !  **Purpose**:  To return the character code based on the ASCII character set !       of the specified character of the FvlStr object. <br> !  **Usage**: <br> !   --->    I = IACHAR(vStr, Pos) <br> !  **Note**: A character code is a position of the character in a character set. <br> MODULE FUNCTION Get_IACHAR ( vStr , Pos ) RESULT ( I ) !&#94; To get the character code based on the ASCII character set of the specified !  character. TYPE ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: Pos !! index specifying the FvlStr's character tSInt32 :: I !&#94; the requested character code (position in the character set); !  I = -1 if invalid set of input is given. END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE ICHAR !&#94; **Function Interface**: ICHAR <br> !  **Purpose**:  To return the character code based on the compiler's character set !       of the specified character of the FvlStr object. <br> !  **Usage**: <br> !   --->    I = ICHAR(vStr, Pos) <br> !  **Note**: A character code is a position of the character in a character set. <br> MODULE FUNCTION Get_ICHAR ( vStr , Pos ) RESULT ( I ) !&#94; To get the character code based on the processor's character set of the specified !  character. TYPE ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: Pos !! index specifying the FvlStr's character tSInt32 :: I !&#94; the requested character code (position in the character set); !  I = -1 if invalid set of input is given. END FUNCTION ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'User-Defined IO' Procedures       ----- !------------------------------------------------------------------ INTERFACE WRITE ( UNFORMATTED ) !&#94; **Subroutine Interface**: WRITE(UNFORMATTED) <br> !  **Purpose**:  To write a character string of the FvlStr object to a connected !       unformatted unit. <br> !  **Usage**: <br> !   --->    WRITE(UNIT=IOUnit) vStr <br> MODULE SUBROUTINE Write_Unformatted ( vStr , IOUnit , IOStat , IOMsg ) !&#94; To write a character string of the FvlStr object to a connected unformatted unit. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tSInt32 , INTENT ( OUT ) :: IOStat !! status of io operation tCharStar , INTENT ( INOUT ) :: IOMsg !! an io message if is IOStat is non-zero END SUBROUTINE Write_Unformatted ! --------------------------------------------------------------------- END INTERFACE INTERFACE READ ( UNFORMATTED ) !&#94; **Subroutine Interface**: READ(UNFORMATTED) <br> !  **Purpose**:  To read a character sequence from a connected unformatted unit !       into the FvlStr object. <br> !  **Usage**: <br> !   --->    READ(UNIT=IOUnit) vStr <br> MODULE SUBROUTINE Read_Unformatted ( vStr , IOUnit , IOStat , IOMsg ) !&#94; To read a character sequence from a connected unformatted unit into the FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tSInt32 , INTENT ( OUT ) :: IOStat !! status of io operation tCharStar , INTENT ( INOUT ) :: IOMsg !! an io message if is IOStat is non-zero END SUBROUTINE Read_Unformatted ! --------------------------------------------------------------------- END INTERFACE INTERFACE WRITE ( FORMATTED ) !&#94; **Subroutine Interface**: WRITE(FORMATTED) <br> !  **Purpose**:  To write a character string of the FvlStr object to a connected !       formatted unit. <br> !  **Usage**: <br> !   ! using the list-directed format output <br> !   --->    WRITE(UNIT=IOUnit, FMT=*) vStr <br> !   --->    WRITE(UNIT=IOUnit, FMT=*, IOSTAT=IOStat, IOMSG=IOMsg) vStr <br> !   ! using the DT edit descriptor <br> !   --->    WRITE(UNIT=IOUnit, FMT='(DT)') vStr <br> !   --->    WRITE(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr <br> MODULE SUBROUTINE Write_Formatted ( vStr , IOUnit , IOType , VList , IOStat , IOMsg ) !&#94; To write a character string of the FvlStr object to a connected formatted unit. CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tCharStar , INTENT ( IN ) :: IOType !! type of io tSInt32 , INTENT ( IN ) :: VList (:) !! list of integer array from part of the DT edit descriptor tSInt32 , INTENT ( OUT ) :: IOStat !! status of io operation tCharStar , INTENT ( INOUT ) :: IOMsg !! an io message if is IOStat is non-zero END SUBROUTINE Write_Formatted ! --------------------------------------------------------------------- END INTERFACE INTERFACE READ ( FORMATTED ) !&#94; **Subroutine Interface**: READ(FORMATTED) <br> !  **Purpose**:  To read a character sequence from a connected formatted unit !       into the FvlStr object. <br> !  **Usage**: <br> !   ! using the list-directed format input <br> !   --->    READ(UNIT=IOUnit, FMT=*) vStr <br> !   --->    READ(UNIT=IOUnit, FMT=*, IOSTAT=IOStat, IOMSG=IOMsg) vStr <br> !   ! using the DT edit descriptor <br> !   --->    READ(UNIT=IOUnit, FMT='(DT)') vStr <br> !   --->    READ(UNIT=IOUnit, FMT='(DT)', IOSTAT=IOStat, IOMSG=IOMsg) vStr <br> MODULE SUBROUTINE Read_Formatted ( vStr , IOUnit , IOType , VList , IOStat , IOMsg ) !&#94; To read a character sequence from a connected formatted unit into the FvlStr object. CLASS ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object tSInt32 , INTENT ( IN ) :: IOUnit !! connected io unit number tCharStar , INTENT ( IN ) :: IOType !! type of io tSInt32 , INTENT ( IN ) :: VList (:) !! list of integer array from part of the DT edit descriptor tSInt32 , INTENT ( OUT ) :: IOStat !! status of io operation tCharStar , INTENT ( INOUT ) :: IOMsg !! an io message if is IOStat is non-zero END SUBROUTINE Read_Formatted ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Miscellaneous' Procedures         ----- !------------------------------------------------------------------ INTERFACE Swap !&#94; **Subroutine Interface**: Swap <br> !  **Purpose**:  To swap values of two FvlStr objects or two arrays !       of FvlStr objects. <br> !  **Usage**: <br> !   --->    CALL Swap(vStrA, vStrB) <br> !   --->    CALL Swap(vStrArrA, vStrArrB) <br> MODULE SUBROUTINE SwapFvlStr ( AVal , BVal ) !&#94; To swap values of two FvlStr objects. TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal !! value of A TYPE ( FvlStr ), INTENT ( INOUT ) :: BVal !! value of B END SUBROUTINE SwapFvlStr ! --------------------------------------------------------------------- MODULE SUBROUTINE SwapFvlStrArray ( AVal , BVal ) !&#94; To swap values of two arrays of FvlStr objects. TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal (:) !! array A of FvlStr objects TYPE ( FvlStr ), INTENT ( INOUT ) :: BVal (:) !! array B of FvlStr objects END SUBROUTINE SwapFvlStrArray ! --------------------------------------------------------------------- END INTERFACE INTERFACE ToCharStar !&#94; **Subroutine Interface**: ToCharStar <br> !  **Purpose**:  To convert a FvlStr object to an assumed-length character string.  <br> !  **Usage**: <br> !   --->    CALL ToCharStar(vStr, cStr) <br> !  **Important Note**:  This procedure is intended to be used internally only. <br> MODULE PROCEDURE CharStar_From_FvlStr END INTERFACE INTERFACE PtrToStr !&#94; **Function Interface**: PtrToStr <br> !  **Purpose**:  To set a pointer to the string of the FvlStr object.  <br> !  **Usage**: <br> !   --->    StrPtr => PtrToStr(vStr) <br> !   --->    IF (.NOT.ASSOCIATED(PtrToStr(vStr))) DoSomething <br> !  **Important Note**:  This procedure is intended to be used internally only. <br> MODULE PROCEDURE Pointer_To_FvlStr END INTERFACE INTERFACE IsReady !&#94; **Function Interface**: IsReady <br> !  **Purpose**:  To check whether the FvlStr object is ready to be used or not. !       Return true if the object's string is allocated.  Otherwise, return false.  <br> !  **Usage**: <br> !   --->    Flag = IsReady(vStr) <br> !   --->    IF (.NOT.IsReady(vStr)) DoSomething <br> MODULE PROCEDURE Is_FvlStr_Ready END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !-------------------------------------------------------------------------------------- !               DEFERRED-BINDING PROCEDURES OF HASHABLE CLASS !-------------------------------------------------------------------------------------- SUBROUTINE FvlStr_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS ROUTINE: !&#94; To perform copy of the source object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW SELECT TYPE ( DstObj ) TYPE IS ( FvlStr ) IF ( ALLOCATED ( SrcObj % cStr )) THEN ALLOCATE ( DstObj % cStr , SOURCE = SrcObj % cStr ) ELSE ALLOCATE ( tCharLen ( 0 ) :: DstObj % cStr ) END IF ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'FvlStr_Copy' , ModName , ErrSevere , 'Type of DstObj is invalid.' ) END SELECT RETURN END SUBROUTINE FvlStr_Copy !************************************************************************************** FUNCTION FvlStr_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS ROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( FvlStr ) Flag = ( LhsObj % cStr == RhsObj % cStr ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION FvlStr_IsEqualTo !****************************************************************************** SUBROUTINE FvlStr_MemFree ( Obj ) !** PURPOSE OF THIS ROUTINE: !&#94; To free memory of the FvlStr object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( INOUT ) :: Obj ! FvlStr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( Obj % cStr )) DEALLOCATE ( Obj % cStr ) RETURN END SUBROUTINE FvlStr_MemFree !****************************************************************************** FUNCTION FvlStr_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS ROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Obj % cStr )) THEN Str = '{FlvStr : ' // Obj % cStr // '}' ELSE Str = '{FlvStr : NULL}' END IF RETURN END FUNCTION FvlStr_ToString !************************************************************************************** FUNCTION FvlStr_CompareTo ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS ROUTINE: !&#94; To compare a FvlStr object with a Comparable object. !  This is a deferred procedure inherited from the *Comparable* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: A !! FvlStr object CLASS ( Comparable ), INTENT ( IN ) :: B !! Comparable object tSInt32 :: Flag !&#94; output flag with value of <br> !   -1 if A < B, <br> !    0 if A == B, or <br> !   +1 if A > B. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW SELECT TYPE ( B ) TYPE IS ( FvlStr ) IF (. NOT . ALLOCATED ( A % cStr )) THEN Flag = - 3 CALL Handle_ErrLevel ( 'FvlStr_CompareTo' , ModName , ErrSevere , & 'The string of \"A\" is NOT yet ready to be used.' ) ELSEIF (. NOT . ALLOCATED ( B % cStr )) THEN Flag = - 3 CALL Handle_ErrLevel ( 'FvlStr_CompareTo' , ModName , ErrSevere , & 'The string of \"B\" is NOT yet ready to be used.' ) ELSE IF ( A % cStr > B % cStr ) THEN Flag = 1 ELSEIF ( A % cStr < B % cStr ) THEN Flag = - 1 ELSE Flag = 0 END IF END IF CLASS DEFAULT Flag = - 2 CALL Handle_ErrLevel ( 'FvlStr_CompareTo' , ModName , ErrSevere , 'Type of B is invalid.' ) END SELECT RETURN END FUNCTION FvlStr_CompareTo !****************************************************************************** FUNCTION FvlStr_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS ROUTINE: !&#94; To get compute hash code for the given key. !  This is a deferred procedure inherited from the *Hashable* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: Obj tHash :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize tChar :: Chr ! FLOW IF ( ALLOCATED ( Obj % cStr )) THEN Chr = Obj % cStr ( 1 : 1 ) KeySize = C_SIZEOF ( Chr ) * LEN ( Obj % cStr ) Code = ComputeHash ( Obj % cStr , KeySize , HashSeed , RemoveSign = TrueVal ) ELSE Code = 0_kIndex END IF RETURN END FUNCTION FvlStr_HashCode !-------------------------------------------------------------------------------------- !                           FINAL PROCEDURE !-------------------------------------------------------------------------------------- SUBROUTINE FinalizeFvlStr ( vStr ) !** PURPOSE OF THIS ROUTINE: !&#94; To finalize the FvlStr object !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: vStr !! FvlStr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW CALL vStr % MemFree () RETURN END SUBROUTINE FinalizeFvlStr !****************************************************************************** SUBROUTINE CharStar_From_FvlStr ( vStr , cStr ) !** PURPOSE OF THIS ROUTINE: !&#94; To convert a FvlStr object to an assumed-length character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tCharStar , INTENT ( OUT ) :: cStr !! character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinLen !** FLOW IF ( ALLOCATED ( vStr % cStr )) THEN MinLen = MIN ( LEN ( cStr ), LEN ( vStr % cStr )) cStr ( 1 : MinLen ) = vStr % cStr ( 1 : MinLen ) ELSE cStr = '' END IF RETURN END SUBROUTINE CharStar_From_FvlStr !****************************************************************************** FUNCTION Pointer_To_FvlStr ( vStr ) RESULT ( pStr ) !** PURPOSE OF THIS ROUTINE: !&#94; To set a pointer to the string of the FvlStr object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), TARGET , INTENT ( IN ) :: vStr !! FvlStr object tCharLen (:), POINTER :: pStr !! pointer to object's string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( vStr % cStr )) THEN pStr => vStr % cStr ELSE pStr => NULL () END IF RETURN END FUNCTION Pointer_To_FvlStr !****************************************************************************** FUNCTION Is_FvlStr_Ready ( vStr ) RESULT ( Flag ) !** PURPOSE OF THIS ROUTINE: !&#94; To check whether the string of the FvlStr object is allocated or not. !  If allocated, return true.  Otherwise, return false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( FvlStr ), INTENT ( IN ) :: vStr !! FvlStr object tLogical :: Flag !! flag indicating whether the string is allocated or not. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( vStr % cStr )) THEN Flag = TrueVal ELSE Flag = FalseVal END IF RETURN END FUNCTION Is_FvlStr_Ready !****************************************************************************** END MODULE MClass_FvlStr !******************************************************************************","tags":"","loc":"sourcefile\\mclass_fvlstr.f90.html"},{"title":"MBase_ChrStr.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_ChrStr !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains routines that handle and manipulate character strings. !   These routines supplement the Fortran intrinsic procedures provided for !   the Fortran's *CHARACTER* type.  The routines provided in this module !   can be categorized into 5 groups as follows. <br> !   (1) *Character* procedures are routines for a single character.  The following !       list shows available (i.e. public) character procedures. <br> !       - IsCharacterInClass, <br> !       - ChangeCaseCharacter, and <br> !       - CharacterDescription. <br> !   (2) *Assignment* procedures are conversion routines between a character string !       and an other (Fortran intrinsic) type.  These conversion routines are intended !       to be used in an assignment expression.  <br> !   (3) *Conversion* procedures are conversion routines between a character string !       and an other (Fortran intrinsic) type.  These conversion routines are NOT !       intended to be used in an assignment expression; therefore, they have !       different interfaces from those intended for an assignment expression. !       The following list shows available (i.e. public) conversion procedures. <br> !       - CharString, <br> !       - ToChrArrFixed, <br> !       - ToChrArrAlloc, <br> !       - ToCString, <br> !       - ParseByte, <br> !       - ParseShort, <br> !       - ParseInteger, <br> !       - ParseLong, <br> !       - ParseRSingle, <br> !       - ParseRDouble, <br> !       - ParseRQuad, <br> !       - ParseCSingle, <br> !       - ParseCDouble, <br> !       - ParseCQuad, and <br> !       - ParseLogical. <br> !   (4) *Inquiry* procedures are routines that inquire information relating to !       a character string.  The following list shows available (i.e. public) !       inquiry procedures. <br> !       - IsStringNumber, <br> !       - IsStringLogical, <br> !       - IsStringInClass, <br> !       - IsStringInCharacterSet, <br> !       - CountSubString, <br> !       - CountCharacters, <br> !       - CountCharactersProtect, <br> !       - CountWords, <br> !       - FindProtectedRegions, <br> !       - FindSubstring, <br> !       - FindDelimiters, <br> !       - FindSeparators, <br> !       - FindSubstringProtect, <br> !       - FindDelimitersProtect, <br> !       - FindSeparatorsProtect, <br> !       - StartWith, <br> !       - EndWith, <br> !       - GetSubstring, and <br> !       - GetSlice. <br> !   (5) *Manipulation* procedures are routines that perform a manipulation on !       a character string.  The following list shows available (i.e. public) !       manipulation procedures. <br> !       - ChangeCase, <br> !       - BlankCompressChangeCase, <br> !       - CropBlanks, <br> !       - CompactString, <br> !       - CompressString, <br> !       - InsertSubstring, <br> !       - RemoveCharacters, <br> !       - RemoveCharactersProtect, <br> !       - RemoveSubstring, <br> !       - RemoveSubstringProtect, <br> !       - ReplaceSubstring, <br> !       - ReplaceSubstringProtect, <br> !       - ReplaceSubstringRecursive <br> !       - Partition, <br> !       - Split, and <br> !       - SplitProtect. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_CharUtil USE MBase_DoublyLinkedLists , ONLY : QueueChar => ListCharacter IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! conversion procedures PUBLIC :: CharString PUBLIC :: ToChrArrFixed , ToChrArrAlloc , ToCString PUBLIC :: ParseByte , ParseShort , ParseInteger , ParseLong PUBLIC :: ParseRSingle , ParseRDouble , ParseRQuad PUBLIC :: ParseCSingle , ParseCDouble , ParseCQuad PUBLIC :: ParseLogical PUBLIC :: ASSIGNMENT ( = ) ! inquiry procedures PUBLIC :: IsStringNumber , IsStringLogical , IsStringInClass , IsStringInCharacterSet PUBLIC :: CountSubString , CountCharacters , CountCharactersProtect , CountWords PUBLIC :: FindProtectedRegions , FindSubstring , FindDelimiters , FindSeparators PUBLIC :: FindSubstringProtect , FindDelimitersProtect , FindSeparatorsProtect PUBLIC :: StartWith , EndWith , GetSubstring , GetSlice ! case procedures PUBLIC :: ChangeCase , BlankCompressChangeCase ! editing procedures PUBLIC :: CropBlanks , CompactString , CompressString PUBLIC :: InsertSubstring , Partition , Split , SplitProtect PUBLIC :: RemoveCharacters , RemoveCharactersProtect PUBLIC :: RemoveSubstring , RemoveSubstringProtect PUBLIC :: ReplaceSubstring , ReplaceSubstringProtect , ReplaceSubstringRecursive ! character procedures PUBLIC :: IsCharacterInClass , ChangeCaseCharacter , CharacterDescription PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharParam :: ModName = 'MBase_ChrStr' !------------------------------------------------------------------ !-----                  FailIndex parameters                  ----- !------------------------------------------------------------------ !% unknown index tSInt32 , PARAMETER , PUBLIC :: ID_UNKNOWN_INDEX = - 5 !% character string not yet allocated tSInt32 , PARAMETER , PUBLIC :: ID_NOT_ALLOCATED = - 4 !% character string with zero length tSInt32 , PARAMETER , PUBLIC :: ID_ZERO_LENGTH = - 3 !% missing character tSInt32 , PARAMETER , PUBLIC :: ID_MISSING_CHARACTER = - 2 !% empty string tSInt32 , PARAMETER , PUBLIC :: ID_EMPTY_STRING = - 1 !% fail index not applicable tSInt32 , PARAMETER , PUBLIC :: ID_NO_FAILINDEX = 0 !** DERIVED TYPE DEFINITIONS ! na !** MODULE VARIABLE DECLARATIONS: ! na !** INTERFACE DEFINITIONS: !------------------------------------------------------------------ !-----      Interfaces for 'Character' Procedures             ----- !------------------------------------------------------------------ INTERFACE IsCharacterInClass !&#94; **Function Interface**: IsCharacterInClass <br> !  **Purpose**:  To check whether a given character is in the specified class. <br> !  **Usage**: <br> !   --->    Flag = IsCharacterInClass('A', 'ASCII', FailIndex) <br> !   --->    IF (.NOT.IsCharacterInClass('5', 'ALPHANUM')) DoSomething MODULE FUNCTION IsCharacterInClass ( Chr , ClassType , FailIndex ) RESULT ( ClassFlag ) !&#94; To check whether a given character is in the specified class where !  the following character classes are recognized. <br> !  - 'ALPHABET': The given character is a valid letter [a-zA-Z]. <br> !  - 'ALPHANUM': The given character is a valid letter or digit [a-zA-Z0-9]. <br> !  - 'ASCII': The given character is a valid ASCII character. <br> !  - 'BLANK': The given character is a valid blank character, that is blank !       space or tab. <br> !  - 'CONTROL': The given character is a valid control character where control !       characters are in the ranges 00..1F and 7F..9F, that is from ASCII #0 !       to #31 and from #127 to #159. <br> !  - 'DIGIT': The given character is a valid digit [0-9]. <br> !  - 'GRAPHICAL': The given character is a valid graphical character not !       including space that is from ASCII #33 to #126. <br> !  - 'LOGICAL': The given character is a valid logical value, that is 't', 'T', !       'f', and 'F'. <br> !  - 'LOWERCASE': The given character is a valid lower-case letter, that is !       [a-z]. <br> !  - 'PUNCTUATION': The given character is a valid punctuation character, that !       is _,;:.?![](){}@\"'. <br> !  - 'PRINTABLE': The given character is a valid printable character including !       space that is from ASCII #32 to #126. <br> !  - 'UPPERCASE': The given character is a valid upper-case letter, that is !       [A-Z]. <br> !  - 'WHITESPACE': The given character is a valid white space, that is space, !       tab, vertical tab, form-feed, newline or carriage return. <br> !  - 'HEXDIGIT': The given character is a valid hexadecimal digit characters !       that is [0-9A-Fa-f]. <br> !  - 'OCTDIGIT': The given character is a valid octal digit characters !       that is [0-9A-Fa-f]. tChar , INTENT ( IN ) :: Chr !! the specified character tCharStar , INTENT ( IN ) :: ClassType !! character class tIndex , OPTIONAL , INTENT ( OUT ) :: FailIndex !&#94; return 1 if the character class is valid; otherwise, return 0. tLogical :: ClassFlag !! true if the character is in the specified class END FUNCTION ! --------------------------------------------------------------------- END INTERFACE INTERFACE ChangeCaseCharacter !&#94; **Subroutine Interface**: ChangeCaseCharacter <br> !  **Purpose**:  To change case of the given character according to flag. <br> !  **Usage**: <br> !   ! if *Char* is an alphabet character, change it to its upper case <br> !   --->    CALL ChangeCaseCharacter(Char, .TRUE.) !   ! if *Char* is an alphabet character, change it to its lower case <br> !   --->    CALL ChangeCaseCharacter(Char, .FALSE.) !   ! if *Char* is NOT an alphabet character, nothing done <br> !   --->    CALL ChangeCaseCharacter(Char, .TRUE.) MODULE ELEMENTAL SUBROUTINE ChangeCaseCharacter ( Chr , ToUpper ) !&#94; To change case of the given character according to flag. tChar , INTENT ( INOUT ) :: Chr !! the specified character tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the character to upper case <br> ! - true if requesting an uppercase character <br> ! - false if requesting a lowercase character END SUBROUTINE ChangeCaseCharacter ! --------------------------------------------------------------------- END INTERFACE INTERFACE CharacterDescription !&#94; **Function Interface**: CharacterDescription <br> !  **Purpose**:  To provide a description of the given character. <br> !  **Usage**: <br> !   --->    Description = CharacterDescription('~') MODULE FUNCTION CharacterDescription ( Chr ) RESULT ( Description ) !&#94; To provide a description of the given character. tChar , INTENT ( IN ) :: Chr !! the specified character tCharAlloc :: Description !! the character description END FUNCTION ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Assignment' Procedures            ----- !------------------------------------------------------------------ INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) <br> !  **Purpose**:  To convert between a character string and an other !                (Fortran intrinsic) type via an assignment expression. <br> !  **Usage**: <br> !   ! convert a 64-bit integer number to a character string <br> !   --->    cStr = I64Num <br> !   ! convert a character string to a quadruple-precision real number <br> !   --->    RQPNum = cStr <br> !  **Important Note**: The *assignment* and *conversion* operations are !            functionally similar but have some subtle differences.  In !            particular for those procedures that convert from a decimal !            string to a number, the *assignment* procedures will silently !            convert to a proper representation if the input string is !            *INVALID* whereas the *conversion* procedures can optionally !            report the error occurred. <br> MODULE SUBROUTINE ChrStr_From_IByte ( cStr , IntNum ) !&#94; To convert from a 8-bit integer number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = IntNum tCharAlloc , INTENT ( OUT ) :: cStr tSInt8 , INTENT ( IN ) :: IntNum END SUBROUTINE ChrStr_From_IByte ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_IShort ( cStr , IntNum ) !&#94; To convert from a 16-bit integer number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = IntNum tCharAlloc , INTENT ( OUT ) :: cStr tSInt16 , INTENT ( IN ) :: IntNum END SUBROUTINE ChrStr_From_IShort ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_Integer ( cStr , IntNum ) !&#94; To convert from a 32-bit integer number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = IntNum tCharAlloc , INTENT ( OUT ) :: cStr tSInt32 , INTENT ( IN ) :: IntNum END SUBROUTINE ChrStr_From_Integer ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_ILong ( cStr , IntNum ) !&#94; To convert from a 64-bit integer number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = IntNum tCharAlloc , INTENT ( OUT ) :: cStr tSInt64 , INTENT ( IN ) :: IntNum END SUBROUTINE ChrStr_From_ILong ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_RSingle ( cStr , RealNum ) !&#94; To convert from a single-precision real number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = RealNum tCharAlloc , INTENT ( OUT ) :: cStr tRealSP , INTENT ( IN ) :: RealNum END SUBROUTINE ChrStr_From_RSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_RDouble ( cStr , RealNum ) !&#94; To convert from a double-precision real number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = RealNum tCharAlloc , INTENT ( OUT ) :: cStr tRealDP , INTENT ( IN ) :: RealNum END SUBROUTINE ChrStr_From_RDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_RQuad ( cStr , RealNum ) !&#94; To convert from a quadruple-precision real number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = RealNum tCharAlloc , INTENT ( OUT ) :: cStr tRealQP , INTENT ( IN ) :: RealNum END SUBROUTINE ChrStr_From_RQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_CSingle ( cStr , CmpxNum ) !&#94; To convert from a single-precision complex number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = CmpxNum tCharAlloc , INTENT ( OUT ) :: cStr tCmpxSP , INTENT ( IN ) :: CmpxNum END SUBROUTINE ChrStr_From_CSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_CDouble ( cStr , CmpxNum ) !&#94; To convert from a double-precision complex number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = CmpxNum tCharAlloc , INTENT ( OUT ) :: cStr tCmpxDP , INTENT ( IN ) :: CmpxNum END SUBROUTINE ChrStr_From_CDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_CQuad ( cStr , CmpxNum ) !&#94; To convert from a quadruple-precision complex number to a character string !  via an assignment expression. <br> !  *Usage*: cStr = CmpxNum tCharAlloc , INTENT ( OUT ) :: cStr tCmpxQP , INTENT ( IN ) :: CmpxNum END SUBROUTINE ChrStr_From_CQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_From_Logical ( cStr , Boolean ) !&#94; To convert from a logical value to a character string !  via an assignment expression. <br> !  *Usage*: cStr = Boolean tCharAlloc , INTENT ( OUT ) :: cStr tLogical , INTENT ( IN ) :: Boolean END SUBROUTINE ChrStr_From_Logical ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_IByte ( IntNum , cStr ) !&#94; To convert from a character string to a 8-bit integer number !  via an assignment expression. <br> !  *Usage*: IntNum = cStr tCharStar , INTENT ( IN ) :: cStr tSInt8 , INTENT ( OUT ) :: IntNum END SUBROUTINE ChrStr_To_IByte ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_IShort ( IntNum , cStr ) !&#94; To convert from a character string to a 16-bit integer number !  via an assignment expression. <br> !  *Usage*: IntNum = cStr tCharStar , INTENT ( IN ) :: cStr tSInt16 , INTENT ( OUT ) :: IntNum END SUBROUTINE ChrStr_To_IShort ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_Integer ( IntNum , cStr ) !&#94; To convert from a character string to a 32-bit integer number !  via an assignment expression. <br> !  *Usage*: IntNum = cStr tCharStar , INTENT ( IN ) :: cStr tSInt32 , INTENT ( OUT ) :: IntNum END SUBROUTINE ChrStr_To_Integer ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_ILong ( IntNum , cStr ) !&#94; To convert from a character string to a 64-bit integer number !  via an assignment expression. <br> !  *Usage*: IntNum = cStr tCharStar , INTENT ( IN ) :: cStr tSInt64 , INTENT ( OUT ) :: IntNum END SUBROUTINE ChrStr_To_ILong ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_RSingle ( RealNum , cStr ) !&#94; To convert from a character string to a single-precision real number !  via an assignment expression. <br> !  *Usage*: RealNum = cStr tCharStar , INTENT ( IN ) :: cStr tRealSP , INTENT ( OUT ) :: RealNum END SUBROUTINE ChrStr_To_RSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_RDouble ( RealNum , cStr ) !&#94; To convert from a character string to a double-precision real number !  via an assignment expression. <br> !  *Usage*: RealNum = cStr tCharStar , INTENT ( IN ) :: cStr tRealDP , INTENT ( OUT ) :: RealNum END SUBROUTINE ChrStr_To_RDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_RQuad ( RealNum , cStr ) !&#94; To convert from a character string to a quadruple-precision real number !  via an assignment expression. <br> !  *Usage*: RealNum = cStr tCharStar , INTENT ( IN ) :: cStr tRealQP , INTENT ( OUT ) :: RealNum END SUBROUTINE ChrStr_To_RQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_CSingle ( CmpxNum , cStr ) !&#94; To convert from a character string to a single-precision complex number !  via an assignment expression. <br> !  *Usage*: CmpxNum = cStr tCharStar , INTENT ( IN ) :: cStr tCmpxSP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ChrStr_To_CSingle ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_CDouble ( CmpxNum , cStr ) !&#94; To convert from a character string to a double-precision complex number !  via an assignment expression. <br> !  *Usage*: CmpxNum = cStr tCharStar , INTENT ( IN ) :: cStr tCmpxDP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ChrStr_To_CDouble ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_CQuad ( CmpxNum , cStr ) !&#94; To convert from a character string to a quadruple-precision complex number !  via an assignment expression. <br> !  *Usage*: CmpxNum = cStr tCharStar , INTENT ( IN ) :: cStr tCmpxQP , INTENT ( OUT ) :: CmpxNum END SUBROUTINE ChrStr_To_CQuad ! --------------------------------------------------------------------- MODULE SUBROUTINE ChrStr_To_Logical ( Boolean , cStr ) !&#94; To convert from a character string to a logical value !  via an assignment expression. <br> !  *Usage*: Boolean = cStr tCharStar , INTENT ( IN ) :: cStr tLogical , INTENT ( OUT ) :: Boolean END SUBROUTINE ChrStr_To_Logical ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Conversion' Procedures            ----- !------------------------------------------------------------------ INTERFACE CharString !&#94; **Function Interface**: CharString <br> !  **Purpose**:  To construct a character string based on specified input. <br> !  **Usage**: <br> !   ! construct a character string from an array of characters <br> !   --->    cStr = CharString(cArray) <br> !   ! construct a character string from double-precision real number <br> !   --->    cStr = CharString(R64, IsScientific=.TRUE.) <br> MODULE FUNCTION CharacterArray_To_ChrStr ( cArr , IsCString ) RESULT ( cStr ) !&#94; To convert a character array to a character string. tChar , INTENT ( IN ) :: cArr (:) !! array of characters tLogical , OPTIONAL , INTENT ( IN ) :: IsCString !&#94; flag indicating whether the array is a 'C' string or not. <br> !  If true, the array must contain a null character. <br> !  Default is FALSE. tCharAlloc :: cStr !! character string END FUNCTION CharacterArray_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION IByte_To_ChrStr ( IntNum ) RESULT ( cStr ) !&#94; To convert an 8-bit integer value to a character string. tCharAlloc :: cStr tSInt8 , INTENT ( IN ) :: IntNum END FUNCTION IByte_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION IShort_To_ChrStr ( IntNum ) RESULT ( cStr ) !&#94; To convert an 16-bit integer value to a character string. tCharAlloc :: cStr tSInt16 , INTENT ( IN ) :: IntNum END FUNCTION IShort_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION Integer_To_ChrStr ( IntNum ) RESULT ( cStr ) !&#94; To convert an 32-bit integer value to a character string. tCharAlloc :: cStr tSInt32 , INTENT ( IN ) :: IntNum END FUNCTION Integer_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION ILong_To_ChrStr ( IntNum ) RESULT ( cStr ) !&#94; To convert an 64-bit integer value to a character string. tCharAlloc :: cStr tSInt64 , INTENT ( IN ) :: IntNum END FUNCTION ILong_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION RSingle_To_ChrStr ( RealNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a single-precision real value to a character string. tRealSP , INTENT ( IN ) :: RealNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION RSingle_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION RDouble_To_ChrStr ( RealNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a double-precision real value to a character string. tRealDP , INTENT ( IN ) :: RealNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION RDouble_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION RQuad_To_ChrStr ( RealNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a quadruple-precision real value to a character string. tRealQP , INTENT ( IN ) :: RealNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION RQuad_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION CSingle_To_ChrStr ( CmpxNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a single-precision complex value to a character string. tCmpxSP , INTENT ( IN ) :: CmpxNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION CSingle_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION CDouble_To_ChrStr ( CmpxNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a double-precision complex value to a character string. tCmpxDP , INTENT ( IN ) :: CmpxNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION CDouble_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION CQuad_To_ChrStr ( CmpxNum , IsScientific ) RESULT ( cStr ) !&#94; To convert a quadruple-precision complex value to a character string. tCmpxQP , INTENT ( IN ) :: CmpxNum tLogical , OPTIONAL , INTENT ( IN ) :: IsScientific !&#94; flag indicating whether the string is expressed in the scientific format. <br> ! Default is FALSE where the string is expressed in the general format. tCharAlloc :: cStr END FUNCTION CQuad_To_ChrStr ! --------------------------------------------------------------------- MODULE FUNCTION Logical_To_ChrStr ( Boolean ) RESULT ( cStr ) !&#94; To convert a logical value to a character string. tCharAlloc :: cStr tLogical , INTENT ( IN ) :: Boolean END FUNCTION Logical_To_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ToChrArrAlloc !&#94; **Function Interface**: ToChrArrAlloc <br> !  **Purpose**:  To convert a character string to an allocatable array !                of characters. <br> !  **Usage**: <br> !   ! convert a character string to a character array <br> !   --->    cArray = ToChrArrAlloc(cStr) <br> !   ! convert a character string to a character array with a null character <br> !   --->    cArray = ToChrArrAlloc(cStr, IsCString=.TRUE.) <br> MODULE FUNCTION CharArray_From_ChrStr_I ( cStr , IsCString ) RESULT ( cArr ) !&#94; To convert a character string to an allocatable array of characters. tCharStar , INTENT ( IN ) :: cStr !! a character string tLogical , OPTIONAL , INTENT ( IN ) :: IsCString !&#94; flag indicating whether the array is a 'C' string or not. <br> !  If true, the array will contain a null character. <br> !  Default is FALSE. tChar , ALLOCATABLE :: cArr (:) !! an array of characters END FUNCTION CharArray_From_ChrStr_I ! --------------------------------------------------------------------- END INTERFACE INTERFACE ToChrArrFixed !&#94; **Function Interface**: ToChrArrFixed <br> !  **Purpose**:  To convert a character string to an explicit-shape array !                of characters. <br> !  **Usage**: <br> !   --->    cArray = ToChrArrFixed(cStr) MODULE FUNCTION CharArray_From_ChrStr_II ( cStr ) RESULT ( cArr ) !&#94; To convert a character string to an explicit-shape array of characters. tCharStar , INTENT ( IN ) :: cStr !! a character string tChar :: cArr ( LEN ( cStr )) !! an array of characters END FUNCTION CharArray_From_ChrStr_II ! --------------------------------------------------------------------- END INTERFACE INTERFACE ToCString !&#94; **Function Interface**: ToCString <br> !  **Purpose**:  To convert a character string to a 'C' style string, which is an !                explicit-shape array of characters with a null character added. <br> !  **Usage**: <br> !   --->    cArray = ToCString(cStr) MODULE FUNCTION CString_From_ChrStr ( cStr ) RESULT ( cArr ) !&#94; To convert a character string to a 'C' style string. tCharStar , INTENT ( IN ) :: cStr !! a character string tChar :: cArr ( LEN ( cStr ) + 1 ) !! a 'C' string END FUNCTION CString_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseByte !&#94; **Function Interface**: ParseByte <br> !  **Purpose**:  To parse a character string as a 8-bit integer number. <br> !  **Usage**: <br> !   --->    IntNum = ParseByte(cStr) <br> !   --->    IntNum = ParseByte(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION IByte_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a character string to a 8-bit integer number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tSInt8 :: IntNum !! integer number END FUNCTION IByte_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseShort !&#94; **Function Interface**: ParseShort <br> !  **Purpose**:  To parse a character string as a 16-bit integer number. <br> !  **Usage**: <br> !   --->    IntNum = ParseShort(cStr) <br> !   --->    IntNum = ParseShort(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION IShort_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a character string to a 16-bit integer number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tSInt16 :: IntNum !! integer number END FUNCTION IShort_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseInteger !&#94; **Function Interface**: ParseInteger <br> !  **Purpose**:  To parse a character string as a 32-bit integer number. <br> !  **Usage**: <br> !   --->    IntNum = ParseInteger(cStr) <br> !   --->    IntNum = ParseInteger(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION Integer_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a character string to a 32-bit integer number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tSInt32 :: IntNum !! integer number END FUNCTION Integer_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseLong !&#94; **Function Interface**: ParseLong <br> !  **Purpose**:  To parse a character string as a 64-bit integer number. <br> !  **Usage**: <br> !   --->    IntNum = ParseLong(cStr) <br> !   --->    IntNum = ParseLong(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION ILong_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( IntNum ) !&#94; To convert a character string to a 64-bit integer number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tSInt64 :: IntNum !! integer number END FUNCTION ILong_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseRSingle !&#94; **Function Interface**: ParseRSingle <br> !  **Purpose**:  To parse a character string as a single-precision real number. <br> !  **Usage**: <br> !   --->    RealNum = ParseRSingle(cStr) <br> !   --->    RealNum = ParseRSingle(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION RSingle_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a character string to a single-precision real number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealSP :: RealNum !! real number END FUNCTION RSingle_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseRDouble !&#94; **Function Interface**: ParseRDouble <br> !  **Purpose**:  To parse a character string as a double-precision real number. <br> !  **Usage**: <br> !   --->    RealNum = ParseRDouble(cStr) <br> !   --->    RealNum = ParseRDouble(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION RDouble_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a character string to a double-precision real number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealDP :: RealNum !! real number END FUNCTION RDouble_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseRQuad !&#94; **Function Interface**: ParseRQuad <br> !  **Purpose**:  To parse a character string as a quadruple-precision real number. <br> !  **Usage**: <br> !   --->    RealNum = ParseRQuad(cStr) <br> !   --->    RealNum = ParseRQuad(cStr, ErrFlag, ErrMsg) <br> MODULE FUNCTION RQuad_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( RealNum ) !&#94; To convert a character string to a quadruple-precision real number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tRealQP :: RealNum !! real number END FUNCTION RQuad_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseCSingle !&#94; **Function Interface**: ParseCSingle <br> !  **Purpose**:  To parse a character string as a single-precision complex number. <br> !  **Usage**: <br> !   --->    CmpxNum = ParseCSingle(cStr) <br> !   --->    CmpxNum = ParseCSingle(cStr, ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. MODULE FUNCTION CSingle_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a character string to a single-precision complex number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tCmpxSP :: CmpxNum !! complex number END FUNCTION CSingle_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseCDouble !&#94; **Function Interface**: ParseCDouble <br> !  **Purpose**:  To parse a character string as a double-precision complex number. <br> !  **Usage**: <br> !   --->    CmpxNum = ParseCDouble(cStr) <br> !   --->    CmpxNum = ParseCDouble(cStr, ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. MODULE FUNCTION CDouble_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a character string to a double-precision complex number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tCmpxDP :: CmpxNum !! complex number END FUNCTION CDouble_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseCQuad !&#94; **Function Interface**: ParseCQuad <br> !  **Purpose**:  To parse a character string as a quadruple-precision complex number. <br> !  **Usage**: <br> !   --->    CmpxNum = ParseCQuad(cStr) <br> !   --->    CmpxNum = ParseCQuad(cStr, ErrFlag, ErrMsg) <br> !  **Note**: A valid string representing a complex number consists of a pair of !            real-number (or integer-number) strings, separated by a comma, and !            enclosed in parentheses. MODULE FUNCTION CQuad_From_ChrStr ( cStr , ErrFlag , ErrMsg ) RESULT ( CmpxNum ) !&#94; To convert a character string to a quadruple-precision complex number. tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! error message tCmpxQP :: CmpxNum !! complex number END FUNCTION CQuad_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE INTERFACE ParseLogical !&#94; **Function Interface**: ParseLogical <br> !  **Purpose**:  To parse a character string as a logical value. <br> !  **Usage**: <br> !   --->    Boolean = ParseLogical(cStr) <br> MODULE FUNCTION Logical_From_ChrStr ( cStr ) RESULT ( Boolean ) !&#94; To convert a character string to a logical value. tCharStar , INTENT ( IN ) :: cStr !! character string LOGICAL :: Boolean !! logical value END FUNCTION Logical_From_ChrStr ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----          Interfaces for 'Inquiry' Procedures           ----- !------------------------------------------------------------------ INTERFACE IsStringNumber !&#94; **Function Interface**: IsStringNumber <br> !  **Purpose**:  To check whether a character string is a valid number and !                return a flag indicating what kind of number the string is. <br> !  **Usage**: <br> !   --->    NumFlag = IsStringNumber('123a31')                        ! return -1 <br> !   --->    NumFlag = IsStringNumber('123')                           ! return 0 <br> !   --->    NumFlag = IsStringNumber('1.23')                          ! return 0 <br> !   --->    NumFlag = IsStringNumber('123', Strict=.TRUE.)            ! return 1 <br> !   --->    NumFlag = IsStringNumber('1.23', Strict=.TRUE.)           ! return 2 <br> !   --->    NumFlag = IsStringNumber('(123, 456)')                    ! return 3 <br> !   --->    NumFlag = IsStringNumber('(12.3, 4.56)', NumVal=CmplxNum) ! return 3 and also get number <br> !  **Technical Notes**: <br> !   A (strict) integer number is a whole number with no decimal point. !   It can have a leading sign and is interpreted as a decimal number. !   It takes a general form of [s]n[n...] where <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). <br> !   A (strict) real number is a number with decimal point or an exponent part. !   The general form of a real number with no exponent part is [s]n[n...] and !   a real number with an exponent part has a general form of [s]n[n...]E[s]nn... !   where  <br> !   - s is a sign; required if negative (-), optional if positive (+). <br> !   - n is a decimal digit (0 through 9). A decimal point must appear if !     the real number has no exponent part. <br> !   - E is an exponent indicator where it can be 'E', 'e', 'D', 'd'. <br> !   A complex number is a pair of real or integer numbers, separated by a comma, !   and enclosed in parentheses.  The first number represents the real part and !   the second number represents the imaginary part. MODULE FUNCTION IsStringNumber ( cStr , Strict , NumVal ) RESULT ( NumFlag ) !&#94; To check whether a character string is a valid number and !  if so, what kind of number it is. <br> tCharStar , INTENT ( IN ) :: cStr !&#94; character string tLogical , OPTIONAL , INTENT ( IN ) :: Strict !&#94; true if requesting strict integer/real number; default is false. CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: NumVal !&#94; (optional) value of number if it is valid tSInt32 :: NumFlag !&#94; flag indicating what kind of number the string represents. <br> ! Return -1 if the string is NOT a number. <br> ! Return  0 if the string is a valid integer or real number. <br> ! Return  1 if the string is strictly an integer number. <br> ! Return  2 if the string is strictly a real number. <br> ! Return  3 if the string is a valid complex number. END FUNCTION IsStringNumber ! --------------------------------------------------------------------- END INTERFACE INTERFACE IsStringLogical !&#94; **Function Interface**: IsStringLogical <br> !  **Purpose**: To check whether a character string is a logical value where !               valid one include 'T', 'F', 't', 'f', 'TRUE', 'FALSE', 'true', !               'false'. <br> !  **Usage**: <br> !   --->    Flag = IsStringLogical('a') <br> !   --->    Flag = IsStringLogical('f', LogVal) MODULE FUNCTION IsStringLogical ( cStr , Boolean ) RESULT ( LogFlag ) tCharStar , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: Boolean !! (optional) logical value tLogical :: LogFlag !! true if the string is a valid logical value END FUNCTION IsStringLogical ! --------------------------------------------------------------------- END INTERFACE INTERFACE IsStringInClass !&#94; **Function Interface**: IsStringInClass <br> !  **Purpose**:  To check whether a given string is in the specified class. <br> !  **Usage**: <br> !   --->    Flag = IsStringInClass('AbCd', 'ASCII', FailIndex) <br> !   --->    IF (.NOT.IsStringInClass('32.105e-32', 'REAL') DoSomething RECURSIVE MODULE FUNCTION IsStringInClass ( cStr , ClassType , FailIndex ) RESULT ( ClassFlag ) !&#94; To check whether the given character string is in the specified class. !  To be in the specified class, all characters in the string must be !  valid characters of that class. <br> !  The recognized character string classes include those of character classes !  (see the <a href=\"../module/mbase_chrstr.html#interface-ischaracterinclass\"> !  IsCharacterInClass</a> routine) and the following additional classes: <br> !  - 'COMPLEX': The character string is a valid complex constant in Fortran, !       with optional sign and surrounding white spaces. <br> !  - 'FNAME': The character string is a valid FORTRAN name that can contain !       letters, digits, and underscores. The first character must be a letter. <br> !  - 'INTEGER': The character string is a valid integer constant in Fortran, !       with optional surrounding white spaces. <br> !  - 'LOGICAL': The character string is considered a valid logical value, that !       is 't', 'T', 'true', 'TRUE', 'f', 'F', 'false' and 'FALSE', with !       optional surrounding white spaces. <br> !  - 'REAL': The character string is a valid real constant in Fortran, with !       optional surrounding white spaces. tCharStar , INTENT ( IN ) :: cStr !! specified character string tCharStar , INTENT ( IN ) :: ClassType !! character string class tIndex , OPTIONAL , INTENT ( OUT ) :: FailIndex !! flag indicating position of the failed character tLogical :: ClassFlag !! true if the string is in the specified class END FUNCTION IsStringInClass ! --------------------------------------------------------------------- END INTERFACE INTERFACE IsStringInCharacterSet !&#94; **Function Interface**: IsStringInCharacterSet <br> !  **Purpose**:  To check whether all characters in the character string are !                in the specified character set. <br> !  **Usage**: <br> !   --->    Flag = IsStringInCharacterSet('Ab23Cd', SET_ALPHANUM, FailIndex) <br> !   --->    IF (.NOT.IsStringInCharacterSet('32.105Q-32', SET_NUMERICS) DoSomething MODULE FUNCTION IsStringInCharacterSet ( cStr , ChrSet , FailID ) RESULT ( Flag ) !&#94; To check whether all characters in the character string are !  in the given character set. <br> !  Note: This routine is an alternative to the *VERIFY* intrinsic function. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: ChrSet !! character set tIndex , INTENT ( OUT ) :: FailID !! index indicating position of invalid character tLogical :: Flag !! true if all characters are in the set END FUNCTION IsStringInCharacterSet ! --------------------------------------------------------------------- END INTERFACE INTERFACE CountSubstring !&#94; **Function Interface**: CountSubstring <br> !  **Purpose**:  To count the number of occurrences of the given !                substring in the specified character string. <br> !  **Usage**: <br> !   --->    Count = CountSubstring(String, SubStr) <br> !   --->    Count = CountSubstring(String, SubStr, Overlap=.TRUE.) MODULE FUNCTION CountSubstring ( cStr , sStr , Overlap ) RESULT ( nCount ) !&#94; To count the number of occurrences of the given substring in the !  specified character string. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: sStr !! substring tLogical , OPTIONAL , INTENT ( IN ) :: Overlap !&#94; flag indicating whether overlapping occurrences of the substring !  are allowed or not. <br> !  - If true, count the overlapping occurrences. <br> !  - If false, count the non-overlapping occurrences . <br> !  Default is false. tIndex :: nCount !! number of occurrences END FUNCTION CountSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE CountCharacters !&#94; **Function Interface**: CountCharacters <br> !  **Purpose**:  To count the number of occurrences of character(s) in the !                specified character string for any character appearing in !                the given character set. <br> !  **Usage**: <br> !   --->    Count = CountCharacters(String, CharSet) MODULE FUNCTION CountCharacters ( cStr , ChrSet ) RESULT ( nCount ) !&#94; To count the number of occurrences of character(s) in the specified !  character string for any character appearing in the given character set. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: ChrSet !! character set tIndex :: nCount !! number of occurrences END FUNCTION CountCharacters ! --------------------------------------------------------------------- END INTERFACE INTERFACE CountCharactersProtect !&#94; **Function Interface**: CountCharactersProtect <br> !  **Purpose**:  To count the number of occurrences of delimiter(s) in the !                unprotected region(s) of the specified character string !                where a delimiter is any character appearing in the !                given character set. <br> !  **Usage**: <br> !   --->    Count = CountCharactersProtect(String, CharSet) <br> !   --->    Count = CountCharactersProtect(String, CharSet, ExclMrk=.FALSE.) <br> MODULE FUNCTION CountCharactersProtect ( cStr , ChrSet , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of delimiter(s) in the unprotected !  region(s) of the specified character string where a delimiter is any !  character appearing in the given character set. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: ChrSet !! character set tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION CountCharactersProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE CountWords !&#94; **Function Interface**: CountWords <br> !  **Purpose**:  To count the number of words (separated by blanks) in the !                specified character string where blanks are characters in !                the <a href=\"../module/mbase_chrstr.html#variable-set_blanks\"> !                SET_BLANKS</a> character set. <br> !  **Usage**: <br> !   --->    Count = CountWords(String) MODULE FUNCTION CountWords ( cStr ) RESULT ( nCount ) !&#94; To count the number of words (separated by blanks) in the specified !  character string. tCharStar , INTENT ( IN ) :: cStr !! character string tIndex :: nCount !! number of words END FUNCTION CountWords ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindProtectedRegions !&#94; **Function Interface**: FindProtectedRegions <br> !  **Purpose**:  To find the number of protected regions marked by two (single !                or double) quotes and/or by an exclamation mark.  Also, return !                positions of the first and last characters of each region. <br> !  **Usage**: <br> !   --->    nRegion = FindProtectedRegions(String, lPos, rPos) <br> !   --->    nRegion = FindProtectedRegions(String, lPos, rPos, ExclMrk=.FALSE.) MODULE FUNCTION FindProtectedRegions ( cStr , lPos , rPos , ExclMrk ) RESULT ( nRegion ) !&#94; To look for quotes (and/or an exclamation mark) to find regions !  that must be protected from character string editing.  Return !  the number of protected regions as well as positions of the !  first and last characters of each region. <br> !  **Technical Notes**: <br> !  - Single quote, double quote and optionally exclamation mark are used as !    delimiters to find protected regions. <br> !  - Two single quotes or two double quotes are used to define a protected !    region whereas an exclamation mark indicates that all characters !    following it are all protected. <br> !  - This routine is designed specifically for manipulating Fortran source code !    where an exclamation mark is used for a comment and two (single or double) !    quotes are used to specify a value to a character variable or literal. tCharStar , INTENT ( IN ) :: cStr !! character string tIndex , ALLOCATABLE , INTENT ( OUT ) :: lPos (:) !&#94; positions of the first character of protected regions tIndex , ALLOCATABLE , INTENT ( OUT ) :: rPos (:) !&#94; positions of the last character of protected regions tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nRegion !! number of protected regions END FUNCTION FindProtectedRegions ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindSubstring !&#94; **Function Interface**: FindSubstring <br> !  **Purpose**:  To count the number of non-overlapping occurrences of the given !                substring in the specified character string and also return !                position(s) of the first character of substring found. <br> !  **Usage**: <br> !   --->    Count = FindSubstring(String, SubStr, FirstPos) MODULE FUNCTION FindSubstring ( cStr , sStr , sPos ) RESULT ( nCount ) !&#94; To count the number of non-overlapping occurrences of the given !  substring in the specified character string and also return !  position(s) of the first character of substring found. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: sStr !! substring tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !! position(s) of the first character of substring found tIndex :: nCount !! number of occurrences END FUNCTION FindSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindSubstringProtect !&#94; **Function Interface**: FindSubstringProtect <br> !  **Purpose**:  To count the number of non-overlapping occurrences of the given !                substring in unprotected regions of the specified character !                string and also return position(s) of the first character of !                substring found. <br> !  **Usage**: <br> !   --->    Count = FindSubstringProtect(String, SubStr, FirstPos) <br> !   --->    Count = FindSubstringProtect(String, SubStr, FirstPos, ExclMrk=.FALSE.) MODULE FUNCTION FindSubstringProtect ( cStr , sStr , sPos , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of non-overlapping occurrences of the given substring !  in unprotected regions of the specified character string and also return !  position(s) of the first character of substring found. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: sStr !! substring tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !! position(s) of the first character of substring found tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindSubstringProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindDelimiters !&#94; **Function Interface**: FindDelimiters <br> !  **Purpose**:  To count the number of occurrences of delimiter(s) in the specified !                character string and also return position(s) of the delimiter(s) found. !                A delimiter is any character appearing in the given character set. <br> !  **Usage**: <br> !   --->    Count = FindDelimiters(String, CharSet, DPos) MODULE FUNCTION FindDelimiters ( cStr , ChrSet , dPos ) RESULT ( nCount ) !&#94; To count the number of occurrences of delimiter(s) in the specified !  character string and also return position(s) of the delimiter(s) found. !  A delimiter is any character appearing in the given character set. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: ChrSet !! a set of characters tIndex , ALLOCATABLE , INTENT ( OUT ) :: dPos (:) !! position(s) of the delimiter(s) found tIndex :: nCount !! number of occurrences END FUNCTION FindDelimiters ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindDelimitersProtect !&#94; **Function Interface**: FindDelimitersProtect <br> !  **Purpose**:  To count the number of occurrences of delimiter(s) in unprotected !                regions of the specified character string and also return position(s) !                of the delimiter(s) found.  A delimiter is any character appearing !                in the given character set. <br> !  **Usage**: <br> !   --->    Count = FindDelimitersProtect(String, CharSet, DPos) <br> !   --->    Count = FindDelimitersProtect(String, CharSet, DPos, ExclMrk=.FALSE.) MODULE FUNCTION FindDelimitersProtect ( cStr , ChrSet , dPos , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of delimiter(s) in unprotected regions !  of the specified character string and also return position(s) of the !  delimiter(s) found.  A delimiter is any character appearing in the given !  character set. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: ChrSet !! a set of characters tIndex , ALLOCATABLE , INTENT ( OUT ) :: dPos (:) !! position(s) of the delimiter(s) found tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindDelimitersProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindSeparators !&#94; **Function Interface**: FindSeparators <br> !  **Purpose**:  To count the number of occurrences of separator(s) in the !                specified character string and also return (the first) !                position(s) of the separator(s) found. <br> !  **Usage**: <br> !   ! a separator is any (single) character in the *Separator* argument <br> !   --->    Count = FindSeparators(String, Separator, .TRUE., Pos) <br> !   ! a separator is a character string specified by the *Separator* argument <br> !   --->    Count = FindSeparators(String, Separator, .FALSE., Pos) MODULE FUNCTION FindSeparators ( cStr , Separator , CharSet , sPos ) RESULT ( nCount ) !&#94; To count the number of occurrences of separator(s) in the specified !  character string and also return (the first) position(s) of the !  separator(s) found. <br> !  A separator can be a (single) character or a character string (multiple !  characters). <br> !  The *CharSet* argument is a flag used to specify whether the separator !  is a character or a character string. <br> !  If the *CharSet* argument is true, the *Separator* argument contains a !  set of characters where a separator is any character in the set. <br> !  If the *CharSet* argument is false, the *Separator* argument specifies !  the character-string separator. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: Separator !! separator tLogical , INTENT ( IN ) :: CharSet !! a flag indicating type of the separator tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !! (first) position(s) of the separator(s) found tIndex :: nCount !! number of occurrences END FUNCTION FindSeparators ! --------------------------------------------------------------------- END INTERFACE INTERFACE FindSeparatorsProtect !&#94; **Function Interface**: FindSeparatorsProtect <br> !  **Purpose**:  To count the number of occurrences of separator(s) in the !                specified character string and also return (the first) !                position(s) of the separator(s) found. <br> !  **Usage**: <br> !   ! both quotes and an exclamation mark used to define protected regions.  <br> !   --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos)  ! separator is a single character <br> !   --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos) ! separator is a character string <br> !   ! only quotes used to define protected regions.  <br> !   --->    Count = FindSeparatorsProtect(String, Separator, .TRUE., Pos, ExclMrk=.FALSE.) <br> !   --->    Count = FindSeparatorsProtect(String, Separator, .FALSE., Pos, ExclMrk=.FALSE.) MODULE FUNCTION FindSeparatorsProtect ( cStr , Separator , CharSet , sPos , ExclMrk ) RESULT ( nCount ) !&#94; To count the number of occurrences of separator(s) in unprotected !  regions of the specified character string and also return (the first) !  position(s) of the separator(s) found. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findseparators\"> !  FindSeparators</a> routine for explanations regarding the separator and !  its types. !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: Separator !! separator tLogical , INTENT ( IN ) :: CharSet !! a flag indicating type of the separator tIndex , ALLOCATABLE , INTENT ( OUT ) :: sPos (:) !! (first) position(s) of the separator(s) found tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tIndex :: nCount !! number of occurrences END FUNCTION FindSeparatorsProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE GetSubstring !&#94; **Function Interface**: GetSubstring <br> !  **Purpose**:  To get a substring (specified by the leftmost and rightmost !                indices) of the given character string. <br> !  **Usage**: <br> !   --->    Substring = GetSubstring(String, LeftIndx, RightIndx) MODULE FUNCTION GetSubstring ( cStr , lPos , rPos ) RESULT ( cSub ) !&#94; To return a substring specified by the *lPos* and *rPos* arguments !  of the given character string. <br> !  If the *lPos* argument is less than 1, then 1 is used as a !  starting position of the substring. <br> !  Similarly, if the *rPos* argument is greater than the length of !  the string, then the length is used as an ending position. <br> !  Also, If the *rPos* argument is less than the *lPos* argument, !  a zero-length string is returned. tCharStar , INTENT ( IN ) :: cStr !! character string tIndex , INTENT ( IN ) :: lPos !! leftmost index tIndex , INTENT ( IN ) :: rPos !! rightmost index tCharAlloc :: cSub !! substring END FUNCTION GetSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE GetSlice !&#94; **Function Interface**: GetSlice <br> !  **Purpose**:  To extract characters from the region between the first and !                last indices (both inclusive) of the given string by taking !                strides of length *Stride*. <br> !  **Usage**: <br> !   --->    Slice = GetSlice(String, FirstIndx, LastIndx, Stride) MODULE FUNCTION GetSlice ( cStr , First , Last , Stride ) RESULT ( Slice ) !&#94; To extract characters from the region between the first and last indices !  (both inclusive) of the given string by taking strides of length *Stride*. tCharStar , INTENT ( IN ) :: cStr !! character string tIndex , OPTIONAL , INTENT ( IN ) :: First !&#94; the first index; can be greater than the last index if *Stride* is negative. tIndex , OPTIONAL , INTENT ( IN ) :: Last !&#94; the last index; can be less than the first index if *Stride* is negative. tIndex , OPTIONAL , INTENT ( IN ) :: Stride !&#94; a step (length) between characters extracted; can be negative. tCharAlloc :: Slice !! slice of the string END FUNCTION GetSlice END INTERFACE INTERFACE StartWith !&#94; **Function Interface**: StartWith <br> !  **Purpose**:  To check whether the given character string starts with the !                specified substring or not.  Both the string and the substring !                must not have a zero length. <br> !  **Usage**: <br> !   --->    Flag = StartWith(String, Substring) <br> !   --->    IF (.NOT.StartWith(String, Substring)) DoSomething MODULE FUNCTION StartWithSubstring ( cStr , sStr ) RESULT ( Flag ) !&#94; To check whether the given character string starts with the specified !  substring or not.  Both the string and the substring must not have a !  zero length. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: sStr !! substring tLogical :: Flag !! true if the string starts with the substring END FUNCTION StartWithSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE EndWith !&#94; **Function Interface**: EndWith <br> !  **Purpose**:  To check whether the given character string ends with the !                specified substring or not.  Both the string and the substring !                must not have a zero length. <br> !  **Usage**: <br> !   --->    Flag = EndWith(String, Substring) <br> !   --->    IF (.NOT.EndWith(String, Substring)) DoSomething MODULE FUNCTION EndWithSubstring ( cStr , sStr ) RESULT ( Flag ) !&#94; To check whether the given character string ends with the specified !  substring or not.  Both the string and the substring must not have a !  zero length. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: sStr !! substring tLogical :: Flag !! true if the string ends with the substring END FUNCTION EndWithSubstring ! --------------------------------------------------------------------- END INTERFACE !------------------------------------------------------------------ !-----      Interfaces for 'Manipulation' Procedures          ----- !------------------------------------------------------------------ INTERFACE CropBlanks !&#94; **Function Interface**: CropBlanks <br> !  **Purpose**:  To remove leading and trailing blanks from the character string. <br> !  **Usage**: <br> !   --->    OutStr = CropBlanks(InStr) <br> !   --->    OutStr = CropBlanks(InStr, SpaceOnly=.TRUE.) <br> !  **Note**: CropBlanks(InStr,.TRUE.) is the same as TRIM(ADJUSTL(InStr)). MODULE FUNCTION CropBlanks ( cStrIn , SpaceOnly ) RESULT ( cStrOut ) !&#94; To remove leading and trailing blanks from the character string. tCharStar , INTENT ( IN ) :: cStrIn !! input string tLogical , OPTIONAL , INTENT ( IN ) :: SpaceOnly !&#94; flag indicating whether to only remove the space character or not. <br> ! - True if requesting to remove only the space character. <br> ! - False if requesting to remove both the tab and the space characters. <br> ! Default is false. tCharAlloc :: cStrOut !! output string END FUNCTION CropBlanks ! --------------------------------------------------------------------- END INTERFACE INTERFACE CompactString !&#94; **Function Interface**: CompactString <br> !  **Purpose**:  To convert multiple spaces and tabs into a single space, !                delete control characters and removes initial (leading !                and trailing) spaces. <br> !  **Usage**: <br> !   --->    OutStr = CompactString(InStr) MODULE FUNCTION CompactString ( cStrIn ) RESULT ( cStrOut ) !&#94; To convert multiple spaces and tabs into a single space, delete control !  characters and removes initial (leading and trailing) spaces. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharAlloc :: cStrOut !! output string END FUNCTION CompactString ! --------------------------------------------------------------------- END INTERFACE INTERFACE CompressString !&#94; **Function Interface**: CompressString <br> !  **Purpose**:  To remove spaces, tabs and control characters from the !                character string. <br> !  **Usage**: <br> !   --->    OutStr = CompressString(InStr) <br> !  **Note**: Unlike the *CompactString* procedure, the output string !            contains no space between its characters. MODULE FUNCTION CompressString ( cStrIn ) RESULT ( cStrOut ) !&#94; To remove spaces, tabs and control characters from the character string. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharAlloc :: cStrOut !! output string END FUNCTION CompressString ! --------------------------------------------------------------------- END INTERFACE INTERFACE ChangeCase !&#94; **Subroutine Interface**: ChangeCase <br> !  **Purpose**:  To change case of all alphabet characters of the specified !                character string according to the given flag.  If protected !                regions are specified, only characters in unprotected regions !                are changed. <br> !  **Usage**: <br> !   ! change all alphabet characters to upper cases <br> !   --->    CALL ChangeCase(String, .TRUE.) <br> !   ! change all alphabet characters only in unprotected regions to lower cases <br> !   --->    CALL ChangeCase(String, nRegion, lPos, rPos, .FALSE.) MODULE ELEMENTAL SUBROUTINE ChangeCaseString ( cStr , ToUpper ) !&#94; To change case of all alphabet characters of the specified character !  string according to the given flag. tCharStar , INTENT ( INOUT ) :: cStr !! character string tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> END SUBROUTINE ChangeCaseString ! --------------------------------------------------------------------- MODULE SUBROUTINE ChangeCaseProtect ( cStr , nRegion , lPos , rPos , ToUpper ) !&#94; To change case of all alphabet characters of the specified character !  string in *unprotected regions* according to the given flag. tCharStar , INTENT ( INOUT ) :: cStr !! character string tIndex , INTENT ( IN ) :: nRegion !! number of protected regions tIndex , INTENT ( IN ) :: lPos (:) !! positions of the first character of protected regions tIndex , INTENT ( IN ) :: rPos (:) !! positions of the last character of protected regions tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> END SUBROUTINE ChangeCaseProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE BlankCompressChangeCase !&#94; **Function Interface**: BlankCompressChangeCase <br> !  **Purpose**:  To first remove all blank characters and then change case of all !                alphabet characters of the specified character string according !                to the given flag. <br> !  **Usage**: <br> !   --->    OutStr = BlankCompressChangeCase(InStr, .TRUE.) MODULE FUNCTION BlankCompressChangeCase ( cStrIn , ToUpper ) RESULT ( cStrOut ) !&#94; To first remove all blank characters and then change case of all alphabet !  characters of the specified character string according to the given flag. tCharStar , INTENT ( IN ) :: cStrIn !! input string tLogical , INTENT ( IN ) :: ToUpper !&#94; flag indicating whether to change the string's characters to !  upper-case characters or not. <br> !  - If true, the string contains upper-case characters on exit. <br> !  - If false, the string contains lower-case characters on exit. <br> tCharAlloc :: cStrOut !! output string END FUNCTION BlankCompressChangeCase ! --------------------------------------------------------------------- END INTERFACE INTERFACE InsertSubstring !&#94; **Function Interface**: InsertSubstring <br> !  **Purpose**:  To insert a given substring into the character string at a !                specified position. <br> !  **Usage**: <br> !   --->    OutStr = InsertSubstring(InStr, Pos, SubStr) MODULE FUNCTION InsertSubstring ( cStrIn , Pos , sStr ) RESULT ( cStrOut ) !&#94; To insert a given substring into the character string at a !  specified position. <br> !  If the *Pos* argument is less than 1, then 1 is used as an insertion point. <br> !  If the *Pos* argument is greater than length of the character string, then !  the substring is inserted at the end of the character string. tCharStar , INTENT ( IN ) :: cStrIn !! input string tIndex , INTENT ( IN ) :: Pos !! the insertion point tCharStar , INTENT ( IN ) :: sStr !! substring tCharAlloc :: cStrOut !! output string END FUNCTION InsertSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE RemoveCharacters !&#94; **Function Interface**: RemoveCharacters <br> !  **Purpose**:  To remove characters from the character string depending on !                specified input. <br> !  **Usage**: <br> !   --->    OutStr = RemoveCharacters(InStr, CharSet) <br> !   --->    OutStr = RemoveCharacters(InStr, CharSet, Option=2) MODULE FUNCTION RemoveCharacters ( cStrIn , ChrSet , Option ) RESULT ( cStrOut ) !&#94; To remove characters from the character string depending on !  the specified character set and optionally the option flag. <br> !  The *ChrSet* argument is a required input that contains a set of !  characters to be removed whereas the *Option* argument is an !  optional input that indicates where characters in the character !  string to be removed are.  Available options include: <br> !  - Option = -1 --> nothing to be removed. <br> !  - Option =  0 --> leading (prefix) and trailing (suffix) character(s) !                    to be removed. <br> !  - Option =  1 --> leading (prefix) character(s) to be removed. <br> !  - Option =  2 --> trailing (suffix) character(s) to be removed. <br> !  - Option =  3 --> all characters in the *ChrSet* set to be removed. <br> ! If the *Option* argument is not present, the default option is set to 0. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: ChrSet !! set of characters to be removed tSInt32 , OPTIONAL , INTENT ( IN ) :: Option !! flag indicating how to remove characters tCharAlloc :: cStrOut !! output string END FUNCTION RemoveCharacters ! --------------------------------------------------------------------- END INTERFACE INTERFACE RemoveCharactersProtect !&#94; **Function Interface**: RemoveCharactersProtect <br> !  **Purpose**:  To remove characters from the character string depending on !                specified input. <br> !  **Usage**: <br> !   --->    OutStr = RemoveCharactersProtect(InStr, CharSet) <br> !   --->    OutStr = RemoveCharactersProtect(InStr, CharSet, Option=2) <br> !   --->    OutStr = RemoveCharactersProtect(InStr, CharSet, ExclMrk=.FALSE.) <br> !   --->    OutStr = RemoveCharactersProtect(InStr, CharSet, 3, .FALSE.) MODULE FUNCTION RemoveCharactersProtect ( cStrIn , ChrSet , Option , ExclMrk ) RESULT ( cStrOut ) !&#94; To remove characters from the unprotected regions of the character string !  depending on the specified character set and optionally the option flag. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-removecharacters\"> !  RemoveCharacters</a> routine for explanations regarding the *ChrSet* and !  *Option* arguments. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: ChrSet !! set of characters to be removed tSInt32 , OPTIONAL , INTENT ( IN ) :: Option !! flag indicating how to remove characters tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tCharAlloc :: cStrOut !! output string END FUNCTION RemoveCharactersProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE RemoveSubstring !&#94; **Function Interface**: RemoveSubstring <br> !  **Purpose**:  To remove the substring from the character string based on !                specified input. <br> !  **Usage**: <br> !   --->    OutStr = RemoveSubstring(InStr, SubStr) <br> !   --->    OutStr = RemoveSubstring(InStr, SubStr, FirstOnly=.TRUE.) <br> !   --->    OutStr = RemoveSubstring(InStr, sLen, sCount, sPos) <br> !   --->    OutStr = RemoveSubstring(InStr, lPos, rPos) <br> MODULE FUNCTION RemoveSubstring ( cStrIn , sStr , FirstOnly ) RESULT ( cStrOut ) !&#94; To remove the substring from the character string. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: sStr !! substring to be removed tLogical , OPTIONAL , INTENT ( IN ) :: FirstOnly !&#94; flag indicating whether to remove only the first substring found or to !  remove all occurrences found. <br> !  If true, only remove the first substring found; otherwise, remove all !  (non-overlapping) occurrences found. <br> !  Default is false. tCharAlloc :: cStrOut !! output string END FUNCTION RemoveSubstring ! --------------------------------------------------------------------- RECURSIVE MODULE FUNCTION RemoveSubstringKnownPos ( cStrIn , sLen , sCount , sPos ) RESULT ( cStrOut ) !&#94; To remove substring from the character string by providing length, number of !  occurrences and position(s) of first character of the substring. tCharStar , INTENT ( IN ) :: cStrIn !! input string tIndex , INTENT ( IN ) :: sLen !! length of the substring to be removed tIndex , INTENT ( IN ) :: sCount !! number of occurrences of the substring tIndex , INTENT ( IN ) :: sPos ( sCount ) !! position(s) of first character of the substring tCharAlloc :: cStrOut !! output character string END FUNCTION RemoveSubstringKnownPos ! --------------------------------------------------------------------- MODULE FUNCTION DeleteSubstring ( cStrIn , lPos , rPos ) RESULT ( cStrOut ) !&#94; To remove substring from the character string at specified positions. <br> !  If the *lPos* argument is less than 1, then 1 is used as a starting point !  of the substring. <br> !  Similarly, if the *rPos* argument is greater than length of the character !  string, then the length is used as a ending point. <br> !  If the *rPos* argument is less than the *lPos* argument, the original !  character string is returned. tCharStar , INTENT ( IN ) :: cStrIn !! input string tIndex , INTENT ( IN ) :: lPos !! the leftmost character position of the substring tIndex , INTENT ( IN ) :: rPos !! the rightmost character position of the substring tCharAlloc :: cStrOut !! output string END FUNCTION DeleteSubstring ! --------------------------------------------------------------------- END INTERFACE INTERFACE RemoveSubstringProtect !&#94; **Function Interface**: RemoveSubstringProtect <br> !  **Purpose**:  To remove the substring from the unprotected regions of the !                character string based on specified input. <br> !  **Usage**: <br> !   --->    OutStr = RemoveSubstringProtect(InStr, SubStr) <br> !   --->    OutStr = RemoveSubstringProtect(InStr, SubStr, ExclMrk=.FALSE.) <br> !   --->    OutStr = RemoveSubstringProtect(InStr, SubStr, FirstOnly=.TRUE.) <br> !   --->    OutStr = RemoveSubstringProtect(InStr, SubStr, .FALSE., .TRUE.) <br> RECURSIVE MODULE FUNCTION RemoveSubstringProtect ( cStrIn , sStr , ExclMrk , FirstOnly ) RESULT ( cStrOut ) !&#94; To remove the substring from the unprotected regions of the character !  string based on specified input. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: sStr !! substring to be removed tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tLogical , OPTIONAL , INTENT ( IN ) :: FirstOnly !&#94; flag indicating whether to remove only the first substring found or to !  remove all occurrences found. <br> !  If true, only remove the first substring found; otherwise, remove all !  (non-overlapping) occurrences found. <br> !  Default is false. tCharAlloc :: cStrOut !! output string END FUNCTION RemoveSubstringProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE ReplaceSubstring !&#94; **Function Interface**: ReplaceSubstring <br> !  **Purpose**:  To replace all occurrences of the original substring found !                in the given character string with the new substring based !                on specified input. <br> !  **Usage**: <br> !   --->    OutStr = ReplaceSubstring(InStr, OldSub, NewSub) <br> !   --->    OutStr = ReplaceSubstring(InStr, NewSub, OldLen, OldCount, OldPos) MODULE FUNCTION ReplaceSubstring ( cStrIn , oStr , nStr ) RESULT ( cStrOut ) !&#94; To replace all occurrences of the original substring found in the given !  character string with the new substring. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: oStr !! original (old) substring tCharStar , INTENT ( IN ) :: nStr !! new substring tCharAlloc :: cStrOut !! output character string END FUNCTION ReplaceSubstring ! --------------------------------------------------------------------- RECURSIVE MODULE FUNCTION ReplaceSubstringKnownPos ( cStrIn , nStr , oLen , oCount , oPos ) RESULT ( cStrOut ) !&#94; To replace all occurrences of the original substring found in the given !  character string with the new substring by providing length, number of !  occurrences and position(s) of first character of original substring. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: nStr !! new substring tIndex , INTENT ( IN ) :: oLen !! length of original substring tIndex , INTENT ( IN ) :: oCount !! number of occurrences of original substring tIndex , INTENT ( IN ) :: oPos ( oCount ) !! position(s) of first character of original substring tCharAlloc :: cStrOut !! output string END FUNCTION ReplaceSubstringKnownPos ! --------------------------------------------------------------------- END INTERFACE INTERFACE ReplaceSubstringProtect !&#94; **Function Interface**: ReplaceSubstringProtect <br> !  **Purpose**:  To replace all occurrences of the original substring found !                in unprotected regions of the given character string with !                the new substring. <br> !  **Usage**: <br> !   --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub) <br> !   --->    OutStr = ReplaceSubstringProtect(InStr, OldSub, NewSub, ExclMrk=.FALSE.) RECURSIVE MODULE FUNCTION ReplaceSubstringProtect ( cStrIn , oStr , nStr , ExclMrk ) RESULT ( cStrOut ) !&#94; To replace all occurrences of the original substring found in unprotected !  regions of the given character string with the new substring. <br> !  See the <a href=\"../module/mbase_chrstr.html#interface-findprotectedregions\"> !  FindProtectedRegions</a> routine for explanations regarding the protected !  region(s). tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: oStr !! original (old) substring tCharStar , INTENT ( IN ) :: nStr !! new substring tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. tCharAlloc :: cStrOut !! output character string END FUNCTION ReplaceSubstringProtect ! --------------------------------------------------------------------- END INTERFACE INTERFACE ReplaceSubstringRecursive !&#94; **Function Interface**: ReplaceSubstringRecursive <br> !  **Purpose**:  To replace all occurrences of the original substring found !                in the given character string with the new substring in !                a recursive way. <br> !  **Usage**: <br> !   --->    OutStr = ReplaceSubstringRecursive(InStr, OldSub, NewSub) <br> !  **Example**: <br> !   *Input*: cStrIn = 'abbbbb', oStr = 'ab', nStr = 'a' <br> !   *Output* - non-recursive: cStrOut = 'abbbb' <br> !   *Output* - recursive: cStrOut = 'ab' MODULE FUNCTION ReplaceSubstringRecursive ( cStrIn , oStr , nStr ) RESULT ( cStrOut ) !&#94; To replace all occurrences of the original substring found in the given !  character string with the new substring in a recursive way. tCharStar , INTENT ( IN ) :: cStrIn !! input string tCharStar , INTENT ( IN ) :: oStr !! original (old) substring tCharStar , INTENT ( IN ) :: nStr !! new substring tCharAlloc :: cStrOut !! output string END FUNCTION ReplaceSubstringRecursive ! --------------------------------------------------------------------- END INTERFACE INTERFACE Partition !&#94; **Subroutine Interface**: Partition <br> !  **Purpose**:  To partition a character string into two substrings by a !                separator (single character or a multiple-character string). !                The partition occurs at the first occurrence of the separator !                found. <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL Partition(cStr, SepSub, bStr, aStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid <br> !   ! separator.  Also, search the first separator from the back. <br> !   --->    CALL Partition(cStr, SepSet, bStr, aStr, SepChr, Back=.TRUE.) <br> MODULE SUBROUTINE PartitionSepSub ( cStr , SepSub , bStr , aStr , Back ) !&#94; To partition a character string into two substrings where the specified !  separator is a multiple-character string.  The partition occurs at the !  first occurrence of the separator found. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSub !! multiple-character separator tCharAlloc , INTENT ( OUT ) :: bStr !! substring before the separator found tCharAlloc , INTENT ( OUT ) :: aStr !! substring after the separator found tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; flag indicating whether to search the separator from the back or not. <br> !  - True: search the separator from the back. <br> !  - False: search the separator from the front. <br> !  Default is false. END SUBROUTINE PartitionSepSub ! --------------------------------------------------------------------- MODULE SUBROUTINE PartitionSepChr ( cStr , SepSet , bStr , aStr , SepChr , Back ) !&#94; To partition a character string into two substrings where the separator !  is a single character (any character in the specified set of characters). !  The partition occurs at the first occurrence of the separator found. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSet !! set of characters representing valid separators tCharAlloc , INTENT ( OUT ) :: bStr !! substring before the separator found tCharAlloc , INTENT ( OUT ) :: aStr !! substring after the separator found tChar , INTENT ( OUT ) :: SepChr !! the separator found tLogical , OPTIONAL , INTENT ( IN ) :: Back !&#94; flag indicating whether to search the separator from the back or not. <br> !  - True: search the separator from the back. <br> !  - False: search the separator from the front. <br> !  Default is false. END SUBROUTINE PartitionSepChr ! --------------------------------------------------------------------- END INTERFACE INTERFACE Split !&#94; **Subroutine Interface**: Split <br> !  **Purpose**:  To split a character string into multiple substrings by a !                separator (single character or a multiple-character string). <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL Split(cStr, SepSub, qStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid separator. <br> !   --->    CALL Split(cStr, SepSet, qStr, SepChr) <br> MODULE SUBROUTINE SplitSepSub ( cStr , SepSub , qStr ) !&#94; To split a character string into multiple substrings where the specified !  separator is a multiple-character string. tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSub !! multiple-character separator TYPE ( QueueChar ), INTENT ( OUT ) :: qStr !! queue of substrings END SUBROUTINE SplitSepSub ! --------------------------------------------------------------------- MODULE SUBROUTINE SplitSepChr ( cStr , SepSet , qStr , SepChr ) !&#94; To split a character string into multiple substrings where the separator !  is a single character (any character in the specified set of characters). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSet !! set of characters representing valid separators TYPE ( QueueChar ), INTENT ( OUT ) :: qStr !! queue of substrings tChar , ALLOCATABLE , INTENT ( OUT ) :: SepChr (:) !! separators found END SUBROUTINE SplitSepChr ! --------------------------------------------------------------------- END INTERFACE INTERFACE SplitProtect !&#94; **Subroutine Interface**: SplitProtect <br> !  **Purpose**:  To split a character string into multiple substrings by a !                separator (single character or a multiple-character string) !                found in unprotected region(s). <br> !  **Usage**: <br> !   ! *SepSub* is a multiple-character string separator. <br> !   --->    CALL SplitProtect(cStr, SepSub, qStr) <br> !   ! *SepSet* is a set of characters where a character in the set is a valid separator. <br> !   --->    CALL SplitProtect(cStr, SepSet, qStr, SepChr) <br> !   ! The exclamation mark is NOT used to define the protected regions. <br> !   --->    CALL SplitProtect(cStr, SepSub, qStr, ExclMrk=.FALSE.) <br> MODULE SUBROUTINE SplitSepSubProtect ( cStr , SepSub , qStr , ExclMrk ) !&#94; To split a character string into multiple substrings where the specified !  separator is a multiple-character string found in unprotected region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSub !! multiple-character separator TYPE ( QueueChar ), INTENT ( OUT ) :: qStr !! queue of substrings tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. END SUBROUTINE SplitSepSubProtect ! --------------------------------------------------------------------- MODULE SUBROUTINE SplitSepChrProtect ( cStr , SepSet , qStr , SepChr , ExclMrk ) !&#94; To split a character string into multiple substrings where the separator !  is a single character (any character in the specified set of characters) !  found in unprotected region(s). tCharStar , INTENT ( IN ) :: cStr !! character string tCharStar , INTENT ( IN ) :: SepSet !! set of characters representing valid separators TYPE ( QueueChar ), INTENT ( OUT ) :: qStr !! queue of substrings tChar , ALLOCATABLE , INTENT ( OUT ) :: SepChr (:) !! separators found tLogical , OPTIONAL , INTENT ( IN ) :: ExclMrk !&#94; flag indicating whether the exclamation is used to define a protected !  region or not. <br> !  - If true, both the exclamation mark and quotes are used. <br> !  - If false, only quotes are used. <br> !  Default is true. END SUBROUTINE SplitSepChrProtect ! --------------------------------------------------------------------- END INTERFACE ! Private Interface INTERFACE MODULE FUNCTION ReplaceProtectedRegionsWithValidCharacter ( cStrIn , ChrSet , nRegion , lPos , rPos ) RESULT ( cStrOut ) tCharStar , INTENT ( IN ) :: cStrIn tCharStar , INTENT ( IN ) :: ChrSet tIndex , INTENT ( IN ) :: nRegion tIndex , INTENT ( IN ) :: lPos ( nRegion ) tIndex , INTENT ( IN ) :: rPos ( nRegion ) tCharAlloc :: cStrOut END FUNCTION ReplaceProtectedRegionsWithValidCharacter ! --------------------------------------------------------------------- END INTERFACE CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): END MODULE MBase_ChrStr !******************************************************************************","tags":"","loc":"sourcefile\\mbase_chrstr.f90.html"},{"title":"MClass_PatternFinder.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PatternFinder !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PatternFinder* type and its related helper types and routines. !   The *PatternFinder* type is a string type that provides various efficient algorithms for !   a *substring searching* operation.  The *substring searching* is a fundamental string !   operation where given a *text* string of length N and a *pattern* string of length M, !   find an occurrence of the *pattern* within the *text*.  <br> !   Available searching algorithms include:  <br> !   - *BruteForce*: a simple basic searching algorithm [1, 6], <br> !   - *BoyerMoore*: a searching algorithm by Boyer and Mooore [1, 6], <br> !   - *KMP*: a searching algorithm by Knuth, Morris and Pratt [1, 6], <br> !   - *KMPlus*: an optimized version of *KMP* algorithm [1, 6], <br> !   - *RabinKarp*: a searching algorithm by Rabin and Karp [1, 6], <br> !   - *Horspool*: an improved version of *BoyerMoore* algorithm by Horspool [2, 7], <br> !   - *Raita*: an improved version of *Horspool* algorithm by Raita [3, 7], <br> !   - *Sunday*: an improved version of *BoyerMoore* algorithm by Sunday [4], and <br> !   - *BNDM*: a Backwards Non-deterministic DAWG (Directed acyclic word graph) !      Matching algorithm by Gonzalo Navarro and Mathieu Raffinot [5, 7]. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !   [2] <a href=\"https://webhome.cs.uvic.ca/~nigelh/Publications/stringsearch.pdf\"> !       R.N. Horspool. 1980. Practical Fast Searching in Strings. Software-Practice and !       Experience, vol. 10, pp. 501-506. </a> <br> !   [3] <a href=\"https://www.inf.unioeste.br/~adair/ED/Artigos/Tunning%20Boyer-Moore-Horspool%20String%20Search%20Algorithm%20-%20Raita.pdf\"> !       T. Raita. 1992. Tuning the Boyer-Moore-Horspool string searching algorithm. !       Software-Practice and Experience, vol. 22(10), pp. 879-884.</a> <br> !   [4] <a href=\"https://dl.acm.org/doi/10.1145/79173.79184\">D.M. Sunday. 1990.  A very fast !       substring search algorithm.  Communications of the ACM, vol. 33(8), pp. 132-142. </a> <br> !   [5] <a href=\"https://www.semanticscholar.org/paper/A-Bit-Parallel-Approach-to-Suffix-Automata%3A-Fast-Navarro-Raffinot/75cb2a611f737c296a576d396334bc6298982e7a\"> !       G. Navarro and M. Raffinot. 1998. A Bit-Parallel Approach to Suffix Automata: !       Fast Extended String Matching. Combinatorial Pattern Matching, pp. 14-33. </a> <br> !   [6] <a href=\"https://algs4.cs.princeton.edu/home/\">R. Sedgewick and K. Wayne. !       Algorithms, 4th Edition, Online version. </a> <br> !   [7] <a href=\"https://github.com/johannburkard/StringSearch\">StringSearch: !       High-performance pattern matching algorithms in Java. </a> <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_LOC , C_F_POINTER , C_PTR , C_NULL_PTR USE MBase_Common USE MBase_CharUtil , ONLY : IsLetter => Is_Character_Letter , & ToUpper => ToUpperCase , & ToLower => ToLowerCase USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_MathUtil , ONLY : IsPrime USE MBase_SInt128 USE MBase_ErrHandlers USE MClass_Sfc64RNG IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PatternFinder PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../MacroDef/Macro - Util Definitions.f90\" #define     tSInt128    TYPE(SInt128) !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_PatternFinder' ! radix (number of characters in the alphabet set) for extended-ASCII alphabet tIndex , PARAMETER :: Radix = 256_kIndex ! Parameters for searching algorithms tSInt32 , PUBLIC , PARAMETER :: BruteForce = 0 tSInt32 , PUBLIC , PARAMETER :: BoyerMoore = 1 tSInt32 , PUBLIC , PARAMETER :: KMPlus = 2 tSInt32 , PUBLIC , PARAMETER :: KMP = 3 tSInt32 , PUBLIC , PARAMETER :: RabinKarp = 4 tSInt32 , PUBLIC , PARAMETER :: Horspool = 5 tSInt32 , PUBLIC , PARAMETER :: Raita = 6 tSInt32 , PUBLIC , PARAMETER :: Sunday = 7 tSInt32 , PUBLIC , PARAMETER :: BNDM = 8 !** DERIVED TYPE DEFINITIONS !> The *BasePattern* type is a base type used to store information relating !  processed pattern.  This is a private helper type. TYPE BasePattern tIndex :: M ! length of the pattern END TYPE BasePattern !> The *RabinKarpPat* type is a pattern type storing processed information for !  the Rabin-Karp algorithm.  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: RabinKarpPat tIndex :: Hash ! hash code of the pattern tSInt64 :: Q ! a large prime, small enough to avoid long overflow tIndex :: R ! radix tSInt64 :: RM ! MOD(R**(M-1), Q) END TYPE RabinKarpPat !> The *KMPPat* type is a pattern type storing processed information for the !  Knuth-Morris-Pratt algorithm.  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: KMPPat tIndex :: R ! radix tIndex , ALLOCATABLE :: DFA (:,:) ! deterministic finite automaton END TYPE KMPPat !> The *KMPlusPat* type is a pattern type storing processed information for an optimized !  version of the Knuth-Morris-Pratt algorithm.  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: KMPlusPat tIndex , ALLOCATABLE :: Next (:) ! non-deterministic finite automaton END TYPE KMPlusPat !> The *BoyerMoorePat* type is a pattern type storing processed information for the !  Boyer-Moore algorithm.  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: BoyerMoorePat tIndex :: R ! radix tIndex :: Right ( 0 : Radix - 1 ) ! the bad character skip array END TYPE BoyerMoorePat !> The *ChrIntMap* type is a pattern type storing processed information for the !  Horspool and Raita algorithms.  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: ChrIntMap tIndex :: Lowest ! ASCII code of lowest character tIndex :: DefVal ! default value tIndex , ALLOCATABLE :: Arr (:) ! skip array CONTAINS PROCEDURE :: Create => ChrIntMap_Create PROCEDURE :: Construct => ChrIntMap_Construct PROCEDURE :: Set => ChrIntMap_Set PROCEDURE :: Get => ChrIntMap_Get END TYPE ChrIntMap !> The *BNDMPatLen64* type is a pattern type storing processed information for the !  BNDM algorithm(s).  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: BNDMPatLen64 tIndex :: Lowest ! ASCII code of lowest character tSInt64 :: DefVal ! default value tSInt64 , ALLOCATABLE :: Arr (:) ! skip array CONTAINS PROCEDURE :: Create => BNDMPatLen64_Create PROCEDURE :: Construct => BNDMPatLen64_Construct PROCEDURE :: Set => BNDMPatLen64_Set PROCEDURE :: Get => BNDMPatLen64_Get END TYPE BNDMPatLen64 !> The *BNDMPatLen128* type is a pattern type storing processed information for the !  BNDM algorithm(s).  This is a private helper type. TYPE , EXTENDS ( BasePattern ) :: BNDMPatLen128 tIndex :: Lowest ! ASCII code of lowest character tSInt128 :: DefVal ! default value tSInt128 , ALLOCATABLE :: Arr (:) ! skip array CONTAINS PROCEDURE :: Create => BNDMPatLen128_Create PROCEDURE :: Construct => BNDMPatLen128_Construct PROCEDURE :: Set => BNDMPatLen128_Set PROCEDURE :: Get => BNDMPatLen128_Get END TYPE BNDMPatLen128 !> The *PatternFinder* type is a string type that provides various efficient !  algorithms for a *substring searching* operation. TYPE PatternFinder PRIVATE !% searching algorithm tSInt32 :: Algo = BoyerMoore !% current starting (one-based) index of the pattern tIndex :: Index = 0_kIndex !% string representing the pattern tChar , POINTER :: PatTxt (:) => NULL () !% string representing the searched text tCharLen (:), POINTER :: InpTxt => NULL () !% pattern object containing processed information CLASS ( BasePattern ), ALLOCATABLE :: PatObj CONTAINS !> **Type-Bound Subroutine**: SetPattern <br> !  **Purpose**:  To process the specified pattern based on the specified searching algorithm. <br> !  **Usage**: <br> !   --->    CALL Finder%SetPattern(Pattern, SearchAlgo) <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, WildCard='.') <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, Insensitive=.TRUE.) <br> !   --->    CALL Finder%SetPattern(Pattern, BNDM, .TRUE., '*') <br> !  **Note**: <br> !   1. If the length of the pattern is zero, the method just returns without doing anything. <br> !   2. The optional *Insensitive* and *WildCard* arguments are applicable for the BNDM method only. <br> PROCEDURE :: SetPattern => PatternFinder_SetPattern !> **Type-Bound Function**: FindIndex <br> !  **Purpose**:  To find the first occurrence of the (previously specified) *pattern* within the !       specified *text*.  Return an (one-based) index representing the position of the first !       character of the occurrence found.  Return zero if there is no such pattern found.  If the !       pattern has not yet been set, return one. <br> !  **Usage**: <br> !   ! start searching from the beginning of the text <br> !   --->    Index = Finder%FindIndex(Text) <br> !   ! start searching from the specified position (one-based) of the text <br> !   --->    Index = Finder%FindIndex(Text, StartPos) <br> PROCEDURE :: FindIndex => PatternFinder_FindIndex !> **Type-Bound Function**: FindNext <br> !  **Purpose**:  To find the next occurrence of the (previously specified) *pattern* within the !        (previously specified) *text*. <br> !  **Usage**: <br> !   --->    Index = Finder%FindNext() <br> !  **Note**: Must call the *SetPattern* and *FindIndex* methods before calling this method. <br> PROCEDURE :: FindNext => PatternFinder_FindNext !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To reset/clear all components of the *PatternFinder* object. <br> !  **Usage**: <br> !   --->    CALL Finder%Clear() <br> !  **Note**: If the length of the pattern is zero, the method just returns without doing anything. <br> PROCEDURE :: Clear => PatternFinder_Clear !% To perform finalization of the *PatternFinder* object. FINAL :: PatternFinder_Finalize END TYPE PatternFinder !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !-------------------------------------------------------------------------------------- !                           PatternFinder Procedures !-------------------------------------------------------------------------------------- SUBROUTINE PatternFinder_SetPattern ( Finder , Pattern , SearchAlgo , Insensitive , WildCard ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process the specified pattern based on the specified searching algorithm. !  If the length of the pattern is zero, just return without doing anything. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PatternFinder ), INTENT ( INOUT ) :: Finder !! 'PatternFinder' object tCharStar , TARGET , INTENT ( IN ) :: Pattern !! the pattern tIndex , INTENT ( IN ) :: SearchAlgo !! search algorithm tLogical , OPTIONAL , INTENT ( IN ) :: Insensitive !&#94; true if the pattern is case-insensitive; default is false; only applicable for BNDM algorithm. tChar , OPTIONAL , INTENT ( IN ) :: WildCard !&#94; a wild card character; default is \"?\"; only applicable for BNDM algorithm. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( C_PTR ) :: CPtr ! C pointer to the pattern string ! FLOW IF ( LEN ( Pattern ) < 1 ) THEN CALL Handle_ErrLevel ( 'PatternFinder_SetPattern' , ModName , ErrSevere , & 'The pattern length of zero is NOT allowed.' ) RETURN ELSEIF ( SearchAlgo == BNDM ) THEN IF ( LEN ( Pattern ) > 128 ) THEN CALL Handle_ErrLevel ( 'PatternFinder_SetPattern' , ModName , ErrSevere , & 'The pattern length is limited to 128 for the \"BNDM\" algorithm.' ) RETURN END IF END IF ! get a C pointer to input CPtr = C_LOC ( Pattern ) ! associate a Fortran data pointer with the C pointer CALL C_F_POINTER ( cPtr , Finder % PatTxt , [ LEN ( Pattern )]) IF ( ALLOCATED ( Finder % PatObj )) DEALLOCATE ( Finder % PatObj ) Finder % Algo = SearchAlgo SELECT CASE ( SearchAlgo ) CASE ( BNDM ) IF ( LEN ( Pattern ) <= 64 ) THEN ALLOCATE ( BNDMPatLen64 :: Finder % PatObj ) ELSE ALLOCATE ( BNDMPatLen128 :: Finder % PatObj ) END IF SELECT TYPE ( PatObj => Finder % PatObj ) TYPE IS ( BNDMPatLen64 ) CALL BNDMLen64_Process ( PatObj , Finder % PatTxt , Insensitive , WildCard ) TYPE IS ( BNDMPatLen128 ) CALL BNDMLen128_Process ( PatObj , Finder % PatTxt , Insensitive , WildCard ) END SELECT CASE ( Horspool , Raita , Sunday ) ALLOCATE ( ChrIntMap :: Finder % PatObj ) IF ( SearchAlgo /= Sunday ) THEN CALL HorspoolRaita_Process ( Finder % PatObj , Finder % PatTxt ) ELSE CALL Sunday_Process ( Finder % PatObj , Finder % PatTxt ) END IF CASE ( BoyerMoore ) ALLOCATE ( BoyerMoorePat :: Finder % PatObj ) CALL BoyerMoore_Process ( Finder % PatObj , Finder % PatTxt ) CASE ( KMPlus ) ALLOCATE ( KMPlusPat :: Finder % PatObj ) CALL KMPlus_Process ( Finder % PatObj , Finder % PatTxt ) CASE ( KMP ) ALLOCATE ( KMPPat :: Finder % PatObj ) CALL KMP_Process ( Finder % PatObj , Finder % PatTxt ) CASE ( RabinKarp ) ALLOCATE ( RabinKarpPat :: Finder % PatObj ) CALL RabinKarp_Process ( Finder % PatObj , Finder % PatTxt ) CASE ( BruteForce ) ALLOCATE ( BasePattern :: Finder % PatObj ) CALL BruteForce_Process ( Finder % PatObj , Finder % PatTxt ) CASE DEFAULT ALLOCATE ( BoyerMoorePat :: Finder % PatObj ) CALL BoyerMoore_Process ( Finder % PatObj , Finder % PatTxt ) Finder % Algo = BoyerMoore END SELECT ! nullify pointers cPtr = C_NULL_PTR RETURN END SUBROUTINE PatternFinder_SetPattern !****************************************************************************** FUNCTION PatternFinder_FindIndex ( Finder , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the one-based index of the first occurrence of the pattern string !  in the text string.  Return zero if there is no such pattern found.  If the !  pattern has not yet been set, return one. <br> !  Note: The unset pattern is equivalent to the zero-length pattern. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PatternFinder ), INTENT ( INOUT ) :: Finder !! 'PatternFinder' object tCharStar , TARGET , INTENT ( IN ) :: Text !! the text string tIndex , OPTIONAL , INTENT ( IN ) :: StartID !&#94; (one-based) starting index of the text string; !  if not present, starting at 1. tIndex :: Index !&#94; (one-based) index of the first occurrence; !  if pattern not found, return 0. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar , POINTER :: InpTxt (:) => NULL () ! F pointer to the input string TYPE ( C_PTR ) :: CPtr ! C pointer to the input string tIndex :: BeginID ! zero-based index ! FLOW ! set zero-based starting index SET_OPTION ( BeginID , 1_kIndex , StartID ) BeginID = BeginID - 1_kIndex ! check validity of all input IF ((. NOT . ASSOCIATED ( Finder % PatTxt )). OR .(. NOT . ALLOCATED ( Finder % PatObj ))) THEN Index = 1_kIndex CALL Handle_ErrLevel ( 'PatternFinder_FindIndex' , ModName , ErrWarning , & 'The pattern has not yet been set.' ) RETURN ELSEIF (( BeginID < 0_kIndex ). OR .( BeginID == LEN ( Text , KIND = kIndex ))) THEN Index = 0_kIndex CALL Handle_ErrLevel ( 'PatternFinder_FindIndex' , ModName , ErrWarning , & 'The starting index is out of the applicable range.' ) RETURN ELSEIF ( LEN ( Text , KIND = kIndex ) < SIZE ( Finder % PatTxt , KIND = kIndex )) THEN Index = 0_kIndex CALL Handle_ErrLevel ( 'PatternFinder_FindIndex' , ModName , ErrWarning , & 'The text length is less than the pattern length.' ) RETURN ELSEIF (( LEN ( Text , KIND = kIndex ) - BeginID ) < SIZE ( Finder % PatTxt , KIND = kIndex )) THEN ! do not need to report error since all input considered valid Index = 0_kIndex RETURN END IF ! get a C pointer to input CPtr = C_LOC ( Text ) ! associate a Fortran data pointer with the C pointer CALL C_F_POINTER ( cPtr , InpTxt , [ LEN ( Text )]) ! set pointer for FindNext Finder % InpTxt => Text ! find pattern SELECT TYPE ( PatObj => Finder % PatObj ) TYPE IS ( BNDMPatLen64 ) Index = BNDM_Find ( PatObj , InpTxt , BeginID ) TYPE IS ( BNDMPatLen128 ) Index = BNDM_Find ( PatObj , InpTxt , BeginID ) TYPE IS ( ChrIntMap ) SELECT CASE ( Finder % Algo ) CASE ( Horspool ) Index = Horspool_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) CASE ( Raita ) Index = Raita_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) CASE ( Sunday ) Index = Sunday_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) END SELECT TYPE IS ( BoyerMoorePat ) Index = BoyerMoore_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) TYPE IS ( KMPlusPat ) Index = KMPlus_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) TYPE IS ( KMPPat ) Index = KMP_Find ( PatObj , InpTxt , BeginID ) TYPE IS ( RabinKarpPat ) Index = RabinKarp_Find ( PatObj , Finder % PatTxt , InpTxt ( BeginID + 1 :)) TYPE IS ( BasePattern ) Index = BruteForce_Find ( PatObj , Finder % PatTxt , InpTxt , BeginID ) END SELECT ! post-process the index Index = Index + 1_kIndex IF ( Index > LEN ( Text , KIND = kIndex )) Index = 0_kIndex Finder % Index = Index ! nullify pointers cPtr = C_NULL_PTR NULLIFY ( InpTxt ) RETURN END FUNCTION PatternFinder_FindIndex !****************************************************************************** FUNCTION PatternFinder_FindNext ( Finder ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the one-based index of the next occurrence of the pattern string !  in the text string.  Return zero if there is no more pattern found.  This !  routine assumes that the *SetPattern* and the *FindIndex* methods have !  already been called.  If that is not true, return -1. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PatternFinder ), INTENT ( INOUT ) :: Finder !! 'PatternFinder' object tIndex :: Index !&#94; (one-based) index of the first occurrence; !  if pattern not found, return 0. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check validity of all input IF ((. NOT . ASSOCIATED ( Finder % InpTxt )). OR .(. NOT . ASSOCIATED ( Finder % PatTxt )) & . OR .(. NOT . ALLOCATED ( Finder % PatObj ))) THEN Index = - 1_kIndex CALL Handle_ErrLevel ( 'PatternFinder_FindNext' , ModName , ErrWarning , & 'Must call the \"SetPattern\" and the \"FindIndex\" methods first.' ) RETURN ELSEIF ( Finder % Index == 0_kIndex ) THEN Index = 0_kIndex RETURN END IF Index = Finder % FindIndex ( Finder % InpTxt , Finder % Index ) RETURN END FUNCTION PatternFinder_FindNext !****************************************************************************** SUBROUTINE PatternFinder_Clear ( Finder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the 'PatternFinder' object. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PatternFinder ), INTENT ( INOUT ) :: Finder !! 'PatternFinder' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Finder % Algo = BoyerMoore Finder % Index = 0_kIndex NULLIFY ( Finder % PatTxt ) NULLIFY ( Finder % InpTxt ) IF ( ALLOCATED ( Finder % PatObj )) DEALLOCATE ( Finder % PatObj ) RETURN END SUBROUTINE PatternFinder_Clear !****************************************************************************** SUBROUTINE PatternFinder_Finalize ( Finder ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PatternFinder ), INTENT ( INOUT ) :: Finder !! 'PatternFinder' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Finder % Clear () RETURN END SUBROUTINE PatternFinder_Finalize !-------------------------------------------------------------------------------------- !                               Engine Procedures !-------------------------------------------------------------------------------------- SUBROUTINE BNDMLen64_Process ( PatObj , Pattern , Insensitive , WildCard ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for BNDM algorithms where pattern !  length is less than or equal to 64. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen64 ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tLogical , OPTIONAL , INTENT ( IN ) :: Insensitive !&#94; true if the pattern is case-insensitive; default is false; only applicable for BNDM algorithm. tChar , OPTIONAL , INTENT ( IN ) :: WildCard !&#94; a wild card character; default is \"?\"; only applicable for BNDM algorithm. !** SUBROUTINE PARAMETER DECLARATIONS: !% a wild card for single character tCharParam :: WildCardDeflt = '?' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , I tChar :: WC ! wild card character tLogical :: IsCaseInsensitive ! true if case-insensitive tSInt64 :: J , Val ! FLOW SET_OPTION ( WC , WildCardDeflt , WildCard ) SET_OPTION ( IsCaseInsensitive , FalseVal , Insensitive ) N = SIZE ( Pattern , KIND = kIndex ) ! find default value J = 0_kInt64 DO I = 0_kIndex , N - 1_kIndex IF ( Pattern ( I ) == WC ) THEN J = IOR ( J , SHIFTL ( 1_kInt64 , N - I - 1_kIndex )) END IF END DO IF (. NOT . IsCaseInsensitive ) THEN ! ----- case-sensitive ----- ! create character-integer mapping object CALL PatObj % Create ( Pattern , N , J ) PatObj % M = N ! set character-integer mapping J = 1_kInt64 DO I = PatObj % M - 1_kIndex , 0_kIndex , - 1_kIndex Val = IOR ( PatObj % Get ( Pattern ( I )), J ) CALL PatObj % Set ( Pattern ( I ), Val ) J = SHIFTL ( J , 1 ) END DO ELSE ! ----- case-insensitive ----- BLOCK tIndex :: MinVal , MaxVal , I tChar :: P , T ! execution ! compute minval and maxval CALL MinMax_Insensitive ( Pattern , MinVal , MaxVal ) ! create character-integer mapping object CALL PatObj % Construct ( MaxVal - MinVal + 1_kIndex , MinVal , J ) PatObj % M = N ! set character-integer mapping J = 1_kInt64 DO I = PatObj % M - 1_kIndex , 0_kIndex , - 1_kIndex P = Pattern ( I ) IF ( IsLetter ( P )) THEN T = ToLower ( P ) Val = IOR ( PatObj % Get ( T ), J ) CALL PatObj % Set ( T , Val ) T = ToUpper ( P ) Val = IOR ( PatObj % Get ( T ), J ) CALL PatObj % Set ( T , Val ) ELSE Val = IOR ( PatObj % Get ( P ), J ) CALL PatObj % Set ( P , Val ) END IF J = SHIFTL ( J , 1 ) END DO END BLOCK END IF RETURN END SUBROUTINE BNDMLen64_Process !****************************************************************************** SUBROUTINE BNDMLen128_Process ( PatObj , Pattern , Insensitive , WildCard ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for BNDM algorithms where pattern !  length is less than or equal to 128. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen128 ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tLogical , OPTIONAL , INTENT ( IN ) :: Insensitive !&#94; true if the pattern is case-insensitive; default is false; only applicable for BNDM algorithm. tChar , OPTIONAL , INTENT ( IN ) :: WildCard !&#94; a wild card character; default is \"?\"; only applicable for BNDM algorithm. !** SUBROUTINE PARAMETER DECLARATIONS: !% a wild card for single character tCharParam :: WildCardDeflt = '?' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , I tChar :: WC ! wild card character tLogical :: IsCaseInsensitive ! true if case-insensitive tSInt128 :: J , Val ! FLOW SET_OPTION ( WC , WildCardDeflt , WildCard ) SET_OPTION ( IsCaseInsensitive , FalseVal , Insensitive ) N = SIZE ( Pattern , KIND = kIndex ) ! find default value J = ZeroI128 DO I = 0_kIndex , N - 1_kIndex IF ( Pattern ( I ) == WC ) THEN J = IOR ( J , SHIFTL ( OneI128 , ToInt32 ( N - I - 1_kIndex ))) END IF END DO IF (. NOT . IsCaseInsensitive ) THEN ! ----- case-sensitive ----- ! create character-integer mapping object CALL PatObj % Create ( Pattern , N , J ) PatObj % M = N ! set character-integer mapping J = OneI128 DO I = PatObj % M - 1_kIndex , 0_kIndex , - 1_kIndex Val = IOR ( PatObj % Get ( Pattern ( I )), J ) CALL PatObj % Set ( Pattern ( I ), Val ) J = ShiftLOnce ( J ) END DO ELSE ! ----- case-insensitive ----- BLOCK tIndex :: MinVal , MaxVal , I tChar :: P , T ! execution ! compute minval and maxval CALL MinMax_Insensitive ( Pattern , MinVal , MaxVal ) ! create character-integer mapping object CALL PatObj % Construct ( MaxVal - MinVal + 1_kIndex , MinVal , J ) PatObj % M = N ! set character-integer mapping J = OneI128 DO I = PatObj % M - 1_kIndex , 0_kIndex , - 1_kIndex P = Pattern ( I ) IF ( IsLetter ( P )) THEN T = ToLower ( P ) Val = IOR ( PatObj % Get ( T ), J ) CALL PatObj % Set ( T , Val ) T = ToUpper ( P ) Val = IOR ( PatObj % Get ( T ), J ) CALL PatObj % Set ( T , Val ) ELSE Val = IOR ( PatObj % Get ( P ), J ) CALL PatObj % Set ( P , Val ) END IF J = ShiftLOnce ( J ) END DO END BLOCK END IF RETURN END SUBROUTINE BNDMLen128_Process !****************************************************************************** FUNCTION BNDM_Find ( PatObj , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Pos , J , N , Last ! FLOW N = SIZE ( Text , KIND = kIndex ) Pos = StartID SELECT TYPE ( Pat => PatObj ) TYPE IS ( BNDMPatLen64 ) BLOCK tSInt64 :: D OutLoop : DO WHILE ( Pos <= N - 1_kIndex ) J = Pat % M - 1_kIndex Last = Pat % M D = - 1_kInt64 InLoop : DO WHILE ( D /= 0_kInt64 ) D = IAND ( D , Pat % Get ( Text ( Pos + J ))) IF ( D /= 0_kInt64 ) THEN IF ( J == 0_kIndex ) THEN ! pattern found Index = Pos RETURN END IF Last = J END IF J = J - 1_kIndex D = SHIFTL ( D , 1 ) END DO InLoop Pos = Pos + Last END DO OutLoop ! pattern not found Index = N END BLOCK TYPE IS ( BNDMPatLen128 ) BLOCK tSInt128 :: D OutLoop : DO WHILE ( Pos <= N - 1_kIndex ) J = Pat % M - 1_kIndex Last = Pat % M D = - OneI128 InLoop : DO WHILE ( D /= ZeroI128 ) D = IAND ( D , Pat % Get ( Text ( Pos + J ))) IF ( D /= ZeroI128 ) THEN IF ( J == 0_kIndex ) THEN ! pattern found Index = Pos RETURN END IF Last = J END IF J = J - 1_kIndex D = ShiftLOnce ( D ) END DO InLoop Pos = Pos + Last END DO OutLoop ! pattern not found Index = N END BLOCK END SELECT RETURN END FUNCTION BNDM_Find !****************************************************************************** SUBROUTINE HorspoolRaita_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for Horspool and Raita algorithms. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , I ! FLOW N = SIZE ( Pattern , KIND = kIndex ) PatObj % M = N SELECT TYPE ( Pat => PatObj ) TYPE IS ( ChrIntMap ) IF ( LEN ( Pattern ) > 2 ) THEN CALL Pat % Create ( Pattern , N , N ) Pat % M = N ! this statement must exists since the create method will make Pat%M undefined N = N - 1_kIndex DO I = 0_kIndex , N CALL Pat % Set ( Pattern ( I ), N - I ) END DO END IF END SELECT RETURN END SUBROUTINE HorspoolRaita_Process !****************************************************************************** FUNCTION Horspool_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , K , TxtLen ! FLOW ! Unrolled fast paths for patterns of length 1 and 2 IF ( PatObj % M <= 2_kIndex ) THEN Index = Len2OrLess_Find ( PatObj , Pattern , Text , StartID ) RETURN END IF TxtLen = SIZE ( Text , KIND = kIndex ) ! for pattern length of 3 and more SELECT TYPE ( Pat => PatObj ) TYPE IS ( ChrIntMap ) BLOCK tIndex :: LenM1 ! execution LenM1 = Pat % M - 1_kIndex K = LenM1 OutLoop : DO WHILE ( K < TxtLen ) J = LenM1 I = K InLoop : DO WHILE (( J >= 0_kIndex ). AND .( Text ( I ) == Pattern ( J )). AND .( I >= StartID )) J = J - 1_kIndex I = I - 1_kIndex END DO InLoop IF ( J == - 1_kIndex ) THEN ! pattern found Index = I + 1_kIndex RETURN END IF K = K + Pat % Get ( Text ( K )) END DO OutLoop ! pattern not found Index = TxtLen END BLOCK END SELECT RETURN END FUNCTION Horspool_Find !****************************************************************************** FUNCTION Raita_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , K , TxtLen ! FLOW ! Unrolled fast paths for patterns of length 1 and 2 IF ( PatObj % M <= 2_kIndex ) THEN Index = Len2OrLess_Find ( PatObj , Pattern , Text , StartID ) RETURN END IF TxtLen = SIZE ( Text , KIND = kIndex ) ! for pattern length of 3 and more SELECT TYPE ( Pat => PatObj ) TYPE IS ( ChrIntMap ) BLOCK tIndex :: LenM1 , MM1 tChar :: Last , First ! execution LenM1 = Pat % M - 1_kIndex MM1 = LenM1 - 1_kIndex Last = Pattern ( LenM1 ) First = Pattern ( 0 ) I = LenM1 + StartID DO WHILE ( I < TxtLen ) IF (( Text ( I ) == Last ). AND .( Text ( I - LenM1 ) == First )) THEN K = I - 1_kIndex J = MM1 DO WHILE (( K > - 1_kIndex ). AND .( J > - 1_kIndex ). AND .( Text ( K ) == Pattern ( J ))) K = K - 1_kIndex J = J - 1_kIndex END DO IF ( J == - 1_kIndex ) THEN ! pattern found Index = K + 1_kIndex RETURN END IF END IF I = I + Pat % Get ( Text ( I )) END DO ! pattern not found Index = TxtLen END BLOCK END SELECT RETURN END FUNCTION Raita_Find !****************************************************************************** SUBROUTINE Sunday_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for Sunday algorithms. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , I ! FLOW N = SIZE ( Pattern , KIND = kIndex ) PatObj % M = N SELECT TYPE ( Pat => PatObj ) TYPE IS ( ChrIntMap ) IF ( LEN ( Pattern ) > 2 ) THEN CALL Pat % Create ( Pattern , N , N + 1_kIndex ) Pat % M = N ! this statement must exists since the create method will make Pat%M undefined N = N - 1_kIndex DO I = 0_kIndex , N CALL Pat % Set ( Pattern ( I ), N ) END DO END IF END SELECT RETURN END SUBROUTINE Sunday_Process !****************************************************************************** FUNCTION Sunday_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , K , TxtLen ! FLOW ! Unrolled fast paths for patterns of length 1 and 2 IF ( PatObj % M <= 2_kIndex ) THEN Index = Len2OrLess_Find ( PatObj , Pattern , Text , StartID ) RETURN END IF TxtLen = SIZE ( Text , KIND = kIndex ) ! for pattern length of 3 and more SELECT TYPE ( Pat => PatObj ) TYPE IS ( ChrIntMap ) BLOCK tIndex :: LenM1 ! execution LenM1 = Pat % M - 1_kIndex K = LenM1 OutLoop : DO WHILE ( K < TxtLen ) J = LenM1 I = K InLoop : DO WHILE (( J >= 0_kIndex ). AND .( Text ( I ) == Pattern ( J )). AND .( I >= StartID )) J = J - 1_kIndex I = I - 1_kIndex END DO InLoop IF ( J == - 1_kIndex ) THEN ! pattern found Index = I + 1_kIndex RETURN END IF K = K + 1_kIndex IF ( K >= TxtLen ) EXIT K = K + Pat % Get ( Text ( K )) END DO OutLoop ! pattern not found Index = TxtLen END BLOCK END SELECT RETURN END FUNCTION Sunday_Find !****************************************************************************** SUBROUTINE BoyerMoore_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for Boyer-Moore algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: J ! FLOW SELECT TYPE ( Pat => PatObj ) TYPE IS ( BoyerMoorePat ) Pat % M = SIZE ( Pattern , KIND = kIndex ) Pat % R = Radix ! position of rightmost occurrence of c in the pattern Pat % Right = - 1_kIndex DO J = 0_kIndex , Pat % M - 1_kIndex Pat % Right ( IACHAR ( Pattern ( J ))) = J END DO END SELECT RETURN END SUBROUTINE BoyerMoore_Process !****************************************************************************** FUNCTION BoyerMoore_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , N , Skip ! FLOW N = SIZE ( Text , KIND = kIndex ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( BoyerMoorePat ) I = StartID OutLoop : DO Skip = 0_kIndex InLoop : DO J = Pat % M - 1_kIndex , 0_kIndex , - 1_kIndex IF ( Pattern ( J ) /= Text ( I + J )) THEN Skip = MAX ( 1_kIndex , J - Pat % Right ( IACHAR ( Text ( I + J )))) EXIT InLoop END IF END DO InLoop IF ( Skip == 0_kIndex ) THEN ! pattern found Index = I RETURN END IF I = I + Skip IF ( I > N - Pat % M ) EXIT OutLoop END DO OutLoop ! pattern not found Index = N END SELECT RETURN END FUNCTION BoyerMoore_Find !****************************************************************************** SUBROUTINE KMPlus_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for optimized Knuth-Morris-Pratt algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J ! FLOW SELECT TYPE ( Pat => PatObj ) TYPE IS ( KMPlusPat ) Pat % M = SIZE ( Pattern , KIND = kIndex ) ALLOCATE ( Pat % Next ( 0 : Pat % M - 1 )) J = - 1_kIndex DO I = 0_kIndex , Pat % M - 1_kIndex IF ( I == 0_kIndex ) THEN Pat % Next ( I ) = - 1_kIndex ELSEIF ( Pattern ( I ) /= Pattern ( J )) THEN Pat % Next ( I ) = J ELSE Pat % Next ( I ) = Pat % Next ( J ) END IF DO WHILE (( J >= 0_kIndex ). AND .( Pattern ( I ) /= Pattern ( J ))) J = Pat % Next ( J ) END DO J = J + 1_kIndex END DO END SELECT RETURN END SUBROUTINE KMPlus_Process !****************************************************************************** FUNCTION KMPlus_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , N ! FLOW N = SIZE ( Text , KIND = kIndex ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( KMPlusPat ) ! simulate operation of NFA on text J = 0_kIndex DO I = StartID , N - 1_kIndex DO WHILE (( J >= 0_kIndex ). AND .( Text ( I ) /= Pattern ( J ))) J = Pat % Next ( J ) END DO J = J + 1_kIndex IF ( J == Pat % M ) EXIT END DO IF ( J == Pat % M ) THEN ! pattern found Index = I - Pat % M ELSE ! pattern not found Index = N END IF END SELECT RETURN END FUNCTION KMPlus_Find !****************************************************************************** SUBROUTINE KMP_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for Knuth-Morris-Pratt algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , K , X ! FLOW SELECT TYPE ( Pat => PatObj ) TYPE IS ( KMPPat ) Pat % M = SIZE ( Pattern , KIND = kIndex ) Pat % R = Radix ALLOCATE ( Pat % DFA ( 0 : Pat % M - 1 , 0 : Pat % R - 1 )) Pat % DFA ( 0 , IACHAR ( Pattern ( 0 ))) = 1_kIndex X = 0_kIndex DO J = 1_kIndex , Pat % M - 1_kIndex DO I = 0_kIndex , Pat % R - 1_kIndex Pat % DFA ( J , I ) = Pat % DFA ( X , I ) ! Copy mismatch cases END DO K = IACHAR ( Pattern ( J )) Pat % DFA ( J , K ) = J + 1_kIndex ! Set match case X = Pat % DFA ( X , K ) ! Update restart state END DO END SELECT RETURN END SUBROUTINE KMP_Process !****************************************************************************** FUNCTION KMP_Find ( PatObj , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , N ! FLOW N = SIZE ( Text , KIND = kIndex ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( KMPPat ) ! simulate operation of DFA on text J = 0_kIndex DO I = StartID , N - 1_kIndex J = Pat % DFA ( J , IACHAR ( Text ( I ))) J = J + 1_kIndex IF ( J == Pat % M ) EXIT END DO IF ( J == Pat % M ) THEN ! pattern found Index = I - Pat % M ELSE ! pattern not found Index = N END IF END SELECT RETURN END FUNCTION KMP_Find !****************************************************************************** SUBROUTINE RabinKarp_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for Rabin-Karp algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( Sfc64RNG ) :: RNG tSInt64 :: RandVal tIndex :: I ! FLOW CALL RNG % Initialize () RandVal = RNG % NextLong ( MAX_I32 + 1_kInt64 , MAX_I64 - MAX_I32 ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( RabinKarpPat ) Pat % M = SIZE ( Pattern , KIND = kIndex ) Pat % R = Radix Pat % Q = LongRandomPrime ( RandVal ) ! pre-compute MOD(R**(M-1), Q) for use in removing leading digit Pat % RM = 1_kInt64 DO I = 1_kIndex , Pat % M - 1_kIndex Pat % RM = MOD ( Pat % R * Pat % RM , Pat % Q ) END DO Pat % Hash = ComputeHash ( Pattern , Pat % M , Pat % R , Pat % Q ) END SELECT RETURN CONTAINS FUNCTION LongRandomPrime ( RndVal ) RESULT ( PrmVal ) ! To find a prime number larger than the given value tSInt64 , INTENT ( IN ) :: RndVal tSInt64 :: PrmVal ! execution PrmVal = RndVal DO WHILE (. NOT . IsPrime ( PrmVal )) PrmVal = PrmVal + 1_kInt64 END DO RETURN END FUNCTION LongRandomPrime !************************************************************************** FUNCTION ComputeHash ( Key , M , R , Q ) RESULT ( Hash ) ! To compute hash value for key(1:M) tCharStar , INTENT ( IN ) :: Key ( 0 :) tIndex , INTENT ( IN ) :: M tIndex , INTENT ( IN ) :: R tSInt64 , INTENT ( IN ) :: Q tSInt64 :: Hash tIndex :: J ! execution Hash = 0_kInt64 DO J = 0_kIndex , M - 1_kIndex Hash = MOD ( R * Hash + IACHAR ( Key ( J )), Q ) END DO RETURN END FUNCTION ComputeHash !************************************************************************** END SUBROUTINE RabinKarp_Process !****************************************************************************** FUNCTION RabinKarp_Find ( PatObj , Pattern , Text ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Offset , N tSInt64 :: TxtHash ! FLOW N = SIZE ( Text , KIND = kIndex ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( RabinKarpPat ) TxtHash = ComputeHash ( Text , Pat % M , Pat % R , Pat % Q ) ! check for match at StartID IF (( Pat % Hash == TxtHash ). AND . Check ( 0_kIndex , Pat % M )) THEN ! pattern found Index = 0_kIndex RETURN END IF ! check for hash match; if hash match, check for exact match DO I = Pat % M , N - 1_kIndex ! Remove leading digit, add trailing digit, check for match TxtHash = MOD ( MOD (( TxtHash + Pat % Q - Pat % RM * IACHAR ( Text ( I - Pat % M ))), Pat % Q ), Pat % Q ) TxtHash = MOD (( TxtHash * Pat % R + IACHAR ( Text ( I ))), Pat % Q ) Offset = I - Pat % M + 1_kIndex IF (( Pat % Hash == TxtHash ). AND . Check ( Offset , Pat % M )) THEN ! pattern found Index = Offset RETURN END IF END DO ! pattern not found Index = N END SELECT RETURN CONTAINS FUNCTION Check ( K , M ) RESULT ( Flag ) ! Las Vegas version: does pat[] match txt[i..i-m+1] ? tIndex , INTENT ( IN ) :: K tIndex , INTENT ( IN ) :: M tLogical :: Flag tIndex :: J ! execution DO J = 0_kIndex , M - 1_kIndex IF ( Pattern ( J ) /= Text ( K + J )) THEN Flag = FalseVal RETURN END IF END DO Flag = TrueVal RETURN END FUNCTION Check !************************************************************************** FUNCTION ComputeHash ( Key , M , R , Q ) RESULT ( Hash ) ! To compute hash value for key(1:M) tCharStar , INTENT ( IN ) :: Key ( 0 :) tIndex , INTENT ( IN ) :: M tIndex , INTENT ( IN ) :: R tSInt64 , INTENT ( IN ) :: Q tSInt64 :: Hash tIndex :: J ! execution Hash = 0_kInt64 DO J = 0_kIndex , M - 1_kIndex Hash = MOD ( R * Hash + IACHAR ( Key ( J )), Q ) END DO RETURN END FUNCTION ComputeHash !************************************************************************** END FUNCTION RabinKarp_Find !****************************************************************************** SUBROUTINE BruteForce_Process ( PatObj , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To pre-process the specified pattern for brute-force algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( Pat => PatObj ) TYPE IS ( BasePattern ) Pat % M = SIZE ( Pattern , KIND = kIndex ) END SELECT RETURN END SUBROUTINE BruteForce_Process !****************************************************************************** FUNCTION BruteForce_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , N ! FLOW N = SIZE ( Text , KIND = kIndex ) SELECT TYPE ( Pat => PatObj ) TYPE IS ( BasePattern ) DO I = StartID , N - Pat % M DO J = 0_kIndex , Pat % M - 1_kIndex IF ( Text ( I + J ) /= Pattern ( J )) EXIT END DO IF ( J == Pat % M ) THEN ! pattern found Index = I RETURN END IF END DO ! pattern not found Index = N END SELECT RETURN END FUNCTION BruteForce_Find !****************************************************************************** SUBROUTINE ChrIntMap_Create ( PatObj , Pattern , EndID , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'ChrIntMap' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ChrIntMap ), INTENT ( OUT ) :: PatObj !! the 'ChrIntMap' object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tIndex , INTENT ( IN ) :: EndID !! ending index tIndex , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinVal , MaxVal ! FLOW CALL MinMax_Sensitive ( Pattern , EndID , MinVal , MaxVal ) CALL PatObj % Construct ( MaxVal - MinVal + 1_kIndex , MinVal , DefVal ) RETURN END SUBROUTINE ChrIntMap_Create !****************************************************************************** SUBROUTINE ChrIntMap_Construct ( PatObj , Extent , Lowest , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'ChrIntMap' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ChrIntMap ), INTENT ( OUT ) :: PatObj !! the 'ChrIntMap' object tIndex , INTENT ( IN ) :: Extent !! the extent of the pattern tIndex , INTENT ( IN ) :: Lowest !! lowest code tIndex , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( PatObj % Arr ( 0 : Extent - 1 )) PatObj % Lowest = Lowest PatObj % DefVal = DefVal IF ( DefVal /= 0_kIndex ) THEN PatObj % Arr = DefVal ELSE PatObj % Arr = 0_kIndex END IF RETURN END SUBROUTINE ChrIntMap_Construct !****************************************************************************** SUBROUTINE ChrIntMap_Set ( PatObj , C , Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ChrIntMap ), INTENT ( INOUT ) :: PatObj !! the 'ChrIntMap' object tChar , INTENT ( IN ) :: C !! the character tIndex , INTENT ( IN ) :: Val !! the new value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF ( X < SIZE ( PatObj % Arr , KIND = kIndex )) PatObj % Arr ( X ) = Val RETURN END SUBROUTINE ChrIntMap_Set !****************************************************************************** FUNCTION ChrIntMap_Get ( PatObj , C ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ChrIntMap ), INTENT ( INOUT ) :: PatObj !! the 'ChrIntMap' object tChar , INTENT ( IN ) :: C !! the character tIndex :: Val !! the stored value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF (( X < 0_kIndex ). OR .( X >= SIZE ( PatObj % Arr , KIND = kIndex ))) THEN Val = PatObj % DefVal ELSE Val = PatObj % Arr ( X ) END IF RETURN END FUNCTION ChrIntMap_Get !****************************************************************************** SUBROUTINE BNDMPatLen64_Create ( PatObj , Pattern , EndID , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'BNDMPatLen64' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen64 ), INTENT ( OUT ) :: PatObj !! the 'BNDMPatLen64' object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tIndex , INTENT ( IN ) :: EndID !! ending index tSInt64 , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinVal , MaxVal ! FLOW CALL MinMax_Sensitive ( Pattern , EndID , MinVal , MaxVal ) CALL PatObj % Construct ( MaxVal - MinVal + 1_kIndex , MinVal , DefVal ) RETURN END SUBROUTINE BNDMPatLen64_Create !****************************************************************************** SUBROUTINE BNDMPatLen64_Construct ( PatObj , Extent , Lowest , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'BNDMPatLen64' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen64 ), INTENT ( OUT ) :: PatObj !! the 'BNDMPatLen64' object tIndex , INTENT ( IN ) :: Extent !! the extent of the pattern tIndex , INTENT ( IN ) :: Lowest !! lowest code tSInt64 , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( PatObj % Arr ( 0 : Extent - 1 )) PatObj % Lowest = Lowest PatObj % DefVal = DefVal IF ( DefVal /= 0_kInt64 ) THEN PatObj % Arr = DefVal ELSE PatObj % Arr = 0_kInt64 END IF RETURN END SUBROUTINE BNDMPatLen64_Construct !****************************************************************************** SUBROUTINE BNDMPatLen64_Set ( PatObj , C , Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen64 ), INTENT ( INOUT ) :: PatObj !! the 'BNDMPatLen64' object tChar , INTENT ( IN ) :: C !! the character tSInt64 , INTENT ( IN ) :: Val !! the new value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF ( X < SIZE ( PatObj % Arr , KIND = kIndex )) PatObj % Arr ( X ) = Val RETURN END SUBROUTINE BNDMPatLen64_Set !****************************************************************************** FUNCTION BNDMPatLen64_Get ( PatObj , C ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen64 ), INTENT ( INOUT ) :: PatObj !! the 'BNDMPatLen64' object tChar , INTENT ( IN ) :: C !! the character tSInt64 :: Val !! the stored value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF (( X < 0_kIndex ). OR .( X >= SIZE ( PatObj % Arr , KIND = kIndex ))) THEN Val = PatObj % DefVal ELSE Val = PatObj % Arr ( X ) END IF RETURN END FUNCTION BNDMPatLen64_Get !****************************************************************************** SUBROUTINE BNDMPatLen128_Create ( PatObj , Pattern , EndID , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'BNDMPatLen128' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen128 ), INTENT ( OUT ) :: PatObj !! the 'BNDMPatLen128' object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tIndex , INTENT ( IN ) :: EndID !! ending index tSInt128 , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: MinVal , MaxVal ! FLOW CALL MinMax_Sensitive ( Pattern , EndID , MinVal , MaxVal ) CALL PatObj % Construct ( MaxVal - MinVal + 1_kIndex , MinVal , DefVal ) RETURN END SUBROUTINE BNDMPatLen128_Create !****************************************************************************** SUBROUTINE BNDMPatLen128_Construct ( PatObj , Extent , Lowest , DefVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create the 'BNDMPatLen128' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen128 ), INTENT ( OUT ) :: PatObj !! the 'BNDMPatLen128' object tIndex , INTENT ( IN ) :: Extent !! the extent of the pattern tIndex , INTENT ( IN ) :: Lowest !! lowest code tSInt128 , INTENT ( IN ) :: DefVal !! default value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( PatObj % Arr ( 0 : Extent - 1 )) PatObj % Lowest = Lowest PatObj % DefVal = DefVal IF ( DefVal /= ZeroI128 ) THEN PatObj % Arr = DefVal ELSE PatObj % Arr = ZeroI128 END IF RETURN END SUBROUTINE BNDMPatLen128_Construct !****************************************************************************** SUBROUTINE BNDMPatLen128_Set ( PatObj , C , Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen128 ), INTENT ( INOUT ) :: PatObj !! the 'BNDMPatLen128' object tChar , INTENT ( IN ) :: C !! the character tSInt128 , INTENT ( IN ) :: Val !! the new value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF ( X < SIZE ( PatObj % Arr , KIND = kIndex )) PatObj % Arr ( X ) = Val RETURN END SUBROUTINE BNDMPatLen128_Set !****************************************************************************** FUNCTION BNDMPatLen128_Get ( PatObj , C ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the stored value for the given character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BNDMPatLen128 ), INTENT ( INOUT ) :: PatObj !! the 'BNDMPatLen128' object tChar , INTENT ( IN ) :: C !! the character tSInt128 :: Val !! the stored value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: X ! FLOW X = IACHAR ( C , KIND = kIndex ) - PatObj % Lowest IF (( X < 0_kIndex ). OR .( X >= SIZE ( PatObj % Arr , KIND = kIndex ))) THEN Val = PatObj % DefVal ELSE Val = PatObj % Arr ( X ) END IF RETURN END FUNCTION BNDMPatLen128_Get !****************************************************************************** SUBROUTINE MinMax_Insensitive ( PatVal , Min , Max ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find minimum and maximum character codes of the given pattern. !** SUBROUTINE ARGUMENT DECLARATIONS: tChar , INTENT ( IN ) :: PatVal ( 0 :) tIndex , INTENT ( OUT ) :: Min , Max !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: ID , K tChar :: PC ! FLOW Min = Radix - 1_kIndex Max = 0_kIndex DO ID = 0_kIndex , SIZE ( PatVal , KIND = kIndex ) - 1_kIndex PC = PatVal ( ID ) IF ( IsLetter ( PC )) THEN ! the following code is based on the fact that ! upper-case codes are smaller than lower-case codes. K = IACHAR ( ToLower ( PC ), KIND = kIndex ) IF ( Max < K ) Max = K K = IACHAR ( ToUpper ( PC ), KIND = kIndex ) IF ( Min > K ) Min = K ELSE K = IACHAR ( PC , KIND = kIndex ) IF ( Max < K ) Max = K IF ( Min > K ) Min = K END IF END DO RETURN END SUBROUTINE MinMax_Insensitive !****************************************************************************** SUBROUTINE MinMax_Sensitive ( PatVal , EndID , Min , Max ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find minimum and maximum character codes of the given pattern. !** SUBROUTINE ARGUMENT DECLARATIONS: tChar , INTENT ( IN ) :: PatVal ( 0 :) tIndex , INTENT ( IN ) :: EndID tIndex , INTENT ( OUT ) :: Min , Max !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , C ! FLOW Min = Radix - 1_kIndex Max = 0_kIndex DO I = 0_kIndex , EndID - 1_kIndex C = IACHAR ( PatVal ( I ), KIND = kIndex ) IF ( Max < C ) Max = C IF ( Min > C ) Min = C END DO RETURN END SUBROUTINE MinMax_Sensitive !****************************************************************************** FUNCTION Len2OrLess_Find ( PatObj , Pattern , Text , StartID ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the zero-based index of the first occurrence of the pattern string !  in the text string.  Return the length of the text string if there is no such !  pattern found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BasePattern ), INTENT ( INOUT ) :: PatObj !! the pattern data object tChar , INTENT ( IN ) :: Pattern ( 0 :) !! the pattern as an array of characters tChar , INTENT ( IN ) :: Text ( 0 :) !! the text string as an array of characters tIndex , INTENT ( IN ) :: StartID !! (zero-based) starting index of the text string tIndex :: Index !! (zero-based) index of the first occurrence !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , TxtLen ! FLOW TxtLen = SIZE ( Text , KIND = kIndex ) ! Unrolled fast paths for patterns of length 1 and 2 IF ( PatObj % M == 1_kIndex ) THEN DO I = StartID , TxtLen - 1_kIndex IF ( Text ( I ) == Pattern ( 0 )) THEN ! pattern found Index = I RETURN END IF END DO ! pattern not found Index = TxtLen ELSEIF ( PatObj % M == 2_kIndex ) THEN DO I = StartID , TxtLen - 2_kIndex IF ( Text ( I ) == Pattern ( 0 )) THEN IF ( Text ( I + 1 ) == Pattern ( 1 )) THEN ! pattern found Index = I RETURN END IF END IF END DO ! pattern not found Index = TxtLen END IF RETURN END FUNCTION Len2OrLess_Find !****************************************************************************** END MODULE MClass_PatternFinder !******************************************************************************","tags":"","loc":"sourcefile\\mclass_patternfinder.f90.html"},{"title":"MClass_AlphabetTrie.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_AlphabetTrie !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *AlphabetTrie* type and its related routines. !   The *AlphabetTrie* type is a derived type representing a symbol table !   of key-value pairs, with string keys and generic values. <br> !   The *AlphabetTrie* type supports common operations of the symbol table !   including the *Insert*, *Remove*, *Contain*, *GetSize*, *IsEmpty* and !   *GetValue* methods.  It also provides character-based methods for finding !   the string in the symbol table that is the longest prefix of a given prefix, !   finding all strings in the symbol table that start with a given prefix, and !   finding all strings in the symbol table that match a given pattern. <br> !   For all operations provided, the *AlphabetTrie* type supports two types of !   character strings: the Fortran intrinsic *CHARACTER* type and the *FvlStr* !   derived type.  A user can choose to work with one of these two types.  Like !   other symbol tables, the *AlphabetTrie* type does not allow duplicated keys. !   Therefore, if an inserted key is equal to a key stored in the table, an !   associated value of the stored key is replaced by an associated value of !   the inserted key.  <br> !   Similar to the <a href=\"../module/mclass_multiwaytrie.html#type-multiwaytrie\"> !   MultiwayTrie</a> type, the *AlphabetTrie* type technically employs a multi-way !   (R-way) trie implementation.  However, unlike the *MultiwayTrie* type with its !   fixed R (= 256), the *AlphabetTrie* type can be used with any R, which is the !   number of characters (i.e. the radix) in an alphabet set of characters.  Also, !   unlike the *MultiwayTrie* type, an explicit construction is required via either !   the *CreateEmpty* or the *Construct* method where a user must specify a specific !   set of characters via an *alphabet* data type.  <br> !   See the <a href=\"../module/mclass_alphabets.html\">Class_Alphabets</a> module for !   various *alphabet* data types available to be used with the *AlphabetTrie* type. !   Most of these data types commonly have a much smaller radix than 256; therefore, !   the *AlphabetTrie* type is likely more efficient than the *MultiwayTrie* type !   when working with those alphabet data types with small radix.  <br> !   It is important to note that all provided *concrete alphabet* data types also !   require an explicit construction via their *Construct* method.  Therefore, a !   user must construct an *alphabet* data type before supplying it to one of the !   *AlphabetTrie* type's construction methods.  It is also worth mentioning that !   the given alphabet data type must contain all characters (with the exception of !   the wild-card characters) of all strings that the user will specify as input !   arguments.  This means that the user must know in advance what kind of characters !   to be used so that he/she can properly select a particular *alphabet* data type. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_DoublyLinkedLists , ONLY : QueueString => ListCharacter , QueueAny => ListAnyType USE MClass_FvlStr USE MClass_StringBuilder USE MClass_Alphabets , ONLY : Alphabet => BaseAlphabet IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: AlphabetTrie PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_AlphabetTrie' tSInt32 , PARAMETER :: MsgLen = 128 tCharStar , PARAMETER :: NULCHR = ACHAR ( 0 ) !! flag for null node tCharStar , PARAMETER :: NONNUL = ACHAR ( 2 ) !! flag for non-null node !** DERIVED TYPE DEFINITIONS !> The *TrieNode* type is a node type used in conjunction with the !  *AlphabetTrie* type.  It is a private type. TYPE TrieNode !% character flag indicating whether the node is null or not tChar :: Chr = NULCHR !% value (allocated if this is the node corresponding to the last key character) CLASS ( * ), ALLOCATABLE :: Value !% child nodes of this node TYPE ( TrieNode ), ALLOCATABLE :: Next (:) END TYPE TrieNode !> The *AlphabetTrie* type is a container type that utilizes a multi-way trie !  implementation to provide common operations for a symbol table where its !  keys are character strings and its values can be of any type. TYPE AlphabetTrie PRIVATE CLASS ( Alphabet ), POINTER :: Alpha => NULL () !! alphabet object TYPE ( TrieNode ) :: Root !! root of trie tIndex :: N !! number of keys CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => AlphabetTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => AlphabetTrie_Delete !% *Get* is a working method for key inquiring operation PROCEDURE , PRIVATE :: Get => AlphabetTrie_GetNode !% *LongestPrefixLen* is a working method for getting the longest prefix PROCEDURE , PRIVATE :: LongestPrefixLen => AlphabetTrie_LengthOfLongestPrefix !% *Collect* is a working method for key collecting operation PROCEDURE , PRIVATE :: AlphabetTrie_CollectKeys PROCEDURE , PRIVATE :: AlphabetTrie_AssembleKeys PROCEDURE , PRIVATE :: AlphabetTrie_GatherWildcardKeys GENERIC , PRIVATE :: Collect => AlphabetTrie_CollectKeys , & AlphabetTrie_AssembleKeys , & AlphabetTrie_GatherWildcardKeys !% procedures with generic interfaces PROCEDURE , PRIVATE :: AlphabetTrie_Insert_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Insert_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Remove_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Remove_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Contain_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Contain_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: AlphabetTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: AlphabetTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: AlphabetTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: AlphabetTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> ! **Purpose**:  To construct an empty symbol table.  <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(Alphabet) PROCEDURE :: CreateEmpty => AlphabetTrie_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(Alphabet, 10, KeyArr, ValArr) GENERIC :: Construct => AlphabetTrie_ConstructByArray_ChrStr , & AlphabetTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => AlphabetTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => AlphabetTrie_Destructor_ChrStr , & AlphabetTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => AlphabetTrie_Insert_ChrStr , & AlphabetTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => AlphabetTrie_Remove_ChrStr , & AlphabetTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => AlphabetTrie_Contain_ChrStr , & AlphabetTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => AlphabetTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => AlphabetTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => AlphabetTrie_StartWith_ChrStr , & AlphabetTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => AlphabetTrie_GetValue_ChrStr , & AlphabetTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => AlphabetTrie_AllKeys_ChrStr , & AlphabetTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => AlphabetTrie_KeysWithPrefix_CHCH , & AlphabetTrie_KeysWithPrefix_CHVL , & AlphabetTrie_KeysWithPrefix_VLCH , & AlphabetTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => AlphabetTrie_KeysThatMatch_CHCH , & AlphabetTrie_KeysThatMatch_CHVL , & AlphabetTrie_KeysThatMatch_VLCH , & AlphabetTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => AlphabetTrie_WildcardKeys_CHCH , & AlphabetTrie_WildcardKeys_CHVL , & AlphabetTrie_WildcardKeys_VLCH , & AlphabetTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => AlphabetTrie_LongestPrefixOf_ChrStr , & AlphabetTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: AlphabetTrie_Finalizer ! --------------------------------------------------------------------- END TYPE AlphabetTrie !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE TrieNode_New ( Node , Radix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To make the specify node a new one by setting the character-flag component !  to non-null character and also allocate its next-node component. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( INOUT ) :: Node !! trie node tIndex , INTENT ( IN ) :: Radix !! radix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! set character-flag component to non-null character Node % Chr = NONNUL ! allocate next-node component ALLOCATE ( Node % Next ( 0 : Radix - 1 ), STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_New' , ModName , AllocMsg , AllocStat ) RETURN END SUBROUTINE TrieNode_New !****************************************************************************** SUBROUTINE TrieNode_Clear ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the specify node by setting the character-flag component to null !  character and also deallocate its next-node component. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( INOUT ) :: Node !! trie node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! set character-flag component to null character Node % Chr = NULCHR ! deallocate next-node component DEALLOCATE ( Node % Next , STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN ! deallocate next-node component IF ( ALLOCATED ( Node % Value )) THEN DEALLOCATE ( Node % Value , STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_Clear' , ModName , AllocMsg , AllocStat ) END IF ELSE ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_Clear' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE TrieNode_Clear !****************************************************************************** SUBROUTINE AlphabetTrie_CreateEmpty ( Table , Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct an empty symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table CLASS ( Alphabet ), TARGET , INTENT ( IN ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Alpha % IsReady ()) THEN ! set pointer to the Alphabet object Table % Alpha => Alpha ELSE CALL Handle_ErrLevel ( 'AlphabetTrie_CreateEmpty' , ModName , ErrSevere , & 'Cannot create the trie because the alphabet has not yet been created .' ) END IF RETURN END SUBROUTINE AlphabetTrie_CreateEmpty !****************************************************************************** SUBROUTINE AlphabetTrie_ConstructByArray_ChrStr ( Table , Alpha , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table CLASS ( Alphabet ), TARGET , INTENT ( IN ) :: Alpha !! Alphabet object tIndex , INTENT ( IN ) :: N !! number of keys tCharStar , INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( Alpha % IsReady ()) THEN ! set pointer to the Alphabet object Table % Alpha => Alpha ELSE CALL Handle_ErrLevel ( 'AlphabetTrie_ConstructByArray_ChrStr' , ModName , ErrSevere , & 'Cannot create the trie because the alphabet has not yet been created.' ) RETURN END IF ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE AlphabetTrie_ConstructByArray_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_ConstructByArray_FvlStr ( Table , Alpha , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table CLASS ( Alphabet ), TARGET , INTENT ( IN ) :: Alpha !! Alphabet object tIndex , INTENT ( IN ) :: N !! number of keys TYPE ( FvlStr ), INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( Alpha % IsReady ()) THEN ! set pointer to the Alphabet object Table % Alpha => Alpha ELSE CALL Handle_ErrLevel ( 'AlphabetTrie_ConstructByArray_FvlStr' , ModName , ErrSevere , & 'Cannot create the trie because the alphabet has not yet been created.' ) RETURN END IF ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE AlphabetTrie_ConstructByArray_FvlStr !****************************************************************************** SUBROUTINE AlphabetTrie_Clear ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ tCharAlloc :: Key tLogical :: Success ! FLOW ! get all keys CALL Table % GetAllKeys ( KeyQ ) ! remove the key-value pairs Success = KeyQ % Dequeue ( Key ) DO WHILE (. NOT . Success ) CALL Table % Remove ( Key ) IF ( Table % IsEmpty ()) EXIT Success = KeyQ % Dequeue ( Key ) END DO RETURN END SUBROUTINE AlphabetTrie_Clear !****************************************************************************** SUBROUTINE AlphabetTrie_Destructor_ChrStr ( Table , KeyQ , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! a queue of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: Key tLogical :: IsTheEnd ! FLOW ! get all keys CALL Table % GetAllKeys ( KeyQ ) IF ( PRESENT ( ValueQ )) THEN ! get all values while removing the key-value pairs BLOCK CLASS ( * ), ALLOCATABLE :: Value IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key , Value ) CALL ValueQ % Enqueue ( Value ) DEALLOCATE ( Value ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END BLOCK ELSE ! remove the key-value pairs IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END IF ! set pointer to null Table % Alpha => NULL () RETURN END SUBROUTINE AlphabetTrie_Destructor_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_Destructor_FvlStr ( Table , KeyArr , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: KeyArr (:) !! an array of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % Destruct ( KeyQ , ValueQ ) CALL KeyQueue2Array ( KeyQ , KeyArr ) RETURN END SUBROUTINE AlphabetTrie_Destructor_FvlStr !****************************************************************************** SUBROUTINE AlphabetTrie_Finalizer ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Table % Clear () Table % Alpha => NULL () RETURN END SUBROUTINE AlphabetTrie_Finalizer !****************************************************************************** RECURSIVE SUBROUTINE AlphabetTrie_Put ( Table , X , Key , Value , D ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for insertion operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( INOUT ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value tIndex , INTENT ( IN ) :: D !! index of the character in the key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C ! FLOW ! create a subtrie to contain the key and its associated value IF ( X % Chr == NULCHR ) CALL TrieNode_New ( X , Table % Alpha % GetRadix ()) IF ( D > LEN ( Key , KIND = kIndex )) THEN ! X is the node corresponding to the last key character IF (. NOT . ALLOCATED ( X % Value )) THEN ! new key Table % N = Table % N + 1_kIndex ALLOCATE ( X % Value , SOURCE = Value ) ELSE ! existing key so replace existing value with new one ! note: must re-allocate since value can have different type !       so assignment/copy may be invalid. DEALLOCATE ( X % Value ) ALLOCATE ( X % Value , SOURCE = Value ) END IF RETURN END IF ! add next node to the subtrie C = Table % Alpha % GetIndex ( Key ( D : D )) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Put' , ModName , ErrSevere , & 'The \"' // Key ( D : D ) // '\" character is NOT in the alphabet.' ) RETURN END IF CALL Table % Put ( X % Next ( C ), Key , Value , D + 1_kIndex ) RETURN END SUBROUTINE AlphabetTrie_Put !****************************************************************************** SUBROUTINE AlphabetTrie_Insert_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Insert_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Insert_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN !    ELSEIF (Table%Alpha%Verify(Key) /= 0_kIndex) THEN !        CALL Handle_ErrLevel('AlphabetTrie_Insert_ChrStr', ModName, ErrSevere, & !                             'Invalid key.  Not all key characters are in the alphabet.') !        RETURN END IF CALL Table % Put ( Table % Root , Key , Value , 1_kIndex ) RETURN END SUBROUTINE AlphabetTrie_Insert_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_Insert_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Insert_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Insert_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN !    ELSEIF (Table%Alpha%Verify(Key) /= 0_kIndex) THEN !        CALL Handle_ErrLevel('AlphabetTrie_Insert_FvlStr', ModName, ErrSevere, & !                             'Invalid key.  Not all key characters are in the alphabet.') !        RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % Put ( Table % Root , StrPtr , Value , 1_kIndex ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_Insert_FvlStr !****************************************************************************** RECURSIVE FUNCTION AlphabetTrie_GetNode ( Table , NodeIn , Key , D ) RESULT ( NodeOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a pointer to the last node of the subtrie that stores the !  specified key.  If the specified key is not found, return a null pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), TARGET , INTENT ( IN ) :: NodeIn !! input node tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key TYPE ( TrieNode ), POINTER :: NodeOut !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C ! FLOW IF ( NodeIn % Chr == NULCHR ) THEN ! key is not found NodeOut => NULL () ELSEIF ( D > LEN ( Key , KIND = kIndex )) THEN ! NodeIn is the node corresponding to the last key character (i.e. key found) NodeOut => NodeIn ELSE ! search the next node C = Table % Alpha % GetIndex ( Key ( D : D )) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GetNode' , ModName , ErrSevere , & 'The \"' // Key ( D : D ) // '\" character is NOT in the alphabet.' ) RETURN END IF NodeOut => Table % Get ( NodeIn % Next ( C ), Key , D + 1_kIndex ) END IF RETURN END FUNCTION AlphabetTrie_GetNode !****************************************************************************** FUNCTION AlphabetTrie_Contain_ChrStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Contain_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Contain_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( Table % Get ( Table % Root , Key , 1_kIndex )) RETURN END FUNCTION AlphabetTrie_Contain_ChrStr !****************************************************************************** FUNCTION AlphabetTrie_Contain_FvlStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Contain_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Contain_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( Table % Get ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION AlphabetTrie_Contain_FvlStr !****************************************************************************** SUBROUTINE AlphabetTrie_GetValue_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: NodeOut ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GetValue_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GetValue_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF NodeOut => Table % Get ( Table % Root , Key , 1_kIndex ) IF ( ASSOCIATED ( NodeOut )) THEN ! key found IF ( ALLOCATED ( NodeOut % Value )) ALLOCATE ( Value , SOURCE = NodeOut % Value ) END IF NULLIFY ( NodeOut ) RETURN END SUBROUTINE AlphabetTrie_GetValue_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_GetValue_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GetValue_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GetValue_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % GetValue ( StrPtr , Value ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_GetValue_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE AlphabetTrie_Delete ( Table , X , Key , D , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for removal operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( INOUT ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C ! FLOW ! return if this subtrie is null IF ( X % Chr == NULCHR ) RETURN IF ( D > LEN ( Key , KIND = kIndex )) THEN ! X is the node corresponding to the last key character IF ( ALLOCATED ( X % Value )) THEN ! the key-value pair exists so remove it Table % N = Table % N - 1_kIndex IF ( PRESENT ( Value )) ALLOCATE ( Value , SOURCE = X % Value ) DEALLOCATE ( X % Value ) END IF ELSE ! search the next node of the subtrie C = Table % Alpha % GetIndex ( Key ( D : D )) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Delete' , ModName , ErrSevere , & 'The \"' // Key ( D : D ) // '\" character is NOT in the alphabet.' ) RETURN END IF CALL Table % Del ( X % Next ( C ), Key , D + 1_kIndex ) END IF ! remove subtrie rooted at X if it is completely empty IF ( ALLOCATED ( X % Value )) RETURN DO C = 0 , Table % Alpha % GetRadix () - 1 IF ( X % Next ( C )% Chr /= NULCHR ) RETURN END DO CALL TrieNode_Clear ( X ) RETURN END SUBROUTINE AlphabetTrie_Delete !****************************************************************************** SUBROUTINE AlphabetTrie_Remove_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Remove_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Remove_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % Del ( Table % Root , Key , 1_kIndex , Value ) RETURN END SUBROUTINE AlphabetTrie_Remove_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_Remove_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Remove_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_Remove_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % Del ( Table % Root , StrPtr , 1_kIndex , Value ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_Remove_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE AlphabetTrie_CollectKeys ( Table , X , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To collect all of keys in the symbol table that start with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C ! FLOW IF ( X % Chr == NULCHR ) RETURN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) DO C = 0 , Table % Alpha % GetRadix () - 1 CALL Prefix % Append ( Table % Alpha % GetChar ( C )) CALL Table % Collect ( X % Next ( C ), Prefix , KeyQ ) CALL Prefix % DelLastChar () END DO RETURN END SUBROUTINE AlphabetTrie_CollectKeys !****************************************************************************** FUNCTION AlphabetTrie_StartWith_ChrStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_StartWith_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) Found = FalseVal RETURN ELSEIF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_StartWith_ChrStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( Table % Get ( Table % Root , Prefix , 1_kIndex )) RETURN END FUNCTION AlphabetTrie_StartWith_ChrStr !****************************************************************************** FUNCTION AlphabetTrie_StartWith_FvlStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_StartWith_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) Found = FalseVal RETURN ELSEIF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_StartWith_FvlStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( Table % Get ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION AlphabetTrie_StartWith_FvlStr !****************************************************************************** SUBROUTINE AlphabetTrie_KeysWithPrefix_CHCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: X TYPE ( StringBuilder ) :: StrBld ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_CHCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_CHCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF X => Table % Get ( Table % Root , Prefix , 1_kIndex ) IF ( ASSOCIATED ( X )) THEN ! key(s) with prefix found CALL StrBld % Construct ( Prefix ) CALL Table % Collect ( X , StrBld , KeyQ ) NULLIFY ( X ) END IF RETURN END SUBROUTINE AlphabetTrie_KeysWithPrefix_CHCH !****************************************************************************** SUBROUTINE AlphabetTrie_KeysWithPrefix_CHVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_CHVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_CHVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % GetKeysWithPrefix ( Prefix , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE AlphabetTrie_KeysWithPrefix_CHVL !****************************************************************************** SUBROUTINE AlphabetTrie_KeysWithPrefix_VLCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_VLCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_VLCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_KeysWithPrefix_VLCH !****************************************************************************** SUBROUTINE AlphabetTrie_KeysWithPrefix_VLVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_VLVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysWithPrefix_VLVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_KeysWithPrefix_VLVL !****************************************************************************** SUBROUTINE AlphabetTrie_AllKeys_ChrStr ( Table , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_AllKeys_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL Table % GetKeysWithPrefix ( '' , KeyQ ) RETURN END SUBROUTINE AlphabetTrie_AllKeys_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_AllKeys_FvlStr ( Table , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_AllKeys_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL Table % GetAllKeys ( KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE AlphabetTrie_AllKeys_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE AlphabetTrie_AssembleKeys ( Table , X , Prefix , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To assemble all of keys in the symbol table that match the given pattern where the !  question-mark character is interpreted as a wild card character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder (with a prefix of the pattern) tCharStar , INTENT ( IN ) :: Pattern !! string pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings matching the pattern !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard = '?' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C tCharLen ( 1 ) :: Chr tIndex :: D ! FLOW IF ( X % Chr == NULCHR ) RETURN D = Prefix % Length () + 1_kIndex IF ( D > LEN ( Pattern , KIND = kIndex )) THEN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) RETURN END IF Chr = Pattern ( D : D ) IF ( Chr == WildCard ) THEN ! a wild card character found DO C = 0 , Table % Alpha % GetRadix () - 1 CALL Prefix % Append ( Table % Alpha % GetChar ( C )) CALL Table % Collect ( X % Next ( C ), Prefix , Pattern , KeyQ ) CALL Prefix % DelLastChar () END DO ELSE CALL Prefix % Append ( Chr ) C = Table % Alpha % GetIndex ( Chr ) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_AssembleKeys' , ModName , ErrSevere , & 'The \"' // Chr // '\" character is NOT in the alphabet.' ) RETURN END IF CALL Table % Collect ( X % Next ( C ), Prefix , Pattern , KeyQ ) CALL Prefix % DelLastChar () END IF RETURN END SUBROUTINE AlphabetTrie_AssembleKeys !****************************************************************************** SUBROUTINE AlphabetTrie_KeysThatMatch_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysThatMatch_CHCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL StrBld % CreateEmpty () CALL Table % Collect ( Table % Root , StrBld , Pattern , KeyQ ) RETURN END SUBROUTINE AlphabetTrie_KeysThatMatch_CHCH !****************************************************************************** SUBROUTINE AlphabetTrie_KeysThatMatch_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysThatMatch_CHVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL Table % GetKeysThatMatch ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE AlphabetTrie_KeysThatMatch_CHVL !****************************************************************************** SUBROUTINE AlphabetTrie_KeysThatMatch_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysThatMatch_VLCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_KeysThatMatch_VLCH !****************************************************************************** SUBROUTINE AlphabetTrie_KeysThatMatch_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_KeysThatMatch_VLVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_KeysThatMatch_VLVL !****************************************************************************** RECURSIVE SUBROUTINE AlphabetTrie_GatherWildcardKeys ( Table , X , Prefix , Pattern , D , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To gather all of keys in the symbol table that match the given pattern where !  the question-mark character ('?') is interpreted as a wild card character for !  a single character and the asterisk character ('*') is interpreted as a wild !  card character for a sequence of characters. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix tCharStar , INTENT ( IN ) :: Pattern !! string pattern tIndex , INTENT ( IN ) :: D !! current position of character in the pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard_Single = '?' ! a wild card for single character tCharParam :: WildCard_Sequence = '*' ! a wild card for a sequence of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C tCharLen ( 1 ) :: Chr ! FLOW IF ( X % Chr == NULCHR ) RETURN IF ( D > LEN ( Pattern , KIND = kIndex )) THEN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) RETURN END IF Chr = Pattern ( D : D ) IF ( Chr == WildCard_Single ) THEN ! a wild card for a single character found DO C = 0 , Table % Alpha % GetRadix () - 1 CALL Prefix % Append ( Table % Alpha % GetChar ( C )) CALL Table % Collect ( X % Next ( C ), Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END DO ELSEIF ( Chr == WildCard_Sequence ) THEN ! a wild card for a sequence of characters found CALL Table % Collect ( X , Prefix , Pattern , D + 1_kIndex , KeyQ ) DO C = 0 , Table % Alpha % GetRadix () - 1 CALL Prefix % Append ( Table % Alpha % GetChar ( C )) CALL Table % Collect ( X % Next ( C ), Prefix , Pattern , D , KeyQ ) CALL Prefix % DelLastChar () END DO ELSE CALL Prefix % Append ( Chr ) C = Table % Alpha % GetIndex ( Chr ) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_GatherWildcardKeys' , ModName , ErrSevere , & 'The \"' // Chr // '\" character is NOT in the alphabet.' ) RETURN END IF CALL Table % Collect ( X % Next ( C ), Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END IF RETURN END SUBROUTINE AlphabetTrie_GatherWildcardKeys !****************************************************************************** SUBROUTINE AlphabetTrie_WildcardKeys_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_WildcardKeys_CHCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL StrBld % CreateEmpty () CALL Table % Collect ( Table % Root , StrBld , Pattern , 1_kIndex , KeyQ ) RETURN END SUBROUTINE AlphabetTrie_WildcardKeys_CHCH !****************************************************************************** SUBROUTINE AlphabetTrie_WildcardKeys_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_WildcardKeys_CHVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF CALL Table % GetWildcardKeys ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE AlphabetTrie_WildcardKeys_CHVL !****************************************************************************** SUBROUTINE AlphabetTrie_WildcardKeys_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_WildcardKeys_VLCH' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_WildcardKeys_VLCH !****************************************************************************** SUBROUTINE AlphabetTrie_WildcardKeys_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_WildcardKeys_VLVL' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN END IF StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_WildcardKeys_VLVL !****************************************************************************** RECURSIVE FUNCTION AlphabetTrie_LengthOfLongestPrefix ( Table , X , Query , D , LenIn ) RESULT ( LenOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the length of the longest key in the subtrie rooted at the *X* node !  that is a prefix of the specified query, assuming that the first *D* character !  match and a prefix match of the given length (-1 if no such match) has already !  been found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Query !! string query tIndex , INTENT ( IN ) :: D !! current position of character in the query tIndex :: LenIn !! input length tIndex :: LenOut !! length of the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: C ! FLOW LenOut = LenIn ! set default value IF ( X % Chr == NULCHR ) RETURN IF ( ALLOCATED ( X % Value )) LenOut = D IF ( D > LEN ( Query , KIND = kIndex )) RETURN C = Table % Alpha % GetIndex ( Query ( D : D )) IF ( C == - 1_kIndex ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_LengthOfLongestPrefix' , ModName , ErrSevere , & 'The \"' // Query ( D : D ) // '\" character is NOT in the alphabet.' ) RETURN END IF LenOut = Table % LongestPrefixLen ( X % Next ( C ), Query , D + 1_kIndex , LenOut ) RETURN END FUNCTION AlphabetTrie_LengthOfLongestPrefix !****************************************************************************** SUBROUTINE AlphabetTrie_LongestPrefixOf_ChrStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Query !! a query tCharAlloc , INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_LongestPrefixOf_ChrStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( LEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_LongestPrefixOf_ChrStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF Length = Table % LongestPrefixLen ( Table % Root , Query , 1_kIndex , - 1_kIndex ) IF ( Length /= - 1_kIndex ) Prefix = Query ( 1 : Length ) RETURN END SUBROUTINE AlphabetTrie_LongestPrefixOf_ChrStr !****************************************************************************** SUBROUTINE AlphabetTrie_LongestPrefixOf_FvlStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Query !! a query TYPE ( FvlStr ), INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length tCharLen (:), POINTER :: StrPtr ! FLOW IF (. NOT . ASSOCIATED ( Table % Alpha )) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_LongestPrefixOf_FvlStr' , ModName , ErrSevere , & 'The symbol table has not yet been constructed.' ) RETURN ELSEIF ( GETLEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'AlphabetTrie_LongestPrefixOf_FvlStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Query ) IF ( ASSOCIATED ( StrPtr )) THEN Length = Table % LongestPrefixLen ( Table % Root , StrPtr , 1_kIndex , - 1_kIndex ) IF ( Length /= - 1_kIndex ) Prefix = StrPtr ( 1 : Length ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE AlphabetTrie_LongestPrefixOf_FvlStr !****************************************************************************** FUNCTION AlphabetTrie_IsEmpty ( Table ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the table is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( IN ) :: Table !! symbol table tLogical :: Flag !! true if the table is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Table % N == 0_kIndex ) RETURN END FUNCTION AlphabetTrie_IsEmpty !****************************************************************************** FUNCTION AlphabetTrie_GetSize ( Table ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size (number of keys stored) of the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AlphabetTrie ), INTENT ( IN ) :: Table !! symbol table tIndex :: Size !! size of the table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Table % N RETURN END FUNCTION AlphabetTrie_GetSize !****************************************************************************** SUBROUTINE KeyQueue2Array ( KeyQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a queue of character-string keys to an array of keys of !  the FvlStr type. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of keys TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Success tIndex :: I tCharAlloc :: Key ! FLOW IF (. NOT . KeyQ % IsEmpty ()) THEN ALLOCATE ( Keys ( KeyQ % GetSize ())) I = 1_kIndex DO WHILE (. NOT . KeyQ % IsEmpty ()) Success = KeyQ % Dequeue ( Key ) IF ( Success ) THEN Keys ( I ) = Key I = I + 1_kIndex END IF END DO END IF RETURN END SUBROUTINE KeyQueue2Array !****************************************************************************** END MODULE MClass_AlphabetTrie !******************************************************************************","tags":"","loc":"sourcefile\\mclass_alphabettrie.f90.html"},{"title":"MClass_MultiwayTrie.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_MultiwayTrie !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *MultiwayTrie* type and its related routines. !   The *MultiwayTrie* type is a derived type representing a symbol table !   of key-value pairs, with string keys and generic values. <br> !   The *MultiwayTrie* type supports common operations of the symbol table !   including the *Insert*, *Remove*, *Contain*, *GetSize*, *IsEmpty* and !   *GetValue* methods.  It also provides character-based methods for finding !   the string in the symbol table that is the longest prefix of a given prefix, !   finding all strings in the symbol table that start with a given prefix, and !   finding all strings in the symbol table that match a given pattern. <br> !   For all operations provided, the *MultiwayTrie* type supports two types of !   character strings: the Fortran intrinsic *CHARACTER* type and the *FvlStr* !   derived type.  A user can choose to work with one of these two types.  Like !   other symbol tables, the *MultiwayTrie* type does not allow duplicated keys. !   Therefore, if an inserted key is equal to a key stored in the table, an !   associated value of the stored key is replaced by an associated value of !   the inserted key.  Technically, the *MultiwayTrie* type employs a R-way !   (multi-way) trie implementation where R is 256.  This implies that the !   characters are encoded according to the 8-bit Extended ASCII codes. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_DoublyLinkedLists , ONLY : QueueString => ListCharacter , QueueAny => ListAnyType USE MClass_FvlStr USE MClass_StringBuilder IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: MultiwayTrie PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_MultiwayTrie' tSInt32 , PARAMETER :: MsgLen = 128 tSInt32 , PARAMETER :: Radix = 256 !! radix for extended ASCII tCharStar , PARAMETER :: NULCHR = ACHAR ( 0 ) !! flag for null node tCharStar , PARAMETER :: NONNUL = ACHAR ( 2 ) !! flag for non-null node !** DERIVED TYPE DEFINITIONS !> The *TrieNode* type is a node type used in conjunction with the !  *MultiwayTrie* type.  It is a private type. TYPE TrieNode !% character flag indicating whether the node is null or not tChar :: Chr = NULCHR !% value (allocated if this is the node corresponding to the last key character) CLASS ( * ), ALLOCATABLE :: Value !% child nodes of this node TYPE ( TrieNode ), ALLOCATABLE :: Next (:) END TYPE TrieNode !> The *MultiwayTrie* type is a container type that utilizes a multi-way trie !  implementation to provide common operations for a symbol table where its !  keys are character strings and its values can be of any type. TYPE MultiwayTrie PRIVATE TYPE ( TrieNode ) :: Root !! root of trie tIndex :: N !! number of keys CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => MultiwayTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => MultiwayTrie_Delete !% procedures with generic interfaces PROCEDURE , PRIVATE :: MultiwayTrie_Insert_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Insert_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Remove_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Remove_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Contain_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Contain_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: MultiwayTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: MultiwayTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: MultiwayTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: MultiwayTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(10, KeyArr, ValArr) GENERIC :: Construct => MultiwayTrie_ConstructByArray_ChrStr , & MultiwayTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => MultiwayTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => MultiwayTrie_Destructor_ChrStr , & MultiwayTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => MultiwayTrie_Insert_ChrStr , & MultiwayTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => MultiwayTrie_Remove_ChrStr , & MultiwayTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => MultiwayTrie_Contain_ChrStr , & MultiwayTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => MultiwayTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => MultiwayTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => MultiwayTrie_StartWith_ChrStr , & MultiwayTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => MultiwayTrie_GetValue_ChrStr , & MultiwayTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => MultiwayTrie_AllKeys_ChrStr , & MultiwayTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => MultiwayTrie_KeysWithPrefix_CHCH , & MultiwayTrie_KeysWithPrefix_CHVL , & MultiwayTrie_KeysWithPrefix_VLCH , & MultiwayTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => MultiwayTrie_KeysThatMatch_CHCH , & MultiwayTrie_KeysThatMatch_CHVL , & MultiwayTrie_KeysThatMatch_VLCH , & MultiwayTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => MultiwayTrie_WildcardKeys_CHCH , & MultiwayTrie_WildcardKeys_CHVL , & MultiwayTrie_WildcardKeys_VLCH , & MultiwayTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => MultiwayTrie_LongestPrefixOf_ChrStr , & MultiwayTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: MultiwayTrie_Finalizer ! --------------------------------------------------------------------- END TYPE MultiwayTrie !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE TrieNode_New ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To make the specify node a new one by setting the character-flag component !  to non-null character and also allocate its next-node component. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( INOUT ) :: Node !! trie node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! set character-flag component to non-null character Node % Chr = NONNUL ! allocate next-node component ALLOCATE ( Node % Next ( 0 : Radix - 1 ), STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_New' , ModName , AllocMsg , AllocStat ) RETURN END SUBROUTINE TrieNode_New !****************************************************************************** SUBROUTINE TrieNode_Clear ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the specify node by setting the character-flag component to null !  character and also deallocate its next-node component. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( INOUT ) :: Node !! trie node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! set character-flag component to null character Node % Chr = NULCHR ! deallocate next-node component DEALLOCATE ( Node % Next , STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN ! deallocate next-node component IF ( ALLOCATED ( Node % Value )) THEN DEALLOCATE ( Node % Value , STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_Clear' , ModName , AllocMsg , AllocStat ) END IF ELSE ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_Clear' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE TrieNode_Clear !****************************************************************************** SUBROUTINE MultiwayTrie_ConstructByArray_ChrStr ( Table , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tIndex , INTENT ( IN ) :: N !! number of keys tCharStar , INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE MultiwayTrie_ConstructByArray_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_ConstructByArray_FvlStr ( Table , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tIndex , INTENT ( IN ) :: N !! number of keys TYPE ( FvlStr ), INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE MultiwayTrie_ConstructByArray_FvlStr !****************************************************************************** SUBROUTINE MultiwayTrie_Clear ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % Destruct ( KeyQ ) CALL KeyQ % Destruct () RETURN END SUBROUTINE MultiwayTrie_Clear !****************************************************************************** SUBROUTINE MultiwayTrie_Destructor_ChrStr ( Table , KeyQ , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! a queue of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: Key tLogical :: IsTheEnd ! FLOW ! get all keys CALL Table % GetAllKeys ( KeyQ ) IF ( PRESENT ( ValueQ )) THEN ! get all values while removing the key-value pairs BLOCK CLASS ( * ), ALLOCATABLE :: Value IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key , Value ) CALL ValueQ % Enqueue ( Value ) DEALLOCATE ( Value ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END BLOCK ELSE ! remove the key-value pairs IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END IF RETURN END SUBROUTINE MultiwayTrie_Destructor_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_Destructor_FvlStr ( Table , KeyArr , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: KeyArr (:) !! an array of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % Destruct ( KeyQ , ValueQ ) CALL KeyQueue2Array ( KeyQ , KeyArr ) RETURN END SUBROUTINE MultiwayTrie_Destructor_FvlStr !****************************************************************************** SUBROUTINE MultiwayTrie_Finalizer ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Table % Clear () RETURN END SUBROUTINE MultiwayTrie_Finalizer !****************************************************************************** RECURSIVE SUBROUTINE MultiwayTrie_Put ( Table , X , Key , Value , D ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for insertion operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( INOUT ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value tIndex , INTENT ( IN ) :: D !! index of the character in the key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C ! FLOW ! create a subtrie to contain the key and its associated value IF ( X % Chr == NULCHR ) CALL TrieNode_New ( X ) IF ( D > LEN ( Key , KIND = kIndex )) THEN ! X is the node corresponding to the last key character IF (. NOT . ALLOCATED ( X % Value )) THEN ! new key Table % N = Table % N + 1_kIndex ALLOCATE ( X % Value , SOURCE = Value ) ELSE ! existing key so replace existing value with new one ! note: must re-allocate since value can have different type !       so assignment/copy may be invalid. DEALLOCATE ( X % Value ) ALLOCATE ( X % Value , SOURCE = Value ) END IF RETURN END IF ! add next node to the subtrie C = IACHAR ( Key ( D : D )) CALL Table % Put ( X % Next ( C ), Key , Value , D + 1_kIndex ) RETURN END SUBROUTINE MultiwayTrie_Put !****************************************************************************** SUBROUTINE MultiwayTrie_Insert_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Insert_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % Put ( Table % Root , Key , Value , 1_kIndex ) RETURN END SUBROUTINE MultiwayTrie_Insert_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_Insert_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Insert_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % Put ( Table % Root , StrPtr , Value , 1_kIndex ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_Insert_FvlStr !****************************************************************************** RECURSIVE FUNCTION GetNode ( NodeIn , Key , D ) RESULT ( NodeOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a pointer to the last node of the subtrie that stores the !  specified key.  If the specified key is not found, return a null pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), TARGET , INTENT ( IN ) :: NodeIn !! input node tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key TYPE ( TrieNode ), POINTER :: NodeOut !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C ! FLOW IF ( NodeIn % Chr == NULCHR ) THEN ! key is not found NodeOut => NULL () ELSEIF ( D > LEN ( Key , KIND = kIndex )) THEN ! NodeIn is the node corresponding to the last key character (i.e. key found) NodeOut => NodeIn ELSE ! search the next node C = IACHAR ( Key ( D : D )) NodeOut => GetNode ( NodeIn % Next ( C ), Key , D + 1_kIndex ) END IF RETURN END FUNCTION GetNode !****************************************************************************** FUNCTION MultiwayTrie_Contain_ChrStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Contain_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( GetNode ( Table % Root , Key , 1_kIndex )) RETURN END FUNCTION MultiwayTrie_Contain_ChrStr !****************************************************************************** FUNCTION MultiwayTrie_Contain_FvlStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Contain_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( GetNode ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION MultiwayTrie_Contain_FvlStr !****************************************************************************** SUBROUTINE MultiwayTrie_GetValue_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: NodeOut ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_GetValue_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF NodeOut => GetNode ( Table % Root , Key , 1_kIndex ) IF ( ASSOCIATED ( NodeOut )) THEN ! key found IF ( ALLOCATED ( NodeOut % Value )) ALLOCATE ( Value , SOURCE = NodeOut % Value ) END IF NULLIFY ( NodeOut ) RETURN END SUBROUTINE MultiwayTrie_GetValue_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_GetValue_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_GetValue_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % GetValue ( StrPtr , Value ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_GetValue_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE MultiwayTrie_Delete ( Table , X , Key , D , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for removal operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), INTENT ( INOUT ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C ! FLOW ! return if this subtrie is null IF ( X % Chr == NULCHR ) RETURN IF ( D > LEN ( Key , KIND = kIndex )) THEN ! X is the node corresponding to the last key character IF ( ALLOCATED ( X % Value )) THEN ! the key-value pair exists so remove it Table % N = Table % N - 1_kIndex IF ( PRESENT ( Value )) ALLOCATE ( Value , SOURCE = X % Value ) DEALLOCATE ( X % Value ) END IF ELSE ! search the next node of the subtrie C = IACHAR ( Key ( D : D )) CALL Table % Del ( X % Next ( C ), Key , D + 1_kIndex ) END IF ! remove subtrie rooted at X if it is completely empty IF ( ALLOCATED ( X % Value )) RETURN DO C = 0 , Radix - 1 IF ( X % Next ( C )% Chr /= NULCHR ) RETURN END DO CALL TrieNode_Clear ( X ) RETURN END SUBROUTINE MultiwayTrie_Delete !****************************************************************************** SUBROUTINE MultiwayTrie_Remove_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Remove_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % Del ( Table % Root , Key , 1_kIndex , Value ) RETURN END SUBROUTINE MultiwayTrie_Remove_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_Remove_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_Remove_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % Del ( Table % Root , StrPtr , 1_kIndex , Value ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_Remove_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE CollectKeys ( X , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To collect all of keys in the symbol table that start with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C ! FLOW IF ( X % Chr == NULCHR ) RETURN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) DO C = 0 , Radix - 1 CALL Prefix % Append ( ACHAR ( C )) CALL CollectKeys ( X % Next ( C ), Prefix , KeyQ ) CALL Prefix % DelLastChar () END DO RETURN END SUBROUTINE CollectKeys !****************************************************************************** FUNCTION MultiwayTrie_StartWith_ChrStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_StartWith_ChrStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( GetNode ( Table % Root , Prefix , 1_kIndex )) RETURN END FUNCTION MultiwayTrie_StartWith_ChrStr !****************************************************************************** FUNCTION MultiwayTrie_StartWith_FvlStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_StartWith_FvlStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( GetNode ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION MultiwayTrie_StartWith_FvlStr !****************************************************************************** SUBROUTINE MultiwayTrie_KeysWithPrefix_CHCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: X TYPE ( StringBuilder ) :: StrBld ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_KeysWithPrefix_CHCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF X => GetNode ( Table % Root , Prefix , 1_kIndex ) IF ( ASSOCIATED ( X )) THEN ! key(s) with prefix found CALL StrBld % Construct ( Prefix ) CALL CollectKeys ( X , StrBld , KeyQ ) NULLIFY ( X ) END IF RETURN END SUBROUTINE MultiwayTrie_KeysWithPrefix_CHCH !****************************************************************************** SUBROUTINE MultiwayTrie_KeysWithPrefix_CHVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_KeysWithPrefix_CHVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % GetKeysWithPrefix ( Prefix , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE MultiwayTrie_KeysWithPrefix_CHVL !****************************************************************************** SUBROUTINE MultiwayTrie_KeysWithPrefix_VLCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_KeysWithPrefix_VLCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_KeysWithPrefix_VLCH !****************************************************************************** SUBROUTINE MultiwayTrie_KeysWithPrefix_VLVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_KeysWithPrefix_VLVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_KeysWithPrefix_VLVL !****************************************************************************** SUBROUTINE MultiwayTrie_AllKeys_ChrStr ( Table , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL CollectKeys ( Table % Root , StrBld , KeyQ ) RETURN END SUBROUTINE MultiwayTrie_AllKeys_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_AllKeys_FvlStr ( Table , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetAllKeys ( KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE MultiwayTrie_AllKeys_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE AssembleKeys ( X , Prefix , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To assemble all of keys in the symbol table that match the given pattern where the !  question-mark character is interpreted as a wild card character. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder (with a prefix of the pattern) tCharStar , INTENT ( IN ) :: Pattern !! string pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings matching the pattern !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard = '?' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C tCharLen ( 1 ) :: Chr tIndex :: D ! FLOW IF ( X % Chr == NULCHR ) RETURN D = Prefix % Length () + 1_kIndex IF ( D > LEN ( Pattern , KIND = kIndex )) THEN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) RETURN END IF Chr = Pattern ( D : D ) IF ( Chr == WildCard ) THEN ! a wild card character found DO C = 0 , Radix - 1 CALL Prefix % Append ( ACHAR ( C )) CALL AssembleKeys ( X % Next ( C ), Prefix , Pattern , KeyQ ) CALL Prefix % DelLastChar () END DO ELSE CALL Prefix % Append ( Chr ) CALL AssembleKeys ( X % Next ( IACHAR ( Chr )), Prefix , Pattern , KeyQ ) CALL Prefix % DelLastChar () END IF RETURN END SUBROUTINE AssembleKeys !****************************************************************************** SUBROUTINE MultiwayTrie_KeysThatMatch_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL AssembleKeys ( Table % Root , StrBld , Pattern , KeyQ ) RETURN END SUBROUTINE MultiwayTrie_KeysThatMatch_CHCH !****************************************************************************** SUBROUTINE MultiwayTrie_KeysThatMatch_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetKeysThatMatch ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE MultiwayTrie_KeysThatMatch_CHVL !****************************************************************************** SUBROUTINE MultiwayTrie_KeysThatMatch_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_KeysThatMatch_VLCH !****************************************************************************** SUBROUTINE MultiwayTrie_KeysThatMatch_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_KeysThatMatch_VLVL !****************************************************************************** RECURSIVE SUBROUTINE GatherWildcardKeys ( X , Prefix , Pattern , D , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To gather all of keys in the symbol table that match the given pattern where !  the question-mark character ('?') is interpreted as a wild card character for !  a single character and the asterisk character ('*') is interpreted as a wild !  card character for a sequence of characters. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix tCharStar , INTENT ( IN ) :: Pattern !! string pattern tIndex , INTENT ( IN ) :: D !! current position of character in the pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard_Single = '?' ! a wild card for single character tCharParam :: WildCard_Sequence = '*' ! a wild card for a sequence of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C tCharLen ( 1 ) :: Chr ! FLOW IF ( X % Chr == NULCHR ) RETURN IF ( D > LEN ( Pattern , KIND = kIndex )) THEN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) RETURN END IF Chr = Pattern ( D : D ) IF ( Chr == WildCard_Single ) THEN ! a wild card for a single character found DO C = 0 , Radix - 1 CALL Prefix % Append ( ACHAR ( C )) CALL GatherWildcardKeys ( X % Next ( C ), Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END DO ELSEIF ( Chr == WildCard_Sequence ) THEN ! a wild card for a sequence of characters found CALL GatherWildcardKeys ( X , Prefix , Pattern , D + 1_kIndex , KeyQ ) DO C = 0 , Radix - 1 CALL Prefix % Append ( ACHAR ( C )) CALL GatherWildcardKeys ( X % Next ( C ), Prefix , Pattern , D , KeyQ ) CALL Prefix % DelLastChar () END DO ELSE CALL Prefix % Append ( Chr ) CALL GatherWildcardKeys ( X % Next ( IACHAR ( Chr )), Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END IF RETURN END SUBROUTINE GatherWildcardKeys !****************************************************************************** SUBROUTINE MultiwayTrie_WildcardKeys_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL GatherWildcardKeys ( Table % Root , StrBld , Pattern , 1_kIndex , KeyQ ) RETURN END SUBROUTINE MultiwayTrie_WildcardKeys_CHCH !****************************************************************************** SUBROUTINE MultiwayTrie_WildcardKeys_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetWildcardKeys ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE MultiwayTrie_WildcardKeys_CHVL !****************************************************************************** SUBROUTINE MultiwayTrie_WildcardKeys_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_WildcardKeys_VLCH !****************************************************************************** SUBROUTINE MultiwayTrie_WildcardKeys_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_WildcardKeys_VLVL !****************************************************************************** RECURSIVE FUNCTION LengthOfLongestPrefix ( X , Query , D , LenIn ) RESULT ( LenOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the length of the longest key in the subtrie rooted at the *X* node !  that is a prefix of the specified query, assuming that the first *D* character !  match and a prefix match of the given length (-1 if no such match) has already !  been found. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( IN ) :: X !! node representing current subtrie tCharStar , INTENT ( IN ) :: Query !! string query tIndex , INTENT ( IN ) :: D !! current position of character in the query tIndex :: LenIn !! input length tIndex :: LenOut !! length of the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: C ! FLOW LenOut = LenIn ! set default value IF ( X % Chr == NULCHR ) RETURN IF ( ALLOCATED ( X % Value )) LenOut = D IF ( D > LEN ( Query , KIND = kIndex )) RETURN C = IACHAR ( Query ( D : D )) LenOut = LengthOfLongestPrefix ( X % Next ( C ), Query , D + 1_kIndex , LenOut ) RETURN END FUNCTION LengthOfLongestPrefix !****************************************************************************** SUBROUTINE MultiwayTrie_LongestPrefixOf_ChrStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Query !! a query tCharAlloc , INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length ! FLOW IF ( LEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_LongestPrefixOf_ChrStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF Length = LengthOfLongestPrefix ( Table % Root , Query , 1_kIndex , - 1_kIndex ) IF ( Length /= - 1_kIndex ) Prefix = Query ( 1 : Length ) RETURN END SUBROUTINE MultiwayTrie_LongestPrefixOf_ChrStr !****************************************************************************** SUBROUTINE MultiwayTrie_LongestPrefixOf_FvlStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Query !! a query TYPE ( FvlStr ), INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'MultiwayTrie_LongestPrefixOf_FvlStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Query ) IF ( ASSOCIATED ( StrPtr )) THEN Length = LengthOfLongestPrefix ( Table % Root , StrPtr , 1_kIndex , - 1_kIndex ) IF ( Length /= - 1_kIndex ) Prefix = StrPtr ( 1 : Length ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE MultiwayTrie_LongestPrefixOf_FvlStr !****************************************************************************** FUNCTION MultiwayTrie_IsEmpty ( Table ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the table is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( IN ) :: Table !! symbol table tLogical :: Flag !! true if the table is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Table % N == 0_kIndex ) RETURN END FUNCTION MultiwayTrie_IsEmpty !****************************************************************************** FUNCTION MultiwayTrie_GetSize ( Table ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size (number of keys stored) of the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MultiwayTrie ), INTENT ( IN ) :: Table !! symbol table tIndex :: Size !! size of the table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Table % N RETURN END FUNCTION MultiwayTrie_GetSize !****************************************************************************** SUBROUTINE KeyQueue2Array ( KeyQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a queue of character-string keys to an array of keys of !  the FvlStr type. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of keys TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Success tIndex :: I tCharAlloc :: Key ! FLOW IF (. NOT . KeyQ % IsEmpty ()) THEN ALLOCATE ( Keys ( KeyQ % GetSize ())) I = 1_kIndex DO WHILE (. NOT . KeyQ % IsEmpty ()) Success = KeyQ % Dequeue ( Key ) IF ( Success ) THEN Keys ( I ) = Key I = I + 1_kIndex END IF END DO END IF RETURN END SUBROUTINE KeyQueue2Array !****************************************************************************** END MODULE MClass_MultiwayTrie !******************************************************************************","tags":"","loc":"sourcefile\\mclass_multiwaytrie.f90.html"},{"title":"MClass_RECompiler.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_RECompiler !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *RECompiler* type and its related routines.  <br> !   <br> !  **REFERENCES**: <br> !   [1] <a href=\"https:!jakarta.apache.org/regexp/\">The Apache Jakarta Project. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers USE MBase_CharUtil USE MBase_ChrStr , ONLY : CharString USE MBase_SIntUtil , ONLY : ParseInteger => I32_FromChar , ToString => ToDecStrSigned USE MClass_StringBuilder USE MBase_REParameters USE MClass_REProgram IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: RECompiler PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     CharCode(C)     ICHAR(C) #define     ToChar(Code)    CHAR(Code, KIND=kChar) !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_RECompiler' tSInt32 , PARAMETER :: CharMinVal = 0 !    tSInt32,   PARAMETER    :: CharMaxVal = 127                     ! ASCII tSInt32 , PARAMETER :: CharMaxVal = 255 ! extended ASCII !    tSInt32,   PARAMETER    :: CharMaxVal = ToInt32(Z'0000FFFF')  ! UTF-16 !    tSInt32,   PARAMETER    :: CharMaxVal = ToInt32(Z'0010FFFF')  ! UTF-32 !** DERIVED TYPE DEFINITIONS !> The *RECompiler* type is a ... TYPE RECompiler PRIVATE ! ----- The compiled program ----- tChar , ALLOCATABLE :: instruction (:) !! The compiled regular expression 'program' tSInt32 :: lenInstruction !! The amount of the instruction buffer currently in use ! ----- Input state for compiling regular expression ----- tChar , ALLOCATABLE :: pattern (:) !! Input string tSInt32 :: len !! Length of the pattern string tSInt32 :: idx !! Current input index into ac tSInt32 :: parens !! Total number of parentheses pairs ! ----- {m,n} stacks ----- tSInt32 :: bracketMin !! Minimum number of matches tSInt32 :: bracketOpt !! Additional optional matches CONTAINS ! -----                 Private Procedures                      ----- PROCEDURE , PRIVATE :: Initialize => RECompiler_Initialize PROCEDURE , PRIVATE :: Ensure => RECompiler_Ensure PROCEDURE , PRIVATE :: Emit => RECompiler_Emit PROCEDURE , PRIVATE :: NodeInsert => RECompiler_NodeInsert PROCEDURE , PRIVATE :: SetNextOfEnd => RECompiler_SetNextOfEnd PROCEDURE , PRIVATE :: Node => RECompiler_Node PROCEDURE , PRIVATE :: Bracket => RECompiler_Bracket PROCEDURE , PRIVATE :: Escape => RECompiler_Escape PROCEDURE , PRIVATE :: CharacterClass => RECompiler_CharacterClass PROCEDURE , PRIVATE :: Atom => RECompiler_Atom PROCEDURE , PRIVATE :: Terminal => RECompiler_Terminal PROCEDURE , PRIVATE :: Closure => RECompiler_Closure PROCEDURE , PRIVATE :: Branch => RECompiler_Branch PROCEDURE , PRIVATE :: Expression => RECompiler_Expression ! -----                 Public Procedures                       ----- PROCEDURE :: Compile => RECompiler_Compile END TYPE RECompiler ! Private derived type for maintaining character ranges for character classes. TYPE RERange tIndex :: Size = 16_kIndex !! Capacity of current range arrays tSInt32 , ALLOCATABLE :: MinRange (:) !! Range minima tSInt32 , ALLOCATABLE :: MaxRange (:) !! Range maxima tSInt32 :: Num = 0 !! Number of range array elements in use CONTAINS PROCEDURE :: RERange_Include1 PROCEDURE :: RERange_Include2 PROCEDURE :: Initialize => RERange_Initialize PROCEDURE :: Delete => RERange_Delete PROCEDURE :: Merge => RERange_Merge PROCEDURE :: Remove => RERange_Remove GENERIC :: Include => RERange_Include1 , RERange_Include2 END TYPE !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !------------------------------------------------------------------------------- !                           RECompiler Procedures !------------------------------------------------------------------------------- SUBROUTINE RECompiler_Initialize ( Compiler ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the RECompiler object.  Creates (initially empty) storage !  for a regular expression program. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( OUT ) :: Compiler !! RECompiler object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! Start off with a generous, yet reasonable, initial size IF ( ALLOCATED ( Compiler % instruction )) DEALLOCATE ( Compiler % instruction ) ALLOCATE ( tChar :: Compiler % instruction ( 0 : 127 )) Compiler % lenInstruction = 0 RETURN END SUBROUTINE RECompiler_Initialize !****************************************************************************** SUBROUTINE RECompiler_Ensure ( Compiler , n ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To ensure that n more characters can fit in the program buffer. !  If n more can't fit, then the size is doubled until it can. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( IN ) :: n !! Number of additional characters to ensure will fit !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: curlen ! FLOW ! Get current program length curlen = SIZE ( Compiler % instruction ) ! If the current length + n more is too much IF (( Compiler % lenInstruction + n ) >= curlen ) THEN ! Double the size of the program array until n more will fit DO WHILE (( Compiler % lenInstruction + n ) >= curlen ) curlen = curlen * 2 END DO ! Allocate new program array and move data into it BLOCK tChar , ALLOCATABLE :: newInstruction (:) ALLOCATE ( tChar :: newInstruction ( 0 : curlen - 1 )) newInstruction ( 0 : Compiler % lenInstruction - 1 ) = Compiler % instruction ( 0 :) CALL MOVE_ALLOC ( newInstruction , Compiler % instruction ) END BLOCK END IF RETURN END SUBROUTINE RECompiler_Ensure !****************************************************************************** SUBROUTINE RECompiler_Emit ( Compiler , C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To emit a single character into the program stream. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tChar , INTENT ( IN ) :: C !! Character to add !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! Make room for character CALL Compiler % Ensure ( 1 ) ! Add character Compiler % instruction ( Compiler % lenInstruction ) = C Compiler % lenInstruction = Compiler % lenInstruction + 1 RETURN END SUBROUTINE RECompiler_Emit !****************************************************************************** SUBROUTINE RECompiler_NodeInsert ( Compiler , opcode , opdata , insertAt ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a node with a given opcode and opdata at insertAt.  The node relative !  next pointer is initialized to 0. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tChar , INTENT ( IN ) :: opcode !! Opcode for new node tSInt32 , INTENT ( IN ) :: opdata !! Opdata for new node (only the low 16 bits are currently used) tSInt32 , INTENT ( IN ) :: insertAt !! Index at which to insert the new node in the program !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: Index , ALen , DstBase ! FLOW ! Make room for a new node CALL Compiler % Ensure ( nodeSize ) ! Move everything from insertAt to the end down nodeSize elements ALen = Compiler % lenInstruction - insertAt DstBase = insertAt + nodeSize DO Index = ALen - 1 , 0 , - 1 Compiler % instruction ( DstBase + Index ) = Compiler % instruction ( insertAt + Index ) END DO Compiler % instruction ( insertAt ) = opcode Compiler % instruction ( insertAt + offsetOpdata ) = ToChar ( opdata ) Compiler % instruction ( insertAt + offsetNext ) = ToChar ( 0 ) Compiler % lenInstruction = Compiler % lenInstruction + nodeSize RETURN END SUBROUTINE RECompiler_NodeInsert !****************************************************************************** SUBROUTINE RECompiler_SetNextOfEnd ( Compiler , nodeIn , pointToIn , ErrFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To append a node to the end of a node chain. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( IN ) :: nodeIn !! Start of node chain to traverse tSInt32 , INTENT ( IN ) :: pointToIn !! Node to have the tail of the chain point to tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: next , offset , node , pointTo ! FLOW ErrFlag = FalseVal node = nodeIn pointTo = pointToIn ASSOCIATE ( instruction => Compiler % instruction , lenInstruction => Compiler % lenInstruction ) ! Traverse the chain until the next offset is 0 next = CharCode ( instruction ( node + offsetNext )) ! while the 'node' is not the last in the chain ! and the 'node' is not the last in the program. DO WHILE (( next /= 0 ). AND .( node < lenInstruction )) ! if the node we are supposed to point to is in the chain then ! point to the end of the program instead. ! Michael McCallum <gholam@xtra.co.nz> ! FIXME: This is a _hack_ to stop infinite programs. ! I believe that the implementation of the reluctant matches is wrong but ! have not worked out a better way yet. IF ( node == pointTo ) pointTo = lenInstruction node = node + next next = CharCode ( instruction ( node + offsetNext )) END DO ! if we have reached the end of the program then dont set the pointTo. ! im not sure if this will break any thing but passes all the tests. IF ( node < lenInstruction ) THEN ! Some patterns result in very large programs which exceed ! capacity of the short used for specifying signed offset of the ! next instruction. Example: a{1638} offset = pointTo - node IF ( offset /= ToInt32 ( ToInt16 ( offset ))) THEN CALL Handle_ErrLevel ( 'RECompiler_SetNextOfEnd' , ModName , ErrSevere , & 'Exceeded short jump range.' ) ErrFlag = TrueVal RETURN END IF ! Point the last node in the chain to pointTo. instruction ( node + offsetNext ) = ToChar ( offset ) END IF END ASSOCIATE RETURN END SUBROUTINE RECompiler_SetNextOfEnd !****************************************************************************** FUNCTION RECompiler_Node ( Compiler , opcode , opdata ) RESULT ( Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tChar , INTENT ( IN ) :: opcode !! Opcode for new node tSInt32 , INTENT ( IN ) :: opdata !! Opdata for new node (only the low 16 bits are currently used) tSInt32 :: Index !! Index of new node in program !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! Make room for a new node CALL Compiler % Ensure ( nodeSize ) ASSOCIATE ( instruction => Compiler % instruction , lenInstruction => Compiler % lenInstruction ) ! Add new node at end instruction ( lenInstruction ) = opcode instruction ( lenInstruction + offsetOpdata ) = ToChar ( opdata ) instruction ( lenInstruction + offsetNext ) = ToChar ( 0 ) lenInstruction = lenInstruction + nodeSize ! Return index of new node Index = lenInstruction - nodeSize END ASSOCIATE RETURN END FUNCTION RECompiler_Node !****************************************************************************** SUBROUTINE RECompiler_Bracket ( Compiler , ErrFlag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To match bracket {m,n} expression and put results in bracket member variables. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: Number ! FLOW ErrFlag = FalseVal ASSOCIATE ( pattern => Compiler % pattern , len => Compiler % len , idx => Compiler % idx , & bracketMin => Compiler % bracketMin , bracketOpt => Compiler % bracketOpt ) ! Current character must be a '{' IF (( idx >= len ). OR .( pattern ( idx ) /= CHR_BRACE_LEFT )) THEN idx = idx + 1 CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , 'Internal error!' ) ErrFlag = TrueVal RETURN ELSE idx = idx + 1 END IF ! Next char must be a digit IF (( idx >= len ). OR .(. NOT . Is_Character_Digit ( pattern ( idx )))) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , 'Syntax error: Expected digit' ) ErrFlag = TrueVal RETURN END IF ! Get min ('m' of {m,n}) number CALL Number % CreateEmpty ( InitCap = 256_kIndex ) DO WHILE (( idx < len ). AND .( Is_Character_Digit ( pattern ( idx )))) CALL Number % append ( pattern ( idx )) idx = idx + 1 END DO bracketMin = ParseInteger ( Number % ToCharAlloc ( ClearBuffer = . TRUE .), ErrFlag ) IF ( ErrFlag ) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Expected valid number' ) ErrFlag = TrueVal RETURN END IF ! If out of input, fail IF ( idx >= len ) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Expected comma or right bracket' ) ErrFlag = TrueVal RETURN END IF ! If end of expr, optional limit is 0 IF ( pattern ( idx ) == CHR_BRACE_RIGHT ) THEN idx = idx + 1 bracketOpt = 0 RETURN END IF ! Must have at least {m,} and maybe {m,n}. IF (( idx >= len ). OR .( pattern ( idx ) /= ',' )) THEN idx = idx + 1 CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , 'Syntax error: Expected comma' ) ErrFlag = TrueVal RETURN ELSE idx = idx + 1 END IF ! If out of input, fail IF ( idx >= len ) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Expected comma or right bracket' ) ErrFlag = TrueVal RETURN END IF ! If {m,} max is unlimited IF ( pattern ( idx ) == CHR_BRACE_RIGHT ) THEN idx = idx + 1 bracketOpt = bracketUnbounded RETURN END IF ! Next char must be a digit IF (( idx >= len ). OR .(. NOT . Is_Character_Digit ( pattern ( idx )))) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , 'Syntax error: Expected digit' ) ErrFlag = TrueVal RETURN END IF ! Get max number DO WHILE (( idx < len ). AND . Is_Character_Digit ( pattern ( idx ))) CALL Number % Append ( pattern ( idx )) idx = idx + 1 END DO bracketOpt = ParseInteger ( Number % ToCharAlloc ( ClearBuffer = . TRUE .), ErrFlag ) - bracketMin IF ( ErrFlag ) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Expected valid number' ) ErrFlag = TrueVal RETURN END IF ! Optional repetitions must be >= 0 IF ( bracketOpt < 0 ) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Bad range' ) ErrFlag = TrueVal RETURN END IF ! Must have close brace IF (( idx >= len ). OR .( pattern ( idx ) /= CHR_BRACE_RIGHT )) THEN CALL Handle_ErrLevel ( 'RECompiler_Bracket' , ModName , ErrSevere , & 'Syntax error: Missing close brace' ) ErrFlag = TrueVal END IF idx = idx + 1 END ASSOCIATE RETURN END SUBROUTINE RECompiler_Bracket !****************************************************************************** FUNCTION RECompiler_Escape ( Compiler , ErrFlag ) RESULT ( EspCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To match an escape sequence.  Handles quoted chars and octal escapes as well !  as normal escape characters.  Always advances the input stream by the !  right amount.  This code \"understands\" the subtle difference between an !  octal escape and a backref.  You can access the type of ESC_CLASS or !  ESC_COMPLEX or ESC_BACKREF by looking at pattern(idx-1). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: EspCode !! escape code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: escapeChar , c tSInt32 :: hexDigits , val tCharAlloc :: errMsg ! FLOW ErrFlag = FalseVal ASSOCIATE ( pattern => Compiler % pattern , len => Compiler % len , idx => Compiler % idx ) ! \"Shouldn't\" happen IF ( pattern ( idx ) /= CHR_BACKSLASH ) THEN CALL Handle_ErrLevel ( 'RECompiler_Escape' , ModName , ErrSevere , 'Internal error!' ) ErrFlag = TrueVal RETURN END IF ! Escape shouldn't occur as last character in string! IF ( idx + 1 == len ) THEN CALL Handle_ErrLevel ( 'RECompiler_Escape' , ModName , ErrSevere , & 'Syntax error: Escape terminates string' ) ErrFlag = TrueVal RETURN END IF ! Switch on character after backslash idx = idx + 2 escapeChar = pattern ( idx - 1 ) SELECT CASE ( escapeChar ) CASE ( E_BOUND , E_NBOUND ) EspCode = ESC_COMPLEX CASE ( E_ALNUM , E_NALNUM , E_SPACE , E_NSPACE , E_DIGIT , E_NDIGIT ) EspCode = ESC_CLASS CASE ( 'x' ) ! currently, not handle unicode ! CASE ('u', 'x') ! Exact required hex digits for escape type ! IF (escapeChar == 'u') THEN !    hexDigits = 4 ! ELSE !    hexDigits = 2 ! END IF ! note: the above code block handles unicode hexDigits = 2 ! Parse up to hexDigits characters from input val = 0 DO WHILE (( idx < len ). AND .( hexDigits > 0 )) hexDigits = hexDigits - 1 ! Get char c = pattern ( idx ) ! If it's a hexadecimal digit (0-9) IF (( c >= '0' ). AND .( c <= '9' )) THEN ! Compute new value val = SHIFTL ( val , 4 ) + CharCode ( c ) - CharCode ( '0' ) ELSE ! If it's a hexadecimal letter (a-f) c = ToLowerCase ( c ) IF (( c >= 'a' ). AND .( c <= 'f' )) THEN ! Compute new value val = SHIFTL ( val , 4 ) + ( CharCode ( c ) - CharCode ( 'a' )) + 10 ELSE ! If it's not a valid digit or hex letter, the escape must be invalid ! because hexDigits of input have not been absorbed yet. errMsg = 'Expected ' // ToString ( hexDigits ) // & ' hexadecimal digits after \\' // escapeChar CALL Handle_ErrLevel(' RECompiler_Escape ', ModName, ErrSevere, errMsg) ErrFlag = TrueVal RETURN END IF END IF idx = idx + 1 END DO EspCode = val CASE (' t ') EspCode = CharCode(CHR_TAB) CASE (' n ') EspCode = CharCode(CHR_NEWLINE) CASE (' r ') EspCode = CharCode(CHR_CARRIAGE_RETURN) CASE (' f ') EspCode = CharCode(CHR_FORM_FEED) CASE (' 0 ', ' 1 ', ' 2 ', ' 3 ', ' 4 ', ' 5 ', ' 6 ', ' 7 ', ' 8 ', ' 9 ') ! An octal escape starts with a 0 or has two digits in a row IF (((idx < len).AND.Is_Character_Digit(pattern(idx))).OR.(escapeChar == ' 0 ')) THEN ! Handle \\nnn octal escapes val = CharCode(escapeChar) - CharCode(' 0 ') IF ((idx < len).AND.Is_Character_Digit(pattern(idx))) THEN val = SHIFTL(val, 3) + (CharCode(pattern(idx)) - CharCode(' 0 ')) idx = idx + 1 IF ((idx < len).AND.Is_Character_Digit(pattern(idx))) THEN val = SHIFTL(val, 3) + (CharCode(pattern(idx)) - CharCode(' 0 ')) idx = idx + 1 END IF END IF EspCode = val ELSE ! It' s actually a backreference ( \\ [ 1 - 9 ]), not an escape EspCode = ESC_BACKREF END IF CASE DEFAULT ! Simple quoting of a character EspCode = CharCode ( escapeChar ) END SELECT END ASSOCIATE RETURN END FUNCTION RECompiler_Escape !****************************************************************************** FUNCTION RECompiler_CharacterClass ( Compiler , ErrFlag ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compile a character class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Indx !! Index of class node !** SUBROUTINE ARGUMENT DECLARATIONS: tChar , PARAMETER :: CHAR_INVALID = ToChar ( CharMaxVal ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: errMsg tCharAlloc :: charClass tChar :: c ! FLOW ErrFlag = FalseVal ASSOCIATE ( instruction => Compiler % instruction , pattern => Compiler % pattern , & len => Compiler % len , idx => Compiler % idx ) ! Check for bad calling or empty class IF ( pattern ( idx ) /= CHR_BRACKET_LEFT ) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , 'Internal error!' ) ErrFlag = TrueVal RETURN END IF ! Check for unterminated or empty class idx = idx + 1 IF (( idx >= len ). OR .( pattern ( idx ) == CHR_BRACKET_RIGHT )) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Syntax error: Empty or unterminated class' ) ErrFlag = TrueVal RETURN END IF ! Check for POSIX character class IF (( idx < len ). AND .( pattern ( idx ) == CHR_COLON )) THEN BLOCK tSInt32 :: idxStart ! Skip colon idx = idx + 1 ! POSIX character classes are denoted with lowercase ASCII strings idxStart = idx DO WHILE (( idx < len ). AND .( pattern ( idx ) >= 'a' ). AND .( pattern ( idx ) <= 'z' )) idx = idx + 1 END DO ! Should be a \":]\" to terminate the POSIX character class IF ((( idx + 1 ) < len ). AND .( pattern ( idx ) == CHR_COLON ). AND . & ( pattern ( idx + 1 ) == CHR_BRACKET_RIGHT )) THEN ! Get character class charClass = CharString ( pattern ( idxStart : idx - 1 ), IsCString = FalseVal ) ! Select the POSIX class id C = hashPOSIX_GetChar ( charClass ) IF ( C /= OP_STAR ) THEN ! Move past colon and right bracket idx = idx + 2 ! Return new POSIX character class node Indx = Compiler % Node ( OP_POSIXCLASS , CharCode ( C )) ELSE errMsg = 'Syntax error: Invalid POSIX character class \"' // charClass // '\"' CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , errMsg ) ErrFlag = TrueVal END IF RETURN END IF CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Syntax error: Invalid POSIX character class syntax' ) ErrFlag = TrueVal RETURN END BLOCK END IF ! Try to build a class.  Create OP_ANYOF node Indx = Compiler % Node ( OP_ANYOF , 0 ) ! Parse class declaration BLOCK tChar :: last , simpleChar tLogical :: inc , definingRange tSInt32 :: idxFirst , espcode , I tSInt32 :: rangeStart , rangeEnd TYPE ( RERange ) :: range ! initialize inc = TrueVal definingRange = FalseVal idxFirst = idx rangeStart = CharMinVal CALL range % Initialize () WhileLoop : DO WHILE (( idx < len ). AND .( pattern ( idx ) /= CHR_BRACKET_RIGHT )) ! Switch on character switchOnCharacter : SELECT CASE ( pattern ( idx )) CASE ( CHR_CARET ) inc = . NOT . inc IF ( idx == idxFirst ) THEN CALL range % Include ( CharMinVal , CharMaxVal , TrueVal ) END IF idx = idx + 1 CYCLE WhileLoop CASE ( CHR_BACKSLASH ) ! Escape always advances the stream espcode = Compiler % Escape ( ErrFlag ) IF ( ErrFlag ) RETURN escapeBlock : SELECT CASE ( espcode ) CASE ( ESC_COMPLEX , ESC_BACKREF ) ! Word boundaries and backrefs not allowed in a character class! CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Syntax error: Bad character class' ) ErrFlag = TrueVal RETURN CASE ( ESC_CLASS ) ! Classes can't be an endpoint of a range IF ( definingRange ) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Syntax error: Bad character class' ) ErrFlag = TrueVal RETURN END IF ! Handle specific type of class (some are ok) escapeCharacter : SELECT CASE ( pattern ( idx - 1 )) CASE ( E_NSPACE ) CALL range % Include ( CharMinVal , 7 , inc ) ! [Min - \\b ) CALL range % Include ( ToChar ( 11 ), inc ) ! ( \\n - \\f ) CALL range % Include ( 14 , 31 , inc ) ! ( \\r - ' ') CALL range % Include ( 33 , CharMaxVal , inc ) ! (' ' - Max] EXIT escapeCharacter CASE ( E_NALNUM ) CALL range % Include ( CharMinVal , CharCode ( CHR_SLASH ), inc ) ! [Min - '0') CALL range % Include ( CharCode ( CHR_COLON ), CharCode ( CHR_AT_SIGN ), inc ) ! ('9' - 'A') CALL range % Include ( CharCode ( CHR_BRACKET_LEFT ), CharCode ( CHR_CARET ), inc ) ! ('Z' - '_') CALL range % Include ( CHR_GRAVE_ACCENT , inc ) ! ('_' - 'a') CALL range % Include ( CharCode ( CHR_BRACE_LEFT ), CharMaxVal , inc ) ! ('z' - Max] EXIT escapeCharacter CASE ( E_NDIGIT ) CALL range % Include ( CharMinVal , CharCode ( CHR_SLASH ), inc ) ! [Min - '0') CALL range % Include ( CharCode ( CHR_COLON ), CharMaxVal , inc ) ! ('9' - Max] EXIT escapeCharacter CASE ( E_SPACE ) CALL range % Include ( CHR_TAB , inc ) CALL range % Include ( CHR_CARRIAGE_RETURN , inc ) CALL range % Include ( CHR_FORM_FEED , inc ) CALL range % Include ( CHR_NEWLINE , inc ) CALL range % Include ( CHR_BACKSPACE , inc ) CALL range % Include ( CHR_SPACE , inc ) EXIT escapeCharacter CASE ( E_ALNUM , E_DIGIT ) IF ( pattern ( idx - 1 ) == E_ALNUM ) THEN CALL range % Include ( CharCode ( 'a' ), CharCode ( 'z' ), inc ) CALL range % Include ( CharCode ( 'A' ), CharCode ( 'Z' ), inc ) CALL range % Include ( CHR_UNDERSCORE , inc ) ! Fall through! END IF CALL range % Include ( CharCode ( '0' ), CharCode ( '9' ), inc ) EXIT escapeCharacter END SELECT escapeCharacter ! Make last char invalid (can't be a range start) last = CHAR_INVALID EXIT escapeBlock CASE DEFAULT ! Escape is simple so treat as a simple char simpleChar = ToChar ( espcode ) EXIT switchOnCharacter END SELECT escapeBlock CYCLE WhileLoop CASE ( '-' ) ! Start a range if one isn't already started IF ( definingRange ) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Syntax error: Bad class range' ) ErrFlag = TrueVal RETURN END IF definingRange = TrueVal ! If no last character, start of range is 0 IF ( last == CHAR_INVALID ) THEN rangeStart = 0 ELSE rangeStart = CharCode ( last ) END IF ! Premature end of range% define up to CharMaxVal idx = idx + 1 IF (( idx < len ). AND .( pattern ( idx ) == CHR_BRACKET_RIGHT )) THEN simpleChar = ToChar ( CharMaxVal ) EXIT switchOnCharacter END IF CYCLE WhileLoop CASE DEFAULT simpleChar = pattern ( idx ) idx = idx + 1 EXIT switchOnCharacter END SELECT switchOnCharacter ! Handle simple character simpleChar IF ( definingRange ) THEN ! if we are defining a range make it now rangeEnd = CharCode ( simpleChar ) ! Actually create a range if the range is ok IF ( rangeStart >= rangeEnd ) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Bad character class' ) ErrFlag = TrueVal RETURN END IF CALL range % Include ( rangeStart , rangeEnd , inc ) ! We are done defining the range last = CHAR_INVALID definingRange = FalseVal ELSE ! If simple character and not start of range, include it IF (( idx >= len ). OR .( pattern ( idx ) /= '-' )) THEN CALL range % Include ( simpleChar , inc ) END IF last = simpleChar END IF END DO WhileLoop ! Shouldn't be out of input IF ( idx == len ) THEN CALL Handle_ErrLevel ( 'RECompiler_CharacterClass' , ModName , ErrSevere , & 'Unterminated character class' ) ErrFlag = TrueVal RETURN END IF ! Absorb the ']' end of class marker idx = idx + 1 ! Emit character class definition instruction ( Indx + offsetOpdata ) = ToChar ( range % num ) DO I = 0 , range % num - 1 CALL Compiler % Emit ( ToChar ( range % minRange ( I ))) CALL Compiler % Emit ( ToChar ( range % maxRange ( I ))) END DO END BLOCK END ASSOCIATE RETURN END FUNCTION RECompiler_CharacterClass !****************************************************************************** FUNCTION RECompiler_Atom ( Compiler , ErrFlag ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To absorb an atomic character string.  This method is a little tricky because !  it can un-include the last character of string if a closure operator follows. !  This is correct because *+? have higher precedence than concatentation (thus !  ABC* means AB(C*) and NOT (ABC)*). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Indx !! Index of new atom node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: lenAtom , idxEscape , idxBeforeEscape , espcode tChar :: c ! FLOW ErrFlag = FalseVal ! Create a string node Indx = Compiler % Node ( OP_ATOM , 0 ) ! Length of atom lenAtom = 0 ASSOCIATE ( instruction => Compiler % instruction , pattern => Compiler % pattern , & len => Compiler % len , idx => Compiler % idx ) ! Loop while we've got input atomLoop : DO WHILE ( idx < len ) ! Is there a next char? IF (( idx + 1 ) < len ) THEN c = pattern ( idx + 1 ) ! If the next 'char' is an escape, look past the whole escape IF ( pattern ( idx ) == CHR_BACKSLASH ) THEN idxEscape = idx espcode = Compiler % Escape ( ErrFlag ) IF ( ErrFlag ) RETURN IF ( idx < len ) THEN c = pattern ( idx ) END IF idx = idxEscape END IF ! Switch on next char SELECT CASE ( c ) CASE ( CHR_BRACE_LEFT , CHR_QUESTION_MARK , CHR_ASTERISK , CHR_PLUS_SIGN ) ! If the next character is a closure operator and our atom is non-empty, the ! current character should bind to the closure operator rather than the atom IF ( lenAtom /= 0 ) THEN EXIT atomLoop END IF END SELECT END IF ! Switch on current char SELECT CASE ( pattern ( idx )) CASE ( CHR_BRACKET_RIGHT , CHR_CARET , CHR_DOLLAR_SIGN , CHR_PERIOD , CHR_BRACKET_LEFT , & CHR_PARENTHESES_LEFT , CHR_PARENTHESES_RIGHT , CHR_VERTICAL_BAR ) EXIT atomLoop CASE ( CHR_BRACE_LEFT , CHR_QUESTION_MARK , CHR_ASTERISK , CHR_PLUS_SIGN ) ! We should have an atom by now IF ( lenAtom == 0 ) THEN ! No atom before closure CALL Handle_ErrLevel ( 'RECompiler_Atom' , ModName , ErrSevere , & 'Syntax error: Missing operand to closure' ) ErrFlag = TrueVal RETURN END IF EXIT atomLoop CASE ( CHR_BACKSLASH ) ! Get the escaped character (advances input automatically) idxBeforeEscape = idx espcode = Compiler % Escape ( ErrFlag ) IF ( ErrFlag ) RETURN ! Check if it's a simple escape (as opposed to, say, a backreference) IF ( IAND ( espcode , ESC_MASK ) == ESC_MASK ) THEN ! Not a simple escape, so backup to where we were before the escape. idx = idxBeforeEscape EXIT atomLoop END IF ! Add escaped char to atom CALL Compiler % Emit ( ToChar ( espcode )) lenAtom = lenAtom + 1 CASE DEFAULT ! Add normal character to atom CALL Compiler % Emit ( pattern ( idx )) idx = idx + 1 lenAtom = lenAtom + 1 END SELECT END DO atomLoop ! This \"shouldn't\" happen IF ( lenAtom == 0 ) THEN CALL Handle_ErrLevel ( 'RECompiler_Atom' , ModName , ErrSevere , 'Internal error!' ) ErrFlag = TrueVal RETURN END IF ! Emit the atom length into the program instruction ( Indx + offsetOpdata ) = ToChar ( lenAtom ) END ASSOCIATE RETURN END FUNCTION RECompiler_Atom !****************************************************************************** FUNCTION RECompiler_Terminal ( Compiler , Flags , ErrFlag ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To match a terminal node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( INOUT ) :: Flags ( 0 :) !! flags tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Indx !! Index of terminal node (closeable) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ErrFlag = FalseVal ASSOCIATE ( pattern => Compiler % pattern , idx => Compiler % idx , parens => Compiler % parens ) SELECT CASE ( pattern ( idx )) CASE ( OP_EOL , OP_BOL , OP_ANY ) Indx = Compiler % Node ( pattern ( idx ), 0 ) idx = idx + 1 RETURN CASE ( OP_ANYOF ) Indx = Compiler % CharacterClass ( ErrFlag ) RETURN CASE ( OP_OPEN ) Indx = Compiler % Expression ( Flags , ErrFlag ) RETURN CASE ( OP_CLOSE ) CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , & 'Syntax error: Unexpected close parentheses' ) ErrFlag = TrueVal RETURN CASE ( OP_BRANCH ) CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , 'Internal error!' ) ErrFlag = TrueVal RETURN CASE ( CHR_BRACKET_RIGHT ) CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , & 'Syntax error: Mismatched class' ) ErrFlag = TrueVal RETURN CASE ( ToChar ( 0 )) CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , & 'Syntax error: Unexpected end of input' ) ErrFlag = TrueVal RETURN CASE ( OP_MAYBE , OP_PLUS , OP_STAR , CHR_BRACE_LEFT ) CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , & 'Syntax error: Missing operand to closure' ) ErrFlag = TrueVal RETURN CASE ( OP_ESCAPE ) BLOCK tSInt32 :: idxBeforeEscape , espCode , backreference ! Don't forget, escape() advances the input stream! idxBeforeEscape = idx espCode = Compiler % Escape ( ErrFlag ) IF ( ErrFlag ) RETURN ! Switch on escaped character SELECT CASE ( espCode ) CASE ( ESC_CLASS , ESC_COMPLEX ) Flags ( 0 ) = IAND ( Flags ( 0 ), NOT ( NODE_NULLABLE )) Indx = Compiler % Node ( OP_ESCAPE , CharCode ( pattern ( idx - 1 ))) RETURN CASE ( ESC_BACKREF ) backreference = CharCode ( pattern ( idx - 1 )) - CharCode ( '0' ) IF ( parens <= backreference ) THEN CALL Handle_ErrLevel ( 'RECompiler_Terminal' , ModName , ErrSevere , & 'Syntax error: Bad backreference' ) ErrFlag = TrueVal RETURN END IF Flags ( 0 ) = IOR ( Flags ( 0 ), NODE_NULLABLE ) Indx = Compiler % Node ( OP_BACKREF , backreference ) RETURN CASE DEFAULT ! We had a simple escape and we want to have it end up in ! an atom, so we back up and fall though to the default handling idx = idxBeforeEscape Flags ( 0 ) = IAND ( Flags ( 0 ), NOT ( NODE_NULLABLE )) END SELECT END BLOCK END SELECT ! Everything above either fails or returns. ! If it wasn't one of the above, it must be the start of an atom. Flags ( 0 ) = IAND ( Flags ( 0 ), NOT ( NODE_NULLABLE )) Indx = Compiler % Atom ( ErrFlag ) END ASSOCIATE RETURN END FUNCTION RECompiler_Terminal !****************************************************************************** FUNCTION RECompiler_Closure ( Compiler , Flags , ErrFlag ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compile a possibly closured terminal. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( INOUT ) :: Flags ( 0 :) !! flags tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Indx !! Index of closured node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: idxBeforeTerminal , n tSInt32 :: terminalFlags ( 0 : 0 ) tLogical :: greedy tChar :: opcode , closureType ! FLOW ErrFlag = FalseVal ASSOCIATE ( instruction => Compiler % instruction , lenInstruction => Compiler % lenInstruction , & pattern => Compiler % pattern , len => Compiler % len , idx => Compiler % idx ) ! Before terminal idxBeforeTerminal = idx ! Values to pass by reference to Compiler%Terminal() terminalFlags = NODE_NORMAL ! Get terminal symbol Indx = Compiler % Terminal ( terminalFlags , ErrFlag ) IF ( ErrFlag ) RETURN ! Or in flags from terminal symbol flags ( 0 ) = IOR ( flags ( 0 ), terminalFlags ( 0 )) ! Advance input, set NODE_NULLABLE flag and do sanity checks IF ( idx >= len ) RETURN greedy = TrueVal closureType = pattern ( idx ) SELECT CASE ( closureType ) CASE ( OP_MAYBE , OP_STAR , OP_PLUS , CHR_BRACE_LEFT ) IF (( closureType == OP_MAYBE ). OR .( closureType == OP_STAR )) THEN ! The current node can be null flags ( 0 ) = IOR ( flags ( 0 ), NODE_NULLABLE ) END IF IF ( closureType /= CHR_BRACE_LEFT ) THEN ! Eat closure character idx = idx + 1 END IF ! Don't allow blantant stupidity opcode = instruction ( Indx ) IF (( opcode == OP_BOL ). OR .( opcode == OP_EOL )) THEN CALL Handle_ErrLevel ( 'RECompiler_Closure' , ModName , ErrSevere , & 'Syntax error: Bad closure operand' ) ErrFlag = TrueVal RETURN END IF IF ( IAND ( terminalFlags ( 0 ), NODE_NULLABLE ) /= 0 ) THEN CALL Handle_ErrLevel ( 'RECompiler_Closure' , ModName , ErrSevere , & \"Syntax error: Closure operand can't be nullable\" ) ErrFlag = TrueVal RETURN END IF END SELECT ! If the next character is a '?', make the closure non-greedy (reluctant) IF (( idx < len ). AND .( pattern ( idx ) == OP_MAYBE )) THEN idx = idx + 1 greedy = FalseVal END IF IF ( greedy ) THEN ! Actually do the closure now GreedyClosure : SELECT CASE ( closureType ) CASE ( CHR_BRACE_LEFT ) CALL Compiler % Bracket ( ErrFlag ) IF ( ErrFlag ) RETURN BLOCK tSInt32 :: bracketEnd , bracketMin , bracketOpt tSInt32 :: dummy , pos , c , nextpos ! initialize bracketEnd = idx bracketMin = Compiler % bracketMin bracketOpt = Compiler % bracketOpt ! Pointer to the last terminal pos = Indx ! Process min first DO c = 1 , bracketMin - 1 ! Rewind stream and run it through again - more matchers coming idx = idxBeforeTerminal nextpos = Compiler % Terminal ( terminalFlags , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( pos , nextpos , ErrFlag ) IF ( ErrFlag ) RETURN pos = nextpos END DO ! Do the right thing for maximum ({m,}) IF ( bracketOpt == bracketUnbounded ) THEN ! Drop through now and closure expression. ! We are done with the {m,} expr, so skip rest idx = bracketEnd CALL Compiler % NodeInsert ( OP_STAR , 0 , pos ) CALL Compiler % SetNextOfEnd ( pos + nodeSize , pos , ErrFlag ) IF ( ErrFlag ) RETURN EXIT GreedyClosure ELSEIF ( bracketOpt > 0 ) THEN BLOCK tSInt32 :: opt ( 0 : bracketOpt ) tSInt32 :: endpos ! Surround first optional terminal with MAYBE CALL Compiler % NodeInsert ( OP_MAYBE , 0 , pos ) opt ( 0 ) = pos ! Add all the rest optional terminals with preceeding MAYBEs !for (int c = 1 c < bracketOpt c++) DO c = 1 , bracketOpt - 1 opt ( c ) = Compiler % Node ( OP_MAYBE , 0 ) ! Rewind stream and run it through again - more matchers coming idx = idxBeforeTerminal dummy = Compiler % Terminal ( terminalFlags , ErrFlag ) IF ( ErrFlag ) RETURN END DO ! Tie ends together opt ( bracketOpt ) = Compiler % Node ( OP_NOTHING , 0 ) endpos = opt ( bracketOpt ) !for (int c = 0 c < bracketOpt c++) DO c = 0 , bracketOpt - 1 CALL Compiler % SetNextOfEnd ( opt ( c ), endpos , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( opt ( c ) + nodeSize , opt ( c + 1 ), ErrFlag ) IF ( ErrFlag ) RETURN END DO END BLOCK ELSE ! Rollback terminal - no opt matchers present lenInstruction = pos dummy = Compiler % Node ( OP_NOTHING , 0 ) END IF ! We are done. skip the reminder of {m,n} expr idx = bracketEnd !EXIT GreedyClosure END BLOCK CASE ( OP_MAYBE ) CALL Compiler % NodeInsert ( OP_MAYBE , 0 , Indx ) n = Compiler % Node ( OP_NOTHING , 0 ) CALL Compiler % SetNextOfEnd ( Indx , n , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( Indx + nodeSize , n , ErrFlag ) !IF (ErrFlag) RETURN !EXIT GreedyClosure CASE ( OP_STAR ) CALL Compiler % NodeInsert ( OP_STAR , 0 , Indx ) CALL Compiler % SetNextOfEnd ( Indx + nodeSize , Indx , ErrFlag ) !IF (ErrFlag) RETURN !EXIT GreedyClosure CASE ( OP_PLUS ) CALL Compiler % NodeInsert ( OP_CONTINUE , 0 , Indx ) n = Compiler % Node ( OP_PLUS , 0 ) CALL Compiler % SetNextOfEnd ( Indx + nodeSize , n , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( n , Indx , ErrFlag ) !IF (ErrFlag) RETURN !EXIT GreedyClosure END SELECT GreedyClosure ELSE ! Actually do the closure now SELECT CASE ( closureType ) CASE ( OP_MAYBE ) CALL Compiler % NodeInsert ( OP_RELUCTANTMAYBE , 0 , Indx ) n = Compiler % Node ( OP_NOTHING , 0 ) CALL Compiler % SetNextOfEnd ( Indx , n , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( Indx + nodeSize , n , ErrFlag ) !IF (ErrFlag) RETURN CASE ( OP_STAR ) CALL Compiler % NodeInsert ( OP_RELUCTANTSTAR , 0 , Indx ) CALL Compiler % SetNextOfEnd ( Indx + nodeSize , Indx , ErrFlag ) !IF (ErrFlag) RETURN CASE ( OP_PLUS ) CALL Compiler % NodeInsert ( OP_CONTINUE , 0 , Indx ) n = Compiler % Node ( OP_RELUCTANTPLUS , 0 ) CALL Compiler % SetNextOfEnd ( n , Indx , ErrFlag ) IF ( ErrFlag ) RETURN CALL Compiler % SetNextOfEnd ( Indx + nodeSize , n , ErrFlag ) !IF (ErrFlag) RETURN END SELECT END IF END ASSOCIATE RETURN END FUNCTION RECompiler_Closure !****************************************************************************** FUNCTION RECompiler_Branch ( Compiler , Flags , ErrFlag ) RESULT ( Ptr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compile body of one branch of an or operator (implements concatenation). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( INOUT ) :: Flags ( 0 :) !! flags tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Ptr !! pointer to first node in the branch !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: node , chain , closureFlags ( 0 : 0 ) tLogical :: nullable ! FLOW ErrFlag = FalseVal ASSOCIATE ( pattern => Compiler % pattern , idx => Compiler % idx , len => Compiler % len ) ! Get each possibly closured piece and concat Ptr = - 1 chain = - 1 nullable = TrueVal DO WHILE (( idx < len ). AND .( pattern ( idx ) /= OP_BRANCH ). AND .( pattern ( idx ) /= OP_CLOSE )) ! Get new node closureFlags ( 0 ) = NODE_NORMAL node = Compiler % Closure ( closureFlags , ErrFlag ) IF ( ErrFlag ) RETURN IF ( closureFlags ( 0 ) == NODE_NORMAL ) nullable = FalseVal ! If there's a chain, append to the end IF ( chain /= - 1 ) THEN CALL Compiler % SetNextOfEnd ( chain , node , ErrFlag ) IF ( ErrFlag ) RETURN END IF ! Chain starts at current chain = node IF ( Ptr == - 1 ) Ptr = node END DO ! If we don't run loop, make a nothing node IF ( Ptr == - 1 ) Ptr = Compiler % Node ( OP_NOTHING , 0 ) ! Set nullable flag for this branch IF ( nullable ) Flags ( 0 ) = IOR ( Flags ( 0 ), NODE_NULLABLE ) END ASSOCIATE RETURN END FUNCTION RECompiler_Branch !****************************************************************************** FUNCTION RECompiler_Expression ( Compiler , Flags , ErrFlag ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compile an expression with possible parentheses around it.  Parentheses !  matching is done at this level so we can tie the branch tails together. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tSInt32 , INTENT ( INOUT ) :: Flags ( 0 :) !! flags tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred tSInt32 :: Indx !! index of expression in instruction array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: paren , closeParens , branch , nextBranch tSInt32 :: end , currentNode , nextNodeOffset , dummy tLogical :: open ! FLOW ErrFlag = FalseVal ASSOCIATE ( parens => Compiler % parens , instruction => Compiler % instruction , lenInstruction => Compiler % lenInstruction , & pattern => Compiler % pattern , len => Compiler % len , idx => Compiler % idx ) ! Create open paren node unless we were called from the top level (which has no parens) paren = - 1 Indx = - 1 closeParens = parens IF (( IAND ( Flags ( 0 ), NODE_TOPLEVEL ) == 0 ). AND .( pattern ( idx ) == OP_OPEN )) THEN ! if its a cluster ( rather than a proper subexpression ie with backrefs ) IF (( idx + 2 < len ). AND .( pattern ( idx + 1 ) == OP_MAYBE ). AND . & ( pattern ( idx + 2 ) == CHR_COLON )) THEN paren = 2 idx = idx + 3 Indx = Compiler % Node ( OP_OPEN_CLUSTER , 0 ) ELSE paren = 1 idx = idx + 1 Indx = Compiler % Node ( OP_OPEN , parens ) parens = parens + 1 END IF END IF Flags ( 0 ) = IAND ( Flags ( 0 ), NOT ( NODE_TOPLEVEL )) ! Process contents of first branch node open = FalseVal branch = Compiler % Branch ( Flags , ErrFlag ) IF ( ErrFlag ) RETURN IF ( Indx == - 1 ) THEN Indx = branch ELSE CALL Compiler % SetNextOfEnd ( Indx , branch , ErrFlag ) IF ( ErrFlag ) RETURN END IF ! Loop through branches DO WHILE (( idx < len ). AND .( pattern ( idx ) == OP_BRANCH )) ! Now open the first branch since there are more than one IF (. NOT . open ) THEN CALL Compiler % NodeInsert ( OP_BRANCH , 0 , branch ) open = TrueVal END IF idx = idx + 1 nextBranch = Compiler % Node ( OP_BRANCH , 0 ) CALL Compiler % SetNextOfEnd ( branch , nextBranch , ErrFlag ) IF ( ErrFlag ) RETURN branch = nextBranch dummy = Compiler % Branch ( Flags , ErrFlag ) IF ( ErrFlag ) RETURN END DO ! Create an ending node (either a close paren or an OP_END) IF ( paren > 0 ) THEN IF (( idx < len ). AND .( pattern ( idx ) == OP_CLOSE )) THEN idx = idx + 1 ELSE CALL Handle_ErrLevel ( 'RECompiler_Expression' , ModName , ErrSevere , & 'Syntax error: Missing close paren' ) ErrFlag = TrueVal RETURN END IF IF ( paren == 1 ) THEN end = Compiler % Node ( OP_CLOSE , closeParens ) ELSE end = Compiler % Node ( OP_CLOSE_CLUSTER , 0 ) END IF ELSE end = Compiler % Node ( OP_END , 0 ) END IF ! Append the ending node to the Indx nodelist CALL Compiler % SetNextOfEnd ( Indx , end , ErrFlag ) IF ( ErrFlag ) RETURN ! Hook the ends of each branch to the end node currentNode = Indx nextNodeOffset = CharCode ( instruction ( currentNode + offsetNext )) ! while the next node o DO WHILE (( nextNodeOffset /= 0 ). AND .( currentNode < lenInstruction )) ! If branch, make the end of the branch's operand chain point to the end node. IF ( instruction ( currentNode ) == OP_BRANCH ) THEN CALL Compiler % SetNextOfEnd ( currentNode + nodeSize , end , ErrFlag ) IF ( ErrFlag ) RETURN END IF nextNodeOffset = CharCode ( instruction ( currentNode + offsetNext )) currentNode = currentNode + nextNodeOffset END DO ! Return the node list END ASSOCIATE RETURN END FUNCTION RECompiler_Expression !****************************************************************************** FUNCTION RECompiler_Compile ( Compiler , RegexPat , ErrFlag ) RESULT ( PG ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compile a regular expression pattern into a program runnable by the pattern !  matcher class 'REMatcher'. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RECompiler ), INTENT ( INOUT ) :: Compiler !! RECompiler object tCharStar , INTENT ( IN ) :: RegexPat !! regular expression pattern tLogical , INTENT ( OUT ) :: ErrFlag !! true if error occurred TYPE ( REProgram ) :: PG !! REProgram object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: flags ( 0 : 0 ), dummy , I ! FLOW ! Initialize variables for compilation CALL Compiler % Initialize () Compiler % len = LEN ( RegexPat ) ! Precompute pattern length for speed ! Save pattern in instance variable IF ( ALLOCATED ( Compiler % pattern )) DEALLOCATE ( Compiler % pattern ) ALLOCATE ( tChar :: Compiler % pattern ( 0 : Compiler % len - 1 )) DO i = 1 , Compiler % len Compiler % pattern ( i - 1 ) = RegexPat ( i : i ) END DO Compiler % idx = 0 ! Set parsing index to the first character Compiler % lenInstruction = 0 ! Set emitted instruction count to zero Compiler % parens = 1 ! Set paren level to 1 (the implicit outer parens) ErrFlag = FalseVal ASSOCIATE ( instruction => Compiler % instruction , lenInstruction => Compiler % lenInstruction , & pattern => Compiler % pattern , len => Compiler % len , idx => Compiler % idx , & parens => Compiler % parens ) ! Initialize pass by reference flags value flags = NODE_TOPLEVEL ! Parse expression dummy = Compiler % Expression ( flags , ErrFlag ) IF ( ErrFlag ) RETURN ! Should be at end of input IF ( idx /= len ) THEN IF ( pattern ( idx ) == OP_CLOSE ) THEN CALL Handle_ErrLevel ( 'RECompiler_Compile' , ModName , ErrSevere , & 'Syntax error: Unmatched close paren' ) ELSE CALL Handle_ErrLevel ( 'RECompiler_Compile' , ModName , ErrSevere , & 'Syntax error: Unexpected input remains' ) END IF ErrFlag = TrueVal RETURN END IF ! Return the result CALL PG % Construct ( instruction ( 0 : lenInstruction - 1 ), parens ) END ASSOCIATE RETURN END FUNCTION RECompiler_Compile !------------------------------------------------------------------------------- !                           RERange Procedures !------------------------------------------------------------------------------- SUBROUTINE RERange_Initialize ( Range ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the RERange object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( OUT ) :: Range ! RERange object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Range % Size = 16_kIndex Range % Num = 0 CALL MemAlloc ( Range % MinRange , Range % Size , StartID = 0_kIndex ) CALL MemAlloc ( Range % MaxRange , Range % Size , StartID = 0_kIndex ) Range % MinRange = 0 Range % MaxRange = 0 RETURN END SUBROUTINE RERange_Initialize !****************************************************************************** SUBROUTINE RERange_Delete ( Range , Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete the range at a given index from the range lists. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( INOUT ) :: Range ! RERange object tSInt32 , INTENT ( IN ) :: Index ! Index of range to delete from minRange and maxRange arrays !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I ! FLOW I = Index ASSOCIATE ( num => Range % Num , minRange => Range % MinRange , maxRange => Range % MaxRange ) ! Return if no elements left or index is out of range IF (( num == 0 ). OR .( I >= num )) RETURN ! Move elements down I = I + 1 DO WHILE ( I < num ) IF (( I - 1 ) >= 0 ) THEN minRange ( I - 1 ) = minRange ( I ) maxRange ( I - 1 ) = maxRange ( I ) END IF I = I + 1 END DO ! One less element now num = num - 1 END ASSOCIATE RETURN END SUBROUTINE RERange_Delete !****************************************************************************** SUBROUTINE RERange_Merge ( Range , Min , Max ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To merge a range into the range list, coalescing ranges if possible. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( INOUT ) :: Range ! RERange object tSInt32 , INTENT ( IN ) :: Min ! Minimum end of range tSInt32 , INTENT ( IN ) :: Max ! Maximum end of range !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I ! FLOW ASSOCIATE ( num => Range % Num , minRange => Range % MinRange , maxRange => Range % MaxRange ) ! Loop through ranges DO I = 0 , num - 1 ! Min-max is subsumed by minRange(I)-maxRange(I) IF (( min >= minRange ( I )). AND .( max <= maxRange ( I ))) THEN RETURN ! Min-max subsumes minRange(I)-maxRange(I) ELSEIF (( min <= minRange ( I )). AND .( max >= maxRange ( I ))) THEN CALL Range % Delete ( I ) CALL Range % Merge ( min , max ) RETURN ! Min is in the range, but max is outside ELSEIF (( min >= minRange ( I )). AND .( min <= maxRange ( I ))) THEN BLOCK tSInt32 :: newMin newMin = minRange ( I ) CALL Range % Delete ( I ) CALL Range % Merge ( newMin , max ) END BLOCK RETURN ! Max is in the range, but min is outside ELSEIF (( max >= minRange ( I )). AND .( max <= maxRange ( I ))) THEN BLOCK tSInt32 :: newMax newMax = maxRange ( I ) CALL Range % Delete ( I ) CALL Range % Merge ( min , newMax ) END BLOCK RETURN END IF END DO END ASSOCIATE ! Must not overlap any other ranges IF ( Range % Num >= Range % Size ) THEN BLOCK tSInt32 , ALLOCATABLE :: newMin (:), newMax (:) Range % Size = Range % Size * 2_kIndex CALL MemAlloc ( newMin , Range % Size , StartID = 0_kIndex ) CALL MemAlloc ( newMax , Range % Size , StartID = 0_kIndex ) newMin ( 0 : Range % Num - 1 ) = Range % MinRange ( 0 : Range % Num - 1 ) newMax ( 0 : Range % Num - 1 ) = Range % MaxRange ( 0 : Range % Num - 1 ) newMin ( Range % Num :) = 0 newMax ( Range % Num :) = 0 CALL MOVE_ALLOC ( newMin , Range % MinRange ) CALL MOVE_ALLOC ( newMax , Range % MaxRange ) END BLOCK END IF Range % MinRange ( Range % Num ) = min Range % MaxRange ( Range % Num ) = max Range % Num = Range % Num + 1 RETURN END SUBROUTINE RERange_Merge !****************************************************************************** SUBROUTINE RERange_Remove ( Range , Min , Max ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a range by deleting or shrinking all other ranges. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( INOUT ) :: Range ! RERange object tSInt32 , INTENT ( IN ) :: Min ! Minimum end of range tSInt32 , INTENT ( IN ) :: Max ! Maximum end of range !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I ! FLOW ASSOCIATE ( num => Range % Num , minRange => Range % MinRange , maxRange => Range % MaxRange ) ! Loop through ranges DO I = 0 , num - 1 ! minRange(I)-maxRange(I) is subsumed by min-max IF (( minRange ( I ) >= min ). AND .( maxRange ( I ) <= max )) THEN CALL Range % Delete ( I ) RETURN ! min-max is subsumed by minRange(I)-maxRange(I) ELSEIF (( min >= minRange ( I )). AND .( max <= maxRange ( I ))) THEN BLOCK tSInt32 :: minr , maxr minr = minRange ( I ) maxr = maxRange ( I ) CALL Range % Delete ( I ) IF ( minr < min ) CALL Range % Merge ( minr , min - 1 ) IF ( max < maxr ) CALL Range % Merge ( max + 1 , maxr ) END BLOCK RETURN ! minRange is in the range, but maxRange is outside ELSEIF (( minRange ( I ) >= min ). AND .( minRange ( I ) <= max )) THEN minRange ( I ) = max + 1 RETURN ! maxRange is in the range, but minRange is outside ELSEIF (( maxRange ( I ) >= min ). AND .( maxRange ( I ) <= max )) THEN maxRange ( I ) = min - 1 RETURN END IF END DO END ASSOCIATE RETURN END SUBROUTINE RERange_Remove !****************************************************************************** SUBROUTINE RERange_Include1 ( Range , Min , Max , Inc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To include (or excludes) the range from min to max, inclusive. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( INOUT ) :: Range ! RERange object tSInt32 , INTENT ( IN ) :: Min ! Minimum end of range tSInt32 , INTENT ( IN ) :: Max ! Maximum end of range tLogical , INTENT ( IN ) :: Inc ! True if range should be included.  False otherwise. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Inc ) THEN CALL Range % Merge ( Min , Max ) ELSE CALL Range % Remove ( Min , Max ) END IF RETURN END SUBROUTINE RERange_Include1 !****************************************************************************** SUBROUTINE RERange_Include2 ( Range , MinMax , Inc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To include a range with the same min and max. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RERange ), INTENT ( INOUT ) :: Range ! RERange object tChar , INTENT ( IN ) :: MinMax ! Minimum and maximum end of range (inclusive) tLogical , INTENT ( IN ) :: Inc ! True if range should be included.  False otherwise. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Range % Include ( CharCode ( MinMax ), CharCode ( MinMax ), Inc ) RETURN END SUBROUTINE RERange_Include2 !****************************************************************************** END MODULE MClass_RECompiler !******************************************************************************","tags":"","loc":"sourcefile\\mclass_recompiler.f90.html"},{"title":"MClass_Alphabets.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_Alphabets !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains various *alphabet* data types and its related routines. !   An *alphabet* data type is a data type for a given alphabet, which is a set !   of characters.  It is intended to be used with string-processing code that !   must convert between an alphabet of size Radix and the integers (i.e. indices) !   through 1 through Radix. <br> !   The following *concrete alphabet* data types are provided. <br> !   - The *GenericAlphabet* type for any alphabet (i.e. any set of characters). <br> !   - The *BinaryAlphabet* type for binary alphabet {0, 1}. <br> !   - The *OctalAlphabet* type for octal alphabet {0, 1, 2, 3, 4, 5, 6, 7}. <br> !   - The *DecimalAlphabet* type for decimal alphabet {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}. <br> !   - The *HexadecimalAlphabet* type for hexadecimal alphabet !     {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F}. <br> !   - The *DnaAlphabet* type for DNA alphabet {A, C, T, G}. <br> !   - The *ProteinAlphabet* type for protein alphabet !     {A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y}. <br> !   - The *LowercaseAlphabet* type for lowercase alphabet {a, b, c, ..., z}. <br> !   - The *UppercaseAlphabet* type for uppercase alphabet {A, B, C, ..., Z}. <br> !   - The *Base64Alphabet* type for base-64 alphabet {64 characters}. <br> !   - The *Code39Alphabet* type for binary alphabet {43+1 characters}. <br> !   - The *AsciiAlphabet* type for ASCII alphabet {128 characters}. <br> !   - The *ExtendedAsciiAlphabet* type for extended ASCII alphabet {256 characters}. <br> !   All *alphabet* data types provide common operations including: <br> !   - the *Construct* method to create the instance of the alphabet data type, <br> !   - the *Contain* method to check whether the specified character is in the alphabet's !     set of characters, <br> !   - the *Verify* method to check whether all characters of the specified word are in !     the alphabet's set of characters, <br> !   - the *GetRadix* method to get the number of characters in the alphabet's set, <br> !   - the *GetIndex* method to get the index corresponding to the specified character, and <br> !   - the *GetChar* method to get the character corresponding to the specified index. <br> !   All *concrete alphabet* data types provided require an explicit construction before !   other operations can be used.  The *GenericAlphabet* type can be constructed from !   either a given set of characters or a specified radix (which represents a number of !   characters in the set where the characters's code ranges from 0 to radix-1).  Other !   types requires no argument (besides the object itself) for their construction method. <br> !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../MacroDef/Macro - Util Definitions.f90\" !** USE STATEMENTS: USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : CHARACTER_STORAGE_SIZE USE MBase_Common USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx64Bits USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_DJB #else USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_DJB #endif USE MClass_Object USE MClass_Comparable USE MClass_IntrusiveBSTrees USE MClass_IntrusiveHashTree USE MClass_FvlStr IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseAlphabet PUBLIC :: GenericAlphabet PUBLIC :: BinaryAlphabet PUBLIC :: OctalAlphabet PUBLIC :: DecimalAlphabet PUBLIC :: HexadecimalAlphabet PUBLIC :: DnaAlphabet PUBLIC :: ProteinAlphabet PUBLIC :: LowercaseAlphabet PUBLIC :: UppercaseAlphabet PUBLIC :: Base64Alphabet PUBLIC :: Code39Alphabet PUBLIC :: AsciiAlphabet PUBLIC :: ExtendedAsciiAlphabet PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_Alphabet' tIndex , PARAMETER :: MsgLen = 128_kIndex tIndex , PARAMETER :: MaxRadix = 256_kIndex ! extended ASCII ! The number of bits used by 8-bit integer tSInt32 , PARAMETER :: Bits_kInt8 = BIT_SIZE ( 0_kInt8 ) ! should be  8 bits ! The numbers of bits/bytes used by a character tSInt32 , PARAMETER :: Bits_Char = CHARACTER_STORAGE_SIZE tIndex , PARAMETER :: Bytes_Char = ToIndex ( Bits_Char / Bits_kInt8 ) !---------------------------------------------------------------------------- !                           Common Sets of Characters !---------------------------------------------------------------------------- !% The binary alphabet [0, 1]. tCharParam :: BinaryCharset = '01' !% The octal alphabet [0, 1, 2, 3, 4, 5, 6, 7]. tCharParam :: OctalCharset = '01234567' !% The decimal alphabet [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]. tCharParam :: DecimalCharset = '0123456789' !% The hexadecimal alphabet [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F]. tCharParam :: HexadecimalCharset = '0123456789ABCDEF' !% The DNA alphabet [A, C, T, G] tCharParam :: DnaCharset = 'ACGT' !% The protein alphabet [A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y]. tCharParam :: ProteinCharset = 'ACDEFGHIKLMNPQRSTVWY' !% The lowercase alphabet [a, b, c, ..., z]. tCharParam :: LowercaseCharset = 'abcdefghijklmnopqrstuvwxyz' !% The uppercase alphabet [A, B, C, ..., Z]. tCharParam :: UppercaseCharset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !% The base-64 alphabet (64 characters) tCharParam :: Base64Charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/' !% The Code 39 alphabet (43+1 characters). tCharParam :: Code39Charset = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ* -$%./+' !** DERIVED TYPE DEFINITIONS !> The *BaseAlphabet* type is a data type in the *HashTreeNode* class representing !  a key-value pair.  It is intended to be used in conjunction with the *BaseAlphabet* !  type.  This is a private type. TYPE , EXTENDS ( HashTreeNode ) :: CharIndex tChar :: Char tIndex :: Index CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => CharIndex_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => CharIndex_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => CharIndex_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => CharIndex_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => CharIndex_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Comparable Type          ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => CharIndex_CompareTo ! --------------------------------------------------------------------- END TYPE !> The *BaseAlphabet* type is an abstract data type for alphabets intended to !  be used with string-processing code that must convert between an alphabet !  of size R and the integers through 1 through R. TYPE , ABSTRACT :: BaseAlphabet PRIVATE tIndex :: Radix !! the radix of the alphabet TYPE ( CharIndex ), ALLOCATABLE :: KeyVal (:) !! the character-index pairs of the alphabet TYPE ( IntrusiveHashTree ) :: HashMap !! map of the character-index pairs CONTAINS PROCEDURE , PRIVATE :: FromCharSet => Alphabet_FromCharSet PROCEDURE , PRIVATE :: FromRadix => Alphabet_FromRadix PROCEDURE , PRIVATE :: Finalize => Alphabet_Finalize PROCEDURE , PRIVATE :: Alphabet_Verify_ChrStr PROCEDURE , PRIVATE :: Alphabet_Verify_FvlStr !> **Type-Bound Function**: IsReady <br> !  **Purpose**: To check whether the Alphabet object is ready to be used. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%IsReady() <br> !   --->    IF (.NOT.Alphabet%IsReady()) DoSomething PROCEDURE :: IsReady => Alphabet_IsReady !> **Type-Bound Function**: Contain <br> !  **Purpose**: To check whether the Alphabet object contains the specified character or not. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%Contain(Chr) <br> !   --->    IF (.NOT.Alphabet%Contain(Chr)) DoSomething PROCEDURE :: Contain => Alphabet_Contain !> **Type-Bound Function**: Verify <br> !  **Purpose**: To verify that all characters in the specified word are in the set of !               characters of this alphabet.  Return 0 if they are.  Otherwise, return !               a number indicating the first position (index) of the character that !               is not in the set. <br> !  **Usage**: <br> !   --->    Flag = Alphabet%Verify(Word) <br> !   --->    IF (Alphabet%Verify(Word) /= 0) DoSomething GENERIC :: Verify => Alphabet_Verify_ChrStr , Alphabet_Verify_FvlStr !> **Type-Bound Function**: GetRadix <br> !  **Purpose**: To return the number of characters in the Alphabet object. <br> !  **Usage**: <br> !   --->    Radix = Alphabet%GetRadix() <br> PROCEDURE :: GetRadix => Alphabet_Radix !> **Type-Bound Function**: GetIndex <br> !  **Purpose**: To return the index corresponding to the specified character.  If the !               character is not in the Alphabet object, return -1. <br> !  **Usage**: <br> !   --->    Index = Alphabet%GetIndex() <br> PROCEDURE :: GetIndex => Alphabet_ToIndex !> **Type-Bound Function**: GetChar <br> !  **Purpose**: To return the character corresponding to the specified index.  If the !               index is not in the valid range (1 to Radix), return an empty character. <br> !  **Usage**: <br> !   --->    Chr = Alphabet%GetChar() <br> PROCEDURE :: GetChar => Alphabet_ToChar END TYPE BaseAlphabet !> The *GenericAlphabet* type is a generic data type that can represent any alphabets. !  An instance of the *GenericAlphabet* type can be created via the *Construct* method !  from either a given set of characters or a radix (representing a number of characters !  in the set where the characters' code are from 0 to radix-1). TYPE , EXTENDS ( BaseAlphabet ) :: GenericAlphabet CONTAINS PROCEDURE , PRIVATE :: GenericAlphabet_FromCharSet PROCEDURE , PRIVATE :: GenericAlphabet_FromRadix !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object either from a specified set of characters !               or from the radix (which is the number of characters in the set where !               characters' code ranges from 0 to radix-1). <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct(CharSet) <br> !   --->    CALL Alphabet%Construct(Radix) <br> GENERIC :: Construct => GenericAlphabet_FromCharSet , & GenericAlphabet_FromRadix !% To perform finalization of this object. FINAL :: GenericAlphabet_Finalize END TYPE GenericAlphabet !> The *BinaryAlphabet* type is a data type representing the binary alphabet { 0, 1 }. TYPE , EXTENDS ( BaseAlphabet ) :: BinaryAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => BinaryAlphabet_Construct !% To perform finalization of this object. FINAL :: BinaryAlphabet_Finalize END TYPE BinaryAlphabet !> The *OctalAlphabet* type is a data type representing the octal alphabet { 0, 1, 2, 3, 4, 5, 6, 7 }. TYPE , EXTENDS ( BaseAlphabet ) :: OctalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => OctalAlphabet_Construct !% To perform finalization of this object. FINAL :: OctalAlphabet_Finalize END TYPE OctalAlphabet !> The *DecimalAlphabet* type is a data type representing the decimal alphabet !  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }. TYPE , EXTENDS ( BaseAlphabet ) :: DecimalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => DecimalAlphabet_Construct !% To perform finalization of this object. FINAL :: DecimalAlphabet_Finalize END TYPE DecimalAlphabet !> The *HexadecimalAlphabet* type is a data type representing the hexadecimal alphabet !  { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F }. TYPE , EXTENDS ( BaseAlphabet ) :: HexadecimalAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => HexadecimalAlphabet_Construct !% To perform finalization of this object. FINAL :: HexadecimalAlphabet_Finalize END TYPE HexadecimalAlphabet !> The *DnaAlphabet* type is a data type representing the DNA alphabet { A, C, T, G }. TYPE , EXTENDS ( BaseAlphabet ) :: DnaAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => DnaAlphabet_Construct !% To perform finalization of this object. FINAL :: DnaAlphabet_Finalize END TYPE DnaAlphabet !> The *ProteinAlphabet* type is a data type representing the protein alphabet !  { A, C, D, E, F, G, H, I, K, L, M, N, P, Q, R, S, T, V, W, Y }. TYPE , EXTENDS ( BaseAlphabet ) :: ProteinAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => ProteinAlphabet_Construct !% To perform finalization of this object. FINAL :: ProteinAlphabet_Finalize END TYPE ProteinAlphabet !> The *LowercaseAlphabet* type is a data type representing the lowercase alphabet !  { a, b, c, ..., z }. TYPE , EXTENDS ( BaseAlphabet ) :: LowercaseAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => LowercaseAlphabet_Construct !% To perform finalization of this object. FINAL :: LowercaseAlphabet_Finalize END TYPE LowercaseAlphabet !> The *UppercaseAlphabet* type is a data type representing the uppercase alphabet !  { A, B, C, ..., Z }. TYPE , EXTENDS ( BaseAlphabet ) :: UppercaseAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => UppercaseAlphabet_Construct !% To perform finalization of this object. FINAL :: UppercaseAlphabet_Finalize END TYPE UppercaseAlphabet !> The *Base64Alphabet* type is a data type representing the base-64 alphabet { 64 characters }. TYPE , EXTENDS ( BaseAlphabet ) :: Base64Alphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => Base64Alphabet_Construct !% To perform finalization of this object. FINAL :: Base64Alphabet_Finalize END TYPE Base64Alphabet !> The *Code39Alphabet* type is a data type representing the Code-39 alphabet { 43+1 characters }. TYPE , EXTENDS ( BaseAlphabet ) :: Code39Alphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => Code39Alphabet_Construct !% To perform finalization of this object. FINAL :: Code39Alphabet_Finalize END TYPE Code39Alphabet !> The *AsciiAlphabet* type is a data type representing the ASCII alphabet { 0-127 characters' code }. TYPE , EXTENDS ( BaseAlphabet ) :: AsciiAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => AsciiAlphabet_Construct !% To perform finalization of this object. FINAL :: AsciiAlphabet_Finalize END TYPE AsciiAlphabet !> The *ExtendedAsciiAlphabet* type is a data type representing the extended ASCII alphabet !  { 0-255 characters' code }. TYPE , EXTENDS ( BaseAlphabet ) :: ExtendedAsciiAlphabet CONTAINS !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**: To create this Alphabet object. <br> !  **Usage**: <br> !   --->    CALL Alphabet%Construct() <br> PROCEDURE :: Construct => ExtendedAsciiAlphabet_Construct !% To perform finalization of this object. FINAL :: ExtendedAsciiAlphabet_Finalize END TYPE ExtendedAsciiAlphabet !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 CharIndex Procedures                      ----- ! --------------------------------------------------------------------- SUBROUTINE CharIndex_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS ROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( CharIndex ) CALL SrcObj % CopyHashNode ( DstObj ) DstObj % Char = SrcObj % Char DstObj % Index = SrcObj % Index ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'CharIndex_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"CharIndex\" only.' ) RETURN END SELECT RETURN END SUBROUTINE CharIndex_Copy !****************************************************************************** FUNCTION CharIndex_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure by an *Object* object. <br> !  It should be noted that this routine uses all components of !  the *CharIndex* object to check equality. Therefore, although !  (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) can return !  false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( CharIndex ) ! check key equality IF ( LhsObj % Char /= RhsObj % Char ) RETURN ! check value equality where values may be represented by character strings IF ( LhsObj % Index /= RhsObj % Index ) RETURN ! check hash node component equality Flag = LhsObj % IsHashNodeEqual ( RhsObj ) CLASS DEFAULT RETURN END SELECT RETURN END FUNCTION CharIndex_IsEqualTo !****************************************************************************** SUBROUTINE CharIndex_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the CharIndex object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % ResetHashNode () RETURN END SUBROUTINE CharIndex_MemFree !****************************************************************************** FUNCTION CharIndex_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{CharIndex: {Char : ' // Obj % Char // '}, {Index : ' // ToChar ( Obj % Index ) // '}}' RETURN END FUNCTION CharIndex_ToString !****************************************************************************** FUNCTION CharIndex_CompareTo ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare *A* and *B* and return <br> !   1 if *A* is greater than *B*, <br> !   0 if *A* is equal to *B*, <br> !  -1 if *A* is less than *B*, <br> !  -999 if type of *B* is invalid. <br> !  Also, write an error message to the default log file if this happens. <br> !  This is a deferred procedure by an *Comparable* object. <br> !  It is important to note that this routine only uses the key component !  of the *CharIndex* object.  Thus, even though (A%CompareTo(B) == 0) !  is true, A%IsEqualTo(B) may be false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( IN ) :: A CLASS ( Comparable ), INTENT ( IN ) :: B tSInt32 :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( B ) TYPE IS ( CharIndex ) IF ( LGT ( A % Char , B % Char )) THEN Flag = + 1 ELSEIF ( LLT ( A % Char , B % Char )) THEN Flag = - 1 ELSE Flag = 0 END IF CLASS DEFAULT Flag = - 999 CALL Handle_ErrLevel ( 'CharIndex_CompareTo' , ModName , ErrSevere , 'Type of B is valid.' ) END SELECT RETURN END FUNCTION CharIndex_CompareTo !****************************************************************************** FUNCTION CharIndex_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the hash code of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( CharIndex ), INTENT ( IN ) :: Obj !! HashTreeNode object tIndex :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = ComputeHash ( Obj % Char , Bytes_Char , 31311331_kIndex ) RETURN END FUNCTION CharIndex_HashCode ! --------------------------------------------------------------------- ! -----                 BaseAlphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE Alphabet_FromCharSet ( Alpha , CharSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Alphabet object from the specified string representing !  a given set of characters. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object tCharStar , INTENT ( IN ) :: CharSet !! a set of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg tIndex :: I tChar :: C tSInt32 :: IC tLogical :: IsASCHII ( 256 ) ! FLOW Alpha % Radix = LEN ( CharSet , KIND = kIndex ) ALLOCATE ( Alpha % KeyVal ( Alpha % Radix ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat == 0 ) THEN CALL Alpha % HashMap % Construct ( Alpha % Radix * 2_kIndex ) IsASCHII = FalseVal DO I = 1_kIndex , Alpha % Radix C = CharSet ( I : I ) IC = IACHAR ( C ) IF ( IsASCHII ( IC )) THEN CALL Handle_ErrLevel ( 'Alphabet_FromCharSet' , ModName , ErrSevere , & 'Illegal Alphabet.  Duplicated characters are NOT allowed.' ) DEALLOCATE ( Alpha % KeyVal , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrDealloc ( 'Alphabet_FromCharSet' , ModName , AllocMsg , AllocStat ) CALL Alpha % HashMap % Destruct () RETURN END IF IsASCHII ( IC ) = TrueVal Alpha % KeyVal ( I )% Char = C Alpha % KeyVal ( I )% Index = I CALL Alpha % HashMap % Insert ( Alpha % KeyVal ( I )) END DO ELSE CALL Handle_ErrAlloc ( 'Alphabet_FromCharSet' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE Alphabet_FromCharSet !****************************************************************************** SUBROUTINE Alphabet_FromRadix ( Alpha , Radix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Alphabet object from a set of characters where their codes are !  from 0 to Radix-1. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object tIndex , INTENT ( IN ) :: Radix !! the number of characters in the alphabet !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg tIndex :: I INTRINSIC :: ACHAR ! FLOW IF ( Radix > MaxRadix ) THEN CALL Handle_ErrLevel ( 'Alphabet_FromRadix' , ModName , ErrSevere , & 'Illegal radix.  Radix must be less than or equal to 256.' ) RETURN END IF Alpha % Radix = Radix ALLOCATE ( Alpha % KeyVal ( Alpha % Radix ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat == 0 ) THEN CALL Alpha % HashMap % Construct ( Alpha % Radix * 2_kIndex ) DO I = 1_kIndex , Radix Alpha % KeyVal ( I )% Char = ACHAR ( I - 1 ) Alpha % KeyVal ( I )% Index = I CALL Alpha % HashMap % Insert ( Alpha % KeyVal ( I )) END DO ELSE CALL Handle_ErrAlloc ( 'Alphabet_FromRadix' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE Alphabet_FromRadix !****************************************************************************** PURE FUNCTION Alphabet_IsReady ( Alpha ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the Alphabet object is ready to be used. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( IN ) :: Alpha !! Alphabet object tLogical :: Flag !! true if the object is ready to be used !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ALLOCATED ( Alpha % KeyVal ) RETURN END FUNCTION Alphabet_IsReady !****************************************************************************** FUNCTION Alphabet_Contain ( Alpha , C ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the Alphabet object contains the specified character or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object tChar , INTENT ( IN ) :: C !! a character tLogical :: Flag !! true if the character is in the Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( CharIndex ) :: KeyVal ! FLOW KeyVal % Char = C Flag = Alpha % HashMap % Contain ( KeyVal ) RETURN END FUNCTION Alphabet_Contain !****************************************************************************** FUNCTION Alphabet_Verify_ChrStr ( Alpha , Word ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To verify that all characters in the specified word are in the set of !  characters of this alphabet.  Return 0 if they are.  Otherwise, return !  a number indicating the first position (index) of the character that !  is not in the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object tCharStar , INTENT ( IN ) :: Word !! a word tIndex :: Flag !! return number indicating whether all characters are in the set !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( CharIndex ) :: KeyVal tIndex :: I ! FLOW Flag = 0_kIndex DO I = 1_kIndex , LEN ( Word , KIND = kIndex ) KeyVal % Char = Word ( I : I ) IF (. NOT . Alpha % HashMap % Contain ( KeyVal )) THEN Flag = I EXIT END IF END DO RETURN END FUNCTION Alphabet_Verify_ChrStr !****************************************************************************** FUNCTION Alphabet_Verify_FvlStr ( Alpha , Word ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To verify that all characters in the specified word are in the set of !  characters of this alphabet.  Return 0 if they are.  Otherwise, return !  a number indicating the first position (index) of the character that !  is not in the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object TYPE ( FvlStr ), INTENT ( IN ) :: Word !! a word tIndex :: Flag !! return number indicating whether all characters are in the set !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Word ) Flag = Alpha % Verify ( StrPtr ) RETURN END FUNCTION Alphabet_Verify_FvlStr !****************************************************************************** PURE FUNCTION Alphabet_Radix ( Alpha ) RESULT ( Radix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of characters in the Alphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( IN ) :: Alpha !! Alphabet object tIndex :: Radix !! the number of characters in the alphabet !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Radix = Alpha % Radix RETURN END FUNCTION Alphabet_Radix !****************************************************************************** FUNCTION Alphabet_ToIndex ( Alpha , C ) RESULT ( Idx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the index corresponding to the specified character.  If the character !  is not in the Alphabet object, return -1. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object tChar , INTENT ( IN ) :: C !! a character tIndex :: Idx !! index corresponding to the specified character !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( CharIndex ) :: SearchNode CLASS ( HashTreeNode ), POINTER :: StoredNode ! FLOW SearchNode % Char = C IF ( Alpha % HashMap % FindNode ( SearchNode , StoredNode )) THEN IF ( ASSOCIATED ( StoredNode )) THEN SELECT TYPE ( StoredNode ) TYPE IS ( CharIndex ) Idx = StoredNode % Index END SELECT ELSE Idx = - 1_kIndex END IF ELSE Idx = - 1_kIndex END IF RETURN END FUNCTION Alphabet_ToIndex !****************************************************************************** FUNCTION Alphabet_ToChar ( Alpha , Idx ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the character corresponding to the specified index.  If the index !  is not in the valid range (1 to Radix), return an empty character. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseAlphabet ), INTENT ( IN ) :: Alpha !! Alphabet object tIndex , INTENT ( IN ) :: Idx !! an index tChar :: C !! character corresponding to the specified index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (( Idx >= 1_kIndex ). AND .( Idx <= Alpha % Radix )) THEN C = Alpha % KeyVal ( Idx )% Char ELSE C = '' END IF RETURN END FUNCTION Alphabet_ToChar !****************************************************************************** SUBROUTINE Alphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the Alphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: !    TYPE(BaseAlphabet), INTENT(INOUT)   :: Alpha    !! Alphabet object CLASS ( BaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Alpha % KeyVal )) DEALLOCATE ( Alpha % KeyVal ) CALL Alpha % HashMap % Destruct () RETURN END SUBROUTINE Alphabet_Finalize ! --------------------------------------------------------------------- ! -----               GenericAlphabet Procedures                  ----- ! --------------------------------------------------------------------- SUBROUTINE GenericAlphabet_FromCharSet ( Alpha , CharSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Alphabet object from the specified string representing !  a given set of characters. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GenericAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object tCharStar , INTENT ( IN ) :: CharSet !! a set of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( CharSet ) RETURN END SUBROUTINE GenericAlphabet_FromCharSet !****************************************************************************** SUBROUTINE GenericAlphabet_FromRadix ( Alpha , Radix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Alphabet object from a set of characters where their codes are !  from 0 to Radix-1. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( GenericAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object tIndex , INTENT ( IN ) :: Radix !! the number of characters in the alphabet !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromRadix ( Radix ) RETURN END SUBROUTINE GenericAlphabet_FromRadix !****************************************************************************** SUBROUTINE GenericAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( GenericAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE GenericAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               BinaryAlphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE BinaryAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the BinaryAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BinaryAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( BinaryCharset ) RETURN END SUBROUTINE BinaryAlphabet_Construct !****************************************************************************** SUBROUTINE BinaryAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BinaryAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE BinaryAlphabet_Finalize ! --------------------------------------------------------------------- ! -----                OctalAlphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE OctalAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the OctalAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( OctalAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( OctalCharset ) RETURN END SUBROUTINE OctalAlphabet_Construct !****************************************************************************** SUBROUTINE OctalAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( OctalAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE OctalAlphabet_Finalize ! --------------------------------------------------------------------- ! -----              DecimalAlphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE DecimalAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the DecimalAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DecimalAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( DecimalCharset ) RETURN END SUBROUTINE DecimalAlphabet_Construct !****************************************************************************** SUBROUTINE DecimalAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DecimalAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE DecimalAlphabet_Finalize ! --------------------------------------------------------------------- ! -----           HexadecimalAlphabet Procedures                  ----- ! --------------------------------------------------------------------- SUBROUTINE HexadecimalAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the HexadecimalAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HexadecimalAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( HexadecimalCharset ) RETURN END SUBROUTINE HexadecimalAlphabet_Construct !****************************************************************************** SUBROUTINE HexadecimalAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HexadecimalAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE HexadecimalAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               DnaAlphabet Procedures                      ----- ! --------------------------------------------------------------------- SUBROUTINE DnaAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the DnaAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DnaAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( DnaCharset ) RETURN END SUBROUTINE DnaAlphabet_Construct !****************************************************************************** SUBROUTINE DnaAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DnaAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE DnaAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               ProteinAlphabet Procedures                  ----- ! --------------------------------------------------------------------- SUBROUTINE ProteinAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the ProteinAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ProteinAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( ProteinCharset ) RETURN END SUBROUTINE ProteinAlphabet_Construct !****************************************************************************** SUBROUTINE ProteinAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ProteinAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE ProteinAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               LowercaseAlphabet Procedures                ----- ! --------------------------------------------------------------------- SUBROUTINE LowercaseAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the LowercaseAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LowercaseAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( LowercaseCharset ) RETURN END SUBROUTINE LowercaseAlphabet_Construct !****************************************************************************** SUBROUTINE LowercaseAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( LowercaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE LowercaseAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               UppercaseAlphabet Procedures                ----- ! --------------------------------------------------------------------- SUBROUTINE UppercaseAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the UppercaseAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( UppercaseAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( UppercaseCharset ) RETURN END SUBROUTINE UppercaseAlphabet_Construct !****************************************************************************** SUBROUTINE UppercaseAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( UppercaseAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE UppercaseAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               Base64Alphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE Base64Alphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Base64Alphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Base64Alphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( Base64Charset ) RETURN END SUBROUTINE Base64Alphabet_Construct !****************************************************************************** SUBROUTINE Base64Alphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Base64Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE Base64Alphabet_Finalize ! --------------------------------------------------------------------- ! -----               Code39Alphabet Procedures                   ----- ! --------------------------------------------------------------------- SUBROUTINE Code39Alphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the Code39Alphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Code39Alphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromCharset ( Code39Charset ) RETURN END SUBROUTINE Code39Alphabet_Construct !****************************************************************************** SUBROUTINE Code39Alphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Code39Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE Code39Alphabet_Finalize ! --------------------------------------------------------------------- ! -----               AsciiAlphabet Procedures                    ----- ! --------------------------------------------------------------------- SUBROUTINE AsciiAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the AsciiAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( AsciiAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromRadix ( 128_kIndex ) RETURN END SUBROUTINE AsciiAlphabet_Construct !****************************************************************************** SUBROUTINE AsciiAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( AsciiAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE AsciiAlphabet_Finalize ! --------------------------------------------------------------------- ! -----               ExtendedAsciiAlphabet Procedures            ----- ! --------------------------------------------------------------------- SUBROUTINE ExtendedAsciiAlphabet_Construct ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the ExtendedAsciiAlphabet object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ExtendedAsciiAlphabet ), INTENT ( OUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % FromRadix ( 256_kIndex ) RETURN END SUBROUTINE ExtendedAsciiAlphabet_Construct !****************************************************************************** SUBROUTINE ExtendedAsciiAlphabet_Finalize ( Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ExtendedAsciiAlphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Alpha % Finalize () RETURN END SUBROUTINE ExtendedAsciiAlphabet_Finalize !****************************************************************************** END MODULE MClass_Alphabets !******************************************************************************","tags":"","loc":"sourcefile\\mclass_alphabets.f90.html"},{"title":"MBase_REParameters.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_REParameters !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *REProgram* type and its related helper types and routines. !   The *REProgram* type is a string type that provides various efficient algorithms for !   a *substring searching* operation.  The *substring searching* is a fundamental string !   operation where given a *text* string of length N and a *pattern* string of length M, !   find an occurrence of the *pattern* within the *text*.  <br> !  **REFERENCES**: <br> !   [1] <a href=\"https:!jakarta.apache.org/regexp/\">The Apache Jakarta Project. <br> !** USE STATEMENTS: USE MBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables PUBLIC !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS (PART1): ! optimization parameters tSInt32 , PARAMETER :: OPT_HASBACKREFS = 1 tSInt32 , PARAMETER :: OPT_HASBOL = 2 ! Node flags tSInt32 , PARAMETER :: NODE_NORMAL = 0 ! No flags (nothing special) tSInt32 , PARAMETER :: NODE_NULLABLE = 1 ! True if node is potentially null tSInt32 , PARAMETER :: NODE_TOPLEVEL = 2 ! True if top level expr ! Special types of 'escapes' tSInt32 , PARAMETER :: ESC_MASK = ToInt32 ( Z '000FFFF0' ) ! Escape complexity mask tSInt32 , PARAMETER :: ESC_BACKREF = ToInt32 ( Z '000FFFFF' ) ! Escape is really a backreference tSInt32 , PARAMETER :: ESC_COMPLEX = ToInt32 ( Z '000FFFFE' ) ! Escape isn't really a true character tSInt32 , PARAMETER :: ESC_CLASS = ToInt32 ( Z '000FFFFD' ) ! Escape represents a whole class of characters ! {m,n} stacks tSInt32 , PARAMETER :: bracketUnbounded = - 1 ! Unbounded value ! Specifies normal, case-sensitive matching behaviour. tSInt32 , PARAMETER :: MATCH_NORMAL = ToInt32 ( Z '00000000' ) ! Flag to indicate that matching should be case-independent (folded) tSInt32 , PARAMETER :: MATCH_CASEINDEPENDENT = ToInt32 ( Z '00000001' ) ! Newlines should match as BOL/EOL (&#94; and $) tSInt32 , PARAMETER :: MATCH_MULTILINE = ToInt32 ( Z '00000002' ) ! Consider all input a single body of text - newlines are matched by . tSInt32 , PARAMETER :: MATCH_SINGLELINE = ToInt32 ( Z '00000004' ) !*********************************************** !                                              * ! The format of a node in a program is:        * !                                              * ! [ OPCODE ] [ OPDATA ] [ OPNEXT ] [ OPERAND ] * !                                              * ! char OPCODE - instruction                    * ! char OPDATA - modifying data                 * ! char OPNEXT - next node (relative offset)    * !                                              * !*********************************************** !   Opcode              Char       Opdata/Operand  Meaning !   ----------          ---------- --------------- -------------------------------------------------- tChar , PARAMETER :: OP_END = 'E' !                 end of program tChar , PARAMETER :: OP_BOL = '&#94;' !                 match only if at beginning of line tChar , PARAMETER :: OP_EOL = '$' !                 match only if at end of line tChar , PARAMETER :: OP_ANY = '.' !                 match any single character except newline tChar , PARAMETER :: OP_ANYOF = '[' ! count/ranges    match any char in the list of ranges tChar , PARAMETER :: OP_BRANCH = '|' ! node            match this alternative or the next one tChar , PARAMETER :: OP_ATOM = 'A' ! length/string   length of string followed by string itself tChar , PARAMETER :: OP_STAR = '*' ! node            kleene closure tChar , PARAMETER :: OP_PLUS = '+' ! node            positive closure tChar , PARAMETER :: OP_MAYBE = '?' ! node            optional closure tChar , PARAMETER :: OP_ESCAPE = '\\'  ! escape          special escape code char class (escape is E_* code) tChar,    PARAMETER :: OP_OPEN             = ' ( '  ! number          nth opening paren tChar,    PARAMETER :: OP_OPEN_CLUSTER     = ' < '  !                 opening cluster tChar,    PARAMETER :: OP_CLOSE            = ' ) '  ! number          nth closing paren tChar,    PARAMETER :: OP_CLOSE_CLUSTER    = ' > '  !                 closing cluster tChar,    PARAMETER :: OP_BACKREF          = ' # '  ! number          reference nth already matched parenthesized string tChar,    PARAMETER :: OP_GOTO             = ' G '  !                 nothing but a (back-)pointer tChar,    PARAMETER :: OP_NOTHING          = ' N '  !                 match null string such as in ' ( a | ) ' tChar,    PARAMETER :: OP_CONTINUE         = ' C '  !                 continue to the following command (ignore next) tChar,    PARAMETER :: OP_RELUCTANTSTAR    = ' 8 '  ! none/expr       reluctant ' * ' (mnemonic for char is unshifted ' * ') tChar,    PARAMETER :: OP_RELUCTANTPLUS    = ' = '  ! none/expr       reluctant ' + ' (mnemonic for char is unshifted ' + ') tChar,    PARAMETER :: OP_RELUCTANTMAYBE   = ' / '  ! none/expr       reluctant ' ? ' (mnemonic for char is unshifted ' ? ') tChar,    PARAMETER :: OP_POSIXCLASS       = ' P '  ! classid         one of the posix character classes ! Escape codes tChar,    PARAMETER :: E_ALNUM             = ' w '  ! Alphanumeric tChar,    PARAMETER :: E_NALNUM            = ' W '  ! Non-alphanumeric tChar,    PARAMETER :: E_BOUND             = ' b '  ! Word boundary tChar,    PARAMETER :: E_NBOUND            = ' B '  ! Non-word boundary tChar,    PARAMETER :: E_SPACE             = ' s '  ! Whitespace tChar,    PARAMETER :: E_NSPACE            = ' S '  ! Non-whitespace tChar,    PARAMETER :: E_DIGIT             = ' d '  ! Digit tChar,    PARAMETER :: E_NDIGIT            = ' D '  ! Non-digit ! Posix character classes tChar,    PARAMETER :: POSIX_CLASS_ALNUM   = ' w '  ! Alphanumerics tChar,    PARAMETER :: POSIX_CLASS_ALPHA   = ' a '  ! Alphabetics tChar,    PARAMETER :: POSIX_CLASS_BLANK   = ' b '  ! Blanks tChar,    PARAMETER :: POSIX_CLASS_CNTRL   = ' c '  ! Control characters tChar,    PARAMETER :: POSIX_CLASS_DIGIT   = ' d '  ! Digits tChar,    PARAMETER :: POSIX_CLASS_GRAPH   = ' g '  ! Graphic characters tChar,    PARAMETER :: POSIX_CLASS_LOWER   = ' l '  ! Lowercase characters tChar,    PARAMETER :: POSIX_CLASS_PRINT   = ' p '  ! Printable characters tChar,    PARAMETER :: POSIX_CLASS_PUNCT   = ' !'  ! Punctuation tChar , PARAMETER :: POSIX_CLASS_SPACE = 's' ! Spaces tChar , PARAMETER :: POSIX_CLASS_UPPER = 'u' ! Uppercase characters tChar , PARAMETER :: POSIX_CLASS_HEXDG = 'x' ! Hexadecimal digits ! Limits tSInt32 , PARAMETER :: maxNode = 65536 ! Maximum number of nodes in a program tSInt32 , PARAMETER :: MAX_PAREN = 16 ! Number of paren pairs (only 9 can be backrefs) ! Node layout constants tSInt32 , PARAMETER :: offsetOpcode = 0 ! Opcode offset (first character) tSInt32 , PARAMETER :: offsetOpdata = 1 ! Opdata offset (second char) tSInt32 , PARAMETER :: offsetNext = 2 ! Next index offset (third char) tSInt32 , PARAMETER :: nodeSize = 3 ! Node size (in chars) !** DERIVED TYPE DEFINITIONS ! derive type for POSIX character class names TYPE , PRIVATE :: PosixPair tCharLen ( 5 ) :: Name ! class name tChar :: C ! character representing the class END TYPE !** MODULE PARAMETERS (PART2): ! Lookup table for POSIX character class names TYPE ( PosixPair ), PARAMETER :: hashPOSIX ( * ) = & [ PosixPair ( \"alnum\" , POSIX_CLASS_ALNUM ), & PosixPair ( \"alpha\" , POSIX_CLASS_ALPHA ), & PosixPair ( \"blank\" , POSIX_CLASS_BLANK ), & PosixPair ( \"cntrl\" , POSIX_CLASS_CNTRL ), & PosixPair ( \"digit\" , POSIX_CLASS_DIGIT ), & PosixPair ( \"graph\" , POSIX_CLASS_GRAPH ), & PosixPair ( \"lower\" , POSIX_CLASS_LOWER ), & PosixPair ( \"print\" , POSIX_CLASS_PRINT ), & PosixPair ( \"punct\" , POSIX_CLASS_PUNCT ), & PosixPair ( \"space\" , POSIX_CLASS_SPACE ), & PosixPair ( \"upper\" , POSIX_CLASS_UPPER ), & PosixPair ( \"hexdg\" , POSIX_CLASS_HEXDG )] !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !****************************************************************************** FUNCTION hashPOSIX_GetChar ( Name ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !> To check whether the given character is in the given ASCII range !  from ASCII_Min to ASCII_Max. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharLen ( 5 ), INTENT ( IN ) :: Name ! class name tChar :: C ! character representing the class !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I !** FLOW: DO I = 1 , SIZE ( hashPOSIX ) IF ( Name == hashPOSIX ( I )% Name ) THEN C = hashPOSIX ( I )% C RETURN END IF END DO C = OP_STAR RETURN END FUNCTION hashPOSIX_GetChar !****************************************************************************** END MODULE MBase_REParameters !******************************************************************************","tags":"","loc":"sourcefile\\mbase_reparameters.f90.html"},{"title":"MClass_RegexFinder.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_RegexFinder !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *RegexFinder* type and its related helper types and routines. !   The *RegexFinder* type is a string type that provides various efficient algorithms for !   a *substring searching* operation.  The *substring searching* is a fundamental string !   operation where given a *text* string of length N and a *pattern* string of length M, !   find an occurrence of the *pattern* within the *text*.  <br> !  **REFERENCES**: <br> !   [1] <a href=\"https://github.com/zhztheplayer/DFA-Regex\">DFA-Regex: A DFA regex engine in java. <br> !** USE STATEMENTS: USE MBase_Common USE MClass_BitmapState , ONLY : BitmapStateManager USE MClass_DFAutomaton USE MClass_NFAutomaton USE MClass_SyntaxNode USE MClass_SyntaxTree IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: RegexFinder PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_RegexFinder' !** DERIVED TYPE DEFINITIONS !> The *RegexFinder* type is a string type that provides various efficient !  algorithms for a *substring searching* operation. TYPE RegexFinder PRIVATE !% the cached regular expression string pattern tCharAlloc :: RegexPattern !% the cached regular expression string compiled pattern TYPE ( CompiledRegex ) :: CompiledPattern CONTAINS !> **Type-Bound Subroutine**: SetPattern <br> !  **Purpose**:  To set and compile the specified pattern. <br> !  **Usage**: <br> !   --->    CALL Finder%SetPattern(Pattern) <br> PROCEDURE :: SetPattern => RegexFinder_SetPattern !> **Type-Bound Function**: IsMatch <br> !  **Purpose**:  To check whether the specified text matches the previously compiled pattern !                (or the optionally specified pattern). <br> !  **Usage**: <br> !   --->    Flag = Finder%IsMatch(Text) <br> !   --->    IF (.NOT.Finder%IsMatch(Text, Pattern)) DoSomething <br> PROCEDURE :: IsMatch => RegexFinder_IsMatch !> **Type-Bound Function**: FindSubstring <br> !  **Purpose**:  To find a substring within the specified text that matches the previously !                compiled pattern (or the optionally specified pattern).  If the 'StartPos' !                argument is present and greater than 0 and less than the text length, the !                search starts at the 'StartPos' position.  Otherwise, the search start at !                the first position of the text.  The routine returns indices indicating !                the starting and ending positions of the substring if found.  If the !                substring is not found, both indices are set to zeros. <br> !  **Usage**: <br> !   ! find a substring within the text starting at 1 where the pattern has already been set. <br> !   --->    Indices = Finder%FindSubstring(Text) <br> !   ! find a substring within the text starting at StartPos. <br> !   --->    Indices = Finder%FindSubstring(Text, StartPos=StartPos) <br> !   ! find a substring within the text where the pattern has not yet been set. <br> !   --->    Indices = Finder%FindSubstring(Text, Pattern=Pattern) <br> !   ! find a substring within the text starting at StartPos where the pattern has not yet been set. <br> !   --->    Indices = Finder%FindSubstring(Text, StartPos, Pattern) <br> PROCEDURE :: FindSubstring => RegexFinder_FindSubstring END TYPE RegexFinder !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !-------------------------------------------------------------------------------------- !                           RegexFinder Procedures !-------------------------------------------------------------------------------------- SUBROUTINE RegexFinder_SetPattern ( Finder , Pattern ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To process the specified pattern based on the specified searching algorithm. !  If the length of the pattern is zero, just return without doing anything. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RegexFinder ), INTENT ( INOUT ) :: Finder !! 'RegexFinder' object tCharStar , INTENT ( IN ) :: Pattern !! the pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxTree ) :: Tree TYPE ( SyntaxNode ), POINTER :: Root TYPE ( NFAutomaton ) :: NFA TYPE ( BitmapStateManager ) :: Manager TYPE ( DFAutomaton ) :: DFA ! FLOW ! compile the specified pattern CALL Tree % Construct ( Pattern ) Root => Tree % GetRoot () CALL NFA % Construct ( Root ) Manager = NFA % AsBitmapStateManager () Finder % CompiledPattern = DFA % Construct ( Manager ) ! cache the specified pattern Finder % RegexPattern = Pattern ! free memory CALL DFA % Destruct () CALL Manager % Destruct () CALL NFA % Destruct () NULLIFY ( Root ) CALL Tree % Destruct () RETURN END SUBROUTINE RegexFinder_SetPattern !****************************************************************************** FUNCTION RegexFinder_IsMatch ( Finder , Text , Pattern ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified text matches the previously compiled pattern !  (or the optionally specified pattern). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RegexFinder ), INTENT ( INOUT ) :: Finder !! 'RegexFinder' object tCharStar , INTENT ( IN ) :: Text !! the specified text tCharStar , OPTIONAL , INTENT ( IN ) :: Pattern !! the specified pattern tLogical :: Flag !! true if the specified text matches the pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! compile the specified pattern if necessary IF ( PRESENT ( Pattern )) THEN IF ( ALLOCATED ( Finder % RegexPattern )) THEN IF ( Pattern /= Finder % RegexPattern ) CALL Finder % SetPattern ( Pattern ) ELSE CALL Finder % SetPattern ( Pattern ) END IF END IF IF ( ALLOCATED ( Finder % RegexPattern )) THEN BLOCK tSInt32 :: S , I , C S = Finder % CompiledPattern % IS DO I = 1 , LEN ( Text ) C = IACHAR ( Text ( I : I )) S = Finder % CompiledPattern % TransitionTable ( C , S ) IF ( S == Finder % CompiledPattern % RS ) THEN ! fast failed using rejected state Flag = FalseVal RETURN END IF END DO Flag = Finder % CompiledPattern % FS ( S ) END BLOCK ELSE ! pattern has not yet been compiled. Flag = FalseVal END IF RETURN END FUNCTION RegexFinder_IsMatch !****************************************************************************** FUNCTION RegexFinder_FindSubstring ( Finder , Text , StartPos , Pattern ) RESULT ( Indices ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find a substring within the specified text that matches the previously !  compiled pattern (or the optionally specified pattern).  If the 'StartPos' !  argument is present and greater than 0 and less than the text length, !  the search starts at the 'StartPos' position.  Otherwise, the search start !  at the first position of the text. <br> !  The routine returns indices indicating the starting and ending positions of !  the substring if found.  If the substring is not found, both indices are set !  to zeros. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RegexFinder ), INTENT ( INOUT ) :: Finder !! 'RegexFinder' object tCharStar , INTENT ( IN ) :: Text !! the specified text tSInt32 , OPTIONAL , INTENT ( IN ) :: StartPos !! the starting position tCharStar , OPTIONAL , INTENT ( IN ) :: Pattern !! the specified pattern tSInt32 :: Indices ( 2 ) !! indices of the substring !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: FirstPos , LastPos ! FLOW ! compile the specified pattern if necessary IF ( PRESENT ( Pattern )) THEN IF ( ALLOCATED ( Finder % RegexPattern )) THEN IF ( Pattern /= Finder % RegexPattern ) CALL Finder % SetPattern ( Pattern ) ELSE CALL Finder % SetPattern ( Pattern ) END IF END IF IF ( ALLOCATED ( Finder % RegexPattern )) THEN ! determine the search range FirstPos = 1 LastPos = LEN ( Text ) IF ( PRESENT ( StartPos )) THEN IF (( StartPos > 0 ). AND .( StartPos <= LastPos )) FirstPos = StartPos END IF ! set initial values Indices = 0 BLOCK tSInt32 :: S , I , C OuterLoop : DO WHILE ( FirstPos <= LastPos ) S = Finder % CompiledPattern % IS InnerLoop : DO I = FirstPos , LastPos C = IACHAR ( Text ( I : I )) S = Finder % CompiledPattern % TransitionTable ( C , S ) IF ( S == Finder % CompiledPattern % RS ) THEN ! exit loop due to rejected state EXIT InnerLoop ELSEIF ( Finder % CompiledPattern % FS ( S )) THEN ! found the substring Indices ( 1 ) = FirstPos Indices ( 2 ) = I EXIT OuterLoop END IF END DO InnerLoop FirstPos = FirstPos + 1 END DO OuterLoop END BLOCK ELSE ! pattern has not yet been compiled. Indices = 0 END IF RETURN END FUNCTION RegexFinder_FindSubstring !****************************************************************************** END MODULE MClass_RegexFinder !******************************************************************************","tags":"","loc":"sourcefile\\mclass_regexfinder.f90.html"},{"title":"MClass_DFAutomaton.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DFAutomaton !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DFAutomaton* type and its related routines. !   The *DFAutomaton* type is a derived type representing a ... <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MClass_Object , ONLY : Object USE MBase_OptimalHash32 , ONLY : HashFuncOpt => Murmur3_Hash32_Opt USE MClass_IntrusiveHashList USE MClass_IntrusiveLinkedLists USE MClass_TreeInteger4B USE MClass_PQInteger4B USE MClass_SyntaxTree USE MClass_BitmapState IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DFAutomaton PUBLIC :: CompiledRegex PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tHash               tIndex !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_DFAutomaton' tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS TYPE CompiledRegex tSInt32 , ALLOCATABLE :: TransitionTable (:,:) tSInt32 :: IS = - 1 ! initial state tSInt32 :: RS = - 1 ! rejected state tLogical , ALLOCATABLE :: FS (:) ! final states END TYPE CompiledRegex !> The *DFAutomaton* type is a node type... TYPE DFAutomaton TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () TYPE ( BitmapState ), POINTER :: States (:) => NULL () CONTAINS PROCEDURE :: Construct => DFAutomaton_Construct PROCEDURE :: Destruct => DFAutomaton_Destruct PROCEDURE :: Initialize => DFAutomaton_Initialize PROCEDURE :: NFATransMap => DFAutomaton_NFATransMap PROCEDURE :: OriginalDFA => DFAutomaton_OriginalDFA PROCEDURE :: CalculateClosure => DFAutomaton_CalculateClosure PROCEDURE :: DfsClosure => DFAutomaton_DfsClosure PROCEDURE :: TraceReachable => DFAutomaton_TraceReachable PROCEDURE :: Minimize => DFAutomaton_Minimize END TYPE DFAutomaton !> The *StatePackNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: StatePackNode TYPE ( BitmapState ), POINTER :: State => NULL () TYPE ( BitmapStatePack ), POINTER :: Pack => NULL () CONTAINS PROCEDURE :: Copy => StatePackNode_Copy PROCEDURE :: IsEqualTo => StatePackNode_IsEqualTo PROCEDURE :: ToString => StatePackNode_ToString PROCEDURE :: IsKeyEqual => StatePackNode_IsKeyEqual PROCEDURE :: MemFree => StatePackNode_MemFree PROCEDURE :: HashCode => StatePackNode_HashCode PROCEDURE :: Construct => StatePackNode_Construct END TYPE StatePackNode !> The *StateMapNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: StateMapNode TYPE ( BitmapState ), POINTER :: State => NULL () TYPE ( IntrusiveHashList ) :: SubMap ! use BitMapNode as node CONTAINS PROCEDURE :: Copy => StateMapNode_Copy PROCEDURE :: IsEqualTo => StateMapNode_IsEqualTo PROCEDURE :: ToString => StateMapNode_ToString PROCEDURE :: IsKeyEqual => StateMapNode_IsKeyEqual PROCEDURE :: MemFree => StateMapNode_MemFree PROCEDURE :: HashCode => StateMapNode_HashCode PROCEDURE :: Construct => StateMapNode_Construct END TYPE StateMapNode !> The *PackMapNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: PackMapNode TYPE ( BitmapStatePack ), POINTER :: Pack => NULL () TYPE ( IntrusiveHashList ) :: SubMap ! use BitMapNode as node CONTAINS PROCEDURE :: Copy => PackMapNode_Copy PROCEDURE :: IsEqualTo => PackMapNode_IsEqualTo PROCEDURE :: ToString => PackMapNode_ToString PROCEDURE :: IsKeyEqual => PackMapNode_IsKeyEqual PROCEDURE :: MemFree => PackMapNode_MemFree PROCEDURE :: HashCode => PackMapNode_HashCode PROCEDURE :: Construct => PackMapNode_Construct END TYPE PackMapNode !> The *PackIntegerNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: PackIntegerNode TYPE ( BitmapStatePack ), POINTER :: Pack => NULL () tSInt32 :: Val CONTAINS PROCEDURE :: Copy => PackIntegerNode_Copy PROCEDURE :: IsEqualTo => PackIntegerNode_IsEqualTo PROCEDURE :: ToString => PackIntegerNode_ToString PROCEDURE :: IsKeyEqual => PackIntegerNode_IsKeyEqual PROCEDURE :: MemFree => PackIntegerNode_MemFree PROCEDURE :: HashCode => PackIntegerNode_HashCode PROCEDURE :: Construct => PackIntegerNode_Construct END TYPE PackIntegerNode !> The *MapSetNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: MapSetNode TYPE ( TreeInteger4B ) :: TreeMap TYPE ( PQInteger4B ) :: PQSet CONTAINS PROCEDURE :: Copy => MapSetNode_Copy PROCEDURE :: IsEqualTo => MapSetNode_IsEqualTo PROCEDURE :: ToString => MapSetNode_ToString PROCEDURE :: IsKeyEqual => MapSetNode_IsKeyEqual PROCEDURE :: MemFree => MapSetNode_MemFree PROCEDURE :: HashCode => MapSetNode_HashCode PROCEDURE :: Construct => MapSetNode_Construct END TYPE MapSetNode TYPE DFANodeMemHandler tIndex :: SPNodeID = 0_kIndex TYPE ( StatePackNode ), ALLOCATABLE :: SPNode (:) tIndex :: SMNodeID = 0_kIndex TYPE ( StateMapNode ), ALLOCATABLE :: SMNode (:) tIndex :: PMNodeID = 0_kIndex TYPE ( PackMapNode ), ALLOCATABLE :: PMNode (:) tIndex :: PINodeID = 0_kIndex TYPE ( PackIntegerNode ), ALLOCATABLE :: PINode (:) tIndex :: MSNodeID = 0_kIndex TYPE ( MapSetNode ), ALLOCATABLE :: MSNode (:) END TYPE DFANodeMemHandler !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: TYPE ( DFANodeMemHandler ), TARGET :: DFAMemManger CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !------------------------------------------------------------------------------- !                           DFANodeMemHandler Procedures !------------------------------------------------------------------------------- SUBROUTINE StatePackNode_New ( Node , State , Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its state and state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( StatePackNode ), POINTER , INTENT ( INOUT ) :: Node TYPE ( BitmapState ), INTENT ( IN ) :: State TYPE ( BitmapStatePack ), INTENT ( IN ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( DFAMemManger % SPNode )) THEN ! need allocation ALLOCATE ( DFAMemManger % SPNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN DFAMemManger % SPNodeID = 0_kIndex CALL Handle_ErrAlloc ( 'StatePackNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF DFAMemManger % SPNodeID = 1_kIndex ELSEIF ( DFAMemManger % SPNodeID == SIZE ( DFAMemManger % SPNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( StatePackNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( DFAMemManger % SPNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'StatePackNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( DFAMemManger % SPNode )) = DFAMemManger % SPNode CALL MOVE_ALLOC ( NewNode , DFAMemManger % SPNode ) DFAMemManger % SPNodeID = DFAMemManger % SPNodeID + 1 END BLOCK END IF ! set pointer to the storage Node => DFAMemManger % SPNode ( DFAMemManger % SPNodeID ) CALL Node % Construct ( State , Pack ) RETURN END SUBROUTINE StatePackNode_New !****************************************************************************** SUBROUTINE StateMapNode_New ( Node , State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its state. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( StateMapNode ), POINTER , INTENT ( INOUT ) :: Node TYPE ( BitmapState ), INTENT ( IN ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( DFAMemManger % SMNode )) THEN ! need allocation ALLOCATE ( DFAMemManger % SMNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN DFAMemManger % SMNodeID = 0_kIndex CALL Handle_ErrAlloc ( 'StateMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF DFAMemManger % SMNodeID = 1_kIndex ELSEIF ( DFAMemManger % SMNodeID == SIZE ( DFAMemManger % SMNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( StateMapNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( DFAMemManger % SMNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'StateMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( DFAMemManger % SMNode )) = DFAMemManger % SMNode CALL MOVE_ALLOC ( NewNode , DFAMemManger % SMNode ) DFAMemManger % SMNodeID = DFAMemManger % SMNodeID + 1 END BLOCK END IF ! set pointer to the storage Node => DFAMemManger % SMNode ( DFAMemManger % SMNodeID ) CALL Node % Construct ( State ) RETURN END SUBROUTINE StateMapNode_New !****************************************************************************** SUBROUTINE PackMapNode_New ( Node , StatePack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PackMapNode ), POINTER , INTENT ( INOUT ) :: Node TYPE ( BitmapStatePack ), INTENT ( IN ) :: StatePack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( DFAMemManger % PMNode )) THEN ! need allocation ALLOCATE ( DFAMemManger % PMNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN DFAMemManger % PMNodeID = 0_kIndex CALL Handle_ErrAlloc ( 'PackMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF DFAMemManger % PMNodeID = 1_kIndex ELSEIF ( DFAMemManger % PMNodeID == SIZE ( DFAMemManger % PMNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( PackMapNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( DFAMemManger % PMNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'PackMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( DFAMemManger % PMNode )) = DFAMemManger % PMNode CALL MOVE_ALLOC ( NewNode , DFAMemManger % PMNode ) DFAMemManger % PMNodeID = DFAMemManger % PMNodeID + 1 END BLOCK END IF ! set pointer to the storage Node => DFAMemManger % PMNode ( DFAMemManger % PMNodeID ) CALL Node % Construct ( StatePack ) RETURN END SUBROUTINE PackMapNode_New !****************************************************************************** SUBROUTINE PackIntegerNode_New ( Node , StatePack , Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PackIntegerNode ), POINTER , INTENT ( INOUT ) :: Node TYPE ( BitmapStatePack ), INTENT ( IN ) :: StatePack tSInt32 , INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( DFAMemManger % PINode )) THEN ! need allocation ALLOCATE ( DFAMemManger % PINode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN DFAMemManger % PINodeID = 0_kIndex CALL Handle_ErrAlloc ( 'PackIntegerNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF DFAMemManger % PINodeID = 1_kIndex ELSEIF ( DFAMemManger % PINodeID == SIZE ( DFAMemManger % PINode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( PackIntegerNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( DFAMemManger % PINode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'PackIntegerNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( DFAMemManger % PINode )) = DFAMemManger % PINode CALL MOVE_ALLOC ( NewNode , DFAMemManger % PINode ) DFAMemManger % PINodeID = DFAMemManger % PINodeID + 1 END BLOCK END IF ! set pointer to the storage Node => DFAMemManger % PINode ( DFAMemManger % PINodeID ) CALL Node % Construct ( StatePack , Val ) RETURN END SUBROUTINE PackIntegerNode_New !****************************************************************************** SUBROUTINE MapSetNode_New ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and specify its state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( MapSetNode ), POINTER , INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( DFAMemManger % MSNode )) THEN ! need allocation ALLOCATE ( DFAMemManger % MSNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN DFAMemManger % MSNodeID = 0_kIndex CALL Handle_ErrAlloc ( 'MapSetNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF DFAMemManger % MSNodeID = 1_kIndex ELSEIF ( DFAMemManger % MSNodeID == SIZE ( DFAMemManger % MSNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( MapSetNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( DFAMemManger % MSNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'MapSetNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( DFAMemManger % MSNode )) = DFAMemManger % MSNode CALL MOVE_ALLOC ( NewNode , DFAMemManger % MSNode ) DFAMemManger % MSNodeID = DFAMemManger % MSNodeID + 1 END BLOCK END IF ! set pointer to the storage Node => DFAMemManger % MSNode ( DFAMemManger % MSNodeID ) RETURN END SUBROUTINE MapSetNode_New !****************************************************************************** SUBROUTINE DFANodes_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! clear all components IF ( ALLOCATED ( DFAMemManger % SPNode )) THEN DO I = 1_kIndex , SIZE ( DFAMemManger % SPNode , KIND = kIndex ) CALL DFAMemManger % SPNode ( I )% MemFree () END DO DEALLOCATE ( DFAMemManger % SPNode ) END IF IF ( ALLOCATED ( DFAMemManger % SMNode )) THEN DO I = 1_kIndex , SIZE ( DFAMemManger % SMNode , KIND = kIndex ) CALL DFAMemManger % SMNode ( I )% MemFree () END DO DEALLOCATE ( DFAMemManger % SMNode ) END IF IF ( ALLOCATED ( DFAMemManger % PMNode )) THEN DO I = 1_kIndex , SIZE ( DFAMemManger % PMNode , KIND = kIndex ) CALL DFAMemManger % PMNode ( I )% MemFree () END DO DEALLOCATE ( DFAMemManger % PMNode ) END IF IF ( ALLOCATED ( DFAMemManger % PINode )) THEN DO I = 1_kIndex , SIZE ( DFAMemManger % PINode , KIND = kIndex ) CALL DFAMemManger % PINode ( I )% MemFree () END DO DEALLOCATE ( DFAMemManger % PINode ) END IF IF ( ALLOCATED ( DFAMemManger % MSNode )) THEN DO I = 1_kIndex , SIZE ( DFAMemManger % MSNode , KIND = kIndex ) CALL DFAMemManger % MSNode ( I )% MemFree () END DO DEALLOCATE ( DFAMemManger % MSNode ) END IF ! reset indices DFAMemManger % SPNodeID = 0_kIndex DFAMemManger % SMNodeID = 0_kIndex DFAMemManger % PMNodeID = 0_kIndex DFAMemManger % PINodeID = 0_kIndex DFAMemManger % MSNodeID = 0_kIndex RETURN END SUBROUTINE DFANodes_Free !------------------------------------------------------------------------------- !                           DFAutomaton Procedures !------------------------------------------------------------------------------- FUNCTION DFAutomaton_Construct ( DFA , Manager ) RESULT ( RegexPat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the DFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( OUT ) :: DFA TYPE ( BitmapStateManager ), TARGET , INTENT ( IN ) :: Manager TYPE ( CompiledRegex ) :: RegexPat !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW DFA % Manager => Manager DFA % States ( 0 :) => Manager % GetStates () RegexPat % IS = - 1 RegexPat % RS = - 1 CALL DFA % Initialize ( RegexPat ) RETURN END FUNCTION DFAutomaton_Construct !****************************************************************************** SUBROUTINE DFAutomaton_Destruct ( DFA ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the DFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NULLIFY ( DFA % Manager ) NULLIFY ( DFA % States ) CALL BitmapState_Free () CALL DFANodes_Free () RETURN END SUBROUTINE DFAutomaton_Destruct !****************************************************************************** SUBROUTINE DFAutomaton_Initialize ( DFA , RegexPat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform initialization of the DFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( CompiledRegex ), INTENT ( INOUT ) :: RegexPat !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( BitmapState ), POINTER :: InitState TYPE ( BitmapState ), POINTER :: FinalState TYPE ( IntrusiveHashList ) :: ClosureMap ! use StatePackNode as node TYPE ( IntrusiveHashList ) :: NFATransMap ! use StateMapNode as node TYPE ( IntrusiveHashList ) :: DFATransMap ! use PackMapNode as node TYPE ( BitmapStatePack ), POINTER :: InitStatePack tIndex :: InitCap ! FLOW ! initialize InitState => DFA % States ( 0 ) FinalState => DFA % States ( 1 ) ! construct map explicitly InitCap = SIZE ( DFA % States , KIND = kIndex ) CALL ClosureMap % Construct ( InitCap ) CALL NFATransMap % Construct ( InitCap ) CALL DFATransMap % Construct ( InitCap ) ! get closure map ClosureMap = DFA % CalculateClosure ( DFA % States ) ! construct a NFA first CALL DFA % NFATransMap ( ClosureMap , NFATransMap ) ! construct an original DFA using the constructed NFA. ! Each key which is set of nfa states is a new dfa state. InitStatePack => GetPack_StatePackNode ( InitState , ClosureMap ) CALL DFA % OriginalDFA ( InitStatePack , NFATransMap , DFATransMap ) ! construct minimum DFA CALL DFA % Minimize ( DFATransMap , InitStatePack , FinalState , RegexPat ) NULLIFY ( InitState , FinalState , InitStatePack ) RETURN END SUBROUTINE DFAutomaton_Initialize !****************************************************************************** SUBROUTINE DFAutomaton_NFATransMap ( DFA , ClosureMap , NFATransMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the NFA transition map. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: ClosureMap TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: NFATransMap !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StateMapNode ), POINTER :: NewStateMap TYPE ( BitmapStatePack ), POINTER :: Closure TYPE ( BitmapStatePack ), POINTER :: Reachable tSInt32 :: I , J tChar :: C ! FLOW DO I = 0 , SIZE ( DFA % States ) - 1 ASSOCIATE ( State => DFA % States ( I )) CALL StateMapNode_New ( NewStateMap , State ) DO J = 0 , EncodingLen - 1 C = ACHAR ( J ) Closure => GetPack_StatePackNode ( State , ClosureMap ) Reachable => DFA % TraceReachable ( Closure , C , ClosureMap ) IF (. NOT . Reachable % IsEmpty ()) THEN BLOCK TYPE ( BitMapNode ), POINTER :: NewBitNode CALL BitMapNode_New ( NewBitNode , C , DFA % Manager , Reachable ) CALL NewStateMap % SubMap % Insert ( NewBitNode ) NULLIFY ( NewBitNode ) END BLOCK END IF CALL NFATransMap % Insert ( NewStateMap ) NULLIFY ( NewStateMap , Closure , Reachable ) END DO END ASSOCIATE END DO RETURN END SUBROUTINE DFAutomaton_NFATransMap !****************************************************************************** SUBROUTINE DFAutomaton_OriginalDFA ( DFA , StateSet , NFATransMap , DFATransMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the original DFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: StateSet TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: NFATransMap ! use StateMapNode as node TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: DFATransMap ! use PackMapNode as node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( IntrusiveLinearList ) :: Stack ! use BitmapStatePack as node TYPE ( BitmapStatePack ), POINTER :: PopNode TYPE ( IntrusiveHashList ), POINTER :: SubMap TYPE ( BitmapStatePack ), POINTER :: PackUnion tSInt32 :: J tChar :: C TYPE ( IntrusiveLinearList ), POINTER :: StateList ! FLOW CALL Stack % Push ( StateSet ) DO PopNode => StackPop ( Stack ) SubMap => GetMap_PackMapNode ( PopNode , DFATransMap ) IF (. NOT . ASSOCIATED ( SubMap )) THEN BLOCK TYPE ( PackMapNode ), POINTER :: NewNode CALL PackMapNode_New ( NewNode , PopNode ) CALL DFATransMap % Insert ( NewNode ) NULLIFY ( NewNode ) END BLOCK END IF DO J = 0 , EncodingLen - 1 C = ACHAR ( J ) CALL DFA % Manager % NewEmptyPack ( PackUnion ) StateList => PopNode % AsList () CALL StateListLoop ( StateList , NFATransMap , PackUnion , C ) CALL PackUnion % Freeze () CALL CheckPackIsEmpty ( PackUnion , C , DFA % Manager , SubMap , DFATransMap , Stack ) END DO IF ( Stack % IsEmpty ()) EXIT END DO NULLIFY ( PopNode , SubMap , PackUnion , StateList ) RETURN CONTAINS FUNCTION StackPop ( Stack ) RESULT ( PopNode ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: Stack TYPE ( BitmapStatePack ), POINTER :: PopNode !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: StackNode tLogical :: Success ! FLOW PopNode => NULL () Success = Stack % Pop ( StackNode ) IF ( Success . AND . ASSOCIATED ( StackNode )) THEN SELECT TYPE ( StackNode ) TYPE IS ( BitmapStatePack ) PopNode => StackNode END SELECT END IF NULLIFY ( StackNode ) RETURN END FUNCTION StackPop !************************************************************************** SUBROUTINE StateListLoop ( List , NFAMap , UPack , Ch ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: List TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: NFAMap ! use StateMapNode as node TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: UPack tChar , INTENT ( IN ) :: Ch !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: ListNode tLogical :: EndOfList TYPE ( IntrusiveHashList ), POINTER :: SubMap TYPE ( BitmapStatePack ), POINTER :: NFASet ! FLOW EndOfList = List % StartFirst ( ListNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( State => ListNode ) TYPE IS ( BitmapState ) SubMap => GetMap_StateMapNode ( State , NFAMap ) END SELECT NFASet => GetPack_BitMapNode ( Ch , SubMap ) IF ( ASSOCIATED ( NFASet )) CALL UPack % AddAll ( NFASet ) EndOfList = List % MoveForward ( ListNode ) END DO NULLIFY ( ListNode , SubMap , NFASet ) RETURN END SUBROUTINE StateListLoop !************************************************************************** SUBROUTINE CheckPackIsEmpty ( UPack , Ch , Manager , SubMap , DFAMap , Stack ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), TARGET , INTENT ( INOUT ) :: UPack tChar , INTENT ( IN ) :: Ch TYPE ( BitmapStateManager ), INTENT ( INOUT ) :: Manager TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: SubMap ! use BitMapNode as node TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: DFAMap ! use PackMapNode as node TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: Stack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . UPack % IsEmpty ()) THEN BLOCK TYPE ( BitMapNode ), POINTER :: NewNode CALL BitMapNode_New ( NewNode , Ch , Manager , UPack ) CALL SubMap % Insert ( NewNode ) NULLIFY ( NewNode ) END BLOCK BLOCK TYPE ( PackMapNode ) :: KeyNode KeyNode % Pack => UPack IF (. NOT . DFAMap % Contain ( KeyNode )) THEN CALL Stack % Push ( UPack ) END IF NULLIFY ( KeyNode % Pack ) END BLOCK END IF RETURN END SUBROUTINE CheckPackIsEmpty !************************************************************************** END SUBROUTINE DFAutomaton_OriginalDFA !****************************************************************************** FUNCTION DFAutomaton_CalculateClosure ( DFA , States ) RESULT ( ClosureMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform ... !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( BitmapState ), INTENT ( INOUT ) :: States ( 0 :) TYPE ( IntrusiveHashList ) :: ClosureMap ! use StatePackNode as node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StatePackNode ), POINTER :: NewNode TYPE ( BitmapStatePack ), POINTER :: Closure tSInt32 :: I ! FLOW DO I = 0 , SIZE ( States ) - 1 CALL DFA % Manager % NewEmptyPack ( Closure ) CALL DFA % DfsClosure ( States ( I ), Closure ) CALL Closure % Freeze () CALL StatePackNode_New ( NewNode , States ( I ), Closure ) CALL ClosureMap % Insert ( NewNode ) NULLIFY ( NewNode , Closure ) END DO RETURN END FUNCTION DFAutomaton_CalculateClosure !****************************************************************************** SUBROUTINE DFAutomaton_DfsClosure ( DFA , State , Closure ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform ... !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( BitmapState ), INTENT ( INOUT ) :: State TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: Closure !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( IntrusiveLinearList ) :: NFAStack TYPE ( BitmapState ), POINTER :: Pop TYPE ( BitmapStatePack ), POINTER :: DirectTable TYPE ( IntrusiveLinearList ), POINTER :: List ! FLOW CALL NFAStack % Push ( State ) DO Pop => StackPop ( NFAStack ) CALL Closure % AddState ( Pop % GetID ()) DirectTable => Pop % GetDirectTable () List => DirectTable % AsList () CALL StateListLoop ( List , NFAStack , Closure ) IF ( NFAStack % IsEmpty ()) EXIT END DO NULLIFY ( Pop , DirectTable , List ) ASSOCIATE ( Dummy => DFA ); END ASSOCIATE RETURN CONTAINS FUNCTION StackPop ( Stack ) RESULT ( PopNode ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: Stack TYPE ( BitmapState ), POINTER :: PopNode !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: StackNode tLogical :: Success ! FLOW PopNode => NULL () Success = Stack % Pop ( StackNode ) IF ( Success . AND . ASSOCIATED ( StackNode )) THEN SELECT TYPE ( StackNode ) TYPE IS ( BitmapState ) PopNode => StackNode END SELECT END IF NULLIFY ( StackNode ) RETURN END FUNCTION StackPop !************************************************************************** SUBROUTINE StateListLoop ( List , Stack , Closure ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: List TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: Stack TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: Closure !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: ListNode tLogical :: EndOfList ! FLOW EndOfList = List % StartFirst ( ListNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( Next => ListNode ) TYPE IS ( BitmapState ) IF (. NOT . Closure % Contain ( Next % GetID ())) CALL Stack % Push ( Next ) END SELECT EndOfList = List % MoveForward ( ListNode ) END DO NULLIFY ( ListNode ) RETURN END SUBROUTINE StateListLoop !************************************************************************** END SUBROUTINE DFAutomaton_DfsClosure !****************************************************************************** FUNCTION DFAutomaton_TraceReachable ( DFA , Closure , Chr , ClosureMap ) RESULT ( ResPack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform ... !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: Closure tChar , INTENT ( IN ) :: Chr TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: ClosureMap ! use StatePackNode as node TYPE ( BitmapStatePack ), POINTER :: ResPack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( IntrusiveLinearList ), POINTER :: ClosureList CLASS ( DoublyLinkedNode ), POINTER :: ClosureNode TYPE ( IntrusiveHashList ), POINTER :: TransitionMap ! use BitMapNode as node TYPE ( BitmapStatePack ), POINTER :: StateSet tLogical :: IsListEmpty ! FLOW CALL DFA % Manager % NewEmptyPack ( ResPack ) ClosureList => Closure % AsList () IsListEmpty = ClosureList % StartFirst ( ClosureNode ) DO WHILE (. NOT . IsListEmpty ) SELECT TYPE ( ClosureState => ClosureNode ) TYPE IS ( BitmapState ) TransitionMap => ClosureState % GetTransitionMap () StateSet => GetPack_BitMapNode ( Chr , TransitionMap ) IF ( ASSOCIATED ( StateSet )) THEN CALL StateListLoop ( StateSet , ResPack , ClosureMap ) END IF END SELECT IsListEmpty = ClosureList % MoveForward ( ClosureNode ) END DO CALL ResPack % Freeze () NULLIFY ( ClosureNode , ClosureList , TransitionMap , StateSet ) RETURN CONTAINS SUBROUTINE StateListLoop ( StateSet , Pack , ClosureMap ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: StateSet TYPE ( BitmapStatePack ), INTENT ( INOUT ) :: Pack TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: ClosureMap ! use StatePackNode as node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( IntrusiveLinearList ), POINTER :: List CLASS ( DoublyLinkedNode ), POINTER :: ListNode TYPE ( BitmapStatePack ), POINTER :: Other tLogical :: EndOfList ! FLOW List => StateSet % AsList () EndOfList = List % StartFirst ( ListNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( State => ListNode ) TYPE IS ( BitmapState ) Other => GetPack_StatePackNode ( State , ClosureMap ) CALL Pack % AddAll ( Other ) END SELECT EndOfList = List % MoveForward ( ListNode ) END DO NULLIFY ( List , ListNode , Other ) RETURN END SUBROUTINE StateListLoop !************************************************************************** END FUNCTION DFAutomaton_TraceReachable !****************************************************************************** SUBROUTINE DFAutomaton_Minimize ( DFA , TransMap , InitClosure , FinalState , RegexPat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct minimum DFA. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DFAutomaton ), INTENT ( INOUT ) :: DFA TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: TransMap ! use PackMapNode as node TYPE ( BitmapStatePack ), INTENT ( IN ) :: InitClosure TYPE ( BitmapState ), INTENT ( IN ) :: FinalState TYPE ( CompiledRegex ), INTENT ( INOUT ) :: RegexPat !** SUBROUTINE DERIVED-TYPE DEFINITIONS: TYPE RejectState tSInt32 :: Val ( 0 : EncodingLen - 1 ) = 0 END TYPE RejectState !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TreeInteger4B ) :: renamedDFATransitionTable ! use integer-RejectState as key-value pair TYPE ( TreeInteger4B ) :: finalFlags ! use integer-logical as key-value pair TYPE ( TreeInteger4B ) :: groupFlags ! use integer-integer as key-value pair TYPE ( IntrusiveHashList ) :: stateRenamingMap ! use PackIntegerNode tSInt32 :: initStateAfterRenaming tSInt32 :: renamingStateID tSInt32 :: groupTotal TYPE ( RejectState ) :: newRejectedState ! FLOW ! initialize initStateAfterRenaming = - 1 renamingStateID = 1 CALL stateRenamingMap % Construct () ! rename all states BLOCK TYPE ( PackIntegerNode ), POINTER :: NewNode TYPE ( BitmapStatePack ), POINTER :: nfaState CLASS ( HashListNode ), POINTER :: MapNode tLogical :: IsTheEnd IsTheEnd = TransMap % StartFirst ( MapNode ) DO WHILE (. NOT . IsTheEnd ) SELECT TYPE ( PackNode => MapNode ) TYPE IS ( PackMapNode ) nfaState => PackNode % Pack END SELECT IF (( initStateAfterRenaming == - 1 ). AND .( nfaState % IsEqual ( InitClosure ))) THEN initStateAfterRenaming = renamingStateID ! preserve initial state id END IF CALL PackIntegerNode_New ( NewNode , nfaState , renamingStateID ) CALL stateRenamingMap % Insert ( NewNode ) renamingStateID = renamingStateID + 1 IsTheEnd = TransMap % MoveForward ( MapNode ) END DO NULLIFY ( MapNode , nfaState , NewNode ) END BLOCK ! the rejected state 0 CALL renamedDFATransitionTable % Insert ( 0 , newRejectedState ) CALL finalFlags % Insert ( 0 , FalseVal ) ! construct renamed dfa transition table RenamedDFA : BLOCK CLASS ( HashListNode ), POINTER :: MapNode TYPE ( BitmapStatePack ), POINTER :: MapKey TYPE ( IntrusiveHashList ), POINTER :: MapVal tLogical :: IsTheEnd ! execute IsTheEnd = TransMap % StartFirst ( MapNode ) DO WHILE (. NOT . IsTheEnd ) ! get map's key and value SELECT TYPE ( PackNode => MapNode ) TYPE IS ( PackMapNode ) MapKey => PackNode % Pack MapVal => PackNode % SubMap END SELECT renamingStateID = GetVal_PackIntegerNode ( MapKey , stateRenamingMap ) SubMapBlock : BLOCK CLASS ( HashListNode ), POINTER :: SubMapNode tChar :: SubMapKey TYPE ( BitmapStatePack ), POINTER :: SubMapVal tLogical :: EndOfSubMap TYPE ( RejectState ) :: State ! execute EndOfSubMap = MapVal % StartFirst ( SubMapNode ) DO WHILE (. NOT . EndOfSubMap ) ! get submap's key and value SELECT TYPE ( RowNode => SubMapNode ) TYPE IS ( BitMapNode ) SubMapKey = RowNode % Chr SubMapVal => RowNode % State END SELECT State % Val ( IACHAR ( SubMapKey )) = GetVal_PackIntegerNode ( SubMapVal , stateRenamingMap ) EndOfSubMap = MapVal % MoveForward ( SubMapNode ) END DO CALL renamedDFATransitionTable % Insert ( renamingStateID , State ) NULLIFY ( SubMapNode , SubMapVal ) END BLOCK SubMapBlock IF ( MapKey % Contain ( FinalState % GetID ())) THEN CALL finalFlags % Insert ( renamingStateID , TrueVal ) ELSE CALL finalFlags % Insert ( renamingStateID , FalseVal ) END IF IsTheEnd = TransMap % MoveForward ( MapNode ) END DO NULLIFY ( MapNode , MapKey , MapVal ) END BLOCK RenamedDFA ! group states to final states and non-final states GroupFlag : BLOCK tSInt32 :: I , FlagSize tLogical :: Bool DO I = 0 , finalFlags % GetSize () - 1 Bool = GetBool_IntBoolNode ( I , finalFlags ) IF ( Bool ) THEN CALL groupFlags % Insert ( I , 0 ) ELSE CALL groupFlags % Insert ( I , 1 ) END IF END DO END BLOCK GroupFlag ! splitting, group id is the final state id FinalStateID : BLOCK tSInt32 :: prevGroupTotal , sensitiveGroup tSInt32 :: SetID , group , Ch , targetState , targetGroup tLogical :: First , IsTheEnd TYPE ( IntrusiveHashList ) :: invertMap ! use MapSetNode TYPE ( RejectState ) :: RejState TYPE ( MapSetNode ), POINTER :: NewNode TYPE ( TreeInteger4B ), POINTER :: targetGroupTable TYPE ( PQInteger4B ), POINTER :: stateIDSet CLASS ( HashListNode ), POINTER :: CurNode ! initialize groupTotal = 2 DO prevGroupTotal = groupTotal DO sensitiveGroup = 0 , prevGroupTotal - 1 !  <target group table, state id set> DO SetID = 0 , groupFlags % GetSize () - 1 ! use state id to iterate group = GetInt_IntIntNode ( SetID , groupFlags ) IF ( sensitiveGroup == group ) THEN CALL MapSetNode_New ( NewNode ) targetGroupTable => NewNode % TreeMap DO Ch = 0 , EncodingLen - 1 RejState = GetRej_IntRejNode ( SetID , renamedDFATransitionTable ) targetState = RejState % Val ( Ch ) targetGroup = GetInt_IntIntNode ( targetState , groupFlags ) CALL targetGroupTable % Insert ( Ch , targetGroup ) END DO stateIDSet => GetSet_MapSetNode ( NewNode , invertMap ) IF (. NOT . ASSOCIATED ( stateIDSet )) THEN CALL invertMap % Insert ( NewNode ) stateIDSet => NewNode % PQSet END IF CALL stateIDSet % Insert ( SetID ) NULLIFY ( NewNode , stateIDSet , targetGroupTable ) END IF END DO First = TrueVal IsTheEnd = invertMap % StartFirst ( CurNode ) DO WHILE (. NOT . IsTheEnd ) ! get map's key and value SELECT TYPE ( MapSet => CurNode ) TYPE IS ( MapSetNode ) stateIDSet => GetSet_MapSetNode ( MapSet , invertMap ) IF ( First ) THEN First = FalseVal ELSE DO WHILE (. NOT . stateIDSet % IsEmpty ()) IF ( stateIDSet % Remove ( SetID )) THEN CALL groupFlags % Insert ( SetID , groupTotal ) END IF END DO groupTotal = groupTotal + 1 END IF END SELECT IsTheEnd = invertMap % MoveForward ( CurNode ) END DO END DO IF ( prevGroupTotal == groupTotal ) EXIT END DO END BLOCK FinalStateID ! determine initial group state RegexPat % IS = GetInt_IntIntNode ( initStateAfterRenaming , groupFlags ) ! determine rejected group state RegexPat % RS = GetInt_IntIntNode ( 0 , groupFlags ) ! determine final group states FinalGroupStates : BLOCK TYPE ( TreeInteger4B ) :: finalGroupFlags tSInt32 :: I , groupFlag DO I = 0 , groupFlags % GetSize () - 1 groupFlag = GetInt_IntIntNode ( I , groupFlags ) IF ( GetBool_IntBoolNode ( I , finalFlags )) CALL finalGroupFlags % Insert ( groupFlag , 0 ) END DO CALL MemAlloc ( RegexPat % FS , ToIndex ( groupTotal ), StartID = 0_kIndex ) DO I = 0 , groupTotal - 1 RegexPat % FS ( I ) = finalGroupFlags % Contain ( I ) END DO END BLOCK FinalGroupStates ! construct the output transition table CALL MemAlloc ( RegexPat % TransitionTable , [ ToIndex ( EncodingLen ), ToIndex ( groupTotal )], & StartID = [ 0_kIndex , 0_kIndex ]) TransTable : BLOCK tSInt32 :: setID , groupID , Ch TYPE ( RejectState ) :: OrgState OutLoop : DO groupID = 0 , groupTotal - 1 ASSOCIATE ( State => RegexPat % TransitionTable (:, groupID )) InLoop : DO setID = 0 , groupFlags % GetSize () - 1 IF ( groupID == GetInt_IntIntNode ( setID , groupFlags )) THEN OrgState = GetRej_IntRejNode ( SetID , renamedDFATransitionTable ) DO Ch = 0 , EncodingLen - 1 State ( Ch ) = GetInt_IntIntNode ( OrgState % Val ( Ch ), groupFlags ) END DO EXIT InLoop END IF END DO InLoop END ASSOCIATE END DO OutLoop END BLOCK TransTable ! free memory CALL renamedDFATransitionTable % Destruct () CALL finalFlags % Destruct () CALL groupFlags % Destruct () ASSOCIATE ( Dummy => DFA ); END ASSOCIATE RETURN CONTAINS FUNCTION GetInt_IntIntNode ( Key , TreeMap ) RESULT ( Val ) !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Key TYPE ( TreeInteger4B ), INTENT ( INOUT ) :: TreeMap tSInt32 :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( * ), ALLOCATABLE :: Any ! FLOW Val = 0 IF ( TreeMap % GetValue ( Key , Any )) THEN SELECT TYPE ( Any ) TYPE IS ( tSInt32 ) Val = Any END SELECT END IF RETURN END FUNCTION GetInt_IntIntNode !************************************************************************** FUNCTION GetBool_IntBoolNode ( Key , TreeMap ) RESULT ( Val ) !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Key TYPE ( TreeInteger4B ), INTENT ( INOUT ) :: TreeMap tLogical :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( * ), ALLOCATABLE :: Any ! FLOW Val = FalseVal IF ( TreeMap % GetValue ( Key , Any )) THEN SELECT TYPE ( Any ) TYPE IS ( tLogical ) Val = Any END SELECT END IF RETURN END FUNCTION GetBool_IntBoolNode !************************************************************************** FUNCTION GetRej_IntRejNode ( Key , TreeMap ) RESULT ( Val ) !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Key TYPE ( TreeInteger4B ), INTENT ( INOUT ) :: TreeMap TYPE ( RejectState ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( * ), ALLOCATABLE :: Any ! FLOW Val % Val = 0 IF ( TreeMap % GetValue ( Key , Any )) THEN SELECT TYPE ( Any ) TYPE IS ( RejectState ) Val % Val = Any % Val END SELECT END IF RETURN END FUNCTION GetRej_IntRejNode !************************************************************************** END SUBROUTINE DFAutomaton_Minimize !------------------------------------------------------------------------------- !                               StatePackNode Procedures !------------------------------------------------------------------------------- FUNCTION StatePackNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal SELECT TYPE ( RhsObj ) TYPE IS ( StatePackNode ) IF ( ASSOCIATED ( LhsObj % State ). AND . ASSOCIATED ( RhsObj % State )) THEN Flag = LhsObj % State % IsEqual ( RhsObj % State ) END IF END SELECT RETURN END FUNCTION StatePackNode_IsKeyEqual !****************************************************************************** SUBROUTINE StatePackNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Obj % State )) CALL Obj % State % Destruct () CALL Obj % Pack % Destruct () RETURN END SUBROUTINE StatePackNode_MemFree !****************************************************************************** FUNCTION StatePackNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = 0 IF ( ASSOCIATED ( Obj % State )) Code = Obj % State % HashCode () RETURN END FUNCTION StatePackNode_HashCode !****************************************************************************** SUBROUTINE StatePackNode_Construct ( Node , State , Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the StatePackNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( OUT ) :: Node TYPE ( BitmapState ), TARGET , INTENT ( IN ) :: State TYPE ( BitmapStatePack ), TARGET , INTENT ( IN ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % State => State Node % Pack => Pack RETURN END SUBROUTINE StatePackNode_Construct !------------------------------------------------------------------------------- !                               StateMapNode Procedures !------------------------------------------------------------------------------- FUNCTION StateMapNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal SELECT TYPE ( RhsObj ) TYPE IS ( StateMapNode ) IF ( ASSOCIATED ( LhsObj % State ). AND . ASSOCIATED ( RhsObj % State )) THEN Flag = LhsObj % State % IsEqual ( RhsObj % State ) END IF END SELECT RETURN END FUNCTION StateMapNode_IsKeyEqual !****************************************************************************** SUBROUTINE StateMapNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Obj % State )) CALL Obj % State % Destruct () CALL Obj % SubMap % Clear () RETURN END SUBROUTINE StateMapNode_MemFree !****************************************************************************** FUNCTION StateMapNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = 0 IF ( ASSOCIATED ( Obj % State )) Code = Obj % State % HashCode () RETURN END FUNCTION StateMapNode_HashCode !****************************************************************************** SUBROUTINE StateMapNode_Construct ( Node , State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the StateMapNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( OUT ) :: Node TYPE ( BitmapState ), TARGET , INTENT ( IN ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % State => State CALL Node % SubMap % Construct () RETURN END SUBROUTINE StateMapNode_Construct !------------------------------------------------------------------------------- !                               PackMapNode Procedures !------------------------------------------------------------------------------- FUNCTION PackMapNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal SELECT TYPE ( RhsObj ) TYPE IS ( PackMapNode ) IF ( ASSOCIATED ( LhsObj % Pack ). AND . ASSOCIATED ( RhsObj % Pack )) THEN Flag = LhsObj % Pack % IsEqual ( RhsObj % Pack ) END IF END SELECT RETURN END FUNCTION PackMapNode_IsKeyEqual !****************************************************************************** SUBROUTINE PackMapNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Obj % Pack )) CALL Obj % Pack % Destruct () CALL Obj % SubMap % Clear () RETURN END SUBROUTINE PackMapNode_MemFree !****************************************************************************** FUNCTION PackMapNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = 0 IF ( ASSOCIATED ( Obj % Pack )) Code = Obj % Pack % HashCode () RETURN END FUNCTION PackMapNode_HashCode !****************************************************************************** SUBROUTINE PackMapNode_Construct ( Node , Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the PackMapNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( OUT ) :: Node TYPE ( BitmapStatePack ), TARGET , INTENT ( IN ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % Pack => Pack CALL Node % SubMap % Construct () RETURN END SUBROUTINE PackMapNode_Construct !------------------------------------------------------------------------------- !                               PackIntegerNode Procedures !------------------------------------------------------------------------------ FUNCTION PackIntegerNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal SELECT TYPE ( RhsObj ) TYPE IS ( PackIntegerNode ) IF ( ASSOCIATED ( LhsObj % Pack ). AND . ASSOCIATED ( RhsObj % Pack )) THEN Flag = LhsObj % Pack % IsEqual ( RhsObj % Pack ) END IF END SELECT RETURN END FUNCTION PackIntegerNode_IsKeyEqual !******************************************************************************* SUBROUTINE PackIntegerNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Obj % Pack )) CALL Obj % Pack % Destruct () RETURN END SUBROUTINE PackIntegerNode_MemFree !******************************************************************************* FUNCTION PackIntegerNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = 0 IF ( ASSOCIATED ( Obj % Pack )) Code = Obj % Pack % HashCode () RETURN END FUNCTION PackIntegerNode_HashCode !******************************************************************************* SUBROUTINE PackIntegerNode_Construct ( Node , Pack , Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the PackIntegerNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( OUT ) :: Node TYPE ( BitmapStatePack ), TARGET , INTENT ( IN ) :: Pack tSInt32 , INTENT ( IN ) :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % Pack => Pack Node % Val = Val RETURN END SUBROUTINE PackIntegerNode_Construct !------------------------------------------------------------------------------- !                               MapSetNode Procedures !------------------------------------------------------------------------------- FUNCTION MapSetNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal SELECT TYPE ( RhsObj ) TYPE IS ( MapSetNode ) IF ( LhsObj % TreeMap % GetSize () /= RhsObj % TreeMap % GetSize ()) RETURN BLOCK tLogical :: EndOfTree tSInt32 :: LhsKey , RhsKey EndOfTree = LhsObj % TreeMap % StartFirst ( LhsKey ) EndOfTree = RhsObj % TreeMap % StartFirst ( RhsKey ) DO WHILE (. NOT . EndOfTree ) IF ( LhsKey /= RhsKey ) RETURN EndOfTree = LhsObj % TreeMap % MoveForward ( LhsKey ) EndOfTree = RhsObj % TreeMap % MoveForward ( RhsKey ) END DO END BLOCK Flag = TrueVal END SELECT RETURN END FUNCTION MapSetNode_IsKeyEqual !****************************************************************************** SUBROUTINE MapSetNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % TreeMap % Destruct () CALL Obj % PQSet % Destruct () RETURN END SUBROUTINE MapSetNode_MemFree !****************************************************************************** FUNCTION MapSetNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: EndOfTree tSInt32 :: Key , KeySum tIndex :: KeySize ! FLOW Code = 0 KeySum = 0 !    EndOfTree = Obj%TreeMap%StartFirst(Key) DO WHILE (. NOT . EndOfTree ) KeySum = KeySum + Key !        EndOfTree = Obj%TreeMap%MoveForward(Key) END DO KeySize = C_SIZEOF ( KeySum ) Code = HashFuncOpt ( KeySum , KeySize , 3131133 ) ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION MapSetNode_HashCode !****************************************************************************** SUBROUTINE MapSetNode_Construct ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % PQSet % CreateEmpty ( 32_kIndex ) RETURN END SUBROUTINE MapSetNode_Construct !------------------------------------------------------------------------------- !                               Auxiliary Procedures !------------------------------------------------------------------------------- FUNCTION GetPack_StatePackNode ( State , HashMap ) RESULT ( Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the BitmapStatePack object from the map for the specified state. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapState ), TARGET , INTENT ( IN ) :: State TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: HashMap ! of StatePackNode TYPE ( BitmapStatePack ), POINTER :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode TYPE ( StatePackNode ) :: SPNodeIn tLogical :: Success ! FLOW Pack => NULL () SPNodeIn % State => State Success = HashMap % FindNode ( SPNodeIn , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( StatePackNode ) Pack => HashNode % Pack END SELECT END IF NULLIFY ( HashNode , SPNodeIn % State ) RETURN END FUNCTION GetPack_StatePackNode !****************************************************************************** FUNCTION GetPack_BitMapNode ( C , HashMap ) RESULT ( Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the BitmapStatePack object from the map for the specified state. !** SUBROUTINE ARGUMENT DECLARATIONS: tChar , INTENT ( IN ) :: C TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: HashMap ! of BitMapNode TYPE ( BitmapStatePack ), POINTER :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode TYPE ( BitMapNode ) :: SPNodeIn tLogical :: Success ! FLOW Pack => NULL () SPNodeIn % Chr = C Success = HashMap % FindNode ( SPNodeIn , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( BitMapNode ) Pack => HashNode % State END SELECT END IF NULLIFY ( HashNode ) RETURN END FUNCTION GetPack_BitMapNode !****************************************************************************** FUNCTION GetMap_StateMapNode ( State , MainMap ) RESULT ( SubMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the IntrusiveHashList object from the map for the specified state. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapState ), TARGET , INTENT ( IN ) :: State TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: MainMap ! of StateMapNode TYPE ( IntrusiveHashList ), POINTER :: SubMap !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode TYPE ( StateMapNode ) :: SPNodeIn tLogical :: Success ! FLOW SubMap => NULL () SPNodeIn % State => State Success = MainMap % FindNode ( SPNodeIn , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( StateMapNode ) SubMap => HashNode % SubMap END SELECT END IF NULLIFY ( HashNode , SPNodeIn % State ) RETURN END FUNCTION GetMap_StateMapNode !****************************************************************************** FUNCTION GetMap_PackMapNode ( Pack , MainMap ) RESULT ( SubMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the IntrusiveHashList object from the map for the specified state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), TARGET , INTENT ( IN ) :: Pack TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: MainMap ! of PackMapNode TYPE ( IntrusiveHashList ), POINTER :: SubMap !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode TYPE ( PackMapNode ) :: SPNodeIn tLogical :: Success ! FLOW SubMap => NULL () SPNodeIn % Pack => Pack Success = MainMap % FindNode ( SPNodeIn , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( PackMapNode ) SubMap => HashNode % SubMap END SELECT END IF NULLIFY ( HashNode , SPNodeIn % Pack ) RETURN END FUNCTION GetMap_PackMapNode !****************************************************************************** FUNCTION GetVal_PackIntegerNode ( Pack , HashMap ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the integer value from the map for the specified state pack. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), TARGET , INTENT ( IN ) :: Pack TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: HashMap ! of PackIntegerNode tSInt32 :: Val !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode TYPE ( PackIntegerNode ) :: SPNodeIn tLogical :: Success ! FLOW Val = - 1 SPNodeIn % Pack => Pack Success = HashMap % FindNode ( SPNodeIn , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( PackIntegerNode ) Val = HashNode % Val END SELECT END IF NULLIFY ( HashNode , SPNodeIn % Pack ) RETURN END FUNCTION GetVal_PackIntegerNode !****************************************************************************** FUNCTION GetSet_MapSetNode ( Node , MainMap ) RESULT ( PQSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the priority queue object from the map for the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( MapSetNode ), INTENT ( INOUT ) :: Node TYPE ( IntrusiveHashList ), INTENT ( INOUT ) :: MainMap ! of MapSetNode TYPE ( PQInteger4B ), POINTER :: PQSet !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: HashNode tLogical :: Success ! FLOW PQSet => NULL () Success = MainMap % FindNode ( Node , HashNode ) IF ( Success . AND . ASSOCIATED ( HashNode )) THEN SELECT TYPE ( HashNode ) TYPE IS ( MapSetNode ) PQSet => HashNode % PQSet END SELECT END IF NULLIFY ( HashNode ) RETURN END FUNCTION GetSet_MapSetNode !****************************************************************************** ! ----------------------------------------------------------------------------- ! -----                     Deferred Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE StatePackNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the StatePackNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( StatePackNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'StatePackNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE StatePackNode_Copy !****************************************************************************** FUNCTION StatePackNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( StatePackNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = TrueVal ASSOCIATE ( Dummy => LhsObj ); END ASSOCIATE CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION StatePackNode_IsEqualTo !****************************************************************************** FUNCTION StatePackNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StatePackNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'StatePackNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION StatePackNode_ToString !****************************************************************************** SUBROUTINE StateMapNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the StateMapNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( StateMapNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'StateMapNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE StateMapNode_Copy !****************************************************************************** FUNCTION StateMapNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( StateMapNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = TrueVal ASSOCIATE ( Dummy => LhsObj ); END ASSOCIATE CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION StateMapNode_IsEqualTo !****************************************************************************** FUNCTION StateMapNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StateMapNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'StateMapNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION StateMapNode_ToString !****************************************************************************** SUBROUTINE PackMapNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the PackMapNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( PackMapNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'PackMapNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE PackMapNode_Copy !****************************************************************************** FUNCTION PackMapNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( PackMapNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = TrueVal ASSOCIATE ( Dummy => LhsObj ); END ASSOCIATE CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION PackMapNode_IsEqualTo !****************************************************************************** FUNCTION PackMapNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackMapNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'PackMapNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION PackMapNode_ToString !****************************************************************************** SUBROUTINE PackIntegerNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the PackIntegerNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( PackIntegerNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'PackIntegerNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE PackIntegerNode_Copy !****************************************************************************** FUNCTION PackIntegerNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( PackIntegerNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = TrueVal ASSOCIATE ( Dummy => LhsObj ); END ASSOCIATE CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION PackIntegerNode_IsEqualTo !****************************************************************************** FUNCTION PackIntegerNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PackIntegerNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'PackIntegerNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION PackIntegerNode_ToString !****************************************************************************** SUBROUTINE MapSetNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the MapSetNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( MapSetNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'MapSetNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE MapSetNode_Copy !****************************************************************************** FUNCTION MapSetNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( MapSetNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = TrueVal ASSOCIATE ( Dummy => LhsObj ); END ASSOCIATE CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION MapSetNode_IsEqualTo !****************************************************************************** FUNCTION MapSetNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( MapSetNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'MapSetNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION MapSetNode_ToString !****************************************************************************** END MODULE MClass_DFAutomaton !******************************************************************************","tags":"","loc":"sourcefile\\mclass_dfautomaton.f90.html"},{"title":"MBase_StringSorts.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_StringSorts !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains sorting and ranking routines specialized for strings. !   The specified array can be of a *CHARACTER* or a *FvlStr* type. <br> !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../MacroDef/Macro - Util Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ChrStr , ONLY : ChangeCase USE MClass_Comparable USE MClass_FvlStr USE MClass_Alphabets , ONLY : Alphabet => BaseAlphabet #ifdef Indx64Bits USE MBase_DoublyLinkedLists , ONLY : StackInteger => ListInteger8B #else USE MBase_DoublyLinkedLists , ONLY : StackInteger => ListInteger4B #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! sorting and ranking of case-insensitive strings PUBLIC :: Rank_Insensitive PUBLIC :: SortAscend_Insensitive PUBLIC :: SortDescend_Insensitive ! specialized sorting in an ascending order PUBLIC :: LSDSort PUBLIC :: MSDSort PUBLIC :: MSDInplaceSort PUBLIC :: QuickMultiKeySort PUBLIC :: AmericanFlagSort PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! number of total alphabets for extended ASCII character set tIndex , PARAMETER :: Radix = 256_kIndex !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ! public interfaces INTERFACE Rank_Insensitive !&#94; **Subroutine Interface**: Rank_Insensitive <br> !  **Purpose**:  To rank an array of strings in an ascending order using the specified !       ranking procedure where the strings are treated as case-insensitive strings. !       An applicable user-supplied procedure or any applicable ranking procedure (e.g. !       Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in !       the <a href=\"../module/mbase_ranking.html\">MBase_Ranking</a> module can be !       used as an argument. <br> !  **Usage**: <br> !   ! rank an array of Fortran intrinsic character strings <br> !   --->    CALL Rank_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br> !   ! rank an array of FvlStr objects <br> !   --->    CALL Rank_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br> !  **Note**: <br> !   The *Wise_RankChar* and *Wise_RankComp* are examples of applicable ranking procedures !   for Fortran intrinsic character strings and FvlStr objects, respectively. <br> MODULE PROCEDURE ChrStr_RankInsensitive MODULE PROCEDURE FvlStr_RankInsensitive END INTERFACE INTERFACE SortAscend_Insensitive !&#94; **Subroutine Interface**: SortAscend_Insensitive <br> !  **Purpose**:  To sort an array of strings in an ascending order using the specified !       ranking procedure where the strings are treated as case-insensitive strings. !       An applicable user-supplied procedure or any applicable ranking procedure (e.g. !       Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in !       the <a href=\"../module/mbase_ranking.html\">MBase_Ranking</a> module can be !       used as an argument. <br> !  **Usage**: <br> !   ! sort an array of Fortran intrinsic character strings <br> !   --->    CALL SortAscend_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br> !   ! sort an array of FvlStr objects <br> !   --->    CALL SortAscend_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br> !  **Note**: <br> !   The *Wise_RankChar* and *Wise_RankComp* are examples of applicable ranking procedures !   for Fortran intrinsic character strings and FvlStr objects, respectively. <br> MODULE PROCEDURE ChrStr_SortInsensitive_Ascend MODULE PROCEDURE FvlStr_SortInsensitive_Ascend END INTERFACE INTERFACE SortDescend_Insensitive !&#94; **Subroutine Interface**: SortDescend_Insensitive <br> !  **Purpose**:  To sort an array of strings in a descending order using the specified !       ranking procedure where the strings are treated as case-insensitive strings. !       An applicable user-supplied procedure or any applicable ranking procedure (e.g. !       Wise_RankChar, PDQ_RankChar, QuickMo3_RankComp, MergeHalfCopy_RankComp, etc.) in !       the <a href=\"../module/mbase_ranking.html\">MBase_Ranking</a> module can be !       used as an argument. <br> !  **Usage**: <br> !   ! sort an array of Fortran intrinsic character strings <br> !   --->    CALL SortDescend_Insensitive(cStrArr, cStrInd, Wise_RankChar) <br> !   ! sort an array of FvlStr objects <br> !   --->    CALL SortDescend_Insensitive(vStrArr, vStrInd, Wise_RankComp) <br> !  **Note**: <br> !   The *Wise_RankChar* and *Wise_RankComp* are examples of applicable ranking procedures !   for Fortran intrinsic character strings and FvlStr objects, respectively. <br> MODULE PROCEDURE ChrStr_SortInsensitive_Descend MODULE PROCEDURE FvlStr_SortInsensitive_Descend END INTERFACE INTERFACE LSDSort !&#94; **Subroutine Interface**: LSDSort <br> !  **Purpose**:  To sort an array of strings in an ascending order using the LSD !       string sorting algorithm. <br> !  **Usage**: <br> !   --->    CALL LSDSort(cStrArr) <br> !  **Note**: <br> !   This procedure is only applicable for Fortran character strings. <br> MODULE PROCEDURE ChrStr_LSDSort END INTERFACE INTERFACE MSDSort !&#94; **Subroutine Interface**: MSDSort <br> !  **Purpose**:  To sort an array of strings in an ascending order using the MSD !       string sorting algorithm. <br> !  **Usage**: <br> !   --->    CALL MSDSort(Arr) <br> MODULE PROCEDURE ChrStr_MSDSort MODULE PROCEDURE FvlStr_MSDSort END INTERFACE INTERFACE MSDInplaceSort !&#94; **Subroutine Interface**: MSDInplaceSort <br> !  **Purpose**:  To sort an array of strings in an ascending order using the !       in-place MSD string sorting algorithm.  Optionally, if all characters !       of the strings are in a particular alphabet set, a user can specify an !       *Alphabet* data type of that particular alphabet set. <br> !  **Usage**: <br> !   --->    CALL MSDInplaceSort(Arr) <br> !   --->    CALL MSDInplaceSort(Arr, Alphabet) <br> !  **Usage**: See the <a href=\"../module/mclass_alphabets.html\">Class_Alphabets</a> !       module for various *alphabet* data types available to be used with the !       *MSDInplaceSort* procedure. MODULE PROCEDURE ChrStr_MSDSort_Inplace MODULE PROCEDURE FvlStr_MSDSort_Inplace MODULE PROCEDURE ChrStr_MSDSort_Alphabet MODULE PROCEDURE FvlStr_MSDSort_Alphabet END INTERFACE INTERFACE QuickMultiKeySort !&#94; **Subroutine Interface**: QuickMultiKeySort <br> !  **Purpose**:  To sort an array of strings in an ascending order using the !       multi-key quicksort (or 3-way radix quicksort) algorithm. <br> !  **Usage**: <br> !   --->    CALL QuickMultiKeySort(Arr) <br> MODULE PROCEDURE ChrStr_QuickMultiKeySort MODULE PROCEDURE FvlStr_QuickMultiKeySort END INTERFACE INTERFACE AmericanFlagSort !&#94; **Subroutine Interface**: AmericanFlagSort <br> !  **Purpose**:  To sort an array of strings in an ascending order using the !       American-flag algorithm. <br> !  **Usage**: <br> !   --->    CALL AmericanFlagSort(Arr) <br> MODULE PROCEDURE ChrStr_AmericanFlagSort MODULE PROCEDURE FvlStr_AmericanFlagSort END INTERFACE ! private interfaces ABSTRACT INTERFACE SUBROUTINE ChrStrRank ( AVal , AInd ) IMPORT tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE SUBROUTINE ComparableRank ( AVal , AInd ) IMPORT CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE InsertionSort MODULE PROCEDURE ChrStr_InsertionSort MODULE PROCEDURE FvlStr_InsertionSort END INTERFACE INTERFACE IsLessThan MODULE PROCEDURE ChrStr_IsLessThan MODULE PROCEDURE FvlStr_IsLessThan END INTERFACE INTERFACE CharAt MODULE PROCEDURE ChrStr_CharAt MODULE PROCEDURE FvlStr_CharAt MODULE PROCEDURE ChrStr_CharAt_Alphabet MODULE PROCEDURE FvlStr_CharAt_Alphabet END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !------------------------------------------------------------------------------ !-----          CASE-INSENSITIVE RANKING AND SORTING PROCEDURES           ----- !------------------------------------------------------------------------------ SUBROUTINE ChrStr_RankInsensitive ( AVal , AInd , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data ranking for an array of character strings where !  the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( IN ) :: AVal (:) !! array values to be ranked tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) !! indices indicating the ranking PROCEDURE ( ChrStrRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: UCVal (:) ! upper-case array values tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) THEN ! set indices and return AInd = 1_kIndex RETURN END IF ! allocate and make a copy of the specified array ALLOCATE ( UCVal , SOURCE = AVal ) ! change working array to upper-case values CALL ChangeCase ( UCVal , TrueVal ) ! determine indices CALL RankArray ( UCVal , AInd ) ! free memory DEALLOCATE ( UCVal ) RETURN END SUBROUTINE ChrStr_RankInsensitive !****************************************************************************** SUBROUTINE ChrStr_SortInsensitive_Ascend ( AVal , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data sorting in ascending order for an array of !  character strings where the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal (:) !! array values to be ranked PROCEDURE ( ChrStrRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: UCVal (:) ! upper-case array values tIndex :: AInd ( SIZE ( AVal )) ! indices indicating the ranking tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) RETURN ! determine the ranking indices CALL ChrStr_RankInsensitive ( AVal , AInd , RankArray ) ! allocate and make a copy of the given array ALLOCATE ( UCVal , SOURCE = AVal ) ! sort the array in ascending order using the indices AVal = UCVal ( AInd (:)) ! free memory DEALLOCATE ( UCVal ) RETURN END SUBROUTINE ChrStr_SortInsensitive_Ascend !****************************************************************************** SUBROUTINE ChrStr_SortInsensitive_Descend ( AVal , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data sorting in descending order for an array of !  character strings where the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal (:) !! array values to be ranked PROCEDURE ( ChrStrRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: UCVal (:) ! upper-case array values tIndex :: AInd ( SIZE ( AVal )) ! indices indicating the ranking tIndex :: I , NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) RETURN ! determine the ranking indices CALL ChrStr_RankInsensitive ( AVal , AInd , RankArray ) ! allocate and make a copy of the given array ALLOCATE ( UCVal , SOURCE = AVal ) ! sort the array in descending order using the indices DO I = 1_kIndex , NA AVal ( I ) = UCVal ( AInd ( NA - I + 1 )) END DO ! free memory DEALLOCATE ( UCVal ) RETURN END SUBROUTINE ChrStr_SortInsensitive_Descend !****************************************************************************** SUBROUTINE FvlStr_RankInsensitive ( AVal , AInd , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data ranking for an array of FvlStr objects where !  the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( IN ) :: AVal (:) !! array values to be ranked tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) !! indices indicating the ranking PROCEDURE ( ComparableRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( Comparable ), ALLOCATABLE :: UCVal (:) ! upper-case array values tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) THEN ! set indices and return AInd = 1_kIndex RETURN END IF ! allocate and make a copy of the specified array ALLOCATE ( UCVal , SOURCE = AVal ) ! change working array to upper-case values SELECT TYPE ( UCVal ) TYPE IS ( FvlStr ) CALL UCVal % ChangeCase ( TrueVal ) END SELECT ! determine indices CALL RankArray ( UCVal , AInd ) ! free memory DEALLOCATE ( UCVal ) RETURN END SUBROUTINE FvlStr_RankInsensitive !****************************************************************************** SUBROUTINE FvlStr_SortInsensitive_Ascend ( AVal , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data sorting in ascending order for an array of !  FvlStr objects where the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal (:) !! array values to be ranked PROCEDURE ( ComparableRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( FvlStr ) :: UCVal ( SIZE ( AVal )) ! upper-case array values tIndex :: AInd ( SIZE ( AVal )) ! indices indicating the ranking tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) RETURN ! determine the ranking indices CALL FvlStr_RankInsensitive ( AVal , AInd , RankArray ) ! copy the given array UCVal = AVal ! sort the array in ascending order using the indices AVal = UCVal ( AInd (:)) RETURN END SUBROUTINE FvlStr_SortInsensitive_Ascend !****************************************************************************** SUBROUTINE FvlStr_SortInsensitive_Descend ( AVal , RankArray ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform data sorting in descending order for an array of !  FvlStr objects where the character case is ignored. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal (:) !! array values to be ranked PROCEDURE ( ComparableRank ) :: RankArray !! procedure to perform ranking !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( FvlStr ) :: UCVal ( SIZE ( AVal )) ! upper-case array values tIndex :: AInd ( SIZE ( AVal )) ! indices indicating the ranking tIndex :: I , NA !** FLOW ! check and return quickly if we can NA = SIZE ( AVal , KIND = kIndex ) ! check input validity IF ( NA <= 1_kIndex ) RETURN ! determine the ranking indices CALL FvlStr_RankInsensitive ( AVal , AInd , RankArray ) ! copy the given array UCVal = AVal ! sort the array in descending order using the indices DO I = 1_kIndex , NA AVal ( I ) = UCVal ( AInd ( NA - I + 1 )) END DO RETURN END SUBROUTINE FvlStr_SortInsensitive_Descend !------------------------------------------------------------------------------ !-----          SPECIALIZED SORTING PROCEDURES FOR STRINGS                ----- !------------------------------------------------------------------------------ SUBROUTINE ChrStr_LSDSort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using !   the least-significant-digit (LSD) string sorting algorithm, which !   is preferable for *same-length* strings. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA , StrLen !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! get the fixed length of strings StrLen = LEN ( A ( 1 )) ! perform sorting CALL LSD_Sort ( A , NA , StrLen ) RETURN CONTAINS SUBROUTINE LSD_Sort ( AVal , N , W ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the LSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: N !! size of the array tIndex , INTENT ( IN ) :: W !! width or length of each string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: ICount ( 0 : Radix ) ! counting array tCharLen ( W ) :: Buf ( 0 : N - 1 ) ! auxiliary array !** FLOW ! initialize the counting array ICount = 0_kIndex DO J = W , 1_kIndex , - 1_kIndex !------------------------------------------------------ ! --- sort by key-indexed counting on Jth character --- !------------------------------------------------------ ! compute frequency counts DO I = 0_kIndex , N - 1_kIndex K = IACHAR ( AVal ( I )( J : J )) + 1_kIndex ICount ( K ) = ICount ( K ) + 1_kIndex END DO ! transform counts to indices DO L = 0_kIndex , Radix - 1_kIndex ICount ( L + 1 ) = ICount ( L + 1 ) + ICount ( L ) END DO ! distribute the data DO I = 0_kIndex , N - 1_kIndex K = IACHAR ( AVal ( I )( J : J )) L = ICount ( K ) Buf ( L ) = AVal ( I ) ICount ( K ) = L + 1_kIndex END DO ! copy the data back AVal = Buf END DO RETURN END SUBROUTINE LSD_Sort !************************************************************************** END SUBROUTINE ChrStr_LSDSort !****************************************************************************** SUBROUTINE ChrStr_MSDSort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using !   the most-significant-digit (MSD) string sorting algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA tCharLen ( LEN ( A ( 1 ))) :: Aux ( SIZE ( A )) ! auxiliary array !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex , Aux ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D , Buf ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element tCharStar , INTENT ( INOUT ) :: Buf ( 0 :) !! the auxiliary array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: ICount ( 0 : Radix + 1 ) ! counting array ! initialize the counting array ICount = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) ICount ( K + 2 ) = ICount ( K + 2 ) + 1_kIndex END DO ! transform counts to indices DO L = 0_kIndex , Radix ICount ( L + 1 ) = ICount ( L + 1 ) + ICount ( L ) END DO ! distribute the data DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) L = ICount ( K + 1 ) Buf ( L ) = AVal ( I ) ICount ( K + 1 ) = L + 1_kIndex END DO ! copy the data back DO I = Lo , HI AVal ( I ) = Buf ( I - Lo ) END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Radix - 1_kIndex CALL MSD_Sort ( AVal , Lo + ICount ( L ), Lo + ICount ( L + 1 ) - 1_kIndex , D + 1_kIndex , Buf ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE ChrStr_MSDSort !****************************************************************************** SUBROUTINE FvlStr_MSDSort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of FvlStr objects in an ascending order using !   the most-significant-digit (MSD) string sorting algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA TYPE ( FvlStr ) :: Aux ( SIZE ( A )) ! auxiliary array !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex , Aux ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D , Buf ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element TYPE ( FvlStr ), INTENT ( INOUT ) :: Buf ( 0 :) !! the auxiliary array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: ICount ( 0 : Radix + 1 ) ! counting array ! initialize the counting array ICount = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) ICount ( K + 2 ) = ICount ( K + 2 ) + 1_kIndex END DO ! transform counts to indices DO L = 0_kIndex , Radix ICount ( L + 1 ) = ICount ( L + 1 ) + ICount ( L ) END DO ! distribute the data DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) L = ICount ( K + 1 ) Buf ( L ) = AVal ( I ) ICount ( K + 1 ) = L + 1_kIndex END DO ! copy the data back DO I = Lo , HI AVal ( I ) = Buf ( I - Lo ) END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Radix - 1_kIndex CALL MSD_Sort ( AVal , Lo + ICount ( L ), Lo + ICount ( L + 1 ) - 1_kIndex , D + 1_kIndex , Buf ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE FvlStr_MSDSort !****************************************************************************** SUBROUTINE ChrStr_MSDSort_Inplace ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using !   the in-place MSD radix sorting algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: IHead ( 0 : Radix + 1 ) ! index array tIndex :: ITail ( 0 : Radix ) ! index array tCharLen ( LEN ( AVal ( 0 ))) :: Temp ! temporary variable ! initialize the counting array IHead = 0_kIndex ITail = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) IHead ( K + 2 ) = IHead ( K + 2 ) + 1_kIndex END DO ! transform counts to indices IHead ( 0 ) = Lo DO L = 0_kIndex , Radix IHead ( L + 1 ) = IHead ( L + 1 ) + IHead ( L ) ITail ( L ) = IHead ( L + 1 ) END DO ! sort by d-th character in-place DO I = 0_kIndex , Radix DO WHILE ( IHead ( I ) < ITail ( I )) K = CharAt ( AVal ( IHead ( I )), D ) DO WHILE (( K + 1_kIndex ) /= I ) EXCHANGE ( AVal , IHead ( I ), IHead ( K + 1 )) IHead ( K + 1 ) = IHead ( K + 1 ) + 1_kIndex K = CharAt ( AVal ( IHead ( I )), D ) END DO IHead ( I ) = IHead ( I ) + 1_kIndex END DO END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Radix - 1_kIndex CALL MSD_Sort ( AVal , ITail ( L ), ITail ( L + 1 ) - 1_kIndex , D + 1_kIndex ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE ChrStr_MSDSort_Inplace !****************************************************************************** SUBROUTINE FvlStr_MSDSort_Inplace ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of FvlStr objects in an ascending order using !   the in-place MSD radix sorting algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: IHead ( 0 : Radix + 1 ) ! index array tIndex :: ITail ( 0 : Radix ) ! index array ! initialize the counting array IHead = 0_kIndex ITail = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D ) IHead ( K + 2 ) = IHead ( K + 2 ) + 1_kIndex END DO ! transform counts to indices IHead ( 0 ) = Lo DO L = 0_kIndex , Radix IHead ( L + 1 ) = IHead ( L + 1 ) + IHead ( L ) ITail ( L ) = IHead ( L + 1 ) END DO ! sort by d-th character in-place DO I = 0_kIndex , Radix DO WHILE ( IHead ( I ) < ITail ( I )) K = CharAt ( AVal ( IHead ( I )), D ) DO WHILE (( K + 1_kIndex ) /= I ) CALL Swap ( AVal ( IHead ( I )), AVal ( IHead ( K + 1 ))) IHead ( K + 1 ) = IHead ( K + 1 ) + 1_kIndex K = CharAt ( AVal ( IHead ( I )), D ) END DO IHead ( I ) = IHead ( I ) + 1_kIndex END DO END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Radix - 1_kIndex CALL MSD_Sort ( AVal , ITail ( L ), ITail ( L + 1 ) - 1_kIndex , D + 1_kIndex ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE FvlStr_MSDSort_Inplace !****************************************************************************** SUBROUTINE ChrStr_MSDSort_Alphabet ( A , Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings (where all characters of the strings are !   in a particular alphabet set of characters) in an ascending order using the !   in-place MSD radix sorting algorithm.  <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted CLASS ( Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: IHead ( 0 : Alpha % GetRadix () + 1 ) ! index array tIndex :: ITail ( 0 : Alpha % GetRadix ()) ! index array tCharLen ( LEN ( AVal ( 0 ))) :: Temp ! temporary variable ! initialize the counting array IHead = 0_kIndex ITail = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D , Alpha ) IHead ( K + 2 ) = IHead ( K + 2 ) + 1_kIndex END DO ! transform counts to indices IHead ( 0 ) = Lo DO L = 0_kIndex , Alpha % GetRadix () IHead ( L + 1 ) = IHead ( L + 1 ) + IHead ( L ) ITail ( L ) = IHead ( L + 1 ) END DO ! sort by d-th character in-place DO I = 0_kIndex , Alpha % GetRadix () DO WHILE ( IHead ( I ) < ITail ( I )) K = CharAt ( AVal ( IHead ( I )), D , Alpha ) DO WHILE (( K + 1_kIndex ) /= I ) EXCHANGE ( AVal , IHead ( I ), IHead ( K + 1 )) IHead ( K + 1 ) = IHead ( K + 1 ) + 1_kIndex K = CharAt ( AVal ( IHead ( I )), D , Alpha ) END DO IHead ( I ) = IHead ( I ) + 1_kIndex END DO END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Alpha % GetRadix () - 1_kIndex CALL MSD_Sort ( AVal , ITail ( L ), ITail ( L + 1 ) - 1_kIndex , D + 1_kIndex ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE ChrStr_MSDSort_Alphabet !****************************************************************************** SUBROUTINE FvlStr_MSDSort_Alphabet ( A , Alpha ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of FvlStr objects (where all characters of their strings are !   in a particular alphabet set of characters) in an ascending order using the !   in-place MSD radix sorting algorithm.  <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: A (:) !! the array to be sorted CLASS ( Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL MSD_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE MSD_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the MSD sorting algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: I , K , L ! zero-based indices tIndex :: J ! one-based index tIndex :: IHead ( 0 : Alpha % GetRadix () + 1 ) ! index array tIndex :: ITail ( 0 : Alpha % GetRadix ()) ! index array ! initialize the counting array IHead = 0_kIndex ITail = 0_kIndex ! compute frequency counts DO I = Lo , Hi K = CharAt ( AVal ( I ), D , Alpha ) IHead ( K + 2 ) = IHead ( K + 2 ) + 1_kIndex END DO ! transform counts to indices IHead ( 0 ) = Lo DO L = 0_kIndex , Alpha % GetRadix () IHead ( L + 1 ) = IHead ( L + 1 ) + IHead ( L ) ITail ( L ) = IHead ( L + 1 ) END DO ! sort by d-th character in-place DO I = 0_kIndex , Alpha % GetRadix () DO WHILE ( IHead ( I ) < ITail ( I )) K = CharAt ( AVal ( IHead ( I )), D , Alpha ) DO WHILE (( K + 1_kIndex ) /= I ) CALL Swap ( AVal ( IHead ( I )), AVal ( IHead ( K + 1 ))) IHead ( K + 1 ) = IHead ( K + 1 ) + 1_kIndex K = CharAt ( AVal ( IHead ( I )), D , Alpha ) END DO IHead ( I ) = IHead ( I ) + 1_kIndex END DO END DO ! recursively sort for each character (excludes sentinel -1) DO L = 0_kIndex , Alpha % GetRadix () - 1_kIndex CALL MSD_Sort ( AVal , ITail ( L ), ITail ( L + 1 ) - 1_kIndex , D + 1_kIndex ) END DO END BLOCK RETURN END SUBROUTINE MSD_Sort !************************************************************************** END SUBROUTINE FvlStr_MSDSort_Alphabet !****************************************************************************** SUBROUTINE ChrStr_QuickMultiKeySort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using !   the three-way radix quicksort (or multi-key quicksort) algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL Quick_MultiKey_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE Quick_MultiKey_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the multi-key quicksort algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: LT , GT , I , J , K tCharLen ( LEN ( AVal ( 0 ))) :: Temp ! initialize LT = Lo Gt = Hi I = Lo + 1_kIndex J = CharAt ( AVal ( Lo ), D ) ! perform 3-way partitioning DO WHILE ( I <= GT ) K = CharAt ( AVal ( I ), D ) IF ( K < J ) THEN EXCHANGE ( AVal , LT , I ) LT = LT + 1_kIndex I = I + 1_kIndex ELSEIF ( K > J ) THEN EXCHANGE ( AVal , I , GT ) GT = GT - 1_kIndex ELSE I = I + 1_kIndex END IF END DO ! AVal[Lo..LT-1] < J = AVal[LT..GT] < AVal[GT+1..Hi] CALL Quick_MultiKey_Sort ( AVal , Lo , LT - 1_kIndex , D ) IF ( J >= 0_kIndex ) CALL Quick_MultiKey_Sort ( AVal , LT , GT , D + 1_kIndex ) CALL Quick_MultiKey_Sort ( AVal , GT + 1_kIndex , Hi , D ) END BLOCK RETURN END SUBROUTINE Quick_MultiKey_Sort !************************************************************************** END SUBROUTINE ChrStr_QuickMultiKeySort !****************************************************************************** SUBROUTINE FvlStr_QuickMultiKeySort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of FvlStr objects in an ascending order using !   the three-way radix quicksort (or multi-key quicksort) algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL Quick_MultiKey_Sort ( A , 0_kIndex , NA - 1_kIndex , 1_kIndex ) RETURN CONTAINS RECURSIVE SUBROUTINE Quick_MultiKey_Sort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the multi-key quicksort algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) RETURN END IF BLOCK tIndex :: LT , GT , I , J , K ! initialize LT = Lo Gt = Hi I = Lo + 1_kIndex J = CharAt ( AVal ( Lo ), D ) ! perform 3-way partitioning DO WHILE ( I <= GT ) K = CharAt ( AVal ( I ), D ) IF ( K < J ) THEN CALL Swap ( AVal ( LT ), AVal ( I )) LT = LT + 1_kIndex I = I + 1_kIndex ELSEIF ( K > J ) THEN CALL Swap ( AVal ( I ), AVal ( GT )) GT = GT - 1_kIndex ELSE I = I + 1_kIndex END IF END DO ! AVal[Lo..LT-1] < J = AVal[LT..GT] < AVal[GT+1..Hi] CALL Quick_MultiKey_Sort ( AVal , Lo , ( LT - 1_kIndex ), D ) IF ( J >= 0_kIndex ) CALL Quick_MultiKey_Sort ( AVal , LT , GT , ( D + 1_kIndex )) CALL Quick_MultiKey_Sort ( AVal , ( GT + 1_kIndex ), Hi , D ) END BLOCK RETURN END SUBROUTINE Quick_MultiKey_Sort !************************************************************************** END SUBROUTINE FvlStr_QuickMultiKeySort !****************************************************************************** SUBROUTINE ChrStr_AmericanFlagSort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using the American !   flag algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] <a href=\"https://www.usenix.org/publications/compsystems/1993/win_mcilroy.pdf\"> !       P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems, !       Vol. 6, No. 1. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AmericanFlagX.java.html\"> !       Java Code: Non-recursive Americal Flag Sort. </a> <br> !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL American_Flag_Sort ( A , 0_kIndex , NA - 1_kIndex ) RETURN CONTAINS SUBROUTINE American_Flag_Sort ( AVal , StartID , EndID ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the American flag algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: StartID !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: EndID !! ending zero-based index, inclusive !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StackInteger ) :: Stack tIndex :: ICount ( 0 : Radix ) tIndex :: D ! character index to sort by tIndex :: Lo ! starting index tIndex :: Hi ! ending index tIndex :: I ! working index tLogical :: Success tIndex :: C tCharLen ( LEN ( AVal ( 0 ))) :: Temp !** FLOW ! initialize D = 0_kIndex Lo = StartID Hi = EndID ICount = 0_kIndex CALL Stack % Push ( Lo ) CALL Stack % Push ( Hi ) CALL Stack % Push ( D ) DO WHILE (. NOT . Stack % IsEmpty ()) Success = Stack % Pop ( D ) Success = Stack % Pop ( Hi ) Success = Stack % Pop ( Lo ) ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) CYCLE END IF ! compute frequency counts DO I = Lo , Hi C = CharAt ( AVal ( I ), D ) + 1_kIndex ! account for -1 representing end-of-string ICount ( C ) = ICount ( C ) + 1_kIndex END DO ! accumulate counts relative to AVal(0), so that ICount(C) is the number of keys <= C ICount ( 0 ) = ICount ( 0 ) + Lo DO C = 0_kIndex , Radix - 1_kIndex ICount ( C + 1 ) = ICount ( C + 1 ) + ICount ( C ) IF (( C > 0_kIndex ). AND .(( ICount ( C + 1 ) - 1_kIndex ) > ICount ( C ))) THEN ! add subproblem for character C (excludes sentinel C == 0) CALL Stack % Push ( ICount ( C )) CALL Stack % Push ( ICount ( C + 1 ) - 1_kIndex ) CALL Stack % Push ( D + 1_kIndex ) END IF END DO ! permute data in place I = Hi DO ! locate element that must be shifted right of I C = CharAt ( AVal ( I ), D ) + 1_kIndex DO WHILE (( I >= Lo ). AND .(( ICount ( C ) - 1_kIndex ) <= I )) IF (( ICount ( C ) - 1_kIndex ) == I ) ICount ( C ) = ICount ( C ) - 1_kIndex I = I - 1_kIndex IF ( I >= Lo ) C = CharAt ( AVal ( I ), D ) + 1_kIndex END DO ! if I < Lo the sub-array is sorted. IF ( I < Lo ) EXIT ! permute AVal(I) until correct element is in place ICount ( C ) = ICount ( C ) - 1_kIndex DO WHILE ( ICount ( C ) /= I ) EXCHANGE ( AVal , I , ICount ( C )) C = CharAt ( AVal ( I ), D ) + 1_kIndex ICount ( C ) = ICount ( C ) - 1_kIndex END DO I = I - 1_kIndex IF ( I < Lo ) EXIT END DO ! clear ICount array ICount = 0_kIndex END DO RETURN END SUBROUTINE American_Flag_Sort !************************************************************************** END SUBROUTINE ChrStr_AmericanFlagSort !****************************************************************************** SUBROUTINE FvlStr_AmericanFlagSort ( A ) !** PURPOSE OF THIS SUBROUTINE: !&#94;  To sort an array of character strings in an ascending order using the American !   flag algorithm. <br> !    <br> !  **REFERENCES**: <br> !   [1] <a href=\"https://www.usenix.org/publications/compsystems/1993/win_mcilroy.pdf\"> !       P.M. McIlroy and K. Bostic. 1993.  Engineering Radix Sort. Computer Systems, !       Vol. 6, No. 1. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AmericanFlagX.java.html\"> !       Java Code: Non-recursive Americal Flag Sort. </a> <br> !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: A (:) !! the array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: tIndex , PARAMETER :: Insertion_CutOff = 15_kIndex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: NA !** FLOW ! check and return quickly if we can NA = SIZE ( A , KIND = kIndex ) IF ( NA <= 1_kIndex ) RETURN ! perform sorting CALL American_Flag_Sort ( A , 0_kIndex , NA - 1_kIndex ) RETURN CONTAINS SUBROUTINE American_Flag_Sort ( AVal , StartID , EndID ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the American flag algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: StartID !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: EndID !! ending zero-based index, inclusive !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StackInteger ) :: Stack tIndex :: ICount ( 0 : Radix ) tIndex :: D ! character index to sort by tIndex :: Lo ! starting index tIndex :: Hi ! ending index tIndex :: I ! working index tLogical :: Success tIndex :: C !** FLOW ! initialize D = 0_kIndex Lo = StartID Hi = EndID ICount = 0_kIndex CALL Stack % Push ( Lo ) CALL Stack % Push ( Hi ) CALL Stack % Push ( D ) DO WHILE (. NOT . Stack % IsEmpty ()) Success = Stack % Pop ( D ) Success = Stack % Pop ( Hi ) Success = Stack % Pop ( Lo ) ! cutoff to insertion sort for small sub-arrays IF ( Hi <= Lo + Insertion_CutOff ) THEN CALL InsertionSort ( AVal , Lo , Hi , D ) CYCLE END IF ! compute frequency counts DO I = Lo , Hi C = CharAt ( AVal ( I ), D ) + 1_kIndex ! account for -1 representing end-of-string ICount ( C ) = ICount ( C ) + 1_kIndex END DO ! accumulate counts relative to AVal(0), so that ICount(C) is the number of keys <= C ICount ( 0 ) = ICount ( 0 ) + Lo DO C = 0_kIndex , Radix - 1_kIndex ICount ( C + 1 ) = ICount ( C + 1 ) + ICount ( C ) IF (( C > 0_kIndex ). AND .(( ICount ( C + 1 ) - 1_kIndex ) > ICount ( C ))) THEN ! add subproblem for character C (excludes sentinel C == 0) CALL Stack % Push ( ICount ( C )) CALL Stack % Push ( ICount ( C + 1 ) - 1_kIndex ) CALL Stack % Push ( D + 1_kIndex ) END IF END DO ! permute data in place I = Hi DO ! locate element that must be shifted right of I C = CharAt ( AVal ( I ), D ) + 1_kIndex DO WHILE (( I >= Lo ). AND .(( ICount ( C ) - 1_kIndex ) <= I )) IF (( ICount ( C ) - 1_kIndex ) == I ) ICount ( C ) = ICount ( C ) - 1_kIndex I = I - 1_kIndex IF ( I >= Lo ) C = CharAt ( AVal ( I ), D ) + 1_kIndex END DO ! if I < Lo the sub-array is sorted. IF ( I < Lo ) EXIT ! permute AVal(I) until correct element is in place ICount ( C ) = ICount ( C ) - 1_kIndex DO WHILE ( ICount ( C ) /= I ) CALL Swap ( AVal ( I ), AVal ( ICount ( C ))) C = CharAt ( AVal ( I ), D ) + 1_kIndex ICount ( C ) = ICount ( C ) - 1_kIndex END DO I = I - 1_kIndex IF ( I < Lo ) EXIT END DO ! clear ICount array ICount = 0_kIndex END DO RETURN END SUBROUTINE American_Flag_Sort !************************************************************************** END SUBROUTINE FvlStr_AmericanFlagSort !------------------------------------------------------------------------------ !-----                      AUXILIARY PROCEDURES                          ----- !------------------------------------------------------------------------------ SUBROUTINE ChrStr_InsertionSort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of character strings using the insertion sorting algorithm !  whose first D+1 characters of strings are equal. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J ! zero-based indices tCharLen ( LEN ( AVal ( 0 ))) :: Temp !** FLOW DO I = Lo , Hi J = I DO WHILE ( J > Lo ) IF (. NOT . IsLessThan ( AVal ( J ), AVal ( J - 1 ), D )) EXIT EXCHANGE ( AVal , J , J - 1 ) J = J - 1_kIndex END DO END DO RETURN END SUBROUTINE ChrStr_InsertionSort !****************************************************************************** SUBROUTINE FvlStr_InsertionSort ( AVal , Lo , Hi , D ) !** PURPOSE OF THIS SUBROUTINE !&#94; To sort an array of FvlStr objects using the insertion sorting algorithm !  whose first D+1 characters of strings are equal. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( INOUT ) :: AVal ( 0 :) !! the array of strings to be sorted tIndex , INTENT ( IN ) :: Lo !! starting zero-based index, inclusive tIndex , INTENT ( IN ) :: Hi !! ending zero-based index, inclusive tIndex , INTENT ( IN ) :: D !! starting one-based position in a string element !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J ! zero-based indices !** FLOW DO I = Lo , Hi J = I DO WHILE ( J > Lo ) IF (. NOT . IsLessThan ( AVal ( J ), AVal ( J - 1 ), D )) EXIT CALL Swap ( AVal ( J ), AVal ( J - 1 )) END DO END DO RETURN END SUBROUTINE FvlStr_InsertionSort !****************************************************************************** FUNCTION ChrStr_IsLessThan ( V , W , D ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether V is less than W, starting at Dth character. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( IN ) :: V tCharLen ( LEN ( V )), INTENT ( IN ) :: W tIndex , INTENT ( IN ) :: D tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I !** FLOW DO I = D , LEN ( V ) IF ( V ( I : I ) < W ( I : I )) THEN Flag = TrueVal RETURN END IF IF ( V ( I : I ) > W ( I : I )) THEN Flag = FalseVal RETURN END IF END DO Flag = FalseVal RETURN END FUNCTION ChrStr_IsLessThan !****************************************************************************** FUNCTION FvlStr_IsLessThan ( V , W , D ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether V is less than W, starting at Dth character. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( IN ) :: V TYPE ( FvlStr ), INTENT ( IN ) :: W tIndex , INTENT ( IN ) :: D tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I tChar :: vChr , wChr tIndex :: vIndx , wIndx !** FLOW DO I = D , MIN ( V % Length (), W % Length ()) vChr = V % Char ( I ) wChr = W % Char ( I ) vIndx = IACHAR ( vChr , KIND = kIndex ) wIndx = IACHAR ( wChr , KIND = kIndex ) IF ( vIndx < wIndx ) THEN Flag = TrueVal RETURN END IF IF ( vIndx > wIndx ) THEN Flag = FalseVal RETURN END IF END DO Flag = ( V % Length () < W % Length ()) RETURN END FUNCTION FvlStr_IsLessThan !****************************************************************************** FUNCTION ChrStr_CharAt ( V , D ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE !&#94; To return the character code of the Dth character of V. !  Return -1 if D > LEN(V). !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( IN ) :: V tIndex , INTENT ( IN ) :: D tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( D <= LEN ( V , KIND = kIndex )) THEN Indx = IACHAR ( V ( D : D ), KIND = kIndex ) ELSE Indx = - 1_kIndex END IF RETURN END FUNCTION ChrStr_CharAt !****************************************************************************** FUNCTION FvlStr_CharAt ( V , D ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE !&#94; To return the character code of the Dth character of V. !  Return -1 if D > LEN(V). !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( IN ) :: V tIndex , INTENT ( IN ) :: D tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( D <= V % Length ()) THEN BLOCK tChar :: vChr vChr = V % Char ( D ) Indx = IACHAR ( vChr , KIND = kIndex ) END BLOCK ELSE Indx = - 1_kIndex END IF RETURN END FUNCTION FvlStr_CharAt !****************************************************************************** FUNCTION ChrStr_CharAt_Alphabet ( V , D , Alpha ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE !&#94; To return the character code of the Dth character of V. !  Return -1 if D > LEN(V). !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( IN ) :: V tIndex , INTENT ( IN ) :: D CLASS ( Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( D <= LEN ( V , KIND = kIndex )) THEN Indx = Alpha % GetIndex ( V ( D : D )) ELSE Indx = - 1_kIndex END IF RETURN END FUNCTION ChrStr_CharAt_Alphabet !****************************************************************************** FUNCTION FvlStr_CharAt_Alphabet ( V , D , Alpha ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE !&#94; To return the character code of the Dth character of V. !  Return -1 if D > LEN(V). !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( FvlStr ), INTENT ( IN ) :: V tIndex , INTENT ( IN ) :: D CLASS ( Alphabet ), INTENT ( INOUT ) :: Alpha !! Alphabet object tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( D <= V % Length ()) THEN Indx = Alpha % GetIndex ( V % Char ( D )) ELSE Indx = - 1_kIndex END IF RETURN END FUNCTION FvlStr_CharAt_Alphabet !****************************************************************************** END MODULE MBase_StringSorts !******************************************************************************","tags":"","loc":"sourcefile\\mbase_stringsorts.f90.html"},{"title":"MClass_NFAutomaton.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_NFAutomaton !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *NFAutomaton* type and its related routines. !   The *NFAutomaton* type is a derived type representing a ... <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_ErrHandlers USE MClass_IntrusiveHashList USE MClass_IntrusiveLinkedLists USE MClass_SyntaxNode USE MClass_NFAState USE MClass_BitmapState IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: NFAutomaton PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tHash               tIndex !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_NFAutomaton' tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> The *NFAutomaton* type is a node type... TYPE NFAutomaton TYPE ( IntrusiveLinearList ) :: List TYPE ( IntrusiveLinearList ) :: Stack tSInt32 :: NextID = 0 CONTAINS PROCEDURE , PRIVATE :: StackPop => NFAutomaton_StackPop PROCEDURE :: Construct => NFAutomaton_Construct PROCEDURE :: Destruct => NFAutomaton_Destruct PROCEDURE :: NewState => NFAutomaton_NewState PROCEDURE :: DepthFirstSearch => NFAutomaton_DepthFirstSearch PROCEDURE :: Visit => NFAutomaton_Visit PROCEDURE :: AsBitmapStateManager => NFAutomaton_AsBitmapStateManager END TYPE NFAutomaton !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE NFAutomaton_Construct ( NFA , Root ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the NFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( OUT ) :: NFA TYPE ( SyntaxNode ), POINTER , INTENT ( INOUT ) :: Root !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( NFAState ), POINTER :: InitState TYPE ( NFAState ), POINTER :: FinalState ! FLOW NFA % NextID = 0 InitState => NFA % NewState () FinalState => NFA % NewState () CALL NFA % Stack % Push ( FinalState ) CALL NFA % Stack % Push ( InitState ) CALL NFA % DepthFirstSearch ( Root ) CALL SyntaxNode_Free () NULLIFY ( InitState , FinalState ) RETURN END SUBROUTINE NFAutomaton_Construct !****************************************************************************** SUBROUTINE NFAutomaton_Destruct ( NFA ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the NFAutomaton object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW NFA % NextID = 0 CALL NFA % Stack % Clear () CALL NFA % List % Clear () CALL NFAState_Free () RETURN END SUBROUTINE NFAutomaton_Destruct !****************************************************************************** FUNCTION NFAutomaton_NewState ( NFA ) RESULT ( NewState ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create new NFA state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA TYPE ( NFAState ), POINTER :: NewState !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL NFAState_New ( NewState , NFA % NextID ) NFA % NextID = NFA % NextID + 1 CALL NFA % List % AddLast ( NewState ) RETURN END FUNCTION NFAutomaton_NewState !****************************************************************************** RECURSIVE SUBROUTINE NFAutomaton_DepthFirstSearch ( NFA , Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform depth first search. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA TYPE ( SyntaxNode ), INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL NFA % Visit ( Node ) IF ( Node % HasLeft ()) THEN CALL NFA % DepthFirstSearch ( Node % GetLeft ()) CALL NFA % DepthFirstSearch ( Node % GetRight ()) END IF RETURN END SUBROUTINE NFAutomaton_DepthFirstSearch !****************************************************************************** FUNCTION NFAutomaton_StackPop ( NFA ) RESULT ( State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create new NFA state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA TYPE ( NFAState ), POINTER :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: Node ! FLOW State => NULL () IF ( NFA % Stack % Pop ( Node )) THEN SELECT TYPE ( Node ) TYPE IS ( NFAState ) State => Node END SELECT END IF NULLIFY ( Node ) RETURN END FUNCTION NFAutomaton_StackPop !****************************************************************************** SUBROUTINE NFAutomaton_Visit ( NFA , Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform visit operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA TYPE ( SyntaxNode ), INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( NFAState ), POINTER :: IState , FState , NState ! FLOW SELECT CASE ( Node % Type ) CASE ( LeafNode_Char ) IState => NFA % StackPop () FState => NFA % StackPop () IF ( ASSOCIATED ( IState ). AND . ASSOCIATED ( FState )) THEN CALL IState % TransitionRule ( Node % C , FState ) END IF CASE ( BranchNode_Or ) IState => NFA % StackPop () FState => NFA % StackPop () IF ( ASSOCIATED ( IState ). AND . ASSOCIATED ( FState )) THEN CALL NFA % Stack % Push ( FState ) CALL NFA % Stack % Push ( IState ) CALL NFA % Stack % Push ( FState ) CALL NFA % Stack % Push ( IState ) END IF CASE ( BranchNode_Concat ) IState => NFA % StackPop () FState => NFA % StackPop () NState => NFA % NewState () IF ( ASSOCIATED ( IState ). AND . ASSOCIATED ( FState ). AND . ASSOCIATED ( NState )) THEN CALL NFA % Stack % Push ( FState ) CALL NFA % Stack % Push ( NState ) CALL NFA % Stack % Push ( NState ) CALL NFA % Stack % Push ( IState ) END IF CASE ( BranchNode_Many ) IState => NFA % StackPop () FState => NFA % StackPop () NState => NFA % NewState () IF ( ASSOCIATED ( IState ). AND . ASSOCIATED ( FState ). AND . ASSOCIATED ( NState )) THEN CALL IState % DirectRule ( NState ) CALL NState % DirectRule ( FState ) CALL NFA % Stack % Push ( NState ) CALL NFA % Stack % Push ( NState ) END IF CASE ( LeafNode_Closure ) IState => NFA % StackPop () FState => NFA % StackPop () IF ( ASSOCIATED ( IState ). AND . ASSOCIATED ( FState )) THEN CALL IState % DirectRule ( FState ) END IF CASE ( LeafNode_Null ) ! do nothing here CASE DEFAULT ! report error here BLOCK tCharAlloc :: ErrMsg IF ( Node % Type == BranchNode_LBracket ) THEN ErrMsg = 'Invalid operation for the left-bracket node' ELSE ErrMsg = 'Invalid operation for the right-bracket node' END IF CALL Handle_ErrLevel ( 'NFAutomaton_Visit' , ModName , ErrWarning , ErrMsg ) END BLOCK END SELECT NULLIFY ( IState , FState , NState ) RETURN END SUBROUTINE NFAutomaton_Visit !****************************************************************************** FUNCTION NFAutomaton_AsBitmapStateManager ( NFA ) RESULT ( Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create new NFA state. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAutomaton ), INTENT ( INOUT ) :: NFA TYPE ( BitmapStateManager ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Manager % Construct ( NFA % List ) RETURN END FUNCTION NFAutomaton_AsBitmapStateManager !****************************************************************************** END MODULE MClass_NFAutomaton !******************************************************************************","tags":"","loc":"sourcefile\\mclass_nfautomaton.f90.html"},{"title":"MClass_BitMapState.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BitmapState !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BitmapState* type and its related routines. !   The *BitmapState* type is a derived type representing a ... <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MClass_Object , ONLY : Object USE MBase_OptimalHash32 , ONLY : HashFuncOpt => Murmur3_Hash32_Opt USE MClass_IntrusiveLinkedLists USE MClass_IntrusiveHashList USE MClass_NFAState IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BitmapState PUBLIC :: BitmapStateManager PUBLIC :: BitmapStatePack PUBLIC :: BitMapNode PUBLIC :: BitmapState_New PUBLIC :: BitmapStatePack_New PUBLIC :: BitMapNode_New PUBLIC :: BitmapState_Free PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tHash               tIndex !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_BitmapState' tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> The *BitmapStatePack* type is a node type... TYPE , EXTENDS ( DoublyLinkedNode ) :: BitmapStatePack PRIVATE tSInt64 , ALLOCATABLE :: StateBitmap (:) TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () tLogical :: Writable TYPE ( IntrusiveLinearList ) :: List ! use BitmapState as node CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapStatePack_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapStatePack_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitmapStatePack_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapStatePack_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapStatePack_HashCode ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE :: Construct => BitmapStatePack_Construct PROCEDURE :: Destruct => BitmapStatePack_Destruct PROCEDURE :: AddState => BitmapStatePack_AddState PROCEDURE :: AddAll => BitmapStatePack_AddAll PROCEDURE :: Contain => BitmapStatePack_Contain PROCEDURE :: IsEmpty => BitmapStatePack_IsEmpty PROCEDURE :: Size => BitmapStatePack_Size PROCEDURE :: AsList => BitmapStatePack_AsList PROCEDURE :: Freeze => BitmapStatePack_Freeze PROCEDURE :: EnsureWritable => BitmapStatePack_EnsureWritable PROCEDURE :: IsEqual => BitmapStatePack_IsEqual END TYPE BitmapStatePack !> The *BitmapState* type is a node type... TYPE , EXTENDS ( DoublyLinkedNode ) :: BitmapState PRIVATE TYPE ( BitmapStatePack ) :: DirectTable TYPE ( BitmapStateManager ), POINTER :: Manager => NULL () TYPE ( IntrusiveHashList ) :: TransitionMap ! use BitMapNode as node tSInt32 :: ID tLogical :: Writable = TrueVal CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapState_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapState_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitmapState_MemFree !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapState_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapState_HashCode ! --------------------------------------------------------------------- ! -----                     Specific Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE :: Construct => BitmapState_Construct PROCEDURE :: Destruct => BitmapState_Destruct PROCEDURE :: TransitionRule => BitmapState_TransitionRule PROCEDURE :: DirectRule => BitmapState_DirectRule PROCEDURE :: GetTransitionMap => BitmapState_GetTransitionMap PROCEDURE :: GetDirectTable => BitmapState_GetDirectTable PROCEDURE :: GetID => BitmapState_GetID PROCEDURE :: Freeze => BitmapState_Freeze PROCEDURE :: EnsureWritable => BitmapState_EnsureWritable PROCEDURE :: IsEqual => BitmapState_IsEqual END TYPE BitmapState !> The *BitmapStateManager* type is a node type... TYPE BitmapStateManager PRIVATE TYPE ( BitmapState ), ALLOCATABLE :: IStates (:) CONTAINS PROCEDURE :: Construct => BitmapStateManager_Construct PROCEDURE :: Destruct => BitmapStateManager_Destruct PROCEDURE :: GetState => BitmapStateManager_GetState PROCEDURE :: GetStates => BitmapStateManager_GetStates PROCEDURE :: StateCount => BitmapStateManager_StateCount PROCEDURE :: NewEmptyPack => BitmapStateManager_NewEmptyPack END TYPE BitmapStateManager !> The *BitMapNode* type is a node type... TYPE , EXTENDS ( HashListNode ) :: BitMapNode tChar :: Chr TYPE ( BitmapStatePack ), POINTER :: State => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => BitmapNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => BitmapNode_IsEqualTo !> *FreeMemory* is a procedure deferred by the *Object* type. <br> !  Use the *MemFree* method in place of the *FreeMemory* method to free !  memory the *Object* object if the object contains allocatable and/or !  pointer component(s). PROCEDURE :: MemFree => BitMapNode_FreeMemory !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => BitmapNode_ToString !> *HashCode* is a deferred procedure to compute hash code of this object. PROCEDURE :: HashCode => BitmapNode_HashCode ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => BitMapNode_IsKeyEqual !        PROCEDURE   :: MemFree      => BitMapNode_FreeMemory !        PROCEDURE   :: HashCode     => BitMapNode_HashCode PROCEDURE :: Construct => BitMapNode_Construct ! --------------------------------------------------------------------- END TYPE BitMapNode TYPE BitmapStateMemHandler tIndex :: StateID = 0_kIndex TYPE ( BitmapState ), ALLOCATABLE :: BMState (:) tIndex :: PackID = 0_kIndex TYPE ( BitmapStatePack ), ALLOCATABLE :: BMPack (:) tIndex :: NodeID = 0_kIndex TYPE ( BitMapNode ), ALLOCATABLE :: BMNode (:) END TYPE BitmapStateMemHandler !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: TYPE ( BitmapStateMemHandler ), TARGET :: BMSMemManger CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !------------------------------------------------------------------------------- !                           BitmapStateMemHandler Procedures !------------------------------------------------------------------------------- SUBROUTINE BitmapState_New ( State , ID , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapState ), POINTER , INTENT ( INOUT ) :: State tSInt32 , INTENT ( IN ) :: ID TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMState )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMState ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % StateID = 0_kIndex CALL Handle_ErrAlloc ( 'BitmapState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % StateID = 1_kIndex ELSEIF ( BMSMemManger % StateID == SIZE ( BMSMemManger % BMState , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitmapState ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( BMSMemManger % BMState ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitmapState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( BMSMemManger % BMState )) = BMSMemManger % BMState CALL MOVE_ALLOC ( NewState , BMSMemManger % BMState ) BMSMemManger % StateID = BMSMemManger % StateID + 1 END BLOCK END IF ! set pointer to the storage State => BMSMemManger % BMState ( BMSMemManger % StateID ) CALL State % Construct ( ID , Manager ) RETURN END SUBROUTINE BitmapState_New !****************************************************************************** SUBROUTINE BitmapStatePack_New ( Pack , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitmapStatePack ), POINTER , INTENT ( INOUT ) :: Pack TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMPack )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMPack ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % PackID = 0_kIndex CALL Handle_ErrAlloc ( 'BitmapStatePack_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % PackID = 1_kIndex ELSEIF ( BMSMemManger % PackID == SIZE ( BMSMemManger % BMPack , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitmapStatePack ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( BMSMemManger % BMPack ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitmapStatePack_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( BMSMemManger % BMPack )) = BMSMemManger % BMPack CALL MOVE_ALLOC ( NewState , BMSMemManger % BMPack ) BMSMemManger % PackID = BMSMemManger % PackID + 1 END BLOCK END IF ! set pointer to the storage Pack => BMSMemManger % BMPack ( BMSMemManger % PackID ) CALL Pack % Construct ( Manager ) RETURN END SUBROUTINE BitmapStatePack_New !****************************************************************************** SUBROUTINE BitMapNode_New ( Node , Chr , Manager , StatePack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( BitMapNode ), POINTER , INTENT ( INOUT ) :: Node tChar , INTENT ( IN ) :: Chr TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager TYPE ( BitmapStatePack ), TARGET , OPTIONAL , INTENT ( IN ) :: StatePack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( BMSMemManger % BMNode )) THEN ! need allocation ALLOCATE ( BMSMemManger % BMNode ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN BMSMemManger % NodeID = 0_kIndex CALL Handle_ErrAlloc ( 'BitMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF BMSMemManger % NodeID = 1_kIndex ELSEIF ( BMSMemManger % NodeID == SIZE ( BMSMemManger % BMNode , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( BitMapNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( BMSMemManger % BMNode ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'BitMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( BMSMemManger % BMNode )) = BMSMemManger % BMNode CALL MOVE_ALLOC ( NewNode , BMSMemManger % BMNode ) BMSMemManger % NodeID = BMSMemManger % NodeID + 1 END BLOCK END IF ! set pointer to the storage Node => BMSMemManger % BMNode ( BMSMemManger % NodeID ) CALL Node % Construct ( Chr , Manager , StatePack ) RETURN END SUBROUTINE BitMapNode_New !****************************************************************************** SUBROUTINE BitmapState_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( BMSMemManger % BMNode )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMNode , KIND = kIndex ) CALL BMSMemManger % BMNode ( I )% MemFree () END DO DEALLOCATE ( BMSMemManger % BMNode ) END IF IF ( ALLOCATED ( BMSMemManger % BMPack )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMPack , KIND = kIndex ) CALL BMSMemManger % BMPack ( I )% Destruct () END DO DEALLOCATE ( BMSMemManger % BMPack ) END IF IF ( ALLOCATED ( BMSMemManger % BMState )) THEN DO I = 1_kIndex , SIZE ( BMSMemManger % BMState , KIND = kIndex ) CALL BMSMemManger % BMState ( I )% Destruct () END DO DEALLOCATE ( BMSMemManger % BMState ) END IF BMSMemManger % PackID = 0_kIndex BMSMemManger % StateID = 0_kIndex BMSMemManger % NodeID = 0_kIndex RETURN END SUBROUTINE BitmapState_Free ! ----------------------------------------------------------------------------- ! -----                     BitmapState Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE BitmapState_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the BitmapState object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( BitmapState ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'BitmapState_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE BitmapState_Copy !****************************************************************************** FUNCTION BitmapState_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( BitmapState ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = ( LhsObj % Writable . NEQV . RhsObj % Writable ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION BitmapState_IsEqualTo !****************************************************************************** SUBROUTINE BitmapState_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the BitmapState object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END SUBROUTINE BitmapState_MemFree !****************************************************************************** FUNCTION BitmapState_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'BitmapState' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION BitmapState_ToString !------------------------------------------------------------------------------- !                               BitmapState Procedures !------------------------------------------------------------------------------- SUBROUTINE BitmapState_Construct ( State , ID , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the BitmapState object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( OUT ) :: State tSInt32 , INTENT ( IN ) :: ID TYPE ( BitmapStateManager ), TARGET , INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW State % ID = ID CALL State % DirectTable % Construct ( Manager ) State % Manager => Manager CALL State % TransitionMap % Construct () RETURN END SUBROUTINE BitmapState_Construct !****************************************************************************** SUBROUTINE BitmapState_Destruct ( State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the BitmapState object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL State % DirectTable % Destruct () NULLIFY ( State % Manager ) CALL State % TransitionMap % Clear () RETURN END SUBROUTINE BitmapState_Destruct !****************************************************************************** SUBROUTINE BitmapState_TransitionRule ( State , Chr , TargetID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform transition rule. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: State tChar , INTENT ( IN ) :: Chr tSInt32 , INTENT ( IN ) :: TargetID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: StoredNode TYPE ( BitMapNode ) :: KeyNode TYPE ( BitMapNode ), POINTER :: CurNode TYPE ( BitmapStatePack ), POINTER :: Pack tLogical :: Found ! FLOW CALL State % EnsureWritable () KeyNode % Chr = Chr Found = State % TransitionMap % FindNode ( KeyNode , StoredNode ) IF ( Found . AND . ASSOCIATED ( StoredNode )) THEN SELECT TYPE ( StoredNode ) TYPE IS ( BitMapNode ) Pack => StoredNode % State END SELECT ELSE CALL BitMapNode_New ( CurNode , Chr , State % Manager ) CALL State % TransitionMap % Insert ( CurNode ) Pack => CurNode % State END IF CALL Pack % AddState ( TargetID ) NULLIFY ( StoredNode , CurNode , Pack ) RETURN END SUBROUTINE BitmapState_TransitionRule !****************************************************************************** SUBROUTINE BitmapState_DirectRule ( State , TargetID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform direct rule. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: State tSInt32 , INTENT ( IN ) :: TargetID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL State % EnsureWritable () CALL State % DirectTable % AddState ( TargetID ) RETURN END SUBROUTINE BitmapState_DirectRule !****************************************************************************** FUNCTION BitmapState_GetID ( State ) RESULT ( ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get ID of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: State !! object tSInt32 :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ID = State % ID RETURN END FUNCTION BitmapState_GetID !****************************************************************************** FUNCTION BitmapState_GetDirectTable ( State ) RESULT ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the direct table of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), TARGET , INTENT ( IN ) :: State !! object TYPE ( BitmapStatePack ), POINTER :: Table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Table => State % DirectTable RETURN END FUNCTION BitmapState_GetDirectTable !****************************************************************************** FUNCTION BitmapState_GetTransitionMap ( State ) RESULT ( TransMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the transition map of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), TARGET , INTENT ( IN ) :: State !! object TYPE ( IntrusiveHashList ), POINTER :: TransMap !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW TransMap => State % TransitionMap RETURN END FUNCTION BitmapState_GetTransitionMap !****************************************************************************** SUBROUTINE BitmapState_Freeze ( State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform freezing operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: CurEntry tLogical :: EndOfList ! FLOW CALL State % DirectTable % Freeze () EndOfList = State % TransitionMap % StartFirst ( CurEntry ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( MapEntry => CurEntry ) TYPE IS ( BitMapNode ) CALL MapEntry % State % Freeze () END SELECT EndOfList = State % TransitionMap % MoveForward ( CurEntry ) END DO State % Writable = FalseVal RETURN END SUBROUTINE BitmapState_Freeze !****************************************************************************** SUBROUTINE BitmapState_EnsureWritable ( State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To report error if wriable is false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( INOUT ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . State % Writable ) THEN CALL Handle_ErrLevel ( 'BitmapState_EnsureWritable' , ModName , ErrWarning , & 'NFAIState is not writable' ) END IF RETURN END SUBROUTINE BitmapState_EnsureWritable !****************************************************************************** FUNCTION BitmapState_IsEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: LhsObj !! an object TYPE ( BitmapState ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( LhsObj % ID == RhsObj % ID ) RETURN END FUNCTION BitmapState_IsEqual !****************************************************************************** FUNCTION BitmapState_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapState ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize ! FLOW KeySize = C_SIZEOF ( Obj % ID ) Code = HashFuncOpt ( Obj % ID , KeySize , 3131133 ) RETURN END FUNCTION BitmapState_HashCode !------------------------------------------------------------------------------- !                               BitmapStateManager Procedures !------------------------------------------------------------------------------- SUBROUTINE BitmapStateManager_Construct ( Manager , StateList ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the BitmapStateManager object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), INTENT ( OUT ) :: Manager TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: StateList !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: EndOfList ! FLOW ALLOCATE ( Manager % IStates ( 0 : StateList % GetSize () - 1 )) BLOCK CLASS ( DoublyLinkedNode ), POINTER :: CurNode tSInt32 :: ID ! construct IStates EndOfList = StateList % StartFirst ( CurNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( CurState => CurNode ) TYPE IS ( NFAState ) ID = CurState % GetID () CALL Manager % IStates ( ID )% Construct ( ID , Manager ) END SELECT EndOfList = StateList % MoveForward ( CurNode ) END DO ! transform IStates EndOfList = StateList % StartFirst ( CurNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( CurState => CurNode ) TYPE IS ( NFAState ) ID = CurState % GetID () ! loop through direct table CALL DirectTableLoop ( CurState , Manager % IStates ( ID )) ! loop through transition map CALL TransitionMapLoop ( CurState , Manager % IStates ( ID )) END SELECT EndOfList = StateList % MoveForward ( CurNode ) END DO ! freeze IStates DO ID = 0 , SIZE ( Manager % IStates ) - 1 CALL Manager % IStates ( ID )% Freeze () END DO END BLOCK RETURN CONTAINS SUBROUTINE DirectTableLoop ( CState , IState ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( NFAState ), INTENT ( INOUT ) :: CState TYPE ( BitmapState ), INTENT ( INOUT ) :: IState !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: ThisNode TYPE ( IntrusiveHashList ), POINTER :: Table tLogical :: EndOfTable ! FLOW Table => CState % GetDirectTable () EndOfTable = Table % StartFirst ( ThisNode ) DO WHILE (. NOT . EndOfTable ) SELECT TYPE ( NState => ThisNode ) TYPE IS ( NFAState ) CALL IState % DirectRule ( NState % GetID ()) END SELECT EndOfTable = Table % MoveForward ( ThisNode ) END DO RETURN END SUBROUTINE DirectTableLoop !****************************************************************************** SUBROUTINE TransitionMapLoop ( CState , IState ) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( NFAState ), INTENT ( INOUT ) :: CState TYPE ( BitmapState ), INTENT ( INOUT ) :: IState !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: ThisNode TYPE ( IntrusiveHashList ), POINTER :: TransMap TYPE ( IntrusiveHashList ), POINTER :: StateSet tChar :: Chr tLogical :: EndOfMap ! FLOW TransMap => CState % GetTransitionMap () EndOfMap = TransMap % StartFirst ( ThisNode ) DO WHILE (. NOT . EndOfMap ) SELECT TYPE ( ThisNode ) TYPE IS ( HashMapNode ) StateSet => ThisNode % GetSet () Chr = ThisNode % GetChar () END SELECT BLOCK CLASS ( HashListNode ), POINTER :: SetNode tLogical :: EndOfSet EndOfSet = StateSet % StartFirst ( SetNode ) DO WHILE (. NOT . EndOfSet ) SELECT TYPE ( NState => SetNode ) TYPE IS ( NFAState ) CALL IState % TransitionRule ( Chr , NState % GetID ()) END SELECT EndOfSet = StateSet % MoveForward ( SetNode ) END DO END BLOCK EndOfMap = TransMap % MoveForward ( ThisNode ) END DO RETURN END SUBROUTINE TransitionMapLoop !****************************************************************************** END SUBROUTINE BitmapStateManager_Construct !****************************************************************************** SUBROUTINE BitmapStateManager_Destruct ( Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the BitmapStateManager object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), INTENT ( INOUT ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Manager % IStates )) THEN BLOCK tSInt32 :: ID DO ID = 0 , SIZE ( Manager % IStates ) - 1 CALL Manager % IStates ( ID )% Destruct () END DO END BLOCK DEALLOCATE ( Manager % IStates ) END IF RETURN END SUBROUTINE BitmapStateManager_Destruct !****************************************************************************** FUNCTION BitmapStateManager_GetState ( Manager , ID ) RESULT ( State ) !** PURPOSE OF THIS FUNCTION: !&#94; To get a pointer to the specified state of the BitmapStateManager object !  according to the specified ID. !** FUNCTION ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), TARGET , INTENT ( IN ) :: Manager tSInt32 , INTENT ( IN ) :: ID TYPE ( BitmapState ), POINTER :: State !** FUNCTION INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW State => Manager % IStates ( ID ) RETURN END FUNCTION BitmapStateManager_GetState !****************************************************************************** FUNCTION BitmapStateManager_GetStates ( Manager ) RESULT ( States ) !** PURPOSE OF THIS FUNCTION: !&#94; To get a pointer to states of the BitmapStateManager object. !** FUNCTION ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), TARGET , INTENT ( IN ) :: Manager TYPE ( BitmapState ), POINTER :: States (:) !** FUNCTION INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW States => Manager % IStates RETURN END FUNCTION BitmapStateManager_GetStates !****************************************************************************** FUNCTION BitmapStateManager_StateCount ( Manager ) RESULT ( Count ) !** PURPOSE OF THIS FUNCTION: !&#94; To get size of the states of the object. !** FUNCTION ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), INTENT ( IN ) :: Manager tSInt32 :: Count !** FUNCTION INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Count = SIZE ( Manager % IStates ) RETURN END FUNCTION BitmapStateManager_StateCount !****************************************************************************** SUBROUTINE BitmapStateManager_NewEmptyPack ( Manager , Pack ) !** PURPOSE OF THIS FUNCTION: !&#94; To get size of the states of the object. !** FUNCTION ARGUMENT DECLARATIONS: CLASS ( BitmapStateManager ), INTENT ( IN ) :: Manager TYPE ( BitmapStatePack ), POINTER , INTENT ( INOUT ) :: Pack !** FUNCTION INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL BitmapStatePack_New ( Pack , Manager ) RETURN END SUBROUTINE BitmapStateManager_NewEmptyPack ! ----------------------------------------------------------------------------- ! -----                     BitmapStatePack Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE BitmapStatePack_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the BitmapStatePack object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( BitmapStatePack ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'BitmapStatePack_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE BitmapStatePack_Copy !****************************************************************************** FUNCTION BitmapStatePack_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( BitmapStatePack ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = ( LhsObj % Writable . NEQV . RhsObj % Writable ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION BitmapStatePack_IsEqualTo !****************************************************************************** SUBROUTINE BitmapStatePack_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the BitmapStatePack object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END SUBROUTINE BitmapStatePack_MemFree !****************************************************************************** FUNCTION BitmapStatePack_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'BitmapStatePack' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION BitmapStatePack_ToString !------------------------------------------------------------------------------- !                               BitmapStatePack Procedures !------------------------------------------------------------------------------- SUBROUTINE BitmapStatePack_Construct ( Pack , Manager ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the BitmapState object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( OUT ) :: Pack TYPE ( BitmapStateManager ), TARGET , INTENT ( IN ) :: Manager !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length ! FLOW Length = ( Manager % StateCount () - 1_kIndex ) / 63_kIndex + 1_kIndex ! ceiling CALL MemAlloc ( Pack % StateBitmap , Length , StartID = 0_kIndex ) Pack % Manager => Manager RETURN END SUBROUTINE BitmapStatePack_Construct !****************************************************************************** SUBROUTINE BitmapStatePack_Destruct ( Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the BitmapState object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MemFree ( Pack % StateBitmap ) NULLIFY ( Pack % Manager ) CALL Pack % List % Clear () RETURN END SUBROUTINE BitmapStatePack_Destruct !****************************************************************************** SUBROUTINE BitmapStatePack_AddState ( Pack , StateID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add state to the pack object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Pack tSInt32 , INTENT ( IN ) :: StateID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: Bucket , Offset tSInt64 :: F ! FLOW CALL Pack % EnsureWritable () Bucket = StateID / 63 Offset = MOD ( StateID , 63 ) F = SHIFTL ( 1_kInt64 , Offset ) Pack % StateBitmap ( Bucket ) = IOR ( Pack % StateBitmap ( Bucket ), F ) RETURN END SUBROUTINE BitmapStatePack_AddState !****************************************************************************** SUBROUTINE BitmapStatePack_AddAll ( Pack , Other ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add state to the pack object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Pack TYPE ( BitmapStatePack ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I ! FLOW CALL Pack % EnsureWritable () IF (. NOT . ASSOCIATED ( Pack % Manager , Other % Manager )) THEN CALL Handle_ErrLevel ( 'BitmapStatePack_AddAll' , ModName , ErrSevere , & 'Both objects must share the same manager.' ) RETURN END IF DO I = 0 , SIZE ( Pack % StateBitmap ) - 1 Pack % StateBitmap ( I ) = IOR ( Pack % StateBitmap ( I ), Other % StateBitmap ( I )) END DO RETURN END SUBROUTINE BitmapStatePack_AddAll !****************************************************************************** FUNCTION BitmapStatePack_Contain ( Pack , StateID ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the pack object contains the specified ID or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: Pack tSInt32 , INTENT ( IN ) :: StateID tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: Bucket , Offset tSInt64 :: F ! FLOW Bucket = StateID / 63 Offset = MOD ( StateID , 63 ) F = SHIFTL ( 1_kInt64 , Offset ) Flag = ( IOR ( Pack % StateBitmap ( Bucket ), F ) /= 0_kInt64 ) RETURN END FUNCTION BitmapStatePack_Contain !****************************************************************************** FUNCTION BitmapStatePack_IsEmpty ( Pack ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the pack object is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: Pack tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I ! FLOW Flag = FalseVal ASSOCIATE ( B => Pack % StateBitmap ) DO I = 0 , SIZE ( B ) - 1 IF ( B ( I ) /= 0_kInt64 ) RETURN END DO END ASSOCIATE Flag = TrueVal RETURN END FUNCTION BitmapStatePack_IsEmpty !****************************************************************************** FUNCTION BitmapStatePack_AsList ( Pack ) RESULT ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the pack object as a list of states. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), TARGET , INTENT ( INOUT ) :: Pack TYPE ( IntrusiveLinearList ), POINTER :: List !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Pack % Writable ) THEN CALL Handle_ErrLevel ( 'BitmapStatePack_AsList' , ModName , ErrWarning , & 'Pack is still writable. Call AsList only when writing is finished.' ) RETURN END IF IF ( Pack % List % IsEmpty ()) THEN ! add contained states to the list BLOCK tSInt32 :: ID DO ID = 0 , Pack % Manager % StateCount () - 1 IF ( Pack % Contain ( ID )) THEN CALL Pack % List % AddLast ( Pack % Manager % GetState ( ID )) END IF END DO END BLOCK END IF List => Pack % List RETURN END FUNCTION BitmapStatePack_AsList !****************************************************************************** FUNCTION BitmapStatePack_Size ( Pack ) RESULT ( StateSize ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of states of the pack object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: Pack tSInt32 :: StateSize !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I tSInt64 :: B , S ! FLOW S = 0_kInt64 ASSOCIATE ( BState => Pack % StateBitmap ) DO I = 0 , SIZE ( BState ) - 1 B = BState ( I ) DO WHILE ( B /= 0_kInt64 ) S = S + IAND ( B , 1_kInt64 ) B = SHIFTA ( B , 1 ) END DO END DO END ASSOCIATE StateSize = ToInt32 ( S ) RETURN END FUNCTION BitmapStatePack_Size !****************************************************************************** SUBROUTINE BitmapStatePack_Freeze ( Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform freezing operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Pack % Writable = FalseVal RETURN END SUBROUTINE BitmapStatePack_Freeze !****************************************************************************** SUBROUTINE BitmapStatePack_EnsureWritable ( Pack ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To report error if wriable is false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( INOUT ) :: Pack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . Pack % Writable ) THEN CALL Handle_ErrLevel ( 'BitmapStatePack_EnsureWritable' , ModName , ErrWarning , & 'NFAIState is not writable' ) END IF RETURN END SUBROUTINE BitmapStatePack_EnsureWritable !****************************************************************************** FUNCTION BitmapStatePack_IsEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: LhsObj !! an object TYPE ( BitmapStatePack ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal IF ( SIZE ( LhsObj % StateBitmap ) /= SIZE ( RhsObj % StateBitmap )) RETURN BLOCK tIndex :: I DO I = 0 , SIZE ( LhsObj % StateBitmap ) - 1 IF ( LhsObj % StateBitmap ( I ) /= RhsObj % StateBitmap ( I )) RETURN END DO END BLOCK Flag = TrueVal RETURN END FUNCTION BitmapStatePack_IsEqual !****************************************************************************** FUNCTION BitmapStatePack_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapStatePack ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize ! FLOW KeySize = C_SIZEOF ( Obj % StateBitmap ( 1 )) * SIZE ( Obj % StateBitmap ) Code = HashFuncOpt ( Obj % StateBitmap , KeySize , 3131133 ) RETURN END FUNCTION BitmapStatePack_HashCode ! ----------------------------------------------------------------------------- ! -----                     BitmapNode Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE BitmapNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the BitmapNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( BitmapNode ) DstObj = SrcObj ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'BitmapNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE BitmapNode_Copy !****************************************************************************** FUNCTION BitmapNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( BitmapNode ) ! this is not correct implementation but it does not matter since we do not use this any way Flag = ( LhsObj % Chr /= RhsObj % Chr ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION BitmapNode_IsEqualTo !****************************************************************************** FUNCTION BitmapNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitmapNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! this is not correct implementation but it does not matter since we do not use this any way Str = 'BitmapNode' ASSOCIATE ( Dummy => Obj ); END ASSOCIATE RETURN END FUNCTION BitmapNode_ToString !------------------------------------------------------------------------------- !                               BitMapNode Procedures !------------------------------------------------------------------------------- FUNCTION BitMapNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitMapNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( BitMapNode ) Flag = ( LhsObj % Chr == RhsObj % Chr ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION BitMapNode_IsKeyEqual !****************************************************************************** SUBROUTINE BitMapNode_FreeMemory ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitMapNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % State % Destruct () RETURN END SUBROUTINE BitMapNode_FreeMemory !****************************************************************************** FUNCTION BitMapNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitMapNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize ! FLOW KeySize = C_SIZEOF ( Obj % Chr ) Code = HashFuncOpt ( Obj % Chr , KeySize , 3131133 ) RETURN END FUNCTION BitMapNode_HashCode !****************************************************************************** SUBROUTINE BitMapNode_Construct ( Node , Chr , Manager , State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the BitMapNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BitMapNode ), INTENT ( OUT ) :: Node tChar , INTENT ( IN ) :: Chr TYPE ( BitmapStateManager ), INTENT ( IN ) :: Manager TYPE ( BitmapStatePack ), TARGET , OPTIONAL , INTENT ( IN ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( State )) THEN Node % State => State CALL Node % State % Construct ( Manager ) ELSE CALL Manager % NewEmptyPack ( Node % State ) END IF Node % Chr = Chr RETURN END SUBROUTINE BitMapNode_Construct !****************************************************************************** END MODULE MClass_BitmapState !******************************************************************************","tags":"","loc":"sourcefile\\mclass_bitmapstate.f90.html"},{"title":"MClass_TernaryTrie.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TernaryTrie !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TernaryTrie* type and its related routines. !   The *TernaryTrie* type is a derived type representing a symbol table !   of key-value pairs, with string keys and generic values. <br> !   Technically, the *TernaryTrie* type employs a ternary-search tree !   implementation to provide common operations of the symbol table. !   These operations include the *Insert*, *Remove*, *Contain*, *GetSize*, !   *IsEmpty* and *GetValue* methods.  It also provides character-based !   methods for finding the string in the symbol table that is the longest !   prefix of a given prefix, finding all strings in the symbol table that !   start with a given prefix, and finding all strings in the symbol table !   that match a given pattern. <br> !   For all operations provided, the *TernaryTrie* type supports two types !   of character strings: the Fortran intrinsic *CHARACTER* type and the !   *FvlStr* derived type.  A user can choose to work with one of these two !   types.  Like other symbol tables, the *TernaryTrie* type does not allow !   duplicated keys.  Therefore, if an inserted key is equal to a key stored !   in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key.  <br> !    <br> !  **REFERENCES**: <br> !   [1] R. Sedgewick and K. Wayne. 2011.  Algorithms, 4th Edition.  Addison-Wesley. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_DoublyLinkedLists , ONLY : QueueString => ListCharacter , QueueAny => ListAnyType USE MClass_FvlStr USE MClass_StringBuilder IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TernaryTrie PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_TernaryTrie' tSInt32 , PARAMETER :: MsgLen = 128 tSInt32 , PARAMETER :: Radix = 256 !! radix for extended ASCII tCharStar , PARAMETER :: NULCHR = ACHAR ( 0 ) !! flag for null node tCharStar , PARAMETER :: NONNUL = ACHAR ( 2 ) !! flag for non-null node !** DERIVED TYPE DEFINITIONS !> The *TrieNode* type is a node type used in conjunction with the !  *TernaryTrie* type.  It is a private type. TYPE TrieNode !% character tChar :: C !% value associated with the string key CLASS ( * ), ALLOCATABLE :: Value !% left (nodes) subtries TYPE ( TrieNode ), POINTER :: Left => NULL () !% middle (nodes) subtries TYPE ( TrieNode ), POINTER :: Middle => NULL () !% right (nodes) subtries TYPE ( TrieNode ), POINTER :: Right => NULL () END TYPE TrieNode !> The *TernaryTrie* type is a container type that utilizes a ternary search !  tree implementation to provide common operations for a symbol table where !  its keys are character strings and its values can be of any type. TYPE TernaryTrie PRIVATE !% root of trie TYPE ( TrieNode ), POINTER :: Root => NULL () !% number of keys tIndex :: N CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !% *Put* is a working method for insertion operation PROCEDURE , PRIVATE :: Put => TernaryTrie_Put !% *Del* is a working method for removal operation PROCEDURE , PRIVATE :: Del => TernaryTrie_Delete !% procedures with generic interfaces PROCEDURE , PRIVATE :: TernaryTrie_Insert_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Insert_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Remove_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Remove_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Contain_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Contain_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_StartWith_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_StartWith_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_GetValue_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_GetValue_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_AllKeys_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_AllKeys_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_CHCH PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_CHVL PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_VLCH PROCEDURE , PRIVATE :: TernaryTrie_KeysWithPrefix_VLVL PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_CHCH PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_CHVL PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_VLCH PROCEDURE , PRIVATE :: TernaryTrie_KeysThatMatch_VLVL PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_CHCH PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_CHVL PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_VLCH PROCEDURE , PRIVATE :: TernaryTrie_WildcardKeys_VLVL PROCEDURE , PRIVATE :: TernaryTrie_LongestPrefixOf_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_LongestPrefixOf_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_ConstructByArray_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_ConstructByArray_FvlStr PROCEDURE , PRIVATE :: TernaryTrie_Destructor_ChrStr PROCEDURE , PRIVATE :: TernaryTrie_Destructor_FvlStr ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a symbol table from arrays of keys and values.  <br> !  **Usage**: <br> !   --->    CALL Table%Construct(10, KeyArr, ValArr) GENERIC :: Construct => TernaryTrie_ConstructByArray_ChrStr , & TernaryTrie_ConstructByArray_FvlStr !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() <br> PROCEDURE :: Clear => TernaryTrie_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To first retrieve stored keys (and optionally their associated values) !                and then remove all key-value pairs from the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%Destruct(KeyQ) <br> !   --->    CALL Table%Destruct(KeyArr) <br> !   --->    CALL Table%Destruct(KeyQ, ValQ) <br> !   --->    CALL Table%Destruct(KeyArr, ValQ) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: Destruct => TernaryTrie_Destructor_ChrStr , & TernaryTrie_Destructor_FvlStr ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(Key, Value) <br> GENERIC :: Insert => TernaryTrie_Insert_ChrStr , & TernaryTrie_Insert_FvlStr !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the table (if the key found).  Optionally, the associated !                value can be retrieved. <br> !  **Usage**: <br> !   --->    CALL Table%Remove(Key) <br> !   --->    CALL Table%Remove(Key, Value) <br> GENERIC :: Remove => TernaryTrie_Remove_ChrStr , & TernaryTrie_Remove_FvlStr ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(Key) <br> !   --->    IF (.NOT.Table%Contain(Key)) DoSomething GENERIC :: Contain => TernaryTrie_Contain_ChrStr , & TernaryTrie_Contain_FvlStr !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (the number of key-value pairs stored) !                of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => TernaryTrie_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => TernaryTrie_IsEmpty !> **Type-Bound Function**: StartWith <br> !  **Purpose**:  To return a flag indicating whether the symbol table contains !                a key starting with the specified prefix. <br> !  **Usage**: <br> !   --->    Flag = Table%StartWith(Prefix) <br> !   --->    IF (.NOT.Table%StartWith(Prefix)) DoSomeThing GENERIC :: StartWith => TernaryTrie_StartWith_ChrStr , & TernaryTrie_StartWith_FvlStr ! ------------------------------------------------------- ! -----             retrieval procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the table. !                If the key is not found, return an unallocated value. <br> !  **Usage**: <br> !   --->    CALL Table%GetValue(Key, Value) <br> GENERIC :: GetValue => TernaryTrie_GetValue_ChrStr , & TernaryTrie_GetValue_FvlStr !> **Type-Bound Subroutine**: GetAllKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table. <br> !  **Usage**: <br> !   --->    CALL Table%GetAllKeys(KeyQ) <br> !   --->    CALL Table%GetAllKeys(KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetAllKeys => TernaryTrie_AllKeys_ChrStr , & TernaryTrie_AllKeys_FvlStr !> **Type-Bound Subroutine**: GetKeysWithPrefix <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                start with the specified prefix.  Return an empty queue (or an unallocated !                array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyQ) <br> !   --->    CALL Table%GetKeysWithPrefix(Prefix, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysWithPrefix => TernaryTrie_KeysWithPrefix_CHCH , & TernaryTrie_KeysWithPrefix_CHVL , & TernaryTrie_KeysWithPrefix_VLCH , & TernaryTrie_KeysWithPrefix_VLVL !> **Type-Bound Subroutine**: GetKeysThatMatch <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern where the question-mark character is interpreted !                as a wild-card character.  Return an empty queue (or an unallocated array) !                if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyQ) <br> !   --->    CALL Table%GetKeysThatMatch(Pattern, KeyArr) <br> !  **Important Note**: A user must choose which type of keys to be returned.  The method !       returns a queue of keys where their type is the Fortran intrinsic *CHARACTER* type !       or it returns an array of keys where their type is the *FvlStr* type. GENERIC :: GetKeysThatMatch => TernaryTrie_KeysThatMatch_CHCH , & TernaryTrie_KeysThatMatch_CHVL , & TernaryTrie_KeysThatMatch_VLCH , & TernaryTrie_KeysThatMatch_VLVL !> **Type-Bound Subroutine**: GetWildcardKeys <br> !  **Purpose**:  To return a queue (or an array) of all the keys in the symbol table that !                match the given pattern with wild-card characters.  Return an empty queue !                (or an unallocated array) if no such key(s) found. <br> !  **Usage**: <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyQ) <br> !   --->    CALL Table%GetWildcardKeys(Pattern, KeyArr) <br> !  **Important Note**: The *GetWildcardKeys* method is mostly the same as the *GetKeysThatMatch* !       method, except that it recognizes two wild-card characters instead of one.  Similar to !       the *GetKeysThatMatch* method, the question-mark character ('?') is interpreted as a !       wild-card character for a single character.  Additionally, the *GetWildcardKeys* method !       interprets the asterisk character ('*') as a wild-card character for a sequence of !       characters. GENERIC :: GetWildcardKeys => TernaryTrie_WildcardKeys_CHCH , & TernaryTrie_WildcardKeys_CHVL , & TernaryTrie_WildcardKeys_VLCH , & TernaryTrie_WildcardKeys_VLVL !> **Type-Bound Subroutine**: GetLongestPrefixOf <br> !  **Purpose**:  To return the string in the symbol table that is the longest prefix of the !                specified query.  Return an unallocated string if no such string found. <br> !  **Usage**: <br> !   --->    CALL Table%GetLongestPrefixOf(Query, Prefix) <br> GENERIC :: GetLongestPrefixOf => TernaryTrie_LongestPrefixOf_ChrStr , & TernaryTrie_LongestPrefixOf_FvlStr ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the symbol table. FINAL :: TernaryTrie_Finalizer ! --------------------------------------------------------------------- END TYPE TernaryTrie !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE TrieNode_New ( Node , C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the node and assign its character. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( OUT ) :: Node !! trie node tChar , INTENT ( IN ) :: C !! character !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate next-node component ALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN ! set character Node % C = C ELSE ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_New' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE TrieNode_New !****************************************************************************** SUBROUTINE TrieNode_Deallocate ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the specify node by setting the character-flag component to null !  character and also deallocate its next-node component. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( INOUT ) :: Node !! trie node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! deallocate DEALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'TrieNode_Deallocate' , ModName , AllocMsg , AllocStat ) NULLIFY ( Node ) RETURN END SUBROUTINE TrieNode_Deallocate !****************************************************************************** FUNCTION TrieNode_IsLeaf ( Node ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified node is a leaf node or not. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), INTENT ( IN ) :: Node !! trie node tLogical :: Flag !! true if this is the leaf node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ((. NOT . ASSOCIATED ( Node % Left )). AND . & (. NOT . ASSOCIATED ( Node % Right )). AND . & (. NOT . ASSOCIATED ( Node % Middle ))) RETURN END FUNCTION TrieNode_IsLeaf !****************************************************************************** SUBROUTINE TernaryTrie_ConstructByArray_ChrStr ( Table , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tIndex , INTENT ( IN ) :: N !! number of keys tCharStar , INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE TernaryTrie_ConstructByArray_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_ConstructByArray_FvlStr ( Table , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a symbol table based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tIndex , INTENT ( IN ) :: N !! number of keys TYPE ( FvlStr ), INTENT ( IN ) :: Keys ( N ) !! an array of keys CLASS ( * ), INTENT ( IN ) :: Values ( N ) !! an array of associated values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! built symbol table from input arrays DO I = 1 , N CALL Table % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE TernaryTrie_ConstructByArray_FvlStr !****************************************************************************** SUBROUTINE TernaryTrie_Clear ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % Destruct ( KeyQ ) CALL KeyQ % Destruct () RETURN END SUBROUTINE TernaryTrie_Clear !****************************************************************************** SUBROUTINE TernaryTrie_Destructor_ChrStr ( Table , KeyQ , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! a queue of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: Key tLogical :: IsTheEnd ! FLOW ! get all keys CALL Table % GetAllKeys ( KeyQ ) IF ( PRESENT ( ValueQ )) THEN ! get all values while removing the key-value pairs BLOCK CLASS ( * ), ALLOCATABLE :: Value IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key , Value ) CALL ValueQ % Enqueue ( Value ) DEALLOCATE ( Value ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END BLOCK ELSE ! remove the key-value pairs IsTheEnd = KeyQ % StartFirst ( Key ) DO WHILE (. NOT . IsTheEnd ) CALL Table % Remove ( Key ) IF ( Table % IsEmpty ()) EXIT IsTheEnd = KeyQ % MoveForward ( Key ) END DO END IF RETURN END SUBROUTINE TernaryTrie_Destructor_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_Destructor_FvlStr ( Table , KeyArr , ValueQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a symbol table and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: KeyArr (:) !! an array of stored keys TYPE ( QueueAny ), OPTIONAL , INTENT ( OUT ) :: ValueQ !! a queue of stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % Destruct ( KeyQ , ValueQ ) CALL KeyQueue2Array ( KeyQ , KeyArr ) RETURN END SUBROUTINE TernaryTrie_Destructor_FvlStr !****************************************************************************** SUBROUTINE TernaryTrie_Finalizer ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Table % Clear () RETURN END SUBROUTINE TernaryTrie_Finalizer !****************************************************************************** RECURSIVE FUNCTION TernaryTrie_Put ( Table , Y , Key , Value , D ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for insertion operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: Y !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value tIndex , INTENT ( IN ) :: D !! index of the character in the key TYPE ( TrieNode ), POINTER :: X !! node representing new subtrie !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: C ! FLOW ! set output pointer X => Y ! get current character C = Key ( D : D ) ! create a new subtrie IF (. NOT . ASSOCIATED ( X )) CALL TrieNode_New ( X , C ) IF ( LLT ( C , X % C )) THEN X % Left => Table % Put ( X % Left , Key , Value , D ) ELSEIF ( LGT ( C , X % C )) THEN X % Right => Table % Put ( X % Right , Key , Value , D ) ELSEIF ( D < LEN ( Key , KIND = kIndex )) THEN X % Middle => Table % Put ( X % Middle , Key , Value , D + 1_kIndex ) ELSE ! X is the node corresponding to the last key character IF (. NOT . ALLOCATED ( X % Value )) THEN ! new key Table % N = Table % N + 1_kIndex ALLOCATE ( X % Value , SOURCE = Value ) ELSE ! existing key so replace existing value with new one ! note: must re-allocate since value can have different type !       so assignment/copy may be invalid. DEALLOCATE ( X % Value ) ALLOCATE ( X % Value , SOURCE = Value ) END IF END IF RETURN END FUNCTION TernaryTrie_Put !****************************************************************************** SUBROUTINE TernaryTrie_Insert_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Insert_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF Table % Root => Table % Put ( Table % Root , Key , Value , 1_kIndex ) RETURN END SUBROUTINE TernaryTrie_Insert_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_Insert_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert a key-value pair into the symbol table, overwriting the old value !  with the new value if the key is already in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), INTENT ( IN ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Insert_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) Table % Root => Table % Put ( Table % Root , StrPtr , Value , 1_kIndex ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_Insert_FvlStr !****************************************************************************** RECURSIVE FUNCTION GetNode ( Y , Key , D ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a pointer to the last node of the subtrie that stores the !  specified key.  If the specified key is not found, return a null pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: Y !! node representing current subtrie tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key TYPE ( TrieNode ), POINTER :: X !! node representing new subtrie !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: C ! FLOW IF (. NOT . ASSOCIATED ( Y )) THEN X => NULL () RETURN END IF ! get current character C = Key ( D : D ) IF ( LLT ( C , Y % C )) THEN X => GetNode ( Y % Left , Key , D ) ELSEIF ( LGT ( C , Y % C )) THEN X => GetNode ( Y % Right , Key , D ) ELSEIF ( D < LEN ( Key , KIND = kIndex )) THEN X => GetNode ( Y % Middle , Key , D + 1_kIndex ) ELSE X => Y END IF RETURN END FUNCTION GetNode !****************************************************************************** FUNCTION TernaryTrie_Contain_ChrStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Contain_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( GetNode ( Table % Root , Key , 1_kIndex )) RETURN END FUNCTION TernaryTrie_Contain_ChrStr !****************************************************************************** FUNCTION TernaryTrie_Contain_FvlStr ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the symbol table contains the specified key or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key tLogical :: Found !! true if key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Contain_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( GetNode ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION TernaryTrie_Contain_FvlStr !****************************************************************************** SUBROUTINE TernaryTrie_GetValue_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: NodeOut ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_GetValue_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF NodeOut => GetNode ( Table % Root , Key , 1_kIndex ) IF ( ASSOCIATED ( NodeOut )) THEN ! key found IF ( ALLOCATED ( NodeOut % Value )) ALLOCATE ( Value , SOURCE = NodeOut % Value ) END IF NULLIFY ( NodeOut ) RETURN END SUBROUTINE TernaryTrie_GetValue_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_GetValue_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the value associated with the specified key.  Return !  an unallocated value if the key is not found in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Value !! value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_GetValue_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) CALL Table % GetValue ( StrPtr , Value ) NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_GetValue_FvlStr !****************************************************************************** RECURSIVE FUNCTION TernaryTrie_Delete ( Table , Y , Key , D , Value ) RESULT ( X ) !** PURPOSE OF THIS SUBROUTINE: !&#94; This routine is a working routine for removal operation. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( TrieNode ), POINTER , INTENT ( INOUT ) :: Y !! node representing input subtrie tCharStar , INTENT ( IN ) :: Key !! key tIndex , INTENT ( IN ) :: D !! index of the character in the key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value TYPE ( TrieNode ), POINTER :: X !! node representing output subtrie !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: C ! FLOW ! set output pointer X => Y IF (. NOT . ASSOCIATED ( X )) RETURN ! get current character C = Key ( D : D ) IF ( LLT ( C , X % C )) THEN X % Left => Table % Del ( X % Left , Key , D , Value ) ELSEIF ( LGT ( C , X % C )) THEN X % Right => Table % Del ( X % Right , Key , D , Value ) ELSE IF ( D < LEN ( Key , KIND = kIndex )) THEN X % Middle => Table % Del ( X % Middle , Key , D + 1_kIndex , Value ) ELSE ! the last character of the key IF (. NOT . ALLOCATED ( X % Value )) RETURN ! the key-value pair found so remove it Table % N = Table % N - 1_kIndex IF ( PRESENT ( Value )) ALLOCATE ( Value , SOURCE = X % Value ) DEALLOCATE ( X % Value ) END IF IF (. NOT . ALLOCATED ( X % Value )) THEN IF ( TrieNode_IsLeaf ( X )) CALL TrieNode_Deallocate ( X ) END IF END IF RETURN END FUNCTION TernaryTrie_Delete !****************************************************************************** SUBROUTINE TernaryTrie_Remove_ChrStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Remove_ChrStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF ! check whether the key exists or not IF (. NOT . ASSOCIATED ( GetNode ( Table % Root , Key , 1_kIndex ))) RETURN Table % Root => Table % Del ( Table % Root , Key , 1_kIndex , Value ) RETURN END SUBROUTINE TernaryTrie_Remove_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_Remove_FvlStr ( Table , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a key-value pair from the symbol table if the specified key is found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Key !! key CLASS ( * ), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Key ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_Remove_FvlStr' , ModName , ErrSevere , & 'A key string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Key ) IF ( ASSOCIATED ( StrPtr )) THEN ! check whether the key exists or not IF ( ASSOCIATED ( GetNode ( Table % Root , StrPtr , 1_kIndex ))) THEN Table % Root => Table % Del ( Table % Root , StrPtr , 1_kIndex , Value ) END IF END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_Remove_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE CollectKeys ( X , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To collect all of keys in the symbol table that start with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( X )) RETURN CALL CollectKeys ( X % Left , Prefix , KeyQ ) CALL Prefix % Append ( X % C ) IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) CALL CollectKeys ( X % Middle , Prefix , KeyQ ) CALL Prefix % DelLastChar () CALL CollectKeys ( X % Right , Prefix , KeyQ ) RETURN END SUBROUTINE CollectKeys !****************************************************************************** FUNCTION TernaryTrie_StartWith_ChrStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_StartWith_ChrStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF Found = ASSOCIATED ( GetNode ( Table % Root , Prefix , 1_kIndex )) RETURN END FUNCTION TernaryTrie_StartWith_ChrStr !****************************************************************************** FUNCTION TernaryTrie_StartWith_FvlStr ( Table , Prefix ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a flag indicating whether the symbol table contains a key !  starting with the specified prefix. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string tLogical :: Found !! true if a key starting with the prefix found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_StartWith_FvlStr' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) Found = FalseVal RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN Found = ASSOCIATED ( GetNode ( Table % Root , StrPtr , 1_kIndex )) ELSE Found = FalseVal END IF NULLIFY ( StrPtr ) RETURN END FUNCTION TernaryTrie_StartWith_FvlStr !****************************************************************************** SUBROUTINE TernaryTrie_KeysWithPrefix_CHCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: X TYPE ( StringBuilder ) :: StrBld ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_KeysWithPrefix_CHCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF X => GetNode ( Table % Root , Prefix , 1_kIndex ) IF ( ASSOCIATED ( X )) THEN ! key(s) with prefix found CALL StrBld % Construct ( Prefix ) CALL CollectKeys ( X , StrBld , KeyQ ) NULLIFY ( X ) END IF RETURN END SUBROUTINE TernaryTrie_KeysWithPrefix_CHCH !****************************************************************************** SUBROUTINE TernaryTrie_KeysWithPrefix_CHVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW IF ( LEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_KeysWithPrefix_CHVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF CALL Table % GetKeysWithPrefix ( Prefix , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE TernaryTrie_KeysWithPrefix_CHVL !****************************************************************************** SUBROUTINE TernaryTrie_KeysWithPrefix_VLCH ( Table , Prefix , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that start with the !  specified prefix.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys starting with the specified prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_KeysWithPrefix_VLCH' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_KeysWithPrefix_VLCH !****************************************************************************** SUBROUTINE TernaryTrie_KeysWithPrefix_VLVL ( Table , Prefix , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that start with the !  specified prefix.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Prefix !! prefix string TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Prefix ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_KeysWithPrefix_VLVL' , ModName , ErrSevere , & 'A prefix string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Prefix ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysWithPrefix ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_KeysWithPrefix_VLVL !****************************************************************************** SUBROUTINE TernaryTrie_AllKeys_ChrStr ( Table , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL CollectKeys ( Table % Root , StrBld , KeyQ ) RETURN END SUBROUTINE TernaryTrie_AllKeys_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_AllKeys_FvlStr ( Table , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetAllKeys ( KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE TernaryTrie_AllKeys_FvlStr !****************************************************************************** RECURSIVE SUBROUTINE AssembleKeys ( X , Prefix , Pattern , I , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To assemble all of keys in the symbol table that match the given pattern where the !  question-mark character is interpreted as a wild card character. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder (with a prefix of the pattern) tCharStar , INTENT ( IN ) :: Pattern !! string pattern tIndex , INTENT ( IN ) :: I !! current position in the pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings matching the pattern !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard = '?' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: C ! FLOW IF (. NOT . ASSOCIATED ( X )) RETURN C = Pattern ( I : I ) IF (( C == WildCard ). OR . LLT ( C , X % C )) CALL AssembleKeys ( X % Left , Prefix , Pattern , I , KeyQ ) IF (( C == WildCard ). OR .( C == X % C )) THEN IF (( I == LEN ( Pattern , KIND = kIndex )). AND .( ALLOCATED ( X % Value ))) THEN CALL Prefix % Append ( X % C ) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) CALL Prefix % DelLastChar () ELSEIF ( I < LEN ( Pattern , KIND = kIndex )) THEN CALL Prefix % Append ( X % C ) CALL AssembleKeys ( X % Middle , Prefix , Pattern , I + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END IF END IF IF (( C == WildCard ). OR . LGT ( C , X % C )) CALL AssembleKeys ( X % Left , Prefix , Pattern , I , KeyQ ) RETURN END SUBROUTINE AssembleKeys !****************************************************************************** SUBROUTINE TernaryTrie_KeysThatMatch_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL AssembleKeys ( Table % Root , StrBld , Pattern , 1_kIndex , KeyQ ) RETURN END SUBROUTINE TernaryTrie_KeysThatMatch_CHCH !****************************************************************************** SUBROUTINE TernaryTrie_KeysThatMatch_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetKeysThatMatch ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE TernaryTrie_KeysThatMatch_CHVL !****************************************************************************** SUBROUTINE TernaryTrie_KeysThatMatch_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_KeysThatMatch_VLCH !****************************************************************************** SUBROUTINE TernaryTrie_KeysThatMatch_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetKeysThatMatch ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_KeysThatMatch_VLVL !****************************************************************************** RECURSIVE SUBROUTINE GatherWildcardKeys ( X , Prefix , Pattern , D , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To gather all of keys in the symbol table that match the given pattern where !  the question-mark character ('?') is interpreted as a wild card character for !  a single character and the asterisk character ('*') is interpreted as a wild !  card character for a sequence of characters. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: X !! node representing current subtrie TYPE ( StringBuilder ), INTENT ( INOUT ) :: Prefix !! string builder with the specified prefix tCharStar , INTENT ( IN ) :: Pattern !! string pattern tIndex , INTENT ( IN ) :: D !! current position of character in the pattern TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of strings with the specified prefix !** SUBROUTINE PARAMETER DECLARATIONS: tCharParam :: WildCard_Single = '?' ! a wild card for single character tCharParam :: WildCard_Sequence = '*' ! a wild card for a sequence of characters !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tChar :: C ! FLOW IF (. NOT . ASSOCIATED ( X )) RETURN IF ( D > LEN ( Pattern , KIND = kIndex )) THEN IF ( ALLOCATED ( X % Value )) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) RETURN END IF C = Pattern ( D : D ) IF (( C == WildCard_Single ). OR .( C == WildCard_Sequence ). OR . LLT ( C , X % C )) THEN CALL GatherWildcardKeys ( X % Left , Prefix , Pattern , D , KeyQ ) END IF IF (( C == WildCard_Single ). OR .( C == WildCard_Sequence ). OR .( C == X % C )) THEN IF ( C == WildCard_Sequence ) THEN CALL GatherWildcardKeys ( X , Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % Append ( X % C ) CALL GatherWildcardKeys ( X % Middle , Prefix , Pattern , D , KeyQ ) CALL Prefix % DelLastChar () ELSE IF (( D == LEN ( Pattern , KIND = kIndex )). AND .( ALLOCATED ( X % Value ))) THEN CALL Prefix % Append ( X % C ) CALL KeyQ % EnQueue ( Prefix % ToCharAlloc ()) CALL Prefix % DelLastChar () ELSEIF ( D < LEN ( Pattern , KIND = kIndex )) THEN CALL Prefix % Append ( X % C ) CALL GatherWildcardKeys ( X % Middle , Prefix , Pattern , D + 1_kIndex , KeyQ ) CALL Prefix % DelLastChar () END IF END IF END IF IF (( C == WildCard_Single ). OR .( C == WildCard_Sequence ). OR . LGT ( C , X % C )) THEN CALL GatherWildcardKeys ( X % Left , Prefix , Pattern , D , KeyQ ) END IF RETURN END SUBROUTINE GatherWildcardKeys !****************************************************************************** SUBROUTINE TernaryTrie_WildcardKeys_CHCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( StringBuilder ) :: StrBld ! FLOW CALL StrBld % CreateEmpty () CALL GatherWildcardKeys ( Table % Root , StrBld , Pattern , 1_kIndex , KeyQ ) RETURN END SUBROUTINE TernaryTrie_WildcardKeys_CHCH !****************************************************************************** SUBROUTINE TernaryTrie_WildcardKeys_CHVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueString ) :: KeyQ ! FLOW CALL Table % GetWildcardKeys ( Pattern , KeyQ ) CALL KeyQueue2Array ( KeyQ , Keys ) RETURN END SUBROUTINE TernaryTrie_WildcardKeys_CHVL !****************************************************************************** SUBROUTINE TernaryTrie_WildcardKeys_VLCH ( Table , Pattern , KeyQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a queue of all the keys in the symbol table that match the !  specified pattern.  Return an empty queue if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( QueueString ), INTENT ( OUT ) :: KeyQ !! queue of keys that match the specified pattern !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , KeyQ ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_WildcardKeys_VLCH !****************************************************************************** SUBROUTINE TernaryTrie_WildcardKeys_VLVL ( Table , Pattern , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return an array of all the keys in the symbol table that match the !  specified pattern.  Return an unallocated array if no such key(s) found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Pattern !! a pattern TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of all keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharLen (:), POINTER :: StrPtr ! FLOW StrPtr => PtrToStr ( Pattern ) IF ( ASSOCIATED ( StrPtr )) THEN CALL Table % GetWildcardKeys ( StrPtr , Keys ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_WildcardKeys_VLVL !****************************************************************************** FUNCTION LengthOfLongestPrefix ( Y , Query ) RESULT ( Length ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the length of the longest key in the subtrie rooted at the *X* node !  that is a prefix of the specified query, assuming that the first *D* character !  match and a prefix match of the given length (-1 if no such match) has already !  been found. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TrieNode ), POINTER , INTENT ( IN ) :: Y !! node representing the root tCharStar , INTENT ( IN ) :: Query !! string query tIndex :: Length !! length of the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TrieNode ), POINTER :: X tIndex :: I tChar :: C ! FLOW X => Y I = 1_kIndex Length = - 1_kIndex ! use iterative algorithm DO WHILE (( ASSOCIATED ( X )). AND .( I <= LEN ( Query ))) C = Query ( I : I ) IF ( LLT ( C , X % C )) THEN X => X % Left ELSEIF ( LGT ( C , X % C )) THEN X => X % Right ELSE I = I + 1_kIndex IF ( ALLOCATED ( X % Value )) Length = I X => X % Middle END IF END DO NULLIFY ( X ) RETURN END FUNCTION LengthOfLongestPrefix !****************************************************************************** SUBROUTINE TernaryTrie_LongestPrefixOf_ChrStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table tCharStar , INTENT ( IN ) :: Query !! a query tCharAlloc , INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length ! FLOW IF ( LEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_LongestPrefixOf_ChrStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF Length = LengthOfLongestPrefix ( Table % Root , Query ) IF ( Length /= - 1_kIndex ) Prefix = Query ( 1 : Length ) RETURN END SUBROUTINE TernaryTrie_LongestPrefixOf_ChrStr !****************************************************************************** SUBROUTINE TernaryTrie_LongestPrefixOf_FvlStr ( Table , Query , Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the string in the symbol table that is the longest prefix of the !  specified query.  Return an unallocated string if no such string found. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( INOUT ) :: Table !! symbol table TYPE ( FvlStr ), INTENT ( IN ) :: Query !! a query TYPE ( FvlStr ), INTENT ( OUT ) :: Prefix !! the longest prefix of the query !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Length tCharLen (:), POINTER :: StrPtr ! FLOW IF ( GETLEN ( Query ) == 0 ) THEN CALL Handle_ErrLevel ( 'TernaryTrie_LongestPrefixOf_FvlStr' , ModName , ErrSevere , & 'A query string with length of zero is NOT allowed.' ) RETURN END IF StrPtr => PtrToStr ( Query ) IF ( ASSOCIATED ( StrPtr )) THEN Length = LengthOfLongestPrefix ( Table % Root , StrPtr ) IF ( Length /= - 1_kIndex ) Prefix = StrPtr ( 1 : Length ) END IF NULLIFY ( StrPtr ) RETURN END SUBROUTINE TernaryTrie_LongestPrefixOf_FvlStr !****************************************************************************** FUNCTION TernaryTrie_IsEmpty ( Table ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the table is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( IN ) :: Table !! symbol table tLogical :: Flag !! true if the table is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Table % N == 0_kIndex ) RETURN END FUNCTION TernaryTrie_IsEmpty !****************************************************************************** FUNCTION TernaryTrie_GetSize ( Table ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size (number of keys stored) of the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TernaryTrie ), INTENT ( IN ) :: Table !! symbol table tIndex :: Size !! size of the table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Table % N RETURN END FUNCTION TernaryTrie_GetSize !****************************************************************************** SUBROUTINE KeyQueue2Array ( KeyQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert a queue of character-string keys to an array of keys of !  the FvlStr type. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueString ), INTENT ( INOUT ) :: KeyQ !! queue of keys TYPE ( FvlStr ), ALLOCATABLE , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Success tIndex :: I tCharAlloc :: Key ! FLOW IF (. NOT . KeyQ % IsEmpty ()) THEN ALLOCATE ( Keys ( KeyQ % GetSize ())) I = 1_kIndex DO WHILE (. NOT . KeyQ % IsEmpty ()) Success = KeyQ % Dequeue ( Key ) IF ( Success ) THEN Keys ( I ) = Key I = I + 1_kIndex END IF END DO END IF RETURN END SUBROUTINE KeyQueue2Array !****************************************************************************** END MODULE MClass_TernaryTrie !******************************************************************************","tags":"","loc":"sourcefile\\mclass_ternarytrie.f90.html"},{"title":"MClass_NFAState.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_NFAState !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *NFAState* type and its related routines. !   The *NFAState* type is a derived type representing a ... <br> !** USE STATEMENTS: USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_Common USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MClass_Object , ONLY : Object USE MBase_OptimalHash32 , ONLY : HashFuncOpt => Murmur3_Hash32_Opt USE MClass_IntrusiveHashList IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: NFAState PUBLIC :: NFAState_New PUBLIC :: NFAState_Free PUBLIC :: HashMapNode PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     tHash               tIndex !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_NFAState' tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS TYPE , EXTENDS ( HashListNode ) :: HashMapNode PRIVATE tChar :: Chr TYPE ( IntrusiveHashList ) :: Set ! use NFAState as node CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => HashMapNode_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashMapNode_IsEqualTo !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => HashMapNode_ToString ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => HashMapNode_IsKeyEqual PROCEDURE :: MemFree => HashMapNode_FreeMemory PROCEDURE :: HashCode => HashMapNode_HashCode ! specific PROCEDURE :: Construct => HashMapNode_Construct PROCEDURE :: GetSet => HashMapNode_GetSet PROCEDURE :: GetChar => HashMapNode_GetChar END TYPE HashMapNode !> The *NFAState* type is a node type... TYPE , EXTENDS ( HashListNode ) :: NFAState PRIVATE TYPE ( IntrusiveHashList ) :: DirectTable ! use NFAState as node TYPE ( IntrusiveHashList ) :: TransitionMap ! use HashMapNode as node tSInt32 :: ID CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyAssign* is a procedure deferred by the *Object* type. <br> !  Use the assignment expression in place of the *CopyAssign* method !  to make a copy of an *Object* object. PROCEDURE :: Copy => NFAState_Copy !> *IsEqualTo* is a procedure deferred by the *Object* type. <br> !  **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => NFAState_IsEqualTo !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE :: ToString => NFAState_ToString ! --------------------------------------------------------------------- PROCEDURE :: IsKeyEqual => NFAState_IsKeyEqual PROCEDURE :: MemFree => NFAState_FreeMemory PROCEDURE :: HashCode => NFAState_HashCode ! specific PROCEDURE :: Construct => NFAState_Construct PROCEDURE :: TransitionRule => NFAState_TransitionRule PROCEDURE :: DirectRule => NFAState_DirectRule PROCEDURE :: GetTransitionMap => NFAState_GetTransitionMap PROCEDURE :: GetDirectTable => NFAState_GetDirectTable PROCEDURE :: GetID => NFAState_GetID END TYPE NFAState TYPE NFAStateMemHandler tIndex :: StateID = 0_kIndex TYPE ( NFAState ), ALLOCATABLE :: State (:) tIndex :: NodeID = 0_kIndex TYPE ( HashMapNode ), ALLOCATABLE :: Node (:) END TYPE NFAStateMemHandler !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: TYPE ( NFAStateMemHandler ), TARGET :: NFAMemManger CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE NFAState_New ( State , ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( NFAState ), POINTER , INTENT ( INOUT ) :: State tSInt32 , INTENT ( IN ) :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( NFAMemManger % State )) THEN ! need allocation ALLOCATE ( NFAMemManger % State ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN NFAMemManger % StateID = 0_kIndex CALL Handle_ErrAlloc ( 'NFAState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NFAMemManger % StateID = 1_kIndex ELSEIF ( NFAMemManger % StateID == SIZE ( NFAMemManger % State , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( NFAState ), ALLOCATABLE :: NewState (:) ALLOCATE ( NewState ( SIZE ( NFAMemManger % State ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'NFAState_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewState ( 1 : SIZE ( NFAMemManger % State )) = NFAMemManger % State CALL MOVE_ALLOC ( NewState , NFAMemManger % State ) NFAMemManger % StateID = NFAMemManger % StateID + 1 END BLOCK END IF ! set pointer to the storage State => NFAMemManger % State ( NFAMemManger % StateID ) CALL State % Construct ( ID ) RETURN END SUBROUTINE NFAState_New !****************************************************************************** SUBROUTINE HashMapNode_New ( Node , Chr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To allocate the state and specify its ID. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashMapNode ), POINTER , INTENT ( INOUT ) :: Node tChar , INTENT ( IN ) :: Chr !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF (. NOT . ALLOCATED ( NFAMemManger % Node )) THEN ! need allocation ALLOCATE ( NFAMemManger % Node ( 64_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN NFAMemManger % NodeID = 0_kIndex CALL Handle_ErrAlloc ( 'HashMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NFAMemManger % NodeID = 1_kIndex ELSEIF ( NFAMemManger % NodeID == SIZE ( NFAMemManger % Node , KIND = kIndex )) THEN ! need re-allocation BLOCK TYPE ( HashMapNode ), ALLOCATABLE :: NewNode (:) ALLOCATE ( NewNode ( SIZE ( NFAMemManger % Node ) * 2_kIndex ), STAT = AllocStat , ERRMSG = AllocMsg ) IF ( AllocStat /= 0 ) THEN CALL Handle_ErrAlloc ( 'HashMapNode_Allocate' , ModName , AllocMsg , AllocStat ) RETURN END IF NewNode ( 1 : SIZE ( NFAMemManger % Node )) = NFAMemManger % Node CALL MOVE_ALLOC ( NewNode , NFAMemManger % Node ) NFAMemManger % NodeID = NFAMemManger % NodeID + 1 END BLOCK END IF ! set pointer to the storage Node => NFAMemManger % Node ( NFAMemManger % NodeID ) CALL Node % Construct ( Chr ) RETURN END SUBROUTINE HashMapNode_New !****************************************************************************** SUBROUTINE NFAState_Free () !** PURPOSE OF THIS SUBROUTINE: !&#94; To free all the nodes linked to the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: ! na !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( NFAMemManger % Node )) THEN DO I = 1_kIndex , SIZE ( NFAMemManger % Node , KIND = kIndex ) CALL NFAMemManger % Node ( I )% MemFree () END DO DEALLOCATE ( NFAMemManger % Node ) END IF IF ( ALLOCATED ( NFAMemManger % State )) THEN DO I = 1_kIndex , SIZE ( NFAMemManger % State , KIND = kIndex ) CALL NFAMemManger % State ( I )% MemFree () END DO DEALLOCATE ( NFAMemManger % State ) END IF NFAMemManger % StateID = 0_kIndex NFAMemManger % NodeID = 0_kIndex RETURN END SUBROUTINE NFAState_Free !****************************************************************************** SUBROUTINE NFAState_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the NFAState object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( NFAState ) DstObj % ID = SrcObj % ID CALL SrcObj % DirectTable % CloneTo ( DstObj % DirectTable ) CALL SrcObj % TransitionMap % CloneTo ( DstObj % TransitionMap ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'NFAState_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE NFAState_Copy !****************************************************************************** FUNCTION NFAState_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( NFAState ) Flag = ( LhsObj % ID /= RhsObj % ID ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION NFAState_IsEqualTo !****************************************************************************** FUNCTION NFAState_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = 'NFAState: {ID: ' // ToChar ( Obj % ID ) // '}' RETURN END FUNCTION NFAState_ToString !****************************************************************************** FUNCTION NFAState_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( NFAState ) Flag = ( LhsObj % ID == RhsObj % ID ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION NFAState_IsKeyEqual !****************************************************************************** SUBROUTINE NFAState_FreeMemory ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % DirectTable % Destruct () CALL Obj % TransitionMap % Destruct () RETURN END SUBROUTINE NFAState_FreeMemory !****************************************************************************** FUNCTION NFAState_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize ! FLOW KeySize = C_SIZEOF ( Obj % ID ) Code = HashFuncOpt ( Obj % ID , KeySize , 3131133 ) RETURN END FUNCTION NFAState_HashCode !****************************************************************************** SUBROUTINE NFAState_Construct ( State , ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the NFAState object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( OUT ) :: State tSInt32 , INTENT ( IN ) :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL State % DirectTable % Construct () CALL State % TransitionMap % Construct () State % ID = ID RETURN END SUBROUTINE NFAState_Construct !****************************************************************************** SUBROUTINE NFAState_TransitionRule ( CurrState , Chr , State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform transition rule. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( INOUT ) :: CurrState tChar , INTENT ( IN ) :: Chr TYPE ( NFAState ), POINTER , INTENT ( INOUT ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: StoredNode TYPE ( HashMapNode ) :: KeyNode TYPE ( HashMapNode ), POINTER :: CurNode TYPE ( IntrusiveHashList ), POINTER :: StateSet tLogical :: Found ! FLOW KeyNode % Chr = Chr Found = CurrState % TransitionMap % FindNode ( KeyNode , StoredNode ) IF ( Found . AND . ASSOCIATED ( StoredNode )) THEN SELECT TYPE ( StoredNode ) TYPE IS ( HashMapNode ) StateSet => StoredNode % Set END SELECT ELSE CALL HashMapNode_New ( CurNode , Chr ) StateSet => CurNode % Set CALL CurrState % TransitionMap % Insert ( CurNode ) END IF CALL StateSet % Insert ( State ) NULLIFY ( StoredNode , CurNode , StateSet ) RETURN END SUBROUTINE NFAState_TransitionRule !****************************************************************************** SUBROUTINE NFAState_DirectRule ( CurrState , State ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform direct rule. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( INOUT ) :: CurrState TYPE ( NFAState ), POINTER , INTENT ( INOUT ) :: State !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL CurrState % DirectTable % Insert ( State ) RETURN END SUBROUTINE NFAState_DirectRule !****************************************************************************** FUNCTION NFAState_GetID ( State ) RESULT ( ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get ID of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), INTENT ( IN ) :: State !! object tSInt32 :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ID = State % ID RETURN END FUNCTION NFAState_GetID !****************************************************************************** FUNCTION NFAState_GetDirectTable ( State ) RESULT ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the direct table of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), TARGET , INTENT ( IN ) :: State !! object TYPE ( IntrusiveHashList ), POINTER :: Table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Table => State % DirectTable RETURN END FUNCTION NFAState_GetDirectTable !****************************************************************************** FUNCTION NFAState_GetTransitionMap ( State ) RESULT ( TransMap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the transition map of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( NFAState ), TARGET , INTENT ( IN ) :: State !! object TYPE ( IntrusiveHashList ), POINTER :: TransMap !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW TransMap => State % TransitionMap RETURN END FUNCTION NFAState_GetTransitionMap !****************************************************************************** SUBROUTINE HashMapNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the HashMapNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( HashMapNode ) DstObj % Chr = SrcObj % Chr CALL SrcObj % Set % CloneTo ( DstObj % Set ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'HashMapNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE HashMapNode_Copy !****************************************************************************** FUNCTION HashMapNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashMapNode ) Flag = ( LhsObj % Chr == RhsObj % Chr ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashMapNode_IsEqualTo !****************************************************************************** FUNCTION HashMapNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = 'HashMapNode: {Chr: ' // Obj % Chr // '}' RETURN END FUNCTION HashMapNode_ToString !****************************************************************************** FUNCTION HashMapNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether *key* components of the two specified objects are equal to one another or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashMapNode ) Flag = ( LhsObj % Chr == RhsObj % Chr ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashMapNode_IsKeyEqual !****************************************************************************** SUBROUTINE HashMapNode_FreeMemory ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free storage/memory of an object with pointer and/or allocatable components. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % Set % Destruct () RETURN END SUBROUTINE HashMapNode_FreeMemory !****************************************************************************** FUNCTION HashMapNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( IN ) :: Obj !! object tHash :: Code !! hash code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: KeySize ! FLOW KeySize = C_SIZEOF ( Obj % Chr ) Code = HashFuncOpt ( Obj % Chr , KeySize , 3131133 ) RETURN END FUNCTION HashMapNode_HashCode !****************************************************************************** SUBROUTINE HashMapNode_Construct ( State , Chr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the HashMapNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( OUT ) :: State tChar , INTENT ( IN ) :: Chr !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL State % Set % Construct () State % Chr = Chr RETURN END SUBROUTINE HashMapNode_Construct !****************************************************************************** FUNCTION HashMapNode_GetSet ( Node ) RESULT ( Set ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), TARGET , INTENT ( IN ) :: Node TYPE ( IntrusiveHashList ), POINTER :: Set !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Set => Node % Set RETURN END FUNCTION HashMapNode_GetSet !****************************************************************************** FUNCTION HashMapNode_GetChar ( Node ) RESULT ( Chr ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code of the *key* component of the specified object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMapNode ), INTENT ( IN ) :: Node tChar :: Chr !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Chr = Node % Chr RETURN END FUNCTION HashMapNode_GetChar !****************************************************************************** END MODULE MClass_NFAState !******************************************************************************","tags":"","loc":"sourcefile\\mclass_nfastate.f90.html"},{"title":"MClass_SyntaxTree.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_SyntaxTree !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *SyntaxTree* type and its related routines. !   The *SyntaxTree* type is a derived type representing a ... <br> !** USE STATEMENTS: USE MBase_Common USE MBase_CharUtil USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_DoublyLinkedLists , ONLY : ListInteger => ListInteger4B USE MBase_ChrStr , ONLY : ParseInteger USE MClass_IntrusiveLinkedLists USE MClass_StringBuilder USE MClass_SyntaxNode IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: SyntaxTree PUBLIC :: EncodingLen PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_SyntaxTree' tSInt32 , PARAMETER :: MsgLen = 128 #ifdef  __INTEL_COMPILER tSInt32 , PARAMETER :: SetAlphaNum ( * ) = [( IACHAR ( SET_ALPHANUM ( Idx : Idx )), & tSInt32 :: Idx = 1 , LEN ( SET_ALPHANUM ))] tSInt32 , PARAMETER :: SetWhiteSpace ( * ) = [( IACHAR ( SET_WHITESPACES ( Idx : Idx )), & tSInt32 :: Idx = 1 , LEN ( SET_WHITESPACES ))] tSInt32 , PARAMETER :: SetDigit ( * ) = [( IACHAR ( SET_DIGITS ( Idx : Idx )), & tSInt32 :: Idx = 1 , LEN ( SET_DIGITS ))] #else tSInt32 :: Idx tSInt32 , PARAMETER :: SetAlphaNum ( * ) = [( IACHAR ( SET_ALPHANUM ( Idx : Idx )), & Idx = 1 , LEN ( SET_ALPHANUM ))] tSInt32 , PARAMETER :: SetWhiteSpace ( * ) = [( IACHAR ( SET_WHITESPACES ( Idx : Idx )), & Idx = 1 , LEN ( SET_WHITESPACES ))] tSInt32 , PARAMETER :: SetDigit ( * ) = [( IACHAR ( SET_DIGITS ( Idx : Idx )), & Idx = 1 , LEN ( SET_DIGITS ))] #endif tSInt32 , PARAMETER :: SetNewLine ( 1 ) = [ IACHAR ( CHR_NEWLINE )] tSInt32 , PARAMETER :: SetSlashLowerW ( * ) = [ SetAlphaNum , 95 ] tSInt32 , PARAMETER :: SetSlashLowerS ( * ) = SetWhiteSpace tSInt32 , PARAMETER :: SetSlashLowerD ( * ) = SetDigit tSInt32 , PARAMETER :: EncodingLen = 128 tCharParam :: SET_WORDS = SET_ALPHANUM // CHR_UNDERSCORE !** DERIVED TYPE DEFINITIONS !> The *OperatingStack* type is a stack type... TYPE :: OperatingStack TYPE ( IntrusiveLinearList ) :: Stack CONTAINS PROCEDURE :: Visit => OperatingStack_Visit PROCEDURE :: Pop => OperatingStack_Pop PROCEDURE :: IsEmpty => OperatingStack_IsEmpty END TYPE OperatingStack !> The *ShuntingStack* type is a stack type... using Shunting-Yard algorithm. TYPE :: ShuntingStack TYPE ( IntrusiveLinearList ) :: FinalStack TYPE ( IntrusiveLinearList ) :: BranchStack CONTAINS PROCEDURE :: Visit => ShuntingStack_Visit PROCEDURE :: Finish => ShuntingStack_Finish END TYPE ShuntingStack !> The *SyntaxTree* type is a tree type... TYPE :: SyntaxTree PRIVATE tCharAlloc :: Regex tLogical :: ItemTerminated = . FALSE . TYPE ( IntrusiveLinearList ) :: List TYPE ( IntrusiveLinearList ) :: Stack TYPE ( SyntaxNode ), POINTER :: Root => NULL () CONTAINS PRIVATE PROCEDURE , PUBLIC :: Construct => SyntaxTree_Construct PROCEDURE , PUBLIC :: Destruct => SyntaxTree_Destruct PROCEDURE , PUBLIC :: GetRoot => SyntaxTree_GetRoot PROCEDURE :: Build => SyntaxTree_Build PROCEDURE :: Shunt => SyntaxTree_Shunt PROCEDURE :: Normalize => SyntaxTree_Normalize PROCEDURE :: PerformMany => SyntaxTree_PerformMany PROCEDURE :: TryConcatenation => SyntaxTree_TryConcatenation END TYPE SyntaxTree !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE OperatingStack_Visit ( OpStack , Node ) !** PURPOSE OF THIS SUBROUTINE: !! To perform stack operation(s) on the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( OperatingStack ), INTENT ( INOUT ) :: OpStack TYPE ( SyntaxNode ), INTENT ( INOUT ) :: Node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( Node % Type ) CASE ( BranchNode_Or , BranchNode_Many , BranchNode_Concat , BranchNode_LBracket , BranchNode_RBracket ) BLOCK tLogical :: Success CLASS ( DoublyLinkedNode ), POINTER :: Right , Left Success = OpStack % Stack % Pop ( Right ) Success = OpStack % Stack % Pop ( Left ) SELECT CASE ( Node % Type ) CASE ( BranchNode_Or , BranchNode_Many , BranchNode_Concat ) IF ( ASSOCIATED ( Right ). AND . ASSOCIATED ( Left )) THEN CALL Node % Operate ( Left , Right ) END IF END SELECT CALL OpStack % Stack % Push ( Node ) END BLOCK CASE ( LeafNode_Null , LeafNode_Char , LeafNode_Closure ) CALL OpStack % Stack % Push ( Node ) END SELECT RETURN END SUBROUTINE OperatingStack_Visit !****************************************************************************** FUNCTION OperatingStack_Pop ( OpStack , NodeOut ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !! To perform stack operation(s) on the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( OperatingStack ), INTENT ( INOUT ) :: OpStack TYPE ( SyntaxNode ), POINTER , INTENT ( INOUT ) :: NodeOut tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: TopNode ! FLOW Success = OpStack % Stack % Pop ( TopNode ) SELECT TYPE ( TopNode ) TYPE IS ( SyntaxNode ) NodeOut => TopNode END SELECT NULLIFY ( TopNode ) CALL OpStack % Stack % Clear ( DelinkOnly = TrueVal ) RETURN END FUNCTION OperatingStack_Pop !****************************************************************************** FUNCTION OperatingStack_IsEmpty ( OpStack ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !! To perform stack operation(s) on the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( OperatingStack ), INTENT ( IN ) :: OpStack tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IsEmpty = OpStack % Stack % IsEmpty () RETURN END FUNCTION OperatingStack_IsEmpty !****************************************************************************** SUBROUTINE ShuntingStack_Visit ( StStack , InNode ) !** PURPOSE OF THIS SUBROUTINE: !! To perform stack operation(s) on the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShuntingStack ), INTENT ( INOUT ) :: StStack TYPE ( SyntaxNode ), INTENT ( INOUT ) :: InNode !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT CASE ( InNode % Type ) CASE ( BranchNode_LBracket ) CALL StStack % BranchStack % Push ( InNode ) CASE ( BranchNode_RBracket ) BLOCK tLogical :: Success CLASS ( DoublyLinkedNode ), POINTER :: TopNode TYPE ( SyntaxNode ), POINTER :: CurrNode Success = StStack % BranchStack % Pop ( TopNode ) IF ( Success ) THEN SELECT TYPE ( TopNode ) TYPE IS ( SyntaxNode ) CurrNode => TopNode END SELECT DO WHILE ( CurrNode % Type /= BranchNode_LBracket ) CALL StStack % FinalStack % Push ( CurrNode ) Success = StStack % BranchStack % Pop ( TopNode ) SELECT TYPE ( TopNode ) TYPE IS ( SyntaxNode ) CurrNode => TopNode END SELECT END DO END IF NULLIFY ( TopNode , CurrNode ) END BLOCK CASE ( BranchNode_Or , BranchNode_Many , BranchNode_Concat ) BLOCK tLogical :: Success CLASS ( DoublyLinkedNode ), POINTER :: TopNode DO WHILE (. NOT . StStack % BranchStack % IsEmpty ()) TopNode => StStack % BranchStack % PeekTop () SELECT TYPE ( TopNode ) TYPE IS ( SyntaxNode ) IF ( InNode % ID > TopNode % ID ) EXIT END SELECT Success = StStack % BranchStack % Pop ( TopNode ) CALL StStack % FinalStack % Push ( TopNode ) END DO CALL StStack % FinalStack % Push ( InNode ) NULLIFY ( TopNode ) END BLOCK CASE ( LeafNode_Null , LeafNode_Char , LeafNode_Closure ) CALL StStack % FinalStack % Push ( InNode ) END SELECT RETURN END SUBROUTINE ShuntingStack_Visit !****************************************************************************** SUBROUTINE ShuntingStack_Finish ( StStack , ReversedStack ) !** PURPOSE OF THIS SUBROUTINE: !! To return a reversed stack of syntax nodes. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ShuntingStack ), INTENT ( INOUT ) :: StStack TYPE ( IntrusiveLinearList ), INTENT ( OUT ) :: ReversedStack !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Success CLASS ( DoublyLinkedNode ), POINTER :: TopNode ! FLOW DO WHILE (. NOT . StStack % BranchStack % IsEmpty ()) Success = StStack % BranchStack % Pop ( TopNode ) CALL StStack % FinalStack % Push ( TopNode ) END DO DO WHILE (. NOT . StStack % FinalStack % IsEmpty ()) Success = StStack % FinalStack % Pop ( TopNode ) CALL ReversedStack % Push ( TopNode ) END DO RETURN END SUBROUTINE ShuntingStack_Finish !****************************************************************************** SUBROUTINE BookToSet ( Book , Cardinality , Set ) !** PURPOSE OF THIS SUBROUTINE: !! To return a set according to the specified book. !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , INTENT ( IN ) :: Book ( 0 : EncodingLen - 1 ) tSInt32 , INTENT ( IN ) :: Cardinality tSInt32 , INTENT ( OUT ) :: Set ( 0 : Cardinality - 1 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: I , J ! FLOW I = 0 DO J = 0 , EncodingLen - 1 IF ( Book ( J )) THEN Set ( I ) = J I = I + 1 END IF END DO RETURN END SUBROUTINE BookToSet !****************************************************************************** SUBROUTINE Set_Complementary ( Set , Comp ) !** PURPOSE OF THIS SUBROUTINE: !! To return a complementary set of the specified set. !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Set ( 0 :) tSInt32 , INTENT ( OUT ) :: Comp ( 0 : EncodingLen - SIZE ( Set ) - 1 ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Book ( 0 : EncodingLen - 1 ) ! flag for complementary characters tSInt32 :: Cardinality ! number of unique characters tSInt32 :: I , J ! FLOW ! initialize Book = TrueVal Cardinality = EncodingLen ! set book for complementary set DO I = 0 , SIZE ( Set ) - 1 J = Set ( I ) IF ( Book ( J )) THEN Cardinality = Cardinality - 1 Book ( J ) = FalseVal END IF END DO ! get complementary set CALL BookToSet ( Book , Cardinality , Comp ) RETURN END SUBROUTINE Set_Complementary !****************************************************************************** SUBROUTINE Set_Minimum ( Set , MinSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a minimum set of the specified set. ! For example, [e, a, d, f, f, c, c, k, \\s] -> {a, c, d, e, f, k, \\0, \\t}. !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Set ( 0 :) tSInt32 , ALLOCATABLE , INTENT ( OUT ) :: MinSet (:) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Book ( 0 : EncodingLen - 1 ) ! flag for minimum-set characters tSInt32 :: Cardinality ! number of unique characters tSInt32 :: I , J ! FLOW ! initialize Book = FalseVal Cardinality = 0 ! set book for minimum set DO I = 0 , SIZE ( Set ) - 1 J = Set ( I ) IF (. NOT . Book ( J )) THEN Cardinality = Cardinality + 1 Book ( J ) = TrueVal END IF END DO ! get minimum set CALL MemAlloc ( MinSet , ToIndex ( Cardinality ), StartID = 0_kIndex ) CALL BookToSet ( Book , Cardinality , MinSet ) RETURN END SUBROUTINE Set_Minimum !****************************************************************************** SUBROUTINE InterpretToken ( Token , ChrSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a character set according to the specified token. !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , INTENT ( IN ) :: Token tSInt32 , ALLOCATABLE , INTENT ( OUT ) :: ChrSet (:) !** SUBROUTINE PARAMETER DECLARATIONS: tChar , PARAMETER :: ESCAPE_T = 't' tChar , PARAMETER :: ESCAPE_N = 'n' tChar , PARAMETER :: ESCAPE_R = 'r' tChar , PARAMETER :: ESCAPE_D = 'd' tChar , PARAMETER :: ESCAPE_W = 'w' tChar , PARAMETER :: ESCAPE_S = 's' tChar , PARAMETER :: ESCAPE_D_CAPITAL = 'D' tChar , PARAMETER :: ESCAPE_W_CAPITAL = 'W' tChar , PARAMETER :: ESCAPE_S_CAPITAL = 'S' !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( LEN ( Token ) == 1 ) THEN IF ( Token ( 1 : 1 ) == CHR_PERIOD ) THEN ! a character set that matches any single character except the new line character BLOCK tSInt32 :: SetDot ( EncodingLen - 1 ) CALL Set_Complementary ( SetNewLine , SetDot ) CALL GetTokenSet ( SetDot , ChrSet ) END BLOCK ELSE ! a character set that matches the specified character CALL MemAlloc ( ChrSet , 1_kIndex , StartID = 0_kIndex ) ChrSet ( 0 ) = IACHAR ( Token ( 1 : 1 )) END IF ELSEIF (( LEN ( Token ) /= 2 ). OR .( Token ( 1 : 1 ) /= CHR_BACKSLASH )) THEN CALL Handle_ErrLevel ( 'InterpretToken' , ModName , ErrSevere , 'Unrecognized token: ' // Token ) ELSE SELECT CASE ( Token ( 2 : 2 )) CASE ( ESCAPE_N ) ! a character set that matches the new line character CALL MemAlloc ( ChrSet , 1_kIndex , StartID = 0_kIndex ) ChrSet ( 0 ) = IACHAR ( CHR_NEWLINE ) CASE ( ESCAPE_R ) ! a character set that matches the carriage return character CALL MemAlloc ( ChrSet , 1_kIndex , StartID = 0_kIndex ) ChrSet ( 0 ) = IACHAR ( CHR_CARRIAGE_RETURN ) CASE ( ESCAPE_T ) ! a character set that matches the (horizontal) tab character CALL MemAlloc ( ChrSet , 1_kIndex , StartID = 0_kIndex ) ChrSet ( 0 ) = IACHAR ( CHR_TAB ) CASE ( ESCAPE_W ) ! a character set that matches the word characters CALL GetTokenSet ( SetSlashLowerW , ChrSet ) CASE ( ESCAPE_W_CAPITAL ) ! a character set that matches the non-word characters BLOCK tSInt32 :: SetSlashUpperW ( EncodingLen - SIZE ( SetSlashLowerW )) CALL Set_Complementary ( SetSlashLowerW , SetSlashUpperW ) CALL GetTokenSet ( SetSlashUpperW , ChrSet ) END BLOCK CASE ( ESCAPE_S ) ! a character set that matches the white-space characters CALL GetTokenSet ( SetSlashLowerS , ChrSet ) CASE ( ESCAPE_S_CAPITAL ) ! a character set that matches the non-white-space characters BLOCK tSInt32 :: SetSlashUpperS ( EncodingLen - SIZE ( SetSlashLowerS )) CALL Set_Complementary ( SetSlashLowerS , SetSlashUpperS ) CALL GetTokenSet ( SetSlashUpperS , ChrSet ) END BLOCK CASE ( ESCAPE_D ) ! a character set that matches the digit characters CALL GetTokenSet ( SetSlashLowerD , ChrSet ) CASE ( ESCAPE_D_CAPITAL ) ! a character set that matches the non-digit characters BLOCK tSInt32 :: SetSlashUpperD ( EncodingLen - SIZE ( SetSlashLowerD )) CALL Set_Complementary ( SetSlashLowerD , SetSlashUpperD ) CALL GetTokenSet ( SetSlashUpperD , ChrSet ) END BLOCK CASE DEFAULT ! a character set that matches the specified character CALL MemAlloc ( ChrSet , 1_kIndex , StartID = 0_kIndex ) ChrSet ( 0 ) = IACHAR ( Token ( 2 : 2 )) END SELECT END IF RETURN END SUBROUTINE InterpretToken !****************************************************************************** SUBROUTINE GetTokenSet ( Token , ChrSet ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return a character set according to the specified token. !** SUBROUTINE ARGUMENT DECLARATIONS: tSInt32 , INTENT ( IN ) :: Token ( 0 :) tSInt32 , ALLOCATABLE , INTENT ( OUT ) :: ChrSet (:) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL MemAlloc ( ChrSet , SIZE ( Token , KIND = kIndex ), StartID = 0_kIndex ) ChrSet ( 0 :) = Token ( 0 :) RETURN END SUBROUTINE GetTokenSet !****************************************************************************** SUBROUTINE List_AddNewNode ( List , NodeType ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the concatenation node if applicable. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: List tSInt32 , INTENT ( IN ) :: NodeType !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxNode ), POINTER :: Node ! FLOW CALL SyntaxNode_New ( Node , NodeType ) CALL List % AddLast ( Node ) NULLIFY ( Node ) RETURN END SUBROUTINE List_AddNewNode !****************************************************************************** SUBROUTINE List_AddNewCharNode ( List , CharCode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the concatenation node if applicable. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: List tSInt32 , INTENT ( IN ) :: CharCode !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxNode ), POINTER :: Node ! FLOW CALL SyntaxNode_New ( Node , LeafNode_Char ) CALL Node % SetChar ( ACHAR ( CharCode )) CALL List % AddLast ( Node ) NULLIFY ( Node ) RETURN END SUBROUTINE List_AddNewCharNode !****************************************************************************** SUBROUTINE SyntaxTree_PerformMany ( Tree , Least , Most ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To look back for a completed term. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree tSInt32 , INTENT ( IN ) :: Least , Most !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SyntaxNode ), POINTER :: Node ! FLOW IF (. NOT .(( Least == 1 ). AND .( Most == 1 ))) THEN IF (( Least == 0 ). AND .( Most == - 1 )) THEN CALL List_AddNewNode ( Tree % List , BranchNode_Many ) CALL List_AddNewNode ( Tree % List , LeafNode_Null ) ELSE BLOCK TYPE ( IntrusiveLinearList ) :: Sample CLASS ( DoublyLinkedNode ), POINTER :: LastNode tLogical :: Success tSInt32 :: Stack tIndex :: I , J ! check whether the last node is the right bracket one LastNode => Tree % List % GetTail () SELECT TYPE ( LastNode ) TYPE IS ( SyntaxNode ) Node => LastNode END SELECT NULLIFY ( LastNode ) IF ( ASSOCIATED ( Node )) THEN CALL Sample % AddLast ( Node ) Success = Tree % List % RemoveLast () IF ( Node % Type == BranchNode_RBracket ) THEN Stack = 1 DO I = Tree % List % GetSize (), 1 , - 1 ! note: the RemoveAt method uses one-based index. Success = Tree % List % RemoveAt ( I , LastNode ) SELECT TYPE ( LastNode ) TYPE IS ( SyntaxNode ) Node => LastNode END SELECT NULLIFY ( LastNode ) IF ( Node % Type == BranchNode_RBracket ) THEN Stack = Stack + 1 ELSEIF ( Node % Type == BranchNode_LBracket ) THEN Stack = Stack - 1 END IF CALL Sample % AddFirst ( Node ) IF ( Stack == 0 ) EXIT END DO END IF END IF IF ( Most == - 1 ) THEN DO I = 0 , Least - 1 CALL List_AddAllNodes ( Tree % List , Sample ) CALL List_AddNewNode ( Tree % List , BranchNode_Concat ) END DO CALL List_AddAllNodes ( Tree % List , Sample ) CALL List_AddNewNode ( Tree % List , BranchNode_Many ) CALL List_AddNewNode ( Tree % List , LeafNode_Null ) ELSE IF ( Least /= Most ) THEN CALL List_AddNewNode ( Tree % List , BranchNode_LBracket ) DO I = Least , Most CALL List_AddNewNode ( Tree % List , BranchNode_LBracket ) IF ( I == 0 ) THEN CALL List_AddNewNode ( Tree % List , LeafNode_Closure ) ELSE DO J = 0 , I - 1 CALL List_AddAllNodes ( Tree % List , Sample ) IF ( J /= I - 1 ) CALL List_AddNewNode ( Tree % List , BranchNode_Concat ) END DO END IF CALL List_AddNewNode ( Tree % List , BranchNode_RBracket ) IF ( I /= Most ) CALL List_AddNewNode ( Tree % List , BranchNode_Or ) END DO CALL List_AddNewNode ( Tree % List , BranchNode_RBracket ) ELSE CALL List_AddNewNode ( Tree % List , BranchNode_LBracket ) DO I = 0 , Least - 1 CALL List_AddAllNodes ( Tree % List , Sample ) IF ( I /= Least - 1 ) CALL List_AddNewNode ( Tree % List , BranchNode_Concat ) END DO CALL List_AddNewNode ( Tree % List , BranchNode_RBracket ) END IF END IF CALL Sample % Clear () END BLOCK END IF END IF RETURN CONTAINS SUBROUTINE List_AddAllNodes ( List , Sample ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the concatenation node if applicable. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: List TYPE ( IntrusiveLinearList ), INTENT ( INOUT ) :: Sample !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: CurrNode CLASS ( DoublyLinkedNode ), POINTER :: CopyNode tLogical :: EndOfList ! FLOW EndOfList = Sample % StartFirst ( CurrNode ) DO WHILE (. NOT . EndOfList ) ALLOCATE ( CopyNode , SOURCE = CurrNode ) CALL List % AddLast ( CopyNode ) NULLIFY ( CopyNode ) EndOfList = Sample % MoveForward ( CurrNode ) END DO RETURN END SUBROUTINE List_AddAllNodes !************************************************************************** END SUBROUTINE SyntaxTree_PerformMany !****************************************************************************** SUBROUTINE SyntaxTree_TryConcatenation ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the concatenation node if applicable. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Tree % ItemTerminated ) THEN CALL List_AddNewNode ( Tree % List , BranchNode_Concat ) Tree % ItemTerminated = FalseVal END IF RETURN END SUBROUTINE SyntaxTree_TryConcatenation !****************************************************************************** FUNCTION SyntaxTree_GetRoot ( Tree ) RESULT ( Root ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the root node of the syntax tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( IN ) :: Tree TYPE ( SyntaxNode ), POINTER :: Root !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Root => Tree % Root RETURN END FUNCTION SyntaxTree_GetRoot !****************************************************************************** SUBROUTINE SyntaxTree_Normalize ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To parse the regular expression pattern. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: ID tChar :: Chr , Nxt ! FLOW ID = 1 DO WHILE ( ID <= LEN ( Tree % Regex )) CaseBlock : SELECT CASE ( Chr ) CASE ( '[' ) CALL Tree % TryConcatenation () BLOCK TYPE ( ListInteger ) :: AllChar tLogical :: IsComplementarySet tLogical :: Success tSInt32 , ALLOCATABLE :: AllChrSet (:) tSInt32 , ALLOCATABLE :: MinChrSet (:) tSInt32 , ALLOCATABLE :: I IF ( Tree % Regex ( ID : ID ) == '&#94;' ) THEN IsComplementarySet = TrueVal ID = ID + 1 ELSE IsComplementarySet = FalseVal END IF Nxt = Tree % Regex ( ID : ID ) ID = ID + 1 DO WHILE ( Nxt /= ']' ) IF (( Nxt == '\\').OR.(Nxt /= ' . ')) THEN BLOCK tSInt32,  ALLOCATABLE   :: ChrSet(:) tSInt32                 :: I IF (Nxt == ' \\ ') THEN CALL InterpretToken(Tree%Regex(ID-1:ID), ChrSet) ID = ID + 1 ELSE CALL InterpretToken(Nxt, ChrSet) END IF DO I = 0, SIZE(ChrSet)-1 ! note: ChrSet is a zero-based array. CALL AllChar%AddLast(ChrSet(I)) END DO END BLOCK ELSE CALL AllChar%AddLast(IACHAR(Nxt)) END IF Nxt = Tree%Regex(ID:ID) ID = ID + 1 END DO Success = AllChar%ToArray(AllChrSet) CALL Set_Minimum(AllChrSet, MinChrSet) IF (IsComplementarySet) THEN CALL MemAlloc(AllChrSet, EncodingLen-SIZE(MinChrSet,KIND=kIndex), StartID=0_kIndex) CALL Set_Complementary(MinChrSet, AllChrSet) ELSE CALL MOVE_ALLOC(MinChrSet, AllChrSet) END IF CALL List_AddNewNode(Tree%List, BranchNode_LBracket) DoBlock: DO I = 0, SIZE(AllChrSet)-1 CALL List_AddNewCharNode(Tree%List, AllChrSet(I)) IF (I == SIZE(AllChrSet)-1) THEN EXIT DoBlock ELSEIF (AllChrSet(I+1) == 0) THEN EXIT DoBlock END IF CALL List_AddNewNode(Tree%List, BranchNode_Or) END DO DoBlock CALL List_AddNewNode(Tree%List, BranchNode_RBracket) Tree%ItemTerminated = TrueVal END BLOCK CASE (' { ') BLOCK tSInt32             :: Least, Most tLogical            :: DeterministicLength TYPE(StringBuilder) :: SB tCharAlloc          :: CurStr tChar               :: NxtNxt ! initialize Most = -1 DeterministicLength = FalseVal CALL SB%CreateEmpty(InitCap=256_kIndex) Nxt = Tree%Regex(ID:ID) ID = ID + 1 DoLoop: DO CALL SB%Append(Nxt) Nxt = Tree%Regex(ID:ID) ID = ID + 1 IF (Nxt == ' } ') THEN DeterministicLength = TrueVal EXIT DoLoop ELSEIF (Nxt == ' , ') THEN EXIT DoLoop END IF END DO DoLoop CurStr = SB%ToCharAlloc(ClearBuffer=.TRUE.) Least = ParseInteger(CurStr) IF (.NOT.DeterministicLength) THEN Nxt = Tree%Regex(ID:ID) IF (Nxt /= ' } ') THEN NxtNxt = Tree%Regex(ID:ID) ID = ID + 1 DO WHILE (NxtNxt /= ' } ') CALL SB%Append(NxtNxt) NxtNxt = Tree%Regex(ID:ID) ID = ID + 1 END DO IF (SB%Length() /= 0) THEN CurStr = SB%ToCharAlloc(ClearBuffer=.TRUE.) Most = ParseInteger(CurStr) END IF END IF ELSE Most = Least END IF CALL Tree%PerformMany(Least, Most) Tree%ItemTerminated = TrueVal END BLOCK CASE (' ( ') CALL Tree%TryConcatenation() CALL List_AddNewNode(Tree%List, BranchNode_LBracket) Tree%ItemTerminated = FalseVal CASE (' ) ') CALL List_AddNewNode(Tree%List, BranchNode_RBracket) Tree%ItemTerminated = TrueVal CASE (' * ') CALL Tree%PerformMany(0, -1) Tree%ItemTerminated = TrueVal CASE (' ? ') CALL Tree%PerformMany(0, 1) Tree%ItemTerminated = TrueVal CASE (' + ') CALL Tree%PerformMany(1, -1) Tree%ItemTerminated = TrueVal CASE (' | ') CALL List_AddNewNode(Tree%List, BranchNode_Or) Tree%ItemTerminated = FalseVal CASE DEFAULT CALL Tree%TryConcatenation() IF ((Chr == ' \\ ').OR.(Chr == ' . ')) THEN BLOCK tSInt32,  ALLOCATABLE   :: TokenSet(:) tSInt32                 :: I IF (Chr == ' \\' ) THEN CALL InterpretToken ( Tree % Regex ( ID - 1 : ID ), TokenSet ) ID = ID + 1 ELSE CALL InterpretToken ( Chr , TokenSet ) END IF CALL List_AddNewNode ( Tree % List , BranchNode_LBracket ) CALL List_AddNewCharNode ( Tree % List , TokenSet ( 0 )) DO I = 1 , SIZE ( TokenSet ) - 1 CALL List_AddNewNode ( Tree % List , BranchNode_Or ) CALL List_AddNewCharNode ( Tree % List , TokenSet ( I )) END DO CALL List_AddNewNode ( Tree % List , BranchNode_RBracket ) END BLOCK ELSE CALL List_AddNewCharNode ( Tree % List , IACHAR ( Chr )) END IF Tree % ItemTerminated = TrueVal END SELECT CaseBlock END DO RETURN END SUBROUTINE SyntaxTree_Normalize !****************************************************************************** SUBROUTINE SyntaxTree_Shunt ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform shunting yard algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( ShuntingStack ) :: Stack CLASS ( DoublyLinkedNode ), POINTER :: CurrNode tLogical :: EndOfList ! FLOW EndOfList = Tree % List % StartFirst ( CurrNode ) DO WHILE (. NOT . EndOfList ) SELECT TYPE ( CurrNode ) TYPE IS ( SyntaxNode ) CALL Stack % Visit ( CurrNode ) END SELECT EndOfList = Tree % List % MoveForward ( CurrNode ) END DO CALL Stack % Finish ( Tree % Stack ) CALL Tree % List % Clear () RETURN END SUBROUTINE SyntaxTree_Shunt !****************************************************************************** SUBROUTINE SyntaxTree_Build ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To build the syntax tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( OperatingStack ) :: Stack CLASS ( DoublyLinkedNode ), POINTER :: CurrNode tLogical :: Success ! FLOW DO WHILE (. NOT . Tree % Stack % IsEmpty ()) Success = Tree % Stack % Pop ( CurrNode ) SELECT TYPE ( CurrNode ) TYPE IS ( SyntaxNode ) CALL Stack % Visit ( CurrNode ) END SELECT END DO Success = Stack % Pop ( Tree % Root ) RETURN END SUBROUTINE SyntaxTree_Build !****************************************************************************** SUBROUTINE SyntaxTree_Construct ( Tree , Regex ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct the syntax tree based on the specified regular expression pattern. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( OUT ) :: Tree tCharStar , INTENT ( IN ) :: Regex !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! NA ! FLOW Tree % Root => NULL () Tree % Regex = Regex Tree % ItemTerminated = FalseVal CALL Tree % Normalize () CALL Tree % Shunt () CALL Tree % Build () RETURN END SUBROUTINE SyntaxTree_Construct !****************************************************************************** SUBROUTINE SyntaxTree_Destruct ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the syntax tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SyntaxTree ), INTENT ( INOUT ) :: Tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! NA ! FLOW DEALLOCATE ( Tree % Regex ) Tree % ItemTerminated = . FALSE . CALL Tree % List % Clear () CALL Tree % Stack % Clear () NULLIFY ( Tree % Root ) CALL SyntaxNode_Free () RETURN END SUBROUTINE SyntaxTree_Destruct !****************************************************************************** END MODULE MClass_SyntaxTree !******************************************************************************","tags":"","loc":"sourcefile\\mclass_syntaxtree.f90.html"},{"title":"MClass_REProgram.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_REProgram !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *REProgram* type and its related routines.  <br> !   <br> !  **REFERENCES**: <br> !   [1) <a href=\"https:!jakarta.apache.org/regexp/\">The Apache Jakarta Project. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_REParameters IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: REProgram PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     CharCode(C)     ICHAR(C) #define     ToChar(Code)    CHAR(Code, KIND=kChar) !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_REProgram' !** DERIVED TYPE DEFINITIONS !> The *REProgram* type is a derive type that holds compiled regular expressions. TYPE REProgram PRIVATE !% The compiled regular expression 'program' tChar , ALLOCATABLE :: Instruction (:) !% the prefix string optimization tChar , ALLOCATABLE :: Prefix (:) !% optimization flags tSInt32 :: Flags !% maximum parentheses tSInt32 :: MaxParen = - 1 CONTAINS PROCEDURE , PRIVATE :: SetInstructions => REProgram_SetInstructions PROCEDURE :: Construct => REProgram_Construct PROCEDURE :: Destruct => REProgram_Destruct PROCEDURE :: GetInstructions => REProgram_GetInstructions PROCEDURE :: GetPrefix => REProgram_GetPrefix PROCEDURE :: GetMaxParen => REProgram_GetMaxParen PROCEDURE :: GetFlag => REProgram_GetFlag END TYPE REProgram !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** SUBROUTINE REProgram_Construct ( PG , Instruction , Parens ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a regular expression program from the specified instruction. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), INTENT ( INOUT ) :: PG !! 'REProgram' object tChar , INTENT ( IN ) :: Instruction ( 0 :) !! RE opcode instructions tSInt32 , OPTIONAL , INTENT ( IN ) :: Parens !! Count of parens in the program !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL PG % SetInstructions ( Instruction ) IF ( PRESENT ( Parens )) PG % MaxParen = Parens RETURN END SUBROUTINE REProgram_Construct !****************************************************************************** SUBROUTINE REProgram_Destruct ( PG ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the 'REProgram' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), INTENT ( INOUT ) :: PG !! 'REProgram' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( PG % Instruction )) DEALLOCATE ( PG % Instruction ) IF ( ALLOCATED ( PG % Prefix )) DEALLOCATE ( PG % Prefix ) RETURN END SUBROUTINE REProgram_Destruct !****************************************************************************** SUBROUTINE REProgram_SetInstructions ( PG , Instruction ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set a new regular expression program to run.  It is this method which !  performs any special compile-time search optimizations.  Currently only !  two optimizations are in place - one which checks for backreferences !  (so that they can be lazily allocated) and another which attempts to !  find an prefix anchor string so that substantial amounts of input can !  potentially be skipped without running the actual program. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), INTENT ( INOUT ) :: PG !! 'REProgram' object tChar , INTENT ( IN ) :: Instruction ( 0 :) !! Program instruction buffer !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: LenInstruction , Next , LenAtom , I tChar :: NextOp ! FLOW ! Save reference to instruction array LenInstruction = SIZE ( Instruction ) ALLOCATE ( tChar :: PG % Instruction ( 0 : LenInstruction - 1 )) PG % Instruction ( 0 :) = Instruction ( 0 :) ! Initialize other program-related variables PG % Flags = 0 IF ( ALLOCATED ( PG % Prefix )) DEALLOCATE ( PG % Prefix ) ! Try various compile-time optimizations if there's a program IF ( LenInstruction /= 0 ) THEN ! If the first node is a branch IF (( LenInstruction >= nodeSize ). AND .( Instruction ( 0 + offsetOpcode ) == OP_BRANCH )) THEN ! to the end node Next = ToInt16 ( CharCode ( Instruction ( 0 + offsetNext ))) IF (( Instruction ( Next + offsetOpcode ) == OP_END ). AND .( LenInstruction >= ( nodeSize * 2 ))) THEN NextOp = Instruction ( nodeSize + offsetOpcode ) ! the branch starts with an atom IF ( NextOp == OP_ATOM ) THEN ! then get that atom as an prefix because there's no other choice LenAtom = CharCode ( Instruction ( nodeSize + offsetOpdata )) ALLOCATE ( tChar :: PG % Prefix ( 0 : LenAtom - 1 )) PG % Prefix ( 0 : LenAtom - 1 ) = Instruction ( nodeSize * 2 :) ! the branch starts with a BOL ELSEIF ( NextOp == OP_BOL ) THEN ! then set the flag indicating that BOL is present PG % Flags = IOR ( PG % Flags , OPT_HASBOL ) END IF END IF END IF ! Check for backreferences I = 0 BackrefScanLoop : DO WHILE ( I < LenInstruction ) SELECT CASE ( Instruction ( I + offsetOpcode )) CASE ( OP_ANYOF ) I = I + CharCode ( Instruction ( I + offsetOpdata )) * 2 CASE ( OP_ATOM ) I = I + CharCode ( Instruction ( I + offsetOpdata )) CASE ( OP_BACKREF ) PG % Flags = IOR ( PG % Flags , OPT_HASBACKREFS ) EXIT BackrefScanLoop END SELECT I = I + nodeSize END DO BackrefScanLoop END IF RETURN END SUBROUTINE REProgram_SetInstructions !****************************************************************************** FUNCTION REProgram_GetInstructions ( PG ) RESULT ( Instruction ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a pointer to the program instructions.  Return null !  if the program has not yet been compiled. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), TARGET , INTENT ( IN ) :: PG !! 'REProgram' object tChar , POINTER :: Instruction (:) !! Program instructions !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( PG % Instruction )) THEN Instruction => PG % Instruction ELSE Instruction => NULL () END IF RETURN END FUNCTION REProgram_GetInstructions !****************************************************************************** FUNCTION REProgram_GetPrefix ( PG ) RESULT ( Prefix ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a pointer to the program prefix.  Return null !  if the program has not yet been compiled. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), TARGET , INTENT ( IN ) :: PG !! 'REProgram' object tChar , POINTER :: Prefix (:) !! Program prefix !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( PG % Prefix )) THEN Prefix => PG % Prefix ELSE Prefix => NULL () END IF RETURN END FUNCTION REProgram_GetPrefix !****************************************************************************** FUNCTION REProgram_GetMaxParen ( PG ) RESULT ( MaxParen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get maximum parentheses. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), INTENT ( IN ) :: PG !! 'REProgram' object tSInt32 :: MaxParen !! maximum parentheses !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW MaxParen = PG % MaxParen RETURN END FUNCTION REProgram_GetMaxParen !****************************************************************************** FUNCTION REProgram_GetFlag ( PG ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( REProgram ), INTENT ( IN ) :: PG !! 'REProgram' object tSInt32 :: Flag !! flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = PG % Flags RETURN END FUNCTION REProgram_GetFlag !****************************************************************************** END MODULE MClass_REProgram !******************************************************************************","tags":"","loc":"sourcefile\\mclass_reprogram.f90.html"},{"title":"MClass_StringBuilder.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_StringBuilder !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *StringBuilder* type and its related routines.  The *StringBuilder* type !   is a string type that provides a convenient and efficient mechanism for concatenating multiple !   strings (i.e. building a string from several strings).  <br> !   The *StringBuilder* type provides several methods that can be grouped !   into the following categories. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *CreateEmpty* method - method to construct an empty builder, <br> !   - *Construct* method - method to construct the builder from its first specified value, and <br> !   - *Clear* method - method to remove all inserted values from the builder. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *Append* method - method to insert a value into the end of the builder's string, <br> !   - *Insert* method - method to insert a value at a specified position of the builder's string, and <br> !   - *DelLastChar* method - method to remove the last character of the builder's string. <br> !   (3) Conversion-To-String.  Methods for these operations include: <br> !   - *ToCharAlloc* method - method to return the builder's string as an allocatable character string, <br> !   - *ToFvlStr* method - method to return the builder's string as a string of the *FvlStr* type, and <br> !   - *ToCharStar* method - method to return the builder's string as a character string of assumed length. <br> !   (4) Inquiry.  A method for this operation is: <br> !   - *Length* method - method to inquire the current length of the builder's string. <br> !   (5) Miscellaneous.  There are several other methods that the *StringBuilder* type are inherited from !     its parent types (*Object* and *Comparable*). <br> !   It is worth noting that values inserted into the string builder do not need to be strings.  If the type !   of values is one of Fortran intrinsic types or the *FvlStr* type, the values are automatically converted !   into strings.  However, if the type of values is a user-defined one, the user can supply a procedure to !   convert values into strings. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_CharUtil USE MBase_ChrStr USE MClass_Object USE MClass_Comparable USE MClass_FvlStr #ifdef Indx32Bits USE MBase_OptimalHash32 , ONLY : ComputeHash => Murmur3_Hash32_Opt #else USE MBase_OptimalHash64 , ONLY : ComputeHash => XX_Hash64_Opt #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: StringBuilder PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'Class_StringBuilder' tIndex , PARAMETER :: DfltInitCap = 2048_kIndex !** DERIVED TYPE DEFINITIONS !> The *StringBuilder* type is string type that provides a convenient way !  to build a string from multiple strings. TYPE , EXTENDS ( Comparable ) :: StringBuilder PRIVATE tIndex :: Count = 0_kIndex !! the number of characters currently stored tIndex :: Capacity = 0_kIndex !! the maximum number of characters that currently can be stored tCharAlloc :: StrBuf !! string buffer CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: EnsureCapacity => StringBuilder_EnsureCapacity PROCEDURE , PRIVATE :: StringBuilder_Append PROCEDURE , PRIVATE :: StringBuilder_AppendWPrefix ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty string builder. <br> !  **Usage**: <br> !   ! use default initial capacity  <br> !   --->    CALL StrBld%CreateEmpty() <br> !   ! specify initial capacity <br> !   --->    CALL StrBld%CreateEmpty(InitCap=256) <br> PROCEDURE :: CreateEmpty => StringBuilder_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a string builder with the specified value.  This method !       provides a convenient way to create an empty string builder and then add the !       first value into the builder. <br> !  **Usage**: <br> !   --->    CALL StrBld%Construct(Value) <br> PROCEDURE :: Construct => StringBuilder_Construct !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To clear the buffer string of the string builder. <br> !  **Usage**: <br> !   --->    CALL StrBld%Clear() <br> PROCEDURE :: Clear => StringBuilder_Clear !> **Type-Bound Subroutine**: Append <br> !  **Purpose**:  To append the specified value at the end of the builder where the type !       of value can be one of Fortran intrinsic types or the *FvlStr* type.  Optionally, !       a prefix and/or a suffix can be specified.  Also, optionally, if the type of value !       is a user-defined one, a *ToString* procedure must be specified. <br> !  **Usage**: <br> !   ! specify only the value <br> !   --->    CALL StrBld%Append(Val) <br> !   ! specify only the value and its ToString procedure<br> !   --->    CALL StrBld%Append(Val, ToString) <br> !   ! specify the value and its prefix <br> !   --->    CALL StrBld%Append('The computed value is', Val) <br> !   ! specify the value and its prefix and suffix <br> !   --->    CALL StrBld%Append('The speed of light in vacuum =', 299792458, 'm/s.') <br> GENERIC :: Append => StringBuilder_Append , StringBuilder_AppendWPrefix !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified value at the specified position where the type of !       value can be one of Fortran intrinsic types or the *FvlStr* type.  Optionally, if the !       type of value is a user-defined one, a *ToString* procedure must be specified. <br> !  **Usage**: <br> !   --->    CALL StrBld%Insert(Val, Pos) <br> !   --->    CALL StrBld%Insert(Val, Pos, ToString) <br> PROCEDURE :: Insert => StringBuilder_Insert !> **Type-Bound Subroutine**: DelLastChar <br> !  **Purpose**:  To remove the last character from the builder's string. <br> !  **Usage**: <br> !   --->    CALL StrBld%DelLastChar() <br> PROCEDURE :: DelLastChar => StringBuilder_DeleteLastChar !> **Type-Bound Function**: ToCharAlloc <br> !  **Purpose**:  To return characters currently stored in the string builder as an !       allocatable character string.  Optionally, a user can request to clear the !       builder' buffer string. <br> !  **Usage**: <br> !   --->    cStr = StrBld%ToCharAlloc() <br> !   --->    cStr = StrBld%ToCharAlloc(ClearBuffer=.TRUE.) <br> PROCEDURE :: ToCharAlloc => StringBuilder_ToCharAlloc !> **Type-Bound Function**: ToFvlStr <br> !  **Purpose**:  To return characters currently stored in the string builder as a !       string of the *FvlStr* type.  Optionally, a user can request to clear the !       builder' buffer string. <br> !  **Usage**: <br> !   --->    vStr = StrBld%ToFvlStr() <br> !   --->    vStr = StrBld%ToFvlStr(ClearBuffer=.TRUE.) <br> PROCEDURE :: ToFvlStr => StringBuilder_ToFvlStr !> **Type-Bound Subroutine**: ToCharStar <br> !  **Purpose**:  To return characters currently stored in the string builder as !       a character string of assumed length.  Optionally, a user can request !       to clear the builder' buffer string. <br> !  **Usage**: <br> !   --->    CALL StrBld%ToCharStar(cStr) <br> !   --->    CALL StrBld%ToCharStar(cStr, ClearBuffer=.TRUE.) <br> !  **Note**: In order to retrieve all the characters currently stored in the builder, !       the length of the specified string must be at least equal to the current length !       of the string being built, which can be inquired using the *Length* method.<br> PROCEDURE :: ToCharStar => StringBuilder_ToCharStar !> **Type-Bound Function**: Length <br> !  **Purpose**:  To return the current length of the string being built. <br> !  **Usage**: <br> !   --->    Length = StrBld%Length() <br> PROCEDURE :: Length => StringBuilder_GetLength ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => StringBuilder_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => StringBuilder_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => StringBuilder_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StringBuilder_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => StringBuilder_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Comparable Type          ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => StringBuilder_CompareTo ! --------------------------------------------------------------------- ! -----                 Final Procedure                           ----- ! --------------------------------------------------------------------- !% To perform finalization of the *StringBuilder* object. FINAL :: StringBuilder_Finalize ! --------------------------------------------------------------------- END TYPE StringBuilder !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE FUNCTION Anytype2String ( Val ) RESULT ( Str ) IMPORT CLASS ( * ), INTENT ( IN ) :: Val tCharAlloc :: Str END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !-------------------------------------------------------------------------------------- !                   DEFERRED PROCEDURES OF COMPARABLE CLASS !-------------------------------------------------------------------------------------- SUBROUTINE StringBuilder_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS ROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW SELECT TYPE ( DstObj ) TYPE IS ( StringBuilder ) ALLOCATE ( DstObj % StrBuf , SOURCE = SrcObj % StrBuf ) DstObj % Count = SrcObj % Count DstObj % Capacity = SrcObj % Capacity ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'StringBuilder_Copy' , ModName , ErrSevere , 'Type of DstObj is invalid.' ) END SELECT RETURN END SUBROUTINE StringBuilder_Copy !************************************************************************************** FUNCTION StringBuilder_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS ROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( StringBuilder ) IF ( LhsObj % Count == RhsObj % Count ) THEN Flag = ( LhsObj % StrBuf ( 1 : LhsObj % Count ) == RhsObj % StrBuf ( 1 : LhsObj % Count )) ELSE Flag = FalseVal END IF CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION StringBuilder_IsEqualTo !****************************************************************************** SUBROUTINE StringBuilder_MemFree ( Obj ) !** PURPOSE OF THIS ROUTINE: !&#94; To free memory of the StringBuilder object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: Obj ! StringBuilder object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( Obj % StrBuf )) DEALLOCATE ( Obj % StrBuf ) RETURN END SUBROUTINE StringBuilder_MemFree !****************************************************************************** FUNCTION StringBuilder_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS ROUTINE: !&#94; To get the string representation of the StringBuilder type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = Obj % StrBuf ( 1 : Obj % Count ) RETURN END FUNCTION StringBuilder_ToString !****************************************************************************** FUNCTION StringBuilder_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS ROUTINE: !&#94; To get compute hash code for the given key. !  This is a deferred procedure inherited from the *Hashable* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = ComputeHash ( Obj % StrBuf , AnyType_GetByteSize ( Obj % StrBuf ( 1 : Obj % Count ))) RETURN END FUNCTION StringBuilder_HashCode !************************************************************************************** FUNCTION StringBuilder_CompareTo ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS ROUTINE: !&#94; To compare a StringBuilder object with a Comparable object. !  This is a deferred procedure inherited from the *Comparable* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( IN ) :: A !! StringBuilder object CLASS ( Comparable ), INTENT ( IN ) :: B !! Comparable object tSInt32 :: Flag !&#94; output flag with value of <br> !   -1 if A < B, <br> !    0 if A == B, or <br> !   +1 if A > B. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW SELECT TYPE ( B ) TYPE IS ( StringBuilder ) ! compare only stored characters before the rest can be garbages. IF ( A % StrBuf ( 1 : A % Count ) > B % StrBuf ( 1 : B % Count )) THEN Flag = 1 ELSEIF ( A % StrBuf ( 1 : A % Count ) < B % StrBuf ( 1 : B % Count )) THEN Flag = - 1 ELSE Flag = 0 END IF CLASS DEFAULT Flag = - 2 CALL Handle_ErrLevel ( 'StringBuilder_CompareTo' , ModName , ErrSevere , 'Type of B is invalid.' ) END SELECT RETURN END FUNCTION StringBuilder_CompareTo !-------------------------------------------------------------------------------------- !                   SPECIFIC PROCEDURES OF STRING-BUILDER CLASS !-------------------------------------------------------------------------------------- SUBROUTINE StringBuilder_CreateEmpty ( StrBld , InitCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty 'StringBuilder' object with optionally specified initial capacity. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !! initial capacity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set capacity SET_OPTION ( StrBld % Capacity , DfltInitCap , InitCap ) ! allocate buffer IF (. NOT . ALLOCATED ( StrBld % StrBuf )) ALLOCATE ( CHARACTER ( LEN = StrBld % Capacity ) :: StrBld % StrBuf ) ! reset the count StrBld % Count = 0_kIndex RETURN END SUBROUTINE StringBuilder_CreateEmpty !****************************************************************************** SUBROUTINE StringBuilder_Construct ( StrBld , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a string builder with the specified value.  This routine !  provides a convenient way to create an empty string builder and then !  add the first value into the builder. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object CLASS ( * ), INTENT ( IN ) :: Value !! value of any valid type !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL StrBld % CreateEmpty () CALL StrBld % Append ( Value ) RETURN END SUBROUTINE StringBuilder_Construct !****************************************************************************** SUBROUTINE StringBuilder_Clear ( StrBld ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the buffer string of a 'StringBuilder' object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW StrBld % Count = 0_kIndex RETURN END SUBROUTINE StringBuilder_Clear !****************************************************************************** SUBROUTINE StringBuilder_Finalize ( StrBld ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of a 'StringBuilder' object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL StrBld % MemFree () RETURN END SUBROUTINE StringBuilder_Finalize !****************************************************************************** SUBROUTINE StringBuilder_EnsureCapacity ( StrBld , StrLen ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To make sure that a 'StringBuilder' object has enough capacity to hold !  character string with the specified length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tIndex , INTENT ( IN ) :: StrLen !! length of character string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( StrBld % Capacity == 0_kIndex ) CALL StrBld % CreateEmpty () IF ( StrBld % Capacity < ( StrLen + StrBld % Count )) THEN BLOCK tIndex :: NewCap tCharAlloc :: TmpBuf NewCap = MAX ( StrBld % Capacity * 2_kIndex , StrBld % Capacity + StrLen ) ! allocate temporary buffer ALLOCATE ( CHARACTER ( LEN = NewCap ) :: TmpBuf ) ! copy stored characters IF ( StrBld % Count > 0_kIndex ) TmpBuf ( 1 : StrBld % Count ) = StrBld % StrBuf ( 1 : StrBld % Count ) ! move allocation from TmpBuf to StrBuf CALL MOVE_ALLOC ( TmpBuf , StrBld % StrBuf ) ! set capacity StrBld % Capacity = NewCap END BLOCK END IF RETURN END SUBROUTINE StringBuilder_EnsureCapacity !****************************************************************************** SUBROUTINE StringBuilder_Append ( StrBld , Value , ToString ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To append the *Value* argument at the end of the stored characters (i.e. at Count+1). !  The *Value* argument is automatically converted to a string if its type is valid. !  Otherwise, an error is reported to a default log file. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object CLASS ( * ), INTENT ( IN ) :: Value !! value of any valid type PROCEDURE ( Anytype2String ), OPTIONAL :: ToString !! procedure to convert value to string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc , TARGET :: ValStr tCharLen (:), POINTER :: cStrPtr TYPE ( FvlStr ), POINTER :: vStrPtr tIndex :: StrLen , EndID ! FLOW IF (. NOT . PRESENT ( ToString )) THEN CALL GetPointerToValString ( Value ) ELSE ValStr = ToString ( Value ) cStrPtr => ValStr END IF IF ( ASSOCIATED ( cStrPtr )) THEN ! get string length and ensure that there is enough capacity StrLen = LEN ( cStrPtr , KIND = kIndex ) IF ( StrLen > 0_kIndex ) THEN CALL StrBld % EnsureCapacity ( StrLen ) ! insert characters EndID = StrBld % Count + StrLen StrBld % StrBuf ( StrBld % Count + 1 : EndID ) = cStrPtr ( 1 : StrLen ) StrBld % Count = EndID END IF ELSEIF ( ASSOCIATED ( vStrPtr )) THEN ! get string length and ensure that there is enough capacity StrLen = vStrPtr % Length () IF ( StrLen > 0_kIndex ) THEN CALL StrBld % EnsureCapacity ( StrLen ) ! insert characters EndID = StrBld % Count + StrLen CALL ToCharStar ( vStrPtr , StrBld % StrBuf ( StrBld % Count + 1 : EndID )) StrBld % Count = EndID END IF END IF ! free memory and pointers NULLIFY ( cStrPtr , vStrPtr ) IF ( ALLOCATED ( ValStr )) DEALLOCATE ( ValStr ) RETURN CONTAINS SUBROUTINE GetPointerToValString ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert *Val* to string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( * ), TARGET , INTENT ( IN ) :: Val !! value of any valid type !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW cStrPtr => NULL () vStrPtr => NULL () SELECT TYPE ( Val ) TYPE IS ( tCharStar ) cStrPtr => Val TYPE IS ( FvlStr ) vStrPtr => Val TYPE IS ( tSInt32 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt64 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealSP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealDP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt16 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt8 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealQP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxSP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxDP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxQP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tLogical ) ValStr = CharString ( Val ) cStrPtr => ValStr CLASS DEFAULT CALL Handle_ErrLevel ( 'StringBuilder_Append' , ModName , ErrWarning , & 'Type of \"Value\" is invalid.' ) END SELECT RETURN END SUBROUTINE GetPointerToValString !****************************************************************************** END SUBROUTINE StringBuilder_Append !****************************************************************************** SUBROUTINE StringBuilder_AppendWPrefix ( StrBld , Prefix , Value , Suffix , NoPreSpace , NoPostSpace , ToString ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To append the *Value* argument with a prefix text.  Optionally, a suffix text can be !  specified.  This routine provides a convenient way to insert a value with a prefix !  (and a suffix). <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tCharStar , INTENT ( IN ) :: Prefix !! prefix text CLASS ( * ), INTENT ( IN ) :: Value !! value of any valid type tCharStar , OPTIONAL , INTENT ( IN ) :: Suffix !! suffix text tLogical , OPTIONAL , INTENT ( IN ) :: NoPreSpace !&#94; true if there is no space between the prefix text and the value; default is false. tLogical , OPTIONAL , INTENT ( IN ) :: NoPostSpace !&#94; true if there is no space between the prefix text and the value; default is false. PROCEDURE ( Anytype2String ), OPTIONAL :: ToString !! procedure to convert value to string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: PreSpace , PostSpace ! FLOW ! set space flags PreSpace = TrueVal PostSpace = TrueVal IF ( PRESENT ( NoPreSpace )) PreSpace = . NOT . NoPreSpace IF ( PRESENT ( NoPostSpace )) PostSpace = . NOT . NoPostSpace ! append value and text(s) CALL StrBld % Append ( Prefix ) IF ( PreSpace ) CALL StrBld % Append ( CHR_SPACE ) CALL StrBld % Append ( Value , ToString ) IF ( PRESENT ( Suffix )) THEN IF ( PostSpace ) CALL StrBld % Append ( CHR_SPACE ) CALL StrBld % Append ( Suffix ) END IF RETURN END SUBROUTINE StringBuilder_AppendWPrefix !****************************************************************************** SUBROUTINE StringBuilder_Insert ( StrBld , Value , StartID , ToString ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the *Value* argument at the specified position.  The position must be greater !  than 0 and less than or equal to *Count*.  Otherwise, this is the same as appending the !  value.  The *Value* argument is automatically converted to a string if its type is valid. !  Otherwise, an error is reported to a default log file. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object CLASS ( * ), INTENT ( IN ) :: Value !! value of any valid type tIndex , INTENT ( IN ) :: StartID !! position to add the value; must be less than Count PROCEDURE ( Anytype2String ), OPTIONAL :: ToString !! procedure to convert value to string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc , TARGET :: ValStr tCharLen (:), POINTER :: cStrPtr TYPE ( FvlStr ), POINTER :: vStrPtr tIndex :: StrLen , EndID tIndex :: I , J ! FLOW ! check validity of *StartID* IF (( StartID < 1_kIndex ). OR .( StartID > StrBld % Count )) THEN CALL StrBld % Append ( Value , ToString ) RETURN END IF IF (. NOT . PRESENT ( ToString )) THEN CALL GetPointerToValString ( Value ) ELSE ValStr = ToString ( Value ) cStrPtr => ValStr END IF IF ( ASSOCIATED ( cStrPtr )) THEN ! get string length and ensure that there is enough capacity StrLen = LEN ( cStrPtr , KIND = kIndex ) CALL StrBld % EnsureCapacity ( StrLen ) ! move characters out of the spaces to be inserted DO I = StrBld % Count , StartID , - 1_kIndex J = I + StrLen StrBld % StrBuf ( J : J ) = StrBld % StrBuf ( I : I ) END DO ! insert characters EndID = StartID + StrLen - 1_kIndex StrBld % StrBuf ( StartID : EndID ) = cStrPtr ( 1 : StrLen ) StrBld % Count = StrBld % Count + StrLen ELSEIF ( ASSOCIATED ( vStrPtr )) THEN ! get string length and ensure that there is enough capacity StrLen = vStrPtr % Length () CALL StrBld % EnsureCapacity ( StrLen ) ! move characters out of the spaces to be inserted DO I = StrBld % Count , StartID , - 1_kIndex J = I + StrLen StrBld % StrBuf ( J : J ) = StrBld % StrBuf ( I : I ) END DO ! insert characters EndID = StartID + StrLen - 1_kIndex CALL ToCharStar ( vStrPtr , StrBld % StrBuf ( StartID : EndID )) StrBld % Count = StrBld % Count + StrLen END IF ! free memory and pointers NULLIFY ( cStrPtr , vStrPtr ) IF ( ALLOCATED ( ValStr )) DEALLOCATE ( ValStr ) RETURN CONTAINS SUBROUTINE GetPointerToValString ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To convert *Val* to string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( * ), TARGET , INTENT ( IN ) :: Val !! value of any valid type !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW cStrPtr => NULL () vStrPtr => NULL () SELECT TYPE ( Val ) TYPE IS ( tCharStar ) cStrPtr => Val TYPE IS ( FvlStr ) vStrPtr => Val TYPE IS ( tSInt32 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt64 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealSP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealDP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt16 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tSInt8 ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tRealQP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxSP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxDP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tCmpxQP ) ValStr = CharString ( Val ) cStrPtr => ValStr TYPE IS ( tLogical ) ValStr = CharString ( Val ) cStrPtr => ValStr CLASS DEFAULT CALL Handle_ErrLevel ( 'StringBuilder_Insert' , ModName , ErrWarning , & 'Type of \"Value\" is invalid.' ) END SELECT RETURN END SUBROUTINE GetPointerToValString !****************************************************************************** END SUBROUTINE StringBuilder_Insert !****************************************************************************** FUNCTION StringBuilder_ToCharAlloc ( StrBld , ClearBuffer ) RESULT ( cStr ) !** PURPOSE OF THIS ROUTINE: !&#94; To return characters currently stored in the string builder as !  an allocatable character string. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tLogical , OPTIONAL , INTENT ( IN ) :: ClearBuffer !&#94; true if requesting to clear the builder's buffer after getting the string; !  default is false. tCharAlloc :: cStr !! string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ClearBuf ! FLOW SET_OPTION ( ClearBuf , FalseVal , ClearBuffer ) IF ( StrBld % Count > 0_kIndex ) THEN cStr = StrBld % StrBuf ( 1 : StrBld % Count ) ELSE cStr = '' END IF IF ( ClearBuf ) CALL StrBld % Clear () RETURN END FUNCTION StringBuilder_ToCharAlloc !****************************************************************************** FUNCTION StringBuilder_ToFvlStr ( StrBld , ClearBuffer ) RESULT ( vStr ) !** PURPOSE OF THIS ROUTINE: !&#94; To return characters currently stored in the string builder as !  a string of the *FvlStr* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tLogical , OPTIONAL , INTENT ( IN ) :: ClearBuffer !&#94; true if requesting to clear the builder's buffer after getting the string; !  default is false. TYPE ( FvlStr ) :: vStr !! string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ClearBuf ! FLOW SET_OPTION ( ClearBuf , FalseVal , ClearBuffer ) IF ( StrBld % Count > 0_kIndex ) THEN vStr = StrBld % StrBuf ( 1 : StrBld % Count ) ELSE vStr = '' END IF IF ( ClearBuf ) CALL StrBld % Clear () RETURN END FUNCTION StringBuilder_ToFvlStr !****************************************************************************** SUBROUTINE StringBuilder_ToCharStar ( StrBld , cStr , ClearBuffer ) !** PURPOSE OF THIS ROUTINE: !&#94; To return characters currently stored in the string builder as !  a character string of assumed length. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tCharStar , INTENT ( OUT ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( IN ) :: ClearBuffer !&#94; true if requesting to clear the builder's buffer after getting the string; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ClearBuf tIndex :: MinLen ! FLOW SET_OPTION ( ClearBuf , FalseVal , ClearBuffer ) MinLen = MIN ( LEN ( cStr , KIND = kIndex ), StrBld % Count ) IF ( MinLen > 0_kIndex ) cStr ( 1 : MinLen ) = StrBld % StrBuf ( 1 : MinLen ) IF ( ClearBuf ) CALL StrBld % Clear () RETURN END SUBROUTINE StringBuilder_ToCharStar !****************************************************************************** FUNCTION StringBuilder_GetLength ( StrBld ) RESULT ( Length ) !** PURPOSE OF THIS ROUTINE: !&#94; To return the current length of the string being built (i.e. the number !  of characters currently stored in the builder). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object tIndex :: Length !! length of the string !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Length = StrBld % Count RETURN END FUNCTION StringBuilder_GetLength !****************************************************************************** SUBROUTINE StringBuilder_DeleteLastChar ( StrBld ) !** PURPOSE OF THIS ROUTINE: !&#94; To delete the last character of the string being built. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( StringBuilder ), INTENT ( INOUT ) :: StrBld !! 'StringBuilder' object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( StrBld % Count > 0_kIndex ) StrBld % Count = StrBld % Count - 1_kIndex RETURN END SUBROUTINE StringBuilder_DeleteLastChar !****************************************************************************** END MODULE MClass_StringBuilder !******************************************************************************","tags":"","loc":"sourcefile\\mclass_stringbuilder.f90.html"}]}
var tipuesearch = {"pages":[{"title":" eXPerimental Fortran Library (XpfLib) Documentation ","text":"eXPerimental Fortran Library (XpfLib) Documentation !+++ external: XpfBase=./XpfGeneral/XpfBase +++! XpfStructure: eXPerimental Fortran Structure Package XpfStructure is an experimenal package written in Fortran.   It is a sub-package of the XpfGeneral package (a larger package within the XpfLib library), which contains a large collection of general-purpose modules.  The XpfStructure package consists of a large number of modules that implement data structures commonly found in computer science.  The package may be divided into two sub-packages: the Collection sub-package and the Container sub-package. The Collection Sub-package The Collection sub-package implements various common data structures including stack, queue, deque, list, set, priority queue, tree and hash table.  In this sub-package, each data structure is referred to as a collection , which is an object representing a group of objects.  By design, all collections in this sub-package can be considered as generic collections because the same collections can be used with objects of several different data types.  Some collections allow objects of any data type to be inserted whereas other collections may only allow objects of some specific data types to be inserted.  It is important to note that, by design, although each collection can be used with objects of several data types, it only allows objects of one specific type at a time.  To insert objects of different type, the collection must be destructed before it can be used to insert objects of another type.  This means that if a user have objects of two different types to be inserted into a collection type, he/she must also have two collection objects (of the same collection type), each collection object for objects of one particular type. The source code of the Collection sub-package is located in the Collections subfolder, which contains six subfolders.  A brief overview of the Collection sub-package is given below. The ADT subfolder contains four modules that provide abstract derived types (ADT) that are employed as base types for all other collections in the sub-package.  The BaseCollection type defines an application programming interface (API) for various common operations of collections while the BaseIterable type, which is a direct subtype of the BaseCollection type defines additional operations for an iteration over items stored in a collection.  The BaseSymTable type, which is also a direct subtype of the BaseCollection type, defines an API for a symbol table (a collection that associates a value with a key ).  The OrderedSymTable type extends the BaseSymTable type and defines addtional operations for an ordered symbol table. The DynArr subfolder consists of one module and four submodules.  The MClass_DynamicArrays module contains four concrete derived types that represent dynamic-array-based collections.  The StackArray type  represents a last-in-first-out (LIFO) stack while the QueueArray type represents a first-in-first-out (FIFO) queue.  The DequeArray type represents a double-ended queue (deque) and the ListArray type represents a list where an item can be added, removed or retrieved at the (valid) specified index.  All collections in this module employ a resizable array (or the so-called dynamic array ) technique that can increase or decrease its size depending on the current collection size (number of stored items) relative to the current collection capacity.  The MClass_DynamicArrays module provide the interfaces for all aforementioned collections whereas each submodule  provides the actual implementation for each collection. Like the DynArr subfolder, the LnkList subfolder consists of one module and four submodules.  Similary, the MClass_LinkedLists module contains four concrete derived types that represent linked-list-based collections: the StackLinked , QueueLinked , DequeLinked and ListLinked types, which are functionally the same as those dynamic-array-based collections.  As the names suggested, all collections in this module employ a doubly-linked list implementation.  However, unlike conventional implementation, these collections utilize an intrusive linked-list container (available in the XpfBase package) as their component where the linked-list task is done by the intrusive container. The PQueue subfolder consists of two modules.  The MClass_PQBinHeap module provides the PQBinHeap type that can be used to represent either a max-priority queue or a min-priority queue.  The PQBinHeap type employs a binary heap implementation to provide operations for a priority queue.  The MClass_PQMinMax module provides the PQMinMax type, which represents a generalized priority queue.  The PQMinMax type employs a ordered array implementation to provide combined operations of a max-priority queue and a min-priority queue. The Set subfolder also consists of two modules. The MClass_HashSet module provides the HashSet type while the MClass_TreeSet module provides the TreeSet type.  The HashSet type employs an open-addressing hash table implementation to provide common operations for an unordered set.  The TreeSet type employs a balanced binary-search-tree (BST) implementation to provide common operations for an ordered set.  Like the linked-list-based collections, the TreeSet type utilizes an intrusive balanced tree container (also available in the XpfBase package) as its component where the balanced-tree task is done by the intrusive container. The SymTab subfolder consists of five modules that provide five derived types representing symbol tables.  The HashMap type employs an open-addressing hash table implementation to provide common operations for an unordered symbol table while both the HashList and the HashTree types employ a separate-chaining hash table implementation to provide common operations for an unordered symbol table.  Both the HashList and the HashTree types utilize an intrusive hash-table container (a different one for each type, also available in the XpfBase package) as its component where the hash-table task is done by the intrusive container.  The ListTable type employs a linked-list implementation to provide common operations for an unordered symbol table whereas the TreeTable type employs a balanced BST implementation to provide common operations for an ordered symbol table.  Like many other collections previously mentioned, both types also utilizes an intrusive container as its component. The Container Sub-package The Container sub-package implements various common data structures similar to those implemented in the Collection sub-package.  However, each data structure in this sub-package is referred to as a container instead.  Unlike those collection types, most of containers implemented in this sub-package can be used only for objects of one specific data type it is designed for.  Also, unlike those in the Collection sub-package, these containers employs conventional implementation instead of utilizing an intrusive container. The source code of the Container sub-package is located in the Containers subfolder, which contains six subfolders. A brief overview of the Container sub-package is given below. The DblLnkList subfolder consists of fourteen modules, twelve of which provide doubly-linked-list container types for Fortran intrinsic data types.  The ListObject type is designed to be used with inserted items of any derived data types that are a subtype of the Object type whereas the ListAnyType type is designed to be used with inserted items of any data types.  By design, each doubly-linked-list container type can represent various forms of common containers including a LIFO stack, a FIFO queue, a deque or a list.  Therefore, no container specifically representing a stack or a queue is provided in this sub-package.  Because the ListAnyType type can be used with objects of any data type, it is a generic container.  Unlike those collection types, it allows objects of different types to be inserted into the container.  However, to be able to retrieve the stored items, a user must specify an allocatable unlimited polymorphic type as an output argument.  Therefore, the interfaces of item-retrieving routines in the ListAnyType type are different from those collection types although the interfaces of item-insertion routines are similar. The DynArray subfolder consists of thirteen modules, twelve of which provide dynamic-array-based container types for Fortran intrinsic data types. The DArrObject type is designed to be used with inserted items of any derived data types that are a subtype of the Object type.  Similar to a doubly-linked-list container type, a dynamic-array-based container type can represent various forms of common containers including a LIFO stack, a FIFO queue, a deque or a list. The HashTable subfolder consists of nine modules, eight of which provide hash-table container types (representing unordered symbol tables) based on open-addressing implementation for keys of Fortran intrinsic data types.  All these eight modules allow values of any data types to be inserted along with keys of one Fortran intrinsic data type.  The HTabObject type is designed to be used with inserted key-value objects of any derived data types that are a subtype of the Object type.  Its design is slightly differently from other hash-table container types such that it requires a key and a value to be bundled into a derived type in the Object class. The PriorityQ subfolder consists of ten modules, eight of which provide priority queue container types based on binary heap implementation for Fortran intrinsic data types.  Both the PQBasic and the PQHeap types are designed to be used with inserted keys of any derived data types that are a subtype of the Comparable type.  The PQHeap type also employs the binary heap implementation like other eight priority queues.  Unlike other priority queues, the PQBasic type employs an elementary implementation where its array representation can be unordered or ordered by a sorting algorithm. The RBTree subfolder consists of nine modules, eight of which provide balanced-tree container types (representing ordered symbol tables) based on red-black tree implementation for keys of Fortran intrinsic data types.  Like the hash-table container types, all these eight modules allow values of any data types to be inserted along with keys of one Fortran intrinsic data type.  The TreeComparable type is designed in a similar fashion to the HTabObject type and intended to be used with inserted key-value objects of any derived data types that are a subtype of the Comparable type.  As a result, it requires a key and a value to be bundled into a derived type that is in the Comparable class. The Interfaces subfolder contains five modules that provide centralized accesses to the five groups of available container types in this sub-package. Dependencies The XpfStructure pacakge is primarily dependent on the XpfBase and XpfRankNSort packages. Documentation The FORD program can be used to automatically generate the documentation of the XpfStructure package via ford XpfStructureDoc.md . Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"ListTable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseSymTable ) :: ListTable The ListTable type is a collection type that employs a linked-list implementation to\n provide common operations for an unordered symbol table.  The ListTable type employs\n the IntrusiveLinearList type as its component to store TabNode objects.  As an\n intrusive container, the IntrusiveLinearList type provides common linked-list operations\n without a memory management task.  The memory management task of the inserted TabNode objects is handled by the ListTable type. As an unordered symbol table, the ListTable type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the ListTable type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalization Procedures final :: ListTable_Finalize To perform finalization of the object. private  subroutine ListTable_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListTable ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseSymTable_ClearEntries(Collection) To remove all of the pair data items from the collection. This routine provides a basic implementation of the Clear deferred procedure required by the BaseCollection class.\n This routine should be overridden if a better implementation\n is available. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure, public :: CopyCollection => ListTable_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine ListTable_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => ListTable_Destroy Destruct is a procedure deferred by the BaseCollection type. Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine ListTable_Destroy(Collection) To destruct the collection. This is a deferred procedure by the BaseCollection class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection ListTable object procedure, public :: GetSize => ListTable_GetSize GetSize is a procedure deferred by the BaseCollection type. Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function ListTable_GetSize(Collection) result(Size) To get the number of items in the collection.\n This is a deferred procedure inherited from the BaseCollection type. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(in) :: Collection Return Value integer(kind=kInt32) procedure, public :: StartFirst => ListTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) private  function ListTable_Move2FirstPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) To move to the first (starting) pair data in a symbol table.\n For the ListTable , which is an unordered symbol table,\n the starting pair is the first pair inserted. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no pair data or not - true if the collection is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => ListTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) private  function ListTable_Move2NextPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) To move to the next pair data in a symbol table.\n For the ListTable , which is an unordered symbol table,\n the next pair is the pair inserted after the previous one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => ListTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) private  subroutine ListTable_Insert(Collection, Key, Value) To add a key-value pair into a symbol table.  If the specified key is already\n stored in the table, replace the old value with the new one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the associated value to be added to the collection procedure, public :: Delete => ListTable_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). private  subroutine ListTable_Delete(Collection) To delete a key-value pair from a symbol table.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward procedures.\n Therefore, after the call to either procedure and then calling this procedure\n will result in a removal of the current key-value pair of the iteration (i.e.\n the same key-value pair that can be retrieved via those Move procedures). This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object procedure, public :: Remove => ListTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function ListTable_Remove(Collection, Key) result(Flag) To delete the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: Contain => ListTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething private  function ListTable_Contain(Collection, Key) result(Found) To check whether the specified key is currently stored in a symbol table. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => ListTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething private  function ListTable_GetValue(Collection, Key, Value, ValCopy) result(Flag) To get a value associated with the specified key in a symbol table.\n Also, return a flag indicating whether the key-value pair is successfully\n found or not. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: ToArray => ListTable_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething private  function ListTable_ToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get and remove all key-value pairs from the collection.  Also, return a flag\n indicating whether the pairs are successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection ListTable object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => ListTable_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething private  function ListTable_GetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get all keys and/or all values (without removing them) from the collection.  Also,\n return a flag indicating whether the keys and/or values are successfully retrieved. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection ListTable object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , ListTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine ListTable_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine ListTable_CreateByArray(Collection, N, Keys, Values) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of key-value pairs class(*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table procedure, public :: Copy => ListTable_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine ListTable_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Note :  SrcObj must be in the ListTable class. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => ListTable_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function ListTable_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => ListTable_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine ListTable_MemFree(Obj) To free memory of the ListTable object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(inout) :: Obj procedure, public :: ToString => ListTable_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function ListTable_ToString(Obj) result(Str) To get the name of the ListTable type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => ListTable_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function ListTable_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( ListTable ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseSymTable ) :: ListTable PRIVATE ! a working doubly-linked list TYPE ( IntrusiveLinearList ) :: WrkLst !> memory pool of list nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => ListTable_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => ListTable_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => ListTable_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => ListTable_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: ListTable_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => ListTable_CopyCollection !> *Destruct* is a procedure deferred by the *BaseCollection* type. <br> !  **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => ListTable_Destroy !> *GetSize* is a procedure deferred by the *BaseCollection* type. <br> !  **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => ListTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => ListTable_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => ListTable_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => ListTable_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => ListTable_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => ListTable_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => ListTable_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => ListTable_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => ListTable_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => ListTable_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListTable Type             ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => ListTable_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => ListTable_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => ListTable_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => ListTable_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListTable_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => ListTable_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListTable_Finalize ! --------------------------------------------------------------------- END TYPE ListTable","tags":"","loc":"type\\listtable.html"},{"title":"HTabRealSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabRealSP The HTabRealSP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabRealSP object. Arguments Type Intent Optional Attributes Name type( HTabRealSP ), intent(inout) :: Table HTabRealSP object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object integer(kind=kInt32), intent(in) :: N number of key-value pairs real(kind=kSingle), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabRealSP , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(in) :: Table HTabRealSP object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(in) :: Table HTabRealSP object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object real(kind=kSingle), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabRealSP ), intent(inout) :: Table HTabRealSP object type( ListRealSP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabrealsp.html"},{"title":"DArrRealSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrRealSP DArrRealSP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kSingle) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrRealSP ), intent(inout) :: Container DArrRealSP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kSingle), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealSP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kSingle), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container DArrRealSP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container DArrRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(inout) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealSP ), intent(in) :: Container DArrRealSP object real(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrrealsp.html"},{"title":"ListObject – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListObject ListObject is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is a derived type in the Object class (i.e. the Object type or its subtypes). Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListObject ), intent(inout) :: List ListObject object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object integer(kind=kInt32), intent(in) :: N number of items class(Object), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListObject object. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(Object), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node class(Object), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(Object), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething Important Note : This operation will not be successful if items stored\n  in different nodes have different types. private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: SameType => LinkedList_SameType Type-Bound Function : SameType Purpose :  To check whether all stored items have the same type or not. Usage : --->    Flag = List%SameType() --->    IF (.NOT.List%SameType()) DoSomeThing private  function LinkedList_SameType(List) result(Flag) To check whether all stored items have same type or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object Return Value logical true if all items have same type procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object class(Object), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object class(Object), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(Object), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething Important Note : This operation will not be successful if items stored\n  in different nodes have different types. private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(inout) :: List ListObject object class(Object), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListObject ), intent(in) :: List ListObject object class(Object), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. Source Code TYPE ListObject PRIVATE !% size of the list container (i.e. number of nodes in the list) tIndex :: Size = 0 !% pointer to the first node (or the head node) of the list TYPE ( DLLNode ), POINTER :: Head => NULL () !% pointer to the last node (or the tail node) of the list TYPE ( DLLNode ), POINTER :: Tail => NULL () !% pointer to the current node used for iteration purpose TYPE ( DLLNode ), POINTER :: Cursor => NULL () !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: SetNewNode => LinkedList_SetNewNode PROCEDURE , PRIVATE :: RemoveNode => LinkedList_RemoveNode PROCEDURE , PRIVATE :: GetNodeAt => LinkedList_GetNodeAt PROCEDURE , PRIVATE :: Traverse => LinkedList_Traverse ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a list from an array of items <br> !  **Usage**: <br> !   --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items PROCEDURE :: Construct => LinkedList_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> ! **Purpose**:  To destruct a list and get its items if requested <br> !  **Usage**: <br> !   --->    CALL List%Destruct()    ! destruct the list <br> !  **Note**: This method is equivalent to the *Clear* method. PROCEDURE :: Destruct => LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddFirst(Item) PROCEDURE :: AddFirst => LinkedList_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddLast(Item) PROCEDURE :: AddLast => LinkedList_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = List%AddAt(Index, Item) <br> !   --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => LinkedList_AddAt !> **Type-Bound Subroutine**: Remove <br> ! **Purpose**:  To remove an item from the list.  The first item is removed !               by default.  If specified, the last item can be removed instead. <br> !  **Usage**: <br> !   --->    CALL List%Remove()          ! remove the first item <br> !   --->    CALL List%Remove(.FALSE.)   ! remove the last item <br> !   --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: Remove => LinkedList_Remove !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveFirst(Item) <br> !   --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveFirst => LinkedList_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveLast(Item) <br> !   --->    IF (.NOT.List%RemoveLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveLast => LinkedList_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveAt => LinkedList_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the list. <br> !  **Usage**: <br> !   --->    CALL List%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !   *StartFirst* and *MoveForward* methods (or the *StartLast* and !   *MoveBackward* methods).  Therefore, after the call to one of those !   methods and then calling this one will result in a removal of the !   current item of the iteration (i.e. the same item that can be retrieved !   via those iteration methods). PROCEDURE :: Delete => LinkedList_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the list. <br> !  **Usage**: <br> !   --->    CALL List%Clear() PROCEDURE :: Clear => LinkedList_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the list.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%ToArray(Items) <br> !   --->    IF (.NOT.List%ToArray(Items)) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored !   in different nodes have different types. PROCEDURE :: ToArray => LinkedList_ToArray !> **Type-Bound Subroutine**: RemoveDuplicates <br> !  **Purpose**:  To remove nodes with duplicated items from the list. <br> !  **Usage**: <br> !   --->    CALL List%RemoveDuplicates() PROCEDURE :: RemoveDuplicates => LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => LinkedList_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move *forward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = List%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveForward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = List%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveForward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveForward => LinkedList_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => LinkedList_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move *backward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = List%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveBackward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = List%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveBackward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveBackward => LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the list is empty or not. <br> !  **Usage**: <br> !   --->    Flag = List%IsEmpty() <br> !   --->    IF (.NOT.List%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => LinkedList_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the list. <br> !  **Usage**: <br> !   --->    ListSize = List%GetSize() PROCEDURE :: GetSize => LinkedList_GetSize !> **Type-Bound Function**: SameType <br> !  **Purpose**:  To check whether all stored items have the same type or not. <br> !  **Usage**: <br> !   --->    Flag = List%SameType() <br> !   --->    IF (.NOT.List%SameType()) DoSomeThing PROCEDURE :: SameType => LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the first item (without removing it from the list). !                Also, return a flag indicating whether the item is available !                or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekFirst(Item) <br> !   --->    IF (.NOT.List%PeekFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekFirst => LinkedList_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the list). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekLast(Item) <br> !   --->    IF (.NOT.List%PeekLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekLast => LinkedList_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the list) at !                the specified index where the index must be between 1 and the !                list size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekAt(Index, Item) <br> !   --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekAt => LinkedList_PeekAt !> **Type-Bound Subroutine**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the list. Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Flag = List%GetAll(Items) <br> !   --->    IF (.NOT.List%GetAll(Items)) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored !   in different nodes have different types. PROCEDURE :: GetAll => LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => LinkedList_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => LinkedList_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => LinkedList_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => LinkedList_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => LinkedList_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: LinkedList_Finalizer ! --------------------------------------------------------------------- END TYPE ListObject","tags":"","loc":"type\\listobject.html"},{"title":"DArrRealDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrRealDP DArrRealDP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kDouble) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrRealDP ), intent(inout) :: Container DArrRealDP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kDouble), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealDP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kDouble), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container DArrRealDP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container DArrRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(inout) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealDP ), intent(in) :: Container DArrRealDP object real(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrrealdp.html"},{"title":"DArrObject – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrObject DArrObject is a container type that employs a dynamic-array implementation\n to provide common operations for a list container.  It can also represent other\n forms of containers including a LIFO stack, a FIFO queue and a double-ended queue\n (deque).  The type of items stored in this container is a derived type in the Object class (i.e. the Object type or its subtypes). Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrObject ), intent(inout) :: Container DynArr object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity and type of items to be stored --->    CALL Container%CreateEmpty(25, Mold) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, Mold, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Mold, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, Mold, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object integer(kind=kInt32), intent(in) :: InitCap initial size of the container class(Object), intent(in) :: Mold mold providing the type of items to be stored integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object integer(kind=kInt32), intent(in) :: N number of items class(Object), intent(in) :: Items (:) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DynArr class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items class(Object), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items class(Object), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container DynArr object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container DynArr object class(Object), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container DynArr object class(Object), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container DynArr object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items class(Object), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(inout) :: Container DynArr object class(Object), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrObject ), intent(in) :: Container DynArr object class(Object), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. Source Code TYPE DArrObject PRIVATE !> incremental size of the container when the container is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16 !% flag to shrink the container capacity tLogical :: Shrink = . FALSE . !% pointer to first item of the queue tIndex :: First = 1_kIndex !% pointer to next to last item of the queue (i.e. the next available slot) tIndex :: Last = 1_kIndex !% size of the container (number of items) tIndex :: Size = 0_kIndex !% pointer to current item of the iteration tIndex :: Cursor = 0_kIndex !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !% items stored in the container. CLASS ( Object ), ALLOCATABLE :: Items (:) CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Offset => DynArr_GetFirst PROCEDURE , PRIVATE :: Resize => DynArr_MemResize PROCEDURE , PRIVATE :: Growing => DynArr_Growing PROCEDURE , PRIVATE :: Shrinking => DynArr_Shrinking PROCEDURE , PRIVATE :: DynArr_CreateByArray ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty container. <br> !  **Usage**: <br> !   ! create an empty container with specified initial capacity and type of items to be stored <br> !   --->    CALL Container%CreateEmpty(25, Mold) <br> !   ! create a container and specify the optional incremental size <br> !   --->    CALL Container%CreateEmpty(25, Mold, IncSize=16) <br> !   ! create a container and specify the optional shrink flag <br> !   --->    CALL Container%CreateEmpty(25, Mold, Shrink=.TRUE.) PROCEDURE :: CreateEmpty => DynArr_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new container from an array of items. <br> !  **Usage**: <br> !           ! create a container from an array of 25 items <br> !   --->    CALL Container%Construct(25, Arr) <br> !           ! create a container and specify the optional incremental size <br> !   --->    CALL Container%Construct(25, Arr, IncSize=16) <br> !           ! create a container and specify the optional shrink flag <br> !   --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) GENERIC :: Construct => DynArr_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the container and free memory !                of items stored in the container.<br> !  **Usage**: <br> !   --->    CALL Container%Destruct() <br> !  **Important Note**:  For the *DynArr* class, this method is not equivalent !   to the *Clear* method.  Therefore, after calling the *Destruct* method, !   the user should reconstruct the container (by calling a *Construction* !   method again) before using other operations once more.  Otherwise, the !   container's behavior may not be as expected. PROCEDURE :: Destruct => DynArr_Destroy ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the container. <br> !  **Usage**: <br> !   --->    CALL Container%AddFirst(Item) PROCEDURE :: AddFirst => DynArr_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the container. <br> !  **Usage**: <br> !   --->    CALL Container%AddLast(Item) PROCEDURE :: AddLast => DynArr_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the container size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = Container%AddAt(Index, Item) <br> !   --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => DynArr_AddAt !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the container. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveFirst(Item) <br> !   --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething PROCEDURE :: RemoveFirst => DynArr_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the container. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveLast(Item) <br> !   --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DynArr_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the container size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => DynArr_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the container. <br> !  **Usage**: <br> !   --->    CALL Container%Delete() <br> !  **Note**: This method is intended to be used in conjunction with !   the *StartFirst* and *MoveForward* methods.  Therefore, after !   the call to one of those methods and then calling this one !   will result in a removal of the current item of the iteration !   (i.e. the same item that can be retrieved via the *StartFirst* !   and *MoveForward* methods). PROCEDURE :: Delete => DynArr_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the container. <br> !  **Usage**: <br> !   --->    CALL Container%Clear() PROCEDURE :: Clear => DynArr_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the container.  Also, return !                a flag indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%ToArray(Items) <br> !   --->    IF (.NOT.Container%ToArray(Items)) DoSomething PROCEDURE :: ToArray => DynArr_ToArray ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the container is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => DynArr_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the container or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the container. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = Container%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Container%MoveForward() !       ! check whether we reach the end of the container or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the container. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = Container%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Container%MoveForward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveForward => DynArr_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the container is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => DynArr_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return !                a flag indicating whether the cursor pointer has reached the !                end of the container or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the container in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Container%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Container%MoveBackward() !       ! check whether we reach the end of the container or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the container in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Container%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Container%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DynArr_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the container. <br> !  **Usage**: <br> !   --->    Size = Container%GetSize() PROCEDURE :: GetSize => DynArr_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the container is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Container%IsEmpty() <br> !   --->    IF (.NOT.Container%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => DynArr_IsEmpty ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekFirst(Item) <br> !   --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => DynArr_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekLast(Item) <br> !   --->    IF (.NOT.Container%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DynArr_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the container) at !                the specified index where the index must be between 1 and the !                container size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => DynArr_PeekAt !> *GetAll* is a procedure deferred by the *BaseIterable* type. <br> !  **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the container. !                Also, return a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Container%GetAll(Items) <br> !   --->    IF (.NOT.Container%GetAll(Items)) DoSomething PROCEDURE :: GetAll => DynArr_GetAll ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => DynArr_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => DynArr_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => DynArr_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => DynArr_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => DynArr_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: DynArr_Finalizer ! --------------------------------------------------------------------- END TYPE DArrObject","tags":"","loc":"type\\darrobject.html"},{"title":"PQ_Heap – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQ_Heap The PQ_Heap type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQ_Heap ), intent(inout) :: PQ PQ_Heap object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap, Mold)                   ! use default options --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)          ! use min-priority queue --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)            ! specify incremental size --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)         ! specify shrinking --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE.)    ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, Mold, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue class(Comparable), intent(in) :: Mold mold logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object integer(kind=kInt32), intent(in) :: N number of keys class(Comparable), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQ_Heap object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object class(Comparable), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object class(Comparable), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object class(Comparable), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(in) :: PQ PQ_Heap object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(in) :: PQ PQ_Heap object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQ_Heap ), intent(inout) :: PQ PQ_Heap object class(Comparable), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pq_heap.html"},{"title":"DArrCmpxDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrCmpxDP DArrCmpxDP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kDouble) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kDouble), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxDP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kDouble), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container DArrCmpxDP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container DArrCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(inout) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxDP ), intent(in) :: Container DArrCmpxDP object complex(kind=kDouble), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrcmpxdp.html"},{"title":"PQInteger2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQInteger2B The PQInteger2B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQInteger2B ), intent(inout) :: PQ PQInteger2B object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt16), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQInteger2B object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt16), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt16), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt16), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(in) :: PQ PQInteger2B object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(in) :: PQ PQInteger2B object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger2B ), intent(inout) :: PQ PQInteger2B object integer(kind=kInt16), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqinteger2b.html"},{"title":"DArrCharacter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrCharacter DArrCharacter is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is CHARACTER . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrCharacter ), intent(inout) :: Container DArrCharacter object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified character length and initial capacity --->    CALL Container%CreateEmpty(80, 25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(80, 25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(80, 25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, CharLen, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object integer(kind=kInt32), intent(in) :: CharLen length of character string integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object integer(kind=kInt32), intent(in) :: N number of items character(len=*), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCharacter class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items character(len=*), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items character(len=*), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=:), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container DArrCharacter object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container DArrCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items character(len=*), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=:), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(inout) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCharacter ), intent(in) :: Container DArrCharacter object character(len=*), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrcharacter.html"},{"title":"ListCmpxQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListCmpxQP ListCmpxQP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kQuad) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListCmpxQP ), intent(inout) :: List ListCmpxQP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kQuad), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListCmpxQP object. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kQuad), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node complex(kind=kQuad), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(in) :: List ListCmpxQP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(in) :: List ListCmpxQP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(in) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(in) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(inout) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxQP ), intent(in) :: List ListCmpxQP object complex(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listcmpxqp.html"},{"title":"HTabInteger1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabInteger1B The HTabInteger1B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabInteger1B object. Arguments Type Intent Optional Attributes Name type( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt32), intent(in) :: N number of key-value pairs integer(kind=kInt8), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabInteger1B , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(in) :: Table HTabInteger1B object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(in) :: Table HTabInteger1B object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object integer(kind=kInt8), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabInteger1B ), intent(inout) :: Table HTabInteger1B object type( ListInteger1B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabinteger1b.html"},{"title":"HTabCharacter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabCharacter The HTabCharacter type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabCharacter object. Arguments Type Intent Optional Attributes Name type( HTabCharacter ), intent(inout) :: Table HTabCharacter object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object integer(kind=kInt32), intent(in) :: N number of key-value pairs character(len=*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=*), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=*), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabCharacter , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(in) :: Table HTabCharacter object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(in) :: Table HTabCharacter object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=*), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object character(len=*), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabCharacter ), intent(inout) :: Table HTabCharacter object type( ListCharacter ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabcharacter.html"},{"title":"HTabObject – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabObject The HTabObject type is a table type that employs an open-addressing hash table\n implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabObject object. Arguments Type Intent Optional Attributes Name type( HTabObject ), intent(inout) :: Table HTabObject object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty(NulObj, DelObj)                  ! use default options --->    CALL Table%CreateEmpty(NulObj, DelObj, InitCap=25)      ! specify initial capacity --->    CALL Table%CreateEmpty(NulObj, DelObj, LoadFactor=0.5)  ! specify load factor --->    CALL Table%CreateEmpty(NulObj, DelObj, ProbAlgo=2)      ! specify probing algorithm --->    CALL Table%CreateEmpty(NulObj, DelObj, 30, 0.75, 3)     ! specify all options Important Note : A user is required to specify two user-defined key-value pair objects to represent a null\n object and a deleted object where these two objects are not the same one when compared using\n the operator == .  Also, these two objects should never be specified in any operations other\n than the construction operations. private  subroutine HashTable_CreateEmpty(Table, NulObj, DelObj, InitCap, LoadFactor, ProbAlgo) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(in) :: NulObj a user-defined object representing a null object; the user should never specify this\n object in any operations other than the construction operations. class(Object), intent(in) :: DelObj a user-defined object representing a deleted object (different from the null object); the user\n should never specify this object in any operations other than the construction operations. integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key-value array. Usage : ! use default options --->    CALL Table%Construct(40, KeyValArr, NulObj, DelObj) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyValArr, NulObj, DelObj, LoadFactor, ProbAlgo) Important Note : A user is required to specify two user-defined key-value pair objects to represent a null\n object and a deleted object where these two objects are not the same one when compared using\n the operator == .  Also, these two objects should never be specified in any operations other\n than the construction operations. private  subroutine HashTable_CreateByArray(Table, N, KeyVals, NulObj, DelObj, LoadFactor, ProbAlgo) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object integer(kind=kInt32), intent(in) :: N number of key-value pairs class(Object), intent(in) :: KeyVals (:) the key-value pairs to be added to the table class(Object), intent(in) :: NulObj a user-defined object representing a null object; the user should never specify this\n object in any operations other than the construction operations. class(Object), intent(in) :: DelObj a user-defined object representing a deleted object (different from the null object); the user\n should never specify this object in any operations other than the construction operations. real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure, public :: Clear => HashTable_ClearBuckets Type-Bound Subroutine : Clear Purpose :  To free components of the buckets from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearBuckets(Table) To free components of the buckets from the table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(KeyVal) private  subroutine HashTable_Insert(Table, KeyVal) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(in) :: KeyVal key to be inserted and its associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not. Usage : --->    Flag = Table%Remove(KeyVal) --->    IF (.NOT.Table%Remove(KeyVal)) DoSomething private  function HashTable_Remove(Table, KeyVal) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(in) :: KeyVal key to be removed and its associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKeyVal) private  function HashTable_Move2FirstPair(Table, KeyVal) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(out), optional :: KeyVal the first key and its associated value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKeyVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, KeyVal) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabObject , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored bucket(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(out), optional :: KeyVal the next key and its associated value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(in) :: Table HTabObject object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(in) :: Table HTabObject object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(KeyVal) --->    IF (.NOT.Table%Contain(KeyVal)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object class(Object), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all key-value pairs. Usage : --->    CALL Tree%GetKeys(KeyValQueue) private  subroutine HashTable_GetAllKeys(Table, KeyValQ) To return all keys in the table (and all associated values). Arguments Type Intent Optional Attributes Name class( HTabObject ), intent(inout) :: Table HTabObject object type( ListObject ), intent(out) :: KeyValQ key-value queue","tags":"","loc":"type\\htabobject.html"},{"title":"OrderedSymTable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseSymTable ) :: OrderedSymTable The OrderedSymTable type is an abstract collection type that defines an API for an\n ordered symbol table. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. subroutine IfaceDestroy(Collection) Prototype IfaceDestroy is an interface for a procedure to destruct the collection where items\n are all removed first (this operation is essentially the same as that of the Clear method) and the storage of those items are then freed.   For the second operation,\n this may also be done by the Clear method for some collections.  However, for others\n (such as dynamic-array-based collections), this must only be done by this procedure. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: Collection collection object procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. function IfaceSize(Collection) result(Size) Prototype IfaceSize is an interface for a procedure to get the current size of the collection,\n  which represents the number of items currently stored in the collection. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) collection size generic, public :: Construct => CopyCollection subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. function IfaceStartFirst(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) Prototype IfaceStartFirst is an interface for a procedure to move to the first (starting)\n pair data in a symbol table.  It is provided for an iteration over all key-value\n pairs in a symbol table. For an ordered symbol table, the first pair data normally means the key-value pair\n with the smallest key.  For an unordered symbol table, the first pair data can be\n any key-value pair. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection is empty or not procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. function IfaceMoveNext(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) Prototype IfaceMoveNext is an interface for a procedure to move to the next pair data in a symbol\n table.  It is provided for an iteration over all key-value pairs in a symbol table. For an ordered symbol table, the next pair data normally indicates the key-value pair\n with the so-called successor key.  For an unordered symbol table, the next pair data may\n be any key-value pair. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the end of the collection is encountered or not procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified key-value pair to the\n  collection. subroutine IfaceInsert(Collection, Key, Value) Prototype IfaceInsert is an interface for a procedure to add a key-value pair into a symbol\n table.  When implementing this procedure, a symbol table should only allow one value\n being associated with each key (i.e. no duplicate keys in the table).  This means that\n when a user puts a key-value pair into a table already containing that key (and its\n associated value), the new value should then replace the old one.  These conventions\n define the associative array abstraction, where we can think of a symbol table as being\n just like an array, where keys are indices and values are array entries. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the value to be added to the collection procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current key-value pair from the\n  collection.  This method is intended to be employed in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of\n  those methods and then calling this one will result in a removal of the current\n  key-value pair of the iteration (i.e. the same key-value pair that can be obtained\n  via the StartFirst and MoveForward methods). subroutine IfaceDelete(Collection) Prototype IfaceDelete is an interface for a procedure to delete the current key-value pair\n from a symbol table.  This procedure is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to either method\n and then calling this procedure will result in a removal of the current key-value\n pair of the iteration (i.e. the same key-value pair that can be retrieved via those\n iteration methods). Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object procedure(IfaceRemove), public, deferred :: Remove Remove is a deferred procedure to remove the specified key (and its associated\n  value) from the collection. function IfaceRemove(Collection, Key) result(Success) Prototype IfaceRemove is an interface for a procedure to delete the specified key (and its\n associated value) from a symbol table.  Also, return a flag indicating whether the\n key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure(IfaceContain), public, deferred :: Contain Contain is a deferred procedure to check whether the specified key is in the\n  collection or not. function IfaceContain(Collection, Key) result(Found) Prototype IfaceContain is an interface for a procedure to check whether the specified key is in\n a symbol table or not.  Return true if the key is found.  Otherwise, return false. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure(IfaceGetVal), public, deferred :: GetValue GetValue is a deferred procedure to get a value associated with the specified key\n  in the collection. function IfaceGetVal(Collection, Key, Value, ValCopy) result(Success) Prototype IfaceGetVal is an interface for a procedure to obtain a value associated with the\n specified key in a symbol table.  Also, return a flag indicating whether the value\n is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the value is successfully retrieved or not. procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all key-value pairs from\n  the collection. function IfaceToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) Prototype IfaceToArray is an interface for a procedure to get and remove all key-value pairs\n  from the collection.  Also, return a flag indicating whether the items are successfully\n  removed or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection iterable collection object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all keys and/or all values (without\n  removing them) from the collection. function IfaceGetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) Prototype IfaceGetAll is an interface for a procedure to get all keys and/or all values from\n  the collection.  Also, return a flag indicating whether the keys (and/or values) are\n  successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection iterable collection object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseSymTable_ClearEntries(Collection) To remove all of the pair data items from the collection. This routine provides a basic implementation of the Clear deferred procedure required by the BaseCollection class.\n This routine should be overridden if a better implementation\n is available. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure(IfaceMinKey), public, deferred :: GetMinKey GetMinKey is a deferred procedure to get the smallest key (and optionally a value\n  associated with it) in a symbol table. function IfaceMinKey(Collection, Key, Value, ValCopy) result(Flag) Prototype IfaceMinKey is an interface for a procedure to get the smallest key (and optionally\n a value associated with the key) in a symbol table.  Also, return a flag indicating\n whether the key is successfully retrieved or not.  If the table is empty, the flag is\n typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(inout) :: Key the smallest key to be retrieved from the collection class(*), intent(inout), optional :: Value the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure(IfaceMaxKey), public, deferred :: GetMaxKey GetMaxKey is a deferred procedure to get the largest key (and optionally a value\n  associated with it) in a symbol table. function IfaceMaxKey(Collection, Key, Value, ValCopy) result(Flag) Prototype IfaceMaxKey is an interface for a procedure to get the largest key (and optionally\n a value associated with the key) in a symbol table.  Also, return a flag indicating\n whether the key is successfully retrieved or not.  If the table is empty, the flag\nis typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(inout) :: Key the largest key to be retrieved from the collection class(*), intent(inout), optional :: Value the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure(IfaceFloor), public, deferred :: Floor Floor is a deferred procedure to get the largest key (and optionally a value\n  associated with it) in a symbol table less than or equal to the given key. function IfaceFloor(Collection, KeyIn, KeyOut, ValOut, ValCopy) result(Flag) Prototype GetFloor is an interface for a procedure to get the largest key (and optionally\n a value associated with the key) in a symbol table less than or equal to the given\n key.  Also, return a flag indicating whether the floor key is successfully obtained\n or not. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: KeyIn the specified key class(*), intent(inout) :: KeyOut the largest key in the table less than or equal to the given key class(*), intent(inout), optional :: ValOut the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure(IfaceCeiling), public, deferred :: Ceiling Ceiling is a deferred procedure to get the smallest key (and optionally a value\n  associated with it) in a symbol table greater than or equal to the given key. function IfaceCeiling(Collection, KeyIn, KeyOut, ValOut, ValCopy) result(Flag) Prototype IfaceCeiling is an interface for a procedure to get the smallest key (and optionally\n a value associated with the key) in a symbol table greater than or equal to the given\n key.  Also, return a flag indicating whether the ceiling key is successfully retrieved\n or not. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: KeyIn the specified key class(*), intent(inout) :: KeyOut the smallest key in the table less than or equal to the given key class(*), intent(inout), optional :: ValOut the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure(IfaceRank), public, deferred :: GetRank GetRank is a deferred procedure to return the number of keys in the symbol table\n  strictly less than the given key. function IfaceRank(Collection, Key) result(Rank) Prototype IfaceRank is an interface for a procedure to get the number of keys in the symbol\n table strictly less than the given key. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the specified key Return Value integer(kind=kInt32) the number of keys less than the given key. procedure(IfaceSelect), public, deferred :: Select Select is a deferred procedure to get the key (and optionally its associated value) of\n  the specified rank where the applicable range of rank is between 0 and TableSize-1. function IfaceSelect(Collection, Rank, Key, Value, ValCopy) result(Flag) Prototype KeySelect is an interface for a procedure to get the key (and optionally its\n associated value) of the given rank.  Also, return a flag indicating whether the\n ranked key is successfully retrieved or not. This ranked key has the property such that there are keys in the symbol table that\n are smaller.  In other words, this key is the (rank+1)st smallest key in the table. The applicable range of rank is between 0 and TableSize-1 where the rank number is\n zero-based.  If the specified rank is out of range or the table is empty, set the\n returned flag to false.  Otherwise, set the returned flag to true. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table integer(kind=kInt32), intent(in) :: Rank the specified rank class(*), intent(inout) :: Key the key of the specified rank class(*), intent(inout), optional :: Value the value associated with the ranked key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure(IfaceDelMin), public, deferred :: RemoveMin RemoveMin is a deferred procedure to remove the smallest key (and a value associated\n  with it) from a symbol table. function IfaceDelMin(Collection, Key, Value, ValCopy) result(Flag) Prototype IfaceDelMin is an interface for a procedure to remove the smallest key and a value\n associated with the key from a symbol table.  Also, return a flag indicating whether\n the key is successfully removed or not.  If the table is empty, the flag is typically\n false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(inout), optional :: Key the smallest key class(*), intent(inout), optional :: Value the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key is successfully removed or not procedure(IfaceDelMax), public, deferred :: RemoveMax RemoveMax is a deferred procedure to remove the largest key (and a value associated\n  with it) from a symbol table. function IfaceDelMax(Collection, Key, Value, ValCopy) result(Flag) Prototype IfaceDelMax is an interface for a procedure to remove the largest key and a value\n associated with the key from a symbol table.  Also, return a flag indicating whether\n the key is successfully removed or not.  If the table is empty, the flag is typically\n false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(inout), optional :: Key the largest key class(*), intent(inout), optional :: Value the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key is successfully removed or not procedure(IfaceRangeSize), public, deferred :: GetRangeSize GetRangeSize is a deferred procedure to return the number of keys between KeyLo (inclusive) and KeyHi (inclusive). function IfaceRangeSize(Collection, KeyLo, KeyHi) result(Size) Prototype IfaceRangeSize is an interface for a procedure to get the number of keys in the given\n  range (between KeyLo and KeyHi). Arguments Type Intent Optional Attributes Name class( OrderedSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: KeyLo the minimum key (inclusive) class(*), intent(in) :: KeyHi the maximum key (inclusive) Return Value integer(kind=kInt32) the number of keys in the given range Source Code TYPE , ABSTRACT , EXTENDS ( BaseSymTable ) :: OrderedSymTable CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *GetMinKey* is a deferred procedure to get the smallest key (and optionally a value !   associated with it) in a symbol table. <br> PROCEDURE ( IfaceMinKey ), DEFERRED :: GetMinKey !> *GetMaxKey* is a deferred procedure to get the largest key (and optionally a value !   associated with it) in a symbol table. <br> PROCEDURE ( IfaceMaxKey ), DEFERRED :: GetMaxKey !> *Floor* is a deferred procedure to get the largest key (and optionally a value !   associated with it) in a symbol table less than or equal to the given key. <br> PROCEDURE ( IfaceFloor ), DEFERRED :: Floor !> *Ceiling* is a deferred procedure to get the smallest key (and optionally a value !   associated with it) in a symbol table greater than or equal to the given key. <br> PROCEDURE ( IfaceCeiling ), DEFERRED :: Ceiling !> *GetRank* is a deferred procedure to return the number of keys in the symbol table !   strictly less than the given key. <br> PROCEDURE ( IfaceRank ), DEFERRED :: GetRank !> *Select* is a deferred procedure to get the key (and optionally its associated value) of !   the specified rank where the applicable range of rank is between 0 and TableSize-1. <br> PROCEDURE ( IfaceSelect ), DEFERRED :: Select !> *RemoveMin* is a deferred procedure to remove the smallest key (and a value associated !   with it) from a symbol table. <br> PROCEDURE ( IfaceDelMin ), DEFERRED :: RemoveMin !> *RemoveMax* is a deferred procedure to remove the largest key (and a value associated !   with it) from a symbol table. <br> PROCEDURE ( IfaceDelMax ), DEFERRED :: RemoveMax !> *GetRangeSize* is a deferred procedure to return the number of keys between *KeyLo* !   (inclusive) and *KeyHi* (inclusive). <br> PROCEDURE ( IfaceRangeSize ), DEFERRED :: GetRangeSize ! --------------------------------------------------------------------- END TYPE OrderedSymTable","tags":"","loc":"type\\orderedsymtable.html"},{"title":"ListAnyType – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListAnyType ListAnyType is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container can be any data type. Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListAnyType ), intent(inout) :: List ListAnyType object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListAnyType object. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(*), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node class(*), intent(out), optional, ALLOCATABLE :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(*), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items, MakeCopy) --->    IF (.NOT.List%ToArray(Items), MakeCopy) DoSomething Important Note : This operation will not be successful if items stored in\n  different nodes have different types.  Also, a user must supply a procedure\n  to make a copy of an item for the specific type of stored items. private  function LinkedList_ToArray(List, Items, MakeCopy) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list procedure(CopyData) :: MakeCopy procedure to copy items Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates(Compare) Important Note : A user must supply a procedure to compare items stored\n  in the list. private  subroutine LinkedList_RemoveDuplicates(List, Compare) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object procedure(CompareData) :: Compare procedure to compare items procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), optional, ALLOCATABLE :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), optional, ALLOCATABLE :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), optional, ALLOCATABLE :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), optional, ALLOCATABLE :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: SameType => LinkedList_SameType Type-Bound Function : SameType Purpose :  To check whether all stored items have the same type or not. Usage : --->    Flag = List%SameType() --->    IF (.NOT.List%SameType()) DoSomeThing private  function LinkedList_SameType(List) result(Flag) To check whether all stored items have same type or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object Return Value logical true if all items have same type procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items class(*), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items, MakeCopy) --->    IF (.NOT.List%GetAll(Items), MakeCopy) DoSomething Important Note : This operation will not be successful if items stored in\n  different nodes have different types.  Also, a user must supply a procedure\n  to make a copy of an item for the specific type of stored items. private  function LinkedList_GetAllItems(List, Items, MakeCopy) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items procedure(CopyData) :: MakeCopy procedure to copy items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(inout) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListAnyType ), intent(in) :: List ListAnyType object class(*), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. Source Code TYPE ListAnyType PRIVATE !% size of the list container (i.e. number of nodes in the list) tIndex :: Size = 0 !% pointer to the first node (or the head node) of the list TYPE ( DLLNode ), POINTER :: Head => NULL () !% pointer to the last node (or the tail node) of the list TYPE ( DLLNode ), POINTER :: Tail => NULL () !% pointer to the current node used for iteration purpose TYPE ( DLLNode ), POINTER :: Cursor => NULL () !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: SetNewNode => LinkedList_SetNewNode PROCEDURE , PRIVATE :: RemoveNode => LinkedList_RemoveNode PROCEDURE , PRIVATE :: GetNodeAt => LinkedList_GetNodeAt PROCEDURE , PRIVATE :: Traverse => LinkedList_Traverse ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a list from an array of items <br> !  **Usage**: <br> !   --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items PROCEDURE :: Construct => LinkedList_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> ! **Purpose**:  To destruct a list and get its items if requested <br> !  **Usage**: <br> !   --->    CALL List%Destruct()    ! destruct the list <br> !  **Note**: This method is equivalent to the *Clear* method. PROCEDURE :: Destruct => LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddFirst(Item) PROCEDURE :: AddFirst => LinkedList_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddLast(Item) PROCEDURE :: AddLast => LinkedList_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = List%AddAt(Index, Item) <br> !   --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => LinkedList_AddAt !> **Type-Bound Subroutine**: Remove <br> ! **Purpose**:  To remove an item from the list.  The first item is removed !               by default.  If specified, the last item can be removed instead. <br> !  **Usage**: <br> !   --->    CALL List%Remove()          ! remove the first item <br> !   --->    CALL List%Remove(.FALSE.)   ! remove the last item <br> !   --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: Remove => LinkedList_Remove !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveFirst(Item) <br> !   --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveFirst => LinkedList_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveLast(Item) <br> !   --->    IF (.NOT.List%RemoveLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveLast => LinkedList_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveAt => LinkedList_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the list. <br> !  **Usage**: <br> !   --->    CALL List%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !   *StartFirst* and *MoveForward* methods (or the *StartLast* and !   *MoveBackward* methods).  Therefore, after the call to one of those !   methods and then calling this one will result in a removal of the !   current item of the iteration (i.e. the same item that can be retrieved !   via those iteration methods). PROCEDURE :: Delete => LinkedList_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the list. <br> !  **Usage**: <br> !   --->    CALL List%Clear() PROCEDURE :: Clear => LinkedList_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the list.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%ToArray(Items, MakeCopy) <br> !   --->    IF (.NOT.List%ToArray(Items), MakeCopy) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored in !   different nodes have different types.  Also, a user must supply a procedure !   to make a copy of an item for the specific type of stored items. PROCEDURE :: ToArray => LinkedList_ToArray !> **Type-Bound Subroutine**: RemoveDuplicates <br> !  **Purpose**:  To remove nodes with duplicated items from the list. <br> !  **Usage**: <br> !   --->    CALL List%RemoveDuplicates(Compare) <br> !  **Important Note**: A user must supply a procedure to compare items stored !   in the list. PROCEDURE :: RemoveDuplicates => LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => LinkedList_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move *forward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = List%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveForward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = List%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveForward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveForward => LinkedList_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => LinkedList_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move *backward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = List%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveBackward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = List%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveBackward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveBackward => LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the list is empty or not. <br> !  **Usage**: <br> !   --->    Flag = List%IsEmpty() <br> !   --->    IF (.NOT.List%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => LinkedList_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the list. <br> !  **Usage**: <br> !   --->    ListSize = List%GetSize() PROCEDURE :: GetSize => LinkedList_GetSize !> **Type-Bound Function**: SameType <br> !  **Purpose**:  To check whether all stored items have the same type or not. <br> !  **Usage**: <br> !   --->    Flag = List%SameType() <br> !   --->    IF (.NOT.List%SameType()) DoSomeThing PROCEDURE :: SameType => LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the first item (without removing it from the list). !                Also, return a flag indicating whether the item is available !                or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekFirst(Item) <br> !   --->    IF (.NOT.List%PeekFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekFirst => LinkedList_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the list). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekLast(Item) <br> !   --->    IF (.NOT.List%PeekLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekLast => LinkedList_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the list) at !                the specified index where the index must be between 1 and the !                list size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekAt(Index, Item) <br> !   --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekAt => LinkedList_PeekAt !> **Type-Bound Subroutine**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the list. Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Flag = List%GetAll(Items, MakeCopy) <br> !   --->    IF (.NOT.List%GetAll(Items), MakeCopy) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored in !   different nodes have different types.  Also, a user must supply a procedure !   to make a copy of an item for the specific type of stored items. PROCEDURE :: GetAll => LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => LinkedList_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => LinkedList_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => LinkedList_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => LinkedList_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => LinkedList_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: LinkedList_Finalizer ! --------------------------------------------------------------------- END TYPE ListAnyType","tags":"","loc":"type\\listanytype.html"},{"title":"PQInteger1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQInteger1B The PQInteger1B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQInteger1B ), intent(inout) :: PQ PQInteger1B object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt8), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQInteger1B object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt8), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt8), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt8), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(in) :: PQ PQInteger1B object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(in) :: PQ PQInteger1B object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger1B ), intent(inout) :: PQ PQInteger1B object integer(kind=kInt8), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqinteger1b.html"},{"title":"PQ_Basic – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQ_Basic The PQ_Basic type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQBasic_Finalizer To perform finalization of the object. private  subroutine PQBasic_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQ_Basic ), intent(inout) :: PQ PQ_Basic object Type-Bound Procedures procedure, public :: CreateEmpty => PQBasic_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap, Mold)                 ! use default options --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, Mold, Unordered=.TRUE.)    ! specify unordered PQ --->    CALL Table%CreateEmpty(32, Mold, SortAscend=WiseSort) ! specify ascending sorting algorithm --->    CALL Table%CreateEmpty(32, Mold, SortDescend=TimSort) ! specify descending sorting algorithm ! specify all options --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE., .TRUE., RustSort, IntroSort) private  subroutine PQBasic_CreateEmpty(PQ, InitCap, Mold, MinPQ, IncSize, Shrink, Unordered, SortAscend, SortDescend) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue class(Comparable), intent(in) :: Mold mold logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. logical, intent(in), optional :: Unordered true if the priority queue to be internally implemented as an unordered array PQ;\n default is an ordered array PQ. procedure(Sort), optional :: SortAscend procedure to sort in ascending order procedure(Sort), optional :: SortDescend procedure to sort in descending order procedure, public :: Construct => PQBasic_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink, Unordered, SortAscend, SortDescend) private  subroutine PQBasic_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink, Unordered, SortAscend, SortDescend) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object integer(kind=kInt32), intent(in) :: N number of keys class(Comparable), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. logical, intent(in), optional :: Unordered true if the priority queue to be internally implemented as an unordered array PQ;\n default is an ordered array PQ. procedure(Sort), optional :: SortAscend procedure to sort in ascending order procedure(Sort), optional :: SortDescend procedure to sort in descending order procedure, public :: Destruct => PQBasic_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQBasic_Destructor(PQ, Keys) To destruct PQ_Basic object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object class(Comparable), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQBasic_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQBasic_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object class(Comparable), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQBasic_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQBasic_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object class(Comparable), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQBasic_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQBasic_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(in) :: PQ PQ_Basic object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQBasic_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQBasic_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(in) :: PQ PQ_Basic object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQBasic_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQBasic_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQ_Basic ), intent(inout) :: PQ PQ_Basic object class(Comparable), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pq_basic.html"},{"title":"TreeRealSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeRealSP TreeRealSP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeRealSP ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys real(kind=kSingle), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree type( ListRealSP ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree TreeRealSP object real(kind=kSingle), intent(in) :: Low low key real(kind=kSingle), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Low low key real(kind=kSingle), intent(in) :: High high key type( ListRealSP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree type( ListRealSP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: InKey input key real(kind=kSingle), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: InKey input key real(kind=kSingle), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank real(kind=kSingle), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree real(kind=kSingle), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeRealSP ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treerealsp.html"},{"title":"QueueLinked – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseIterable ) :: QueueLinked Description : The QueueLinked type is a collection type that employs a linked-list implementation\n  to provide common operations for a FIFO queue. Usage Overview : The QueueLinked type is a queue collection type that provides common operations of\n  a FIFO queue.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items or from another collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Enqueue method - method to insert an item to the end of the collection, (2.2) Dequeue method - method to get and remove the first item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalization Procedures final :: QueueLinked_Finalize To perform finalization of the object. private  subroutine QueueLinked_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( QueueLinked ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseIterable_ClearItems(Collection) To remove all of the items from the collection.  This routine provides a basic implementation\n of the Clear deferred procedure required by the BaseCollection class. This routine should be overridden if a better implementation is available. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. interface private module subroutine QueueLinked_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueLinked_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueLinked_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueLinked_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueLinked_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueLinked_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueLinked_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueLinked_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueLinked_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  interface QueueLinked_CopyCollection() Arguments None private  interface QueueLinked_CreateByArray() Arguments None generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) private  interface QueueLinked_AddElm() Arguments None procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueLinked_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueLinked_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueLinked_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueLinked_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueLinked_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Obj procedure, public :: ToString => QueueLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function QueueLinked_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueLinked_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseIterable ) :: QueueLinked PRIVATE !> a working doubly-linked list TYPE ( IntrusiveLinearList ) :: WrkLst !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of linked nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: QueueLinked_CreateByArray !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE , PRIVATE :: BaseString => QueueLinked_BaseString ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method in place of the *CopyCollection* method to !  create a collection from another collection. PROCEDURE :: CopyCollection => QueueLinked_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory of items stored !                in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => QueueLinked_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => QueueLinked_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => QueueLinked_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether the !                cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => QueueLinked_Move2NextElm !> Use the *Enqueue* method in place of the *Insert* method to add an item to the queue. PROCEDURE :: Insert => QueueLinked_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => QueueLinked_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => QueueLinked_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, !                return a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => QueueLinked_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => QueueLinked_CreateByArray !> **Type-Bound Subroutine**: Enqueue <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Enqueue(Item) GENERIC :: Enqueue => Insert !> **Type-Bound Function**: Dequeue <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Dequeue(Item) <br> !   --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething PROCEDURE :: Dequeue => QueueLinked_Dequeue !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekFirst(Item) <br> !   --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => QueueLinked_PeekFirst ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => QueueLinked_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => QueueLinked_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => QueueLinked_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => QueueLinked_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => QueueLinked_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: QueueLinked_Finalize ! --------------------------------------------------------------------- END TYPE QueueLinked","tags":"","loc":"type\\queuelinked.html"},{"title":"StackLinked – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( QueueLinked ) :: StackLinked Description : The StackLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a LIFO stack. Usage Overview : The StackLinked type is a stack collection type that provides common operations of\n  a LIFO stack.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items another or from collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Push method - method to insert an item at the top of the collection, (2.2) Pop method - method to get and remove the top (last) item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekTop method - method to retrieve the top (last) item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Note : Since the StackLinked type is a subtype of the QueueLinked type, it can also\n           be used as a FIFO queue. Finalization Procedures final :: StackLinked_Finalize To perform finalization of the object. private  subroutine StackLinked_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( StackLinked ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseIterable_ClearItems(Collection) To remove all of the items from the collection.  This routine provides a basic implementation\n of the Clear deferred procedure required by the BaseCollection class. This routine should be overridden if a better implementation is available. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. interface private module subroutine QueueLinked_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueLinked_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueLinked_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueLinked_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueLinked_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueLinked_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueLinked_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueLinked_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueLinked_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray private  interface QueueLinked_CopyCollection() Arguments None private  interface QueueLinked_CreateByArray() Arguments None generic, public :: Enqueue => Insert private  interface QueueLinked_AddElm() Arguments None procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueLinked_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueLinked_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueLinked_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueLinked_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueLinked_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Obj procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueLinked_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Obj Return Value integer(kind=kInt32) generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) private  interface QueueLinked_AddElm() Arguments None procedure, public :: Pop => StackLinked_Pop Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething interface private module function StackLinked_Pop(Collection, Item, ItemCopy) result(Success) To get and remove the top (last) item of the collection.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( StackLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekTop => StackLinked_PeekTop Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething interface private module function StackLinked_PeekTop(Collection, Item, ItemCopy) result(Success) To get the top (last) item (without removing it from the collection). Also,\n return a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( StackLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: ToString => StackLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function StackLinked_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( StackLinked ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE Source Code TYPE , EXTENDS ( QueueLinked ) :: StackLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething PROCEDURE :: Pop => StackLinked_Pop !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething PROCEDURE :: PeekTop => StackLinked_PeekTop ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StackLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: StackLinked_Finalize ! --------------------------------------------------------------------- END TYPE StackLinked","tags":"","loc":"type\\stacklinked.html"},{"title":"DequeLinked – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( QueueLinked ) :: DequeLinked Description : The DequeLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a double-ended queue (deque).  It can be used as a FIFO\n  queue or a LIFO stack as well. Usage Overview : The DequeLinked type is a deque collection type that provides common operations of\n  a double-ended queue (deque).  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items or from another collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) AddFirst method - method to insert an item to the front of the collection, (2.2) AddLast method - method to insert an item to the end of the collection, (2.3) RemoveFirst method - method to get and remove the first item of the collection, (2.4) RemoveLast method - method to get and remove the last item of the collection, (2.5) Clear method - method to remove all items from the collection. (2.6) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) PeekLast method - method to retrieve the last item of the collection, (3.3) GetSize method - method to get the collection size (number of items stored), (3.4) IsEmpty method - method to check whether the collection is empty or not. (3.5) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item, (4.3) StartLast method - method to start a backward iteration over items, (4.4) MoveBackward method - method to move backward to the previous item. Note : The DequeArray type also supports the usual Enqueue , Dequeue and PeekFirst operations of a FIFO queue as well as the usual Push , Pop and PeekTop operations\n      of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be\n      used in place of insert , remove , peek operations of a deque as desired. Finalization Procedures final :: DequeLinked_Finalize To perform finalization of the object. private  subroutine DequeLinked_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DequeLinked ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseIterable_ClearItems(Collection) To remove all of the items from the collection.  This routine provides a basic implementation\n of the Clear deferred procedure required by the BaseCollection class. This routine should be overridden if a better implementation is available. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. interface private module subroutine QueueLinked_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueLinked_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueLinked_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueLinked_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueLinked_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueLinked_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueLinked_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueLinked_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueLinked_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray private  interface QueueLinked_CopyCollection() Arguments None private  interface QueueLinked_CreateByArray() Arguments None generic, public :: Enqueue => Insert private  interface QueueLinked_AddElm() Arguments None procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueLinked_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueLinked_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueLinked_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueLinked_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueLinked_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Obj procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueLinked_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: StartLast => DequeLinked_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating whether\n               the collection is empty or not. Usage :  See the MoveBackward method. interface private module function DequeLinked_Move2LastElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the last element in the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the last element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DequeLinked_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the collection in reverse\n  order. ! start backward iteration (from the last item)\n  IsTheEnd = Collection%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward(CurrItem)\n  END DO interface private module function DequeLinked_Move2PrevElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the previous element in the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the previous element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: AddFirst => DequeLinked_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) interface private module subroutine DequeLinked_AddFirst(Collection, Item) To insert the specified item at the start of the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) private  interface QueueLinked_AddElm() Arguments None generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething private  interface QueueLinked_Dequeue() Arguments None procedure, public :: RemoveLast => DequeLinked_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection.  Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething interface private module function DequeLinked_RemoveLast(Collection, Item, ItemCopy) result(Success) To get and remove the last item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekLast => DequeLinked_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection).  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething interface private module function DequeLinked_PeekLast(Collection, Item, ItemCopy) result(Success) To get the last item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) private  interface QueueLinked_AddElm() Arguments None generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething private  interface DequeLinked_RemoveLast() Arguments None generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething private  interface DequeLinked_PeekLast() Arguments None procedure, public :: ToString => DequeLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function DequeLinked_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE Source Code TYPE , EXTENDS ( QueueLinked ) :: DequeLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**:  See the *MoveBackward* method. PROCEDURE :: StartLast => DequeLinked_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse across the collection !   in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Collection%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward() !       ! check whether we reach the end of the collection or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the collection in reverse !   order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Collection%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DequeLinked_Move2PrevElm !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddFirst(Item) PROCEDURE :: AddFirst => DequeLinked_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddLast(Item) GENERIC :: AddLast => Insert !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the collection.  Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveFirst(Item) <br> !   --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething GENERIC :: RemoveFirst => Dequeue !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the collection.  Also, return a flag !                indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveLast(Item) <br> !   --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DequeLinked_RemoveLast !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the collection).  Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekLast(Item) <br> !   --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DequeLinked_PeekLast ! --------------------------------------------------------------------- ! -----             Redefined Stack Operations                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection.  Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething GENERIC :: Pop => RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething GENERIC :: PeekTop => PeekLast ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => DequeLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: DequeLinked_Finalize ! --------------------------------------------------------------------- END TYPE DequeLinked","tags":"","loc":"type\\dequelinked.html"},{"title":"ListLinked – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( DequeLinked ) :: ListLinked Description : The ListLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a list. Usage Overview : The ListLinked type provides insert, remove and peek operations at a specified index\n  where the index must be between 1 and the collection size.  The ListLinked type is a\n  subtype of the DequeLinked type; therefore, all operations available for the DequeLinked type are also available for the ListLinked type.  Furthermore, it thus\n  can be used as a deque, a FIFO queue or a LIFO stack. Finalization Procedures final :: ListLinked_Finalize To perform finalization of the object. private  subroutine ListLinked_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListLinked ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseIterable_ClearItems(Collection) To remove all of the items from the collection.  This routine provides a basic implementation\n of the Clear deferred procedure required by the BaseCollection class. This routine should be overridden if a better implementation is available. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. interface private module subroutine QueueLinked_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueLinked_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueLinked_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueLinked_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueLinked_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueLinked_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueLinked_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueLinked_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueLinked_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray private  interface QueueLinked_CopyCollection() Arguments None private  interface QueueLinked_CreateByArray() Arguments None generic, public :: Enqueue => Insert private  interface QueueLinked_AddElm() Arguments None procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueLinked_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueLinked_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueLinked_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueLinked_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueLinked_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(inout) :: Obj procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueLinked_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueLinked ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: StartLast => DequeLinked_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating whether\n               the collection is empty or not. Usage :  See the MoveBackward method. interface private module function DequeLinked_Move2LastElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the last element in the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the last element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DequeLinked_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the collection in reverse\n  order. ! start backward iteration (from the last item)\n  IsTheEnd = Collection%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward(CurrItem)\n  END DO interface private module function DequeLinked_Move2PrevElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the previous element in the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the previous element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: AddFirst => DequeLinked_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) interface private module subroutine DequeLinked_AddFirst(Collection, Item) To insert the specified item at the start of the collection. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection generic, public :: AddLast => Insert private  interface QueueLinked_AddElm() Arguments None generic, public :: RemoveFirst => Dequeue private  interface QueueLinked_Dequeue() Arguments None procedure, public :: RemoveLast => DequeLinked_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection.  Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething interface private module function DequeLinked_RemoveLast(Collection, Item, ItemCopy) result(Success) To get and remove the last item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekLast => DequeLinked_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection).  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething interface private module function DequeLinked_PeekLast(Collection, Item, ItemCopy) result(Success) To get the last item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( DequeLinked ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. generic, public :: Push => Insert private  interface QueueLinked_AddElm() Arguments None generic, public :: Pop => RemoveLast private  interface DequeLinked_RemoveLast() Arguments None generic, public :: PeekTop => PeekLast private  interface DequeLinked_PeekLast() Arguments None procedure, public :: AddAt => ListLinked_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where the index must\n               be between 1 and the collection size.  Also, return a flag indicating\n               whether the item is successfully added. Usage : --->    Success = Collection%AddAt(Index, Item) --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething interface private module function ListLinked_AddAt(Collection, Index, Item) result(Success) To insert the specified item at the specified position in the collection. Arguments Type Intent Optional Attributes Name class( ListLinked ), intent(inout) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to add the item class(*), intent(in) :: Item the item to be added to the collection Return Value logical flag indicating whether the item is successfully added or not. procedure, public :: RemoveAt => ListLinked_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where the index must be\n               between 1 and the collection size.  Also, return a flag indicating whether\n               the item is successfully removed. Usage : --->    Success = Collection%RemoveAt(Index, Item) --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething interface private module function ListLinked_RemoveAt(Collection, Index, Item, ItemCopy) result(Success) To get and remove the item at the specified position.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLinked ), intent(inout) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to retrieve and remove the item class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekAt => ListLinked_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the collection) at the specified\n               index where the index must be between 1 and the collection size.  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekAt(Index, Item) --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething interface private module function ListLinked_PeekAt(Collection, Index, Item, ItemCopy) result(Success) To retrieve the item at the specified position (without removing it from the\n collection). Also, return a flag indicating whether the item is successfully\n retrieved or not. Arguments Type Intent Optional Attributes Name class( ListLinked ), intent(inout) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to retrieve the item class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: ToString => ListLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function ListLinked_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( ListLinked ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE Source Code TYPE , EXTENDS ( DequeLinked ) :: ListLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where the index must !                be between 1 and the collection size.  Also, return a flag indicating !                whether the item is successfully added. <br> !  **Usage**: <br> !   --->    Success = Collection%AddAt(Index, Item) <br> !   --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => ListLinked_AddAt !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where the index must be !                between 1 and the collection size.  Also, return a flag indicating whether !                the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => ListLinked_RemoveAt !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the collection) at the specified !                index where the index must be between 1 and the collection size.  Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => ListLinked_PeekAt ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListLinked_Finalize ! --------------------------------------------------------------------- END TYPE ListLinked","tags":"","loc":"type\\listlinked.html"},{"title":"HashTree – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseSymTable ) :: HashTree The HashTree type is a collection type that employs a separate-chaining hash table\n implementation to provide common operations for an unordered symbol table.  The HashTree type utilizes the IntrusiveHashTree type as its component to store TabNode objects.\n As an intrusive container, the IntrusiveHashTree type provides common operations for\n hash table without a memory management task.  The memory management task of the inserted TabNode objects is handled by the HashTree type. As an unordered symbol table, the HashTree type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the HashTree type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalization Procedures final :: HashTree_Finalize To perform finalization of the object. private  subroutine HashTree_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( HashTree ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseSymTable_ClearEntries(Collection) To remove all of the pair data items from the collection. This routine provides a basic implementation of the Clear deferred procedure required by the BaseCollection class.\n This routine should be overridden if a better implementation\n is available. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure, public :: CopyCollection => HashTree_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine HashTree_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => HashTree_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine HashTree_Destroy(Collection) To destruct the collection. This is a deferred procedure by the BaseCollection class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection HashTree object procedure, public :: GetSize => HashTree_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function HashTree_GetSize(Collection) result(Size) To get the number of items in the collection.\n This is a deferred procedure inherited from the BaseCollection type. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(in) :: Collection Return Value integer(kind=kInt32) procedure, public :: StartFirst => HashTree_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) private  function HashTree_Move2FirstPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) To move to the first (starting) pair data in a symbol table.\n For the HashTree , which is an unordered symbol table,\n the starting pair is the first pair inserted. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no pair data or not - true if the collection is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) private  function HashTree_Move2NextPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) To move to the next pair data in a symbol table.\n For the HashTree , which is an unordered symbol table,\n the next pair is the pair inserted after the previous one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => HashTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) private  subroutine HashTree_Insert(Collection, Key, Value) To add a key-value pair into a symbol table.  If the specified key is already\n stored in the table, replace the old value with the new one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the associated value to be added to the collection procedure, public :: Delete => HashTree_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). private  subroutine HashTree_Delete(Collection) To delete a key-value pair from a symbol table.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward procedures.\n Therefore, after the call to either procedure and then calling this procedure\n will result in a removal of the current key-value pair of the iteration (i.e.\n the same key-value pair that can be retrieved via those Move procedures). This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object procedure, public :: Remove => HashTree_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function HashTree_Remove(Collection, Key) result(Flag) To delete the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: Contain => HashTree_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething private  function HashTree_Contain(Collection, Key) result(Found) To check whether the specified key is currently stored in a symbol table. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTree_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething private  function HashTree_GetValue(Collection, Key, Value, ValCopy) result(Flag) To get a value associated with the specified key in a symbol table.\n Also, return a flag indicating whether the key-value pair is successfully\n found or not. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: ToArray => HashTree_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething private  function HashTree_ToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get and remove all key-value pairs from the collection.  Also, return a flag\n indicating whether the pairs are successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection HashTree object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => HashTree_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething private  function HashTree_GetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get all keys and/or all values (without removing them) from the collection.  Also,\n return a flag indicating whether the keys and/or values are successfully retrieved. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection HashTree object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: CreateEmpty => HashTree_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()            ! use default options --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity private  subroutine HashTree_CreateEmpty(Collection, InitCap) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table generic, public :: Construct => CopyCollection , HashTree_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine HashTree_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine HashTree_CreateByArray(Collection, N, Keys, Values) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of key-value pairs class(*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table procedure, public :: Copy => HashTree_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine HashTree_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Note :  SrcObj must be in the HashTree class. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => HashTree_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function HashTree_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => HashTree_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine HashTree_MemFree(Obj) To free memory of the HashTree object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(inout) :: Obj procedure, public :: ToString => HashTree_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function HashTree_ToString(Obj) result(Str) To get the name of the HashTree type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => HashTree_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function HashTree_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( HashTree ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseSymTable ) :: HashTree PRIVATE ! a working hash table TYPE ( IntrusiveHashTree ) :: WrkTab !> memory pool of hash-tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashTree_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashTree_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashTree_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => HashTree_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: HashTree_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashTree_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashTree_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashTree_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashTree_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashTree_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashTree_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => HashTree_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashTree_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashTree_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashTree_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashTree_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashTree_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()            ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity <br> PROCEDURE :: CreateEmpty => HashTree_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) <br> GENERIC :: Construct => HashTree_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashTree_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashTree_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashTree_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashTree_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashTree_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: HashTree_Finalize ! --------------------------------------------------------------------- END TYPE HashTree","tags":"","loc":"type\\hashtree.html"},{"title":"BaseIterable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseCollection ) :: BaseIterable The BaseIterable type is an abstract collection type that defines an API for\n iterable collections, which are collections that can iterate over their items. It is important to note that, by design, a concrete collection type that extends\n from the BaseIterable type only stores items of one specific type.  To store\n items of another type, the collection must be cleared and/or destructed. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. subroutine IfaceDestroy(Collection) Prototype IfaceDestroy is an interface for a procedure to destruct the collection where items\n are all removed first (this operation is essentially the same as that of the Clear method) and the storage of those items are then freed.   For the second operation,\n this may also be done by the Clear method for some collections.  However, for others\n (such as dynamic-array-based collections), this must only be done by this procedure. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: Collection collection object procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. function IfaceSize(Collection) result(Size) Prototype IfaceSize is an interface for a procedure to get the current size of the collection,\n  which represents the number of items currently stored in the collection. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) collection size generic, public :: Construct => CopyCollection subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. function IfaceStartFirst(Collection, Item, ItemCopy) result(IsEmpty) Prototype IfaceStartFirst is an interface for a procedure to move to the first element in an\n  iterable collection. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection is empty or not procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. function IfaceMoveNext(Collection, Item, ItemCopy) result(IsTheEnd) Prototype IfaceMoveNext is an interface for a procedure to move to the next element in an\n  iterable collection. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the end of the collection is encountered or not procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified item to the collection.  This\n  is a default procedure for adding an item to the collection.  For a particular collection,\n  an alias name (e.g. the Push method for a stack or the Enqueue method for a queue)\n  may be used in place of the Insert method. subroutine IfaceInsert(Collection, Item) Prototype IfaceInsert is an interface for a procedure to add an item to a collection.  For a\n collection with various add procedures.  This procedure should be the default one. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object class(*), intent(in) :: Item the item to be added to the collection procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current item from the collection.  This\n  method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration (i.e. the same item that\n  can be retrieved via the StartFirst and MoveForward methods). subroutine IfaceDelete(Collection) Prototype IfaceDelete is an interface for a procedure to delete an item from a collection.\n  This procedure is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to either method and then calling\n  this procedure will result in a removal of the current item of the iteration (i.e.\n  the same item that can be retrieved via those iteration methods). Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all items from the collection. function IfaceToArray(Collection, Items, ItemCopy) result(Success) Prototype IfaceToArray is an interface for a procedure to get and remove all items from the\n  collection.  Also, return a flag indicating whether the items are successfully\n  removed or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully removed. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all items (without removing them) from the\n  collection. function IfaceGetAll(Collection, Items, ItemCopy) result(Success) Prototype IfaceGetAll is an interface for a procedure to get all items (without removing them)\n  from the collection.  Also, return a flag indicating whether the items are successfully\n  retrieved or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection iterable collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseIterable_ClearItems(Collection) To remove all of the items from the collection.  This routine provides a basic implementation\n of the Clear deferred procedure required by the BaseCollection class. This routine should be overridden if a better implementation is available. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid Source Code TYPE , ABSTRACT , EXTENDS ( BaseCollection ) :: BaseIterable PRIVATE CLASS ( * ), ALLOCATABLE :: Mold CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *StartFirst* is a deferred procedure to start the *forward* iteration. <br> PROCEDURE ( IfaceStartFirst ), DEFERRED :: StartFirst !> *MoveForward* is a deferred procedure to move to the next iteration. <br> PROCEDURE ( IfaceMoveNext ), DEFERRED :: MoveForward !> *Insert* is a deferred procedure to insert the specified item to the collection.  This !   is a default procedure for adding an item to the collection.  For a particular collection, !   an alias name (e.g. the *Push* method for a stack or the *Enqueue* method for a queue) !   may be used in place of the *Insert* method. <br> PROCEDURE ( IfaceInsert ), DEFERRED :: Insert !> *Delete* is a deferred procedure to delete the current item from the collection.  This !   method is intended to be used in conjunction with the *StartFirst* and *MoveForward* !   methods.  Therefore, after the call to one of those methods and then calling this one !   will result in a removal of the current item of the iteration (i.e. the same item that !   can be retrieved via the *StartFirst* and *MoveForward* methods). <br> PROCEDURE ( IfaceDelete ), DEFERRED :: Delete !> *ToArray* is a deferred procedure to retrieve and remove all items from the collection. <br> PROCEDURE ( IfaceToArray ), DEFERRED :: ToArray !> *GetAll* is a deferred procedure to retrieve all items (without removing them) from the !   collection. <br> PROCEDURE ( IfaceGetAll ), DEFERRED :: GetAll ! --------------------------------------------------------------------- ! -----      Deferred Procedures from BaseCollection Type         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() <br> !  **Note**: The *Clear* method provided by the *BaseIterable* type is !       a simple implementation.   It can be overridden by a better and !       more efficient implementation. PROCEDURE :: Clear => BaseIterable_ClearItems !> **Type-Bound Function**: GetItemPtr <br> !  **Purpose**:  To get a pointer to an item stored in a collection.  The pointer is !       intended to be used as a mold for the item (i.e. to provide type of the stored !       items).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    ValPtr => Collection%GetItemPtr() PROCEDURE :: GetItemPtr => BaseIterable_GetItemPtr ! --------------------------------------------------------------------- ! -----       Public Procedures To Be Used Internally             ----- ! --------------------------------------------------------------------- !> *SetMold* is a procedure to set a mold of stored items.  This procedure is intended !   to be used only by a subtype of the *BaseIterable* type, not by a user. PROCEDURE :: SetMold => BaseIterable_SetMold !> *FreeMold* is a procedure to free the mold of stored items.  This procedure is intended !   to be used only by a subtype of the *BaseIterable* type, not by a user. PROCEDURE :: FreeMold => BaseIterable_FreeMold !> *IsItemValid* is a procedure to check whether the specified item is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseIterable* type, not by !   a user. PROCEDURE :: IsItemValid => BaseIterable_IsItemValid ! --------------------------------------------------------------------- END TYPE BaseIterable","tags":"","loc":"type\\baseiterable.html"},{"title":"PQInteger4B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQInteger4B The PQInteger4B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQInteger4B ), intent(inout) :: PQ PQInteger4B object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt32), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQInteger4B object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(in) :: PQ PQInteger4B object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(in) :: PQ PQInteger4B object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger4B ), intent(inout) :: PQ PQInteger4B object integer(kind=kInt32), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqinteger4b.html"},{"title":"HashMap – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseSymTable ) :: HashMap The HashMap type is a collection type that employs an open-addressing hash table\n implementation to provide common operations for an unordered symbol table.  It makes\n no guarantees as to the iteration order of the symbol table; in particular, it does\n not guarantee that the order will remain constant over time. Finalization Procedures final :: HashMap_Finalize To perform finalization of the hash table. private  subroutine HashMap_Finalize(Collection) To perform finalization of the collection. Arguments Type Intent Optional Attributes Name type( HashMap ), intent(inout) :: Collection collection Type-Bound Procedures procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure, public :: CopyCollection => HashMap_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine HashMap_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => HashMap_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() private  subroutine HashMap_ClearItems(Collection) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection procedure, public :: Destruct => HashMap_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. private  subroutine HashMap_Destroy(Collection) To destruct the table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection procedure, public :: GetSize => HashMap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function HashMap_GetSize(Collection) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: Collection collection Return Value integer(kind=kInt32) the number of keys procedure, public :: IsEmpty => HashMap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function HashMap_IsEmpty(Collection) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: Collection collection Return Value logical true if the table is empty procedure, public :: StartFirst => HashMap_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) private  function HashMap_Move2FirstPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashMap_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) private  function HashMap_Move2NextPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HashMap , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => HashMap_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) private  subroutine HashMap_Insert(Collection, Key, Value) To add a key-value pair into the hash table.  If the specified key is already stored\n in the table, replace the old value with the new one. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Delete => HashMap_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine HashMap_Delete(Collection) To delete a key-value pair of the current iteration from a symbol table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection symbol-table collection object procedure, public :: Remove => HashMap_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function HashMap_Remove(Collection, Key) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(in) :: Key key to be removed Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: Contain => HashMap_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething private  function HashMap_Contain(Collection, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashMap_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection. Also,\n      return a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething private  function HashMap_GetValue(Collection, Key, Value, ValCopy) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection class(*), intent(in) :: Key key to be looked for class(*), intent(inout) :: Value associated value procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: ToArray => HashMap_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething private  function HashMap_ToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get and remove all key-value pairs from the collection.  Also, return a flag\n indicating whether the pairs are successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection HashMap object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => HashMap_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething private  function HashMap_GetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get all keys and/or all values (without removing them) from the collection.  Also,\n return a flag indicating whether the keys and/or values are successfully retrieved. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection HashMap object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: CreateEmpty => HashMap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashMap_CreateEmpty(Collection, InitCap, LoadFactor, ProbAlgo, HashCalc, KeyCopy, ValCopy) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key; if not present, use default one. procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). generic, public :: Construct => CopyCollection , HashMap_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional arguments (see the CreateEmpy method) --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine HashMap_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine HashMap_CreateByArray(Collection, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc, KeyCopy, ValCopy) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of key-value pairs class(*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key; if not present, use default one. procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Copy => HashMap_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine HashMap_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Note :  SrcObj must be in the HashMap class. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep flag indicating whether to perform deep copy or shallow copy; - if true, perform shallow copy; - if false, perform deep copy; default is false. procedure, public :: IsEqualTo => HashMap_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function HashMap_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => HashMap_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine HashMap_MemFree(Obj) To free memory of the HashMap object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(inout) :: Obj procedure, public :: ToString => HashMap_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function HashMap_ToString(Obj) result(Str) To get the name of the HashMap type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => HashMap_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function HashMap_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( HashMap ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseSymTable ) :: HashMap PRIVATE !% current capacity of the hash table tIndex :: Capacity = DefaultCapacity !% working table items used to store key-value pairs TYPE ( TabItem ), ALLOCATABLE :: Items (:) !% current index into the working items (used for iteration purpose) tIndex :: Indx = 0_kIndex !% the number of keys not yet visited (used for iteration purpose) tIndex :: KeyLeft = 0_kIndex !% current modification count (used for iteration purpose) tIndex :: IterModCount = 0_kIndex !% load factor tRealDP :: LoadFactor = DefaultLoadFactor !% threshold for resizing tIndex :: Threshold = 0_kIndex !% modification count tIndex :: ModCount = 0_kIndex !% the total number of used buckets inside the hash table (including cells marked as deleted). tIndex :: UsedBuckets = 0_kIndex !% the total number of unique keys currently inside the hash table. tIndex :: KeyCount = 0_kIndex !% probing algorithm tSInt32 :: ProbAlgo = LinearProbing !% index for double hashing tHash :: HashIndx = 0_kIndex !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool !% pointer to a hash function PROCEDURE ( HashFunc ), NOPASS , POINTER :: HashCalc => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: KeyCopy => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: ValCopy => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyItem) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashMap_FindKey !> **Type-Bound Subroutine**: Resize <br> !  **Purpose**:  To resize the collection to the specified capacity. <br> !  **Usage**: <br> !   --->    CALL Collection%Resize(64) PROCEDURE , PRIVATE :: Resize => HashMap_Resize !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: HashMap_CreateByArray !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashMap_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashMap_GetAllVals ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashMap_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => HashMap_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => HashMap_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashMap_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => HashMap_IsEmpty ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashMap_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashMap_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashMap_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => HashMap_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashMap_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashMap_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. Also, !       return a flag indicating whether the key-value pair is successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashMap_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashMap_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashMap_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()                           ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity <br> !   --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor <br> !   --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm <br> !   --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function <br> !   --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options <br> !  **Note**: Any suitable hash function routine from the *ModBase_SimpleHash32*, !       *ModBase_SimpleHash64*, *ModBase_ReferenceHash32*, *ModBase_ReferenceHash64* !       *ModBase_OptimalHash32*, and *ModBase_OptimalHash64* modules can be used to !       specify the *HashCal* argument.  The term *suitable* means that any routine !       that has exactly the same interface as the *HashFunc* abstract function !       is the suitable one.  <br> !  **Note2**: Depending on a type of indices defined in the '*Macro - Basic Definitions.f90*' !       file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices !       while a 64-bit hash-function routine is a suitable one for 64-bit integer indices. !       This is a compile-time choice.  <br> PROCEDURE :: CreateEmpty => HashMap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection and specify the optional arguments (see the *CreateEmpy* method) <br> !   --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => HashMap_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashMap_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashMap_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashMap_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashMap_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashMap_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash table. FINAL :: HashMap_Finalize ! --------------------------------------------------------------------- END TYPE HashMap","tags":"","loc":"type\\hashmap.html"},{"title":"TreeRealDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeRealDP TreeRealDP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeRealDP ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys real(kind=kDouble), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree type( ListRealDP ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree TreeRealDP object real(kind=kDouble), intent(in) :: Low low key real(kind=kDouble), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Low low key real(kind=kDouble), intent(in) :: High high key type( ListRealDP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree type( ListRealDP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: InKey input key real(kind=kDouble), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: InKey input key real(kind=kDouble), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank real(kind=kDouble), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree real(kind=kDouble), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeRealDP ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treerealdp.html"},{"title":"HTabInteger4B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabInteger4B The HTabInteger4B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabInteger4B object. Arguments Type Intent Optional Attributes Name type( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in) :: N number of key-value pairs integer(kind=kInt32), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabInteger4B , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(in) :: Table HTabInteger4B object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(in) :: Table HTabInteger4B object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object integer(kind=kInt32), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabInteger4B ), intent(inout) :: Table HTabInteger4B object type( ListInteger4B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabinteger4b.html"},{"title":"TreeTable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( OrderedSymTable ) :: TreeTable The TreeTable type is a collection type that utilizes a balanced BST implementation to\n  provide common operations for an ordered symbol table.  The TreeTable type uses the IntrusiveRBTree type as its component to store TabNode objects.  As an intrusive\n  BST container, the IntrusiveRBTree type provides common binary-search-tree operations\n  without a memory management task.  The memory management task of the inserted TabNode objects is handled by the TreeTable type. As an ordered symbol table, the TreeTable type is a subtype of the OrderedSymTable type.  Thus, it implements all deferred procedures required by the OrderedSymTable type and all its super classes.  As a symbol table, the TreeTable type does not allow\n  duplicated keys; therefore, if an inserted key is equal to a key stored in the table, an\n  associated value of the stored key is replaced by an associated value of the inserted key. Because the IntrusiveRBTree type is a subtype of the IntrusiveAVLTree type, the WrkTree component can be employed as a red-black tree or an AVL tree.  Therefore, the TreeTable type allows a user to specify which type of binary-search tree implementation\n  to be used.  By default, the red-black tree implementation is used.  The user can call the UseAVLTree method to change to AVL tree implementation.  The UseAVLTree method must\n  be called before inserting an object into the symbol table (i.e when the table is empty).\n  Otherwise, the red-black tree implementation is employed. Finalization Procedures final :: TreeTable_Finalize To perform finalization of the object. private  subroutine TreeTable_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeTable ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure, public :: CopyCollection => TreeTable_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine TreeTable_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the OrderedSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => TreeTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() private  subroutine TreeTable_ClearItems(Collection) To remove all of the items from the collection.  This is a deferred procedure\n by the BaseCollection class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection TreeTable object procedure, public :: Destruct => TreeTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine TreeTable_Destroy(Collection) To destruct the collection.  This is a deferred procedure by the BaseCollection class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection TreeTable object procedure, public :: GetSize => TreeTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function TreeTable_GetSize(Collection) result(Size) To get the number of items in the collection.  This is a deferred procedure\n by the BaseCollection type. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(in) :: Collection Return Value integer(kind=kInt32) procedure, public :: StartFirst => TreeTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) private  function TreeTable_Move2FirstPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) To move to the first (starting) pair data in a symbol table.  For the TreeTable , which\n is an ordered symbol table, the starting pair is the pair with smallest key. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the smallest key as output if requested (and available) class(*), intent(inout), optional :: Value the associated value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no pair data or not - true if the collection is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => TreeTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) private  function TreeTable_Move2NextPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) To move to the next pair data in a symbol table.  For the TreeTable , which is an\n ordered symbol table, the next pair is the so-called successor pair. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: StartLast => TreeTable_Move2LastPair Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order and return a flag\n               indicating whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartLast() --->    IsEmpty = Collection%StartLast(LastKey) --->    IsEmpty = Collection%StartLast(Value=LastVal) --->    IsEmpty = Collection%StartLast(LastKey, LastVal) private  function TreeTable_Move2LastPair(Collection, Key, Value, ValCopy) result(IsEmpty) To move to the last (starting in a reversed order) pair data in a symbol table. For the TreeTable , which is an ordered symbol table,  the starting pair in a reversed order\n is the pair with greatest key. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the greatest key as output if requested (and available) class(*), intent(inout), optional :: Value the associated value as output if requested (and available) procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no pair data or not - true if the collection is empty. - otherwise the first pair data is available. procedure, public :: MoveBackward => TreeTable_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveBackward() --->    IsTheEnd = Collection%MoveBackward(PrevKey) --->    IsTheEnd = Collection%MoveBackward(Value=PrevVal) --->    IsTheEnd = Collection%MoveBackward(PrevKey, PrevVal) private  function TreeTable_Move2PrevPair(Collection, Key, Value, ValCopy) result(IsTheEnd) To move to the previous pair data in a symbol table.  For the TreeTable , which is an\n ordered symbol table,  the previous pair is the so-called predecessor pair. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the previous key as output if requested (and available) class(*), intent(inout), optional :: Value the previous value as output if requested (and available) procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => TreeTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) private  subroutine TreeTable_Insert(Collection, Key, Value) To add a key-value pair into a symbol table.  If the specified key is already stored\n in the table, replace the old value with the new one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the associated value to be added to the collection procedure, public :: Delete => TreeTable_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine TreeTable_Delete(Collection) To delete a key-value pair from a symbol table.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward procedures.\n Therefore, after the call to either procedure and then calling this procedure\n will result in a removal of the current key-value pair of the iteration (i.e.\n the same key-value pair that can be retrieved via those Move procedures). This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object procedure, public :: Remove => TreeTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function TreeTable_Remove(Collection, Key) result(Flag) To delete the specified key (and its associated value) from a symbol table.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: Contain => TreeTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething private  function TreeTable_Contain(Collection, Key) result(Found) To check whether the specified key is currently stored in a symbol table. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => TreeTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection. Also,\n      return a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething private  function TreeTable_GetValue(Collection, Key, Value, ValCopy) result(Flag) To get a value associated with the specified key in a symbol table.\n Also, return a flag indicating whether the key-value pair is successfully\n found or not. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: ToArray => TreeTable_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething private  function TreeTable_ToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get and remove all key-value pairs from the collection.  Also, return a flag\n indicating whether the pairs are successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection TreeTable object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => TreeTable_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething private  function TreeTable_GetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get all keys and/or all values (without removing them) from the collection.  Also,\n return a flag indicating whether the keys and/or values are successfully retrieved. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection TreeTable object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: GetMinKey => TreeTable_GetMinKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated\n               with it) in a symbol table.  Also, return a flag indicating\n               whether the key is successfully retrieved or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%GetMinKey(Key) --->    IF (.NOT.Collection%GetMinKey(Key, Value)) DoSomething private  function TreeTable_GetMinKey(Collection, Key, Value, ValCopy) result(Flag) To get the smallest key (and optionally a value associated with it) in a symbol table.\n Also, return a flag indicating whether the key is successfully retrieved or not.  If\n the table is empty, the flag is typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout) :: Key the smallest key to be retrieved from the collection class(*), intent(inout), optional :: Value the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => TreeTable_GetMaxKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated\n               with it) in a symbol table.  Also, return a flag indicating\n               whether the key is successfully retrieved or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%GetMaxKey(Key) --->    IF (.NOT.Collection%GetMaxKey(Key, Value)) DoSomething private  function TreeTable_GetMaxKey(Collection, Key, Value, ValCopy) result(Flag) To get the largest key (and optionally a value associated with it)\n in a symbol table.  Also, return a flag indicating whether the key\n is successfully retrieved or not.  If the table is empty, the flag\n is typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout) :: Key the largest key to be retrieved from the collection class(*), intent(inout), optional :: Value the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Floor => TreeTable_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated\n               with it) in a symbol table less than or equal to the given\n               key.  Also, return a flag indicating whether the floor key\n               is successfully retrieved or not. Usage : --->    Flag = Collection%Floor(KeyIn, KeyOut) --->    IF (.NOT.Collection%Floor(KeyIn, KeyOut, Value)) DoSomething private  function TreeTable_Floor(Collection, KeyIn, KeyOut, ValOut, ValCopy) result(Flag) To the largest key (and optionally a value associated with the key) in\n a collection less than or equal to the given key.  Also, return a flag\n indicating whether the floor key is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: KeyIn the specified key class(*), intent(inout) :: KeyOut the largest key in the table less than or equal to the given key class(*), intent(inout), optional :: ValOut the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => TreeTable_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated\n               with it) in a symbol table greater than or equal to the given\n               key.  Also, return a flag indicating whether the ceiling key\n               is successfully retrieved or not. Usage : --->    Flag = Collection%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Collection%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function TreeTable_Ceiling(Collection, KeyIn, KeyOut, ValOut, ValCopy) result(Flag) To the smallest key (and optionally a value associated with the key) in\n a collection greater than or equal to the given key.  Also, return a flag\n indicating whether the floor key is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: KeyIn the specified key class(*), intent(inout) :: KeyOut the smallest key in the table greater than or equal to the given key class(*), intent(inout), optional :: ValOut the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => TreeTable_GetRank Type-Bound Function : GetRank Purpose :  To return the number of keys in the symbol table strictly\n               less than the given key. Usage : --->    KeyRank = Collection%GetRank(Key) private  function TreeTable_GetRank(Collection, Key) result(Rank) To get the number of keys in the symbol table strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the specified key Return Value integer(kind=kInt32) the number of keys less than the given key. procedure, public :: Select => TreeTable_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the\n               specified rank where the applicable range of rank is between\n               0 and TableSize-1. Also, return a flag indicating whether the\n               ranked key is successfully retrieved or not. --->    Flag = Collection%Select(Rank, Key) --->    IF (.NOT.Collection%Select(Rank, Key, Value)) DoSomething private  function TreeTable_Select(Collection, Rank, Key, Value, ValCopy) result(Flag) To get the key (and optionally its associated value) of the given rank.\n Also, return a flag indicating whether the ranked key is successfully\n retrieved or not. This ranked key has the property such that there are keys in the symbol\n table that are smaller.  In other words, this key is the (rank+1)st smallest\n key in the table. The applicable range of rank is between 0 and TableSize-1 where the rank number\n is zero-based.  If the specified rank is out of range or the table is empty,\n the returned flag is false.  Otherwise, the returned flag is true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object integer(kind=kInt32), intent(in) :: Rank the specified rank. class(*), intent(inout) :: Key the key of the specified rank class(*), intent(inout), optional :: Value the value associated with the ranked key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: RemoveMin => TreeTable_RemoveMin Type-Bound Function : RemoveMin Purpose :  To remove the smallest key (and a value associated with it)\n               from a symbol table.  Also, return a flag indicating\n               whether the key is successfully removed or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%RemoveMin() --->    Flag = Collection%RemoveMin(MinKey) --->    Flag = Collection%RemoveMin(Value=MinVal) --->    IF (.NOT.Collection%RemoveMin(MinKey, MinVal)) DoSomething private  function TreeTable_RemoveMin(Collection, Key, Value, ValCopy) result(Flag) To remove the smallest key and a value associated with the key from\n a symbol table.  Also, return a flag indicating whether the key is\n successfully removed or not.  If the table is empty, the flag is\n typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the smallest key class(*), intent(inout), optional :: Value the value associated with the smallest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key is successfully removed or not. procedure, public :: RemoveMax => TreeTable_RemoveMax Type-Bound Function : RemoveMax Purpose :  To remove the largest key (and a value associated with it)\n               from a symbol table.  Also, return a flag indicating\n               whether the key is successfully removed or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%RemoveMax() --->    Flag = Collection%RemoveMax(MaxKey) --->    Flag = Collection%RemoveMax(Value=MaxVal) --->    IF (.NOT.Collection%RemoveMax(MaxKey, MaxVal)) DoSomething private  function TreeTable_RemoveMax(Collection, Key, Value, ValCopy) result(Flag) To remove the largest key and a value associated with the key from\n a symbol table.  Also, return a flag indicating whether the key is\n successfully removed or not.  If the table is empty, the flag is\n typically false.  Otherwise, the flag is always true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the largest key class(*), intent(inout), optional :: Value the value associated with the largest key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key is successfully removed or not. procedure, public :: GetRangeSize => TreeTable_RangeSize Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Collection%GetRangeSize(KeyLo, KeyHi) private  function TreeTable_RangeSize(Collection, KeyLo, KeyHi) result(Size) To get the number of keys in the given range (between KeyLo and KeyHi). Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: KeyLo the minimum key (inclusive) class(*), intent(in) :: KeyHi the maximum key (inclusive) Return Value integer(kind=kInt32) the number of keys in the given range. generic, public :: Construct => CopyCollection , TreeTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine TreeTable_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the OrderedSymTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine TreeTable_CreateByArray(Collection, N, Keys, Values) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of key-value pairs class(*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table procedure, public :: UseAVLTree => TreeTable_UseAVLTree Type-Bound Subroutine : UseAVLTree Purpose :  To set the working tree component to work as an AVL tree. Usage : --->    CALL Collection%UseAVLTree() Note : The collection must be empty when calling this method. private  subroutine TreeTable_UseAVLTree(Collection) To set the IsRBTree component to false. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection collection object procedure, public :: UseRBTree => TreeTable_UseRBTree Type-Bound Subroutine : UseRBTree Purpose :  To set the working tree component to work as an red-black RB tree. Usage : --->    CALL Collection%UseRBTree() Note : The collection must be empty when calling this method. private  subroutine TreeTable_UseRBTree(Collection) To set the IsRBTree component to true. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection collection object procedure, public :: Check => TreeTable_CheckIntegrity Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function TreeTable_CheckIntegrity(Collection, Message) result(Flag) To check integrity of the binary-search-tree (BST) data structure. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Collection symbol-table collection object character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: Message message indicating the reason why the tree did not pass the\n integrity test Return Value logical flag for integrity - true if the tree passed the integrity test.\n- false if the tree did not. procedure, public :: Copy => TreeTable_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine TreeTable_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.  This is a deferred procedure\n inherited from the Object type. Note :  SrcObj must be in the TreeTable class. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => TreeTable_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function TreeTable_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => TreeTable_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine TreeTable_MemFree(Obj) To free memory of the TreeTable object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(inout) :: Obj procedure, public :: ToString => TreeTable_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function TreeTable_ToString(Obj) result(Str) To get the name of the TreeTable type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => TreeTable_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function TreeTable_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( TreeTable ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( OrderedSymTable ) :: TreeTable PRIVATE !> a flag indicating whether to use the red-black tree implementation !  or the AVL tree implementation tLogical :: IsRBTree = TrueVal !% a working binary-search tree TYPE ( IntrusiveRBTree ) :: WrkTree !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To check whether the specified key is stored in the !                collection or not.  Optionally, return a stored node !                containing a key equal to the specified key. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => TreeTable_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => TreeTable_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => TreeTable_GetAllVals !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: TreeTable_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => TreeTable_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => TreeTable_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => TreeTable_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => TreeTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => TreeTable_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => TreeTable_Move2NextPair !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order and return a flag !                indicating whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartLast() <br> !   --->    IsEmpty = Collection%StartLast(LastKey) <br> !   --->    IsEmpty = Collection%StartLast(Value=LastVal) <br> !   --->    IsEmpty = Collection%StartLast(LastKey, LastVal) PROCEDURE :: StartLast => TreeTable_Move2LastPair !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveBackward() <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevKey) <br> !   --->    IsTheEnd = Collection%MoveBackward(Value=PrevVal) <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevKey, PrevVal) PROCEDURE :: MoveBackward => TreeTable_Move2PrevPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => TreeTable_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => TreeTable_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => TreeTable_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => TreeTable_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. Also, !       return a flag indicating whether the key-value pair is successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => TreeTable_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => TreeTable_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => TreeTable_GetAll ! --------------------------------------------------------------------- ! -----     Deferred Procedures from OrderedSymTable Type         ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetMinKey <br> !  **Purpose**:  To get the smallest key (and optionally a value associated !                with it) in a symbol table.  Also, return a flag indicating !                whether the key is successfully retrieved or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetMinKey(Key) <br> !   --->    IF (.NOT.Collection%GetMinKey(Key, Value)) DoSomething PROCEDURE :: GetMinKey => TreeTable_GetMinKey !> **Type-Bound Function**: GetMaxKey <br> !  **Purpose**:  To get the largest key (and optionally a value associated !                with it) in a symbol table.  Also, return a flag indicating !                whether the key is successfully retrieved or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetMaxKey(Key) <br> !   --->    IF (.NOT.Collection%GetMaxKey(Key, Value)) DoSomething PROCEDURE :: GetMaxKey => TreeTable_GetMaxKey !> **Type-Bound Function**: Floor <br> !  **Purpose**:  To get the largest key (and optionally a value associated !                with it) in a symbol table less than or equal to the given !                key.  Also, return a flag indicating whether the floor key !                is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Floor(KeyIn, KeyOut) <br> !   --->    IF (.NOT.Collection%Floor(KeyIn, KeyOut, Value)) DoSomething PROCEDURE :: Floor => TreeTable_Floor !> **Type-Bound Function**: Ceiling <br> !  **Purpose**:  To get the smallest key (and optionally a value associated !                with it) in a symbol table greater than or equal to the given !                key.  Also, return a flag indicating whether the ceiling key !                is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Ceiling(KeyIn, KeyOut) <br> !   --->    IF (.NOT.Collection%Ceiling(KeyIn, KeyOut, Value)) DoSomething PROCEDURE :: Ceiling => TreeTable_Ceiling !> **Type-Bound Function**: GetRank <br> !  **Purpose**:  To return the number of keys in the symbol table strictly !                less than the given key. <br> !  **Usage**: <br> !   --->    KeyRank = Collection%GetRank(Key) PROCEDURE :: GetRank => TreeTable_GetRank !> **Type-Bound Subroutine**: Select <br> !  **Purpose**:  To get the key (and optionally its associated value) of the !                specified rank where the applicable range of rank is between !                0 and TableSize-1. Also, return a flag indicating whether the !                ranked key is successfully retrieved or not. <br> !   --->    Flag = Collection%Select(Rank, Key) <br> !   --->    IF (.NOT.Collection%Select(Rank, Key, Value)) DoSomething PROCEDURE :: Select => TreeTable_Select !> **Type-Bound Function**: RemoveMin <br> !  **Purpose**:  To remove the smallest key (and a value associated with it) !                from a symbol table.  Also, return a flag indicating !                whether the key is successfully removed or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMin() <br> !   --->    Flag = Collection%RemoveMin(MinKey) <br> !   --->    Flag = Collection%RemoveMin(Value=MinVal) <br> !   --->    IF (.NOT.Collection%RemoveMin(MinKey, MinVal)) DoSomething PROCEDURE :: RemoveMin => TreeTable_RemoveMin !> **Type-Bound Function**: RemoveMax <br> !  **Purpose**:  To remove the largest key (and a value associated with it) !                from a symbol table.  Also, return a flag indicating !                whether the key is successfully removed or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMax() <br> !   --->    Flag = Collection%RemoveMax(MaxKey) <br> !   --->    Flag = Collection%RemoveMax(Value=MaxVal) <br> !   --->    IF (.NOT.Collection%RemoveMax(MaxKey, MaxVal)) DoSomething PROCEDURE :: RemoveMax => TreeTable_RemoveMax !> **Type-Bound Function**: GetRangeSize <br> !  **Purpose**:  To return the number of keys between *KeyLo* (inclusive) !                and *KeyHi* (inclusive). <br> !  **Usage**: <br> !   --->    RangeSize = Collection%GetRangeSize(KeyLo, KeyHi) PROCEDURE :: GetRangeSize => TreeTable_RangeSize ! --------------------------------------------------------------------- ! -----         Specific Procedures by TreeTable Type             ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => TreeTable_CreateByArray !> **Type-Bound Subroutine**: UseAVLTree <br> !  **Purpose**:  To set the working tree component to work as an AVL tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseAVLTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseAVLTree => TreeTable_UseAVLTree !> **Type-Bound Subroutine**: UseRBTree <br> !  **Purpose**:  To set the working tree component to work as an red-black RB tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseRBTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseRBTree => TreeTable_UseRBTree !> **Type-Bound Function**: Check <br> !  **Purpose**:  To check integrity of the BST data structure. <br> !  **Usage**: <br> !   --->    Flag = Tree%Check() <br> !   --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething PROCEDURE :: Check => TreeTable_CheckIntegrity ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TreeTable_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TreeTable_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TreeTable_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TreeTable_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TreeTable_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: TreeTable_Finalize ! --------------------------------------------------------------------- END TYPE TreeTable","tags":"","loc":"type\\treetable.html"},{"title":"ListCmpxDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListCmpxDP ListCmpxDP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kDouble) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListCmpxDP ), intent(inout) :: List ListCmpxDP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kDouble), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListCmpxDP object. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kDouble), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node complex(kind=kDouble), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(in) :: List ListCmpxDP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(in) :: List ListCmpxDP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(in) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(in) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(inout) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxDP ), intent(in) :: List ListCmpxDP object complex(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listcmpxdp.html"},{"title":"TreeComparable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeComparable TreeComparable is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeComparable ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from an array of key-value pairs. Usage : --->    CALL Tree%Construct(10, KeyValArr) private  subroutine BSTree_ConstructByArray(Tree, N, KeyVal) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of key-value pairs class(Comparable), intent(in) :: KeyVal (N) an array of key-value pairs generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored key-value pairs. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyValQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyValQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree type( ListObject ), intent(out) :: KeyValQ a queue of stored key-value pairs procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(KeyVal) private  subroutine BSTree_Insert(Tree, KeyVal) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: KeyVal key-value pair to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not. Usage : --->    Flag = Tree%Remove(KeyVal) --->    IF (.NOT.Tree%Remove(KeyVal)) DoSomething private  function BSTree_Remove(Tree, KeyVal) result(Flag) To remove the specified key and its associated value from the tree. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: KeyVal key-value pair Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    IF (.NOT.Tree%RemoveMin(KeyVal)) DoSomething private  function BSTree_RemoveMin(Tree, KeyVal) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal smallest key and its associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    IF (.NOT.Tree%RemoveMax(KeyVal)) DoSomething private  function BSTree_RemoveMax(Tree, KeyVal) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal largest key and its associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKeyVal) private  function BSTree_Move2First(Tree, KeyVal) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key-value pair of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal smallest key and its associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKeyVal) private  function BSTree_Move2NextPair(Tree, KeyVal) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key-value pair of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal key and its associated value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKeyVal) private  function BSTree_Move2Last(Tree, KeyVal) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key-value pair of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal the largest key and its associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKeyVal) private  function BSTree_Move2PrevPair(Tree, KeyVal) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key-value pair of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out), optional :: KeyVal key and its associated value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the tree is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(KeyVal) --->    IF (.NOT.Tree%Contain(KeyVal)) DoSomething private  function BSTree_FindKey(Tree, KeyVal, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: KeyVal the key to be looked for type(RBNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyValLo, KeyValHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree TreeComparable object class(Comparable), intent(in) :: Low low key class(Comparable), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and a value associated with it) in the tree.\n               Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(KeyVal) --->    IF (.NOT.Tree%GetMinKey(KeyVal)) DoSomething private  function BSTree_GetSmallestKey(Tree, KeyVal) result(Flag) To return the smallest key and its associated value in the tree. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out) :: KeyVal smallest key and its associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and a value associated with it) in the tree.\n               Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(KeyVal) --->    IF (.NOT.Tree%GetMaxKey(KeyVal)) DoSomething private  function BSTree_GetLargestKey(Tree, KeyVal) result(Flag) To return the largest key and its associated value in the tree. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(out) :: KeyVal largest key and its associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               their associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(KeyVals) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKeyVal, HiKeyVal, KeyVals) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyValQ) To return all keys and their associated values in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: Low low key class(Comparable), intent(in) :: High high key type( ListObject ), intent(out) :: KeyValQ key-value queue private  subroutine BSTree_GetKeys_All(Tree, KeyValQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree type( ListObject ), intent(out) :: KeyValQ key-value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and a value associated with it) in the tree\n               less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyValIn, KeyValOut) --->    IF (.NOT.Tree%Floor(KeyValIn, KeyValOut)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey) result(Flag) To return the largest key in the tree less than or equal to the given key. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: InKey input key (and its associated value) class(Comparable), intent(out) :: OutKey output key (and its associated value) Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and a value associated with it) in the tree\n               greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyValIn, KeyValOut) --->    IF (.NOT.Tree%Ceiling(KeyValIn, KeyValOut)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey) result(Flag) To return the smallest key in the tree greater than or equal to the given key. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: InKey input key (and its associated value) class(Comparable), intent(out) :: OutKey output key (and its associated value) Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and its associated value) of the specified rank where the\n               applicable range of rank is between 0 and TableSize-1. Also, return a flag\n               indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, KeyVal) --->    IF (.NOT.Tree%Select(Rank, KeyVal)) DoSomething private  function BSTree_Select(Tree, Rank, KeyVal) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank class(Comparable), intent(out) :: KeyVal key-value pair of the given rank Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(KeyVal) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree class(Comparable), intent(in) :: Key key (and its associated value) Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeComparable ), intent(inout) :: Tree tree Return Value logical flag for integrity Source Code TYPE TreeComparable PRIVATE ! pointer to the root node (topmost item) of the tree TYPE ( RBNode ), POINTER :: Root => NULL () ! pointer to the current item (or node) used for iteration purpose TYPE ( RBNode ), POINTER :: Cursor => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: BSTree_Destructor_I PROCEDURE , PRIVATE :: BSTree_Destructor_II PROCEDURE , PRIVATE :: BSTree_Traverse_I PROCEDURE , PRIVATE :: BSTree_Traverse_II PROCEDURE , PRIVATE :: BSTree_GetKeys_Range PROCEDURE , PRIVATE :: BSTree_GetKeys_All PROCEDURE , PRIVATE :: IsRankConsistent => BSTree_IsRankConsistent PROCEDURE , PRIVATE :: IsSizeConsistent => BSTree_IsSizeConsistent PROCEDURE , PRIVATE :: IsBSTree => BSTree_IsBinarySearchTree PROCEDURE , PRIVATE :: Is23Tree => BSTree_Is23Tree PROCEDURE , PRIVATE :: IsBalanced => BSTree_IsBalanced GENERIC , PRIVATE :: Traverse => BSTree_Traverse_I , BSTree_Traverse_II ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a tree from an array of key-value pairs.  <br> !  **Usage**: <br> !   --->    CALL Tree%Construct(10, KeyValArr) PROCEDURE :: Construct => BSTree_ConstructByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all key-value pairs from the tree and optionally to !                retrieve stored key-value pairs. <br> !  **Usage**: <br> !   --->    CALL Tree%Destruct() <br> !   --->    CALL Tree%Destruct(KeyValQueue, ValQueue) <br> GENERIC :: Destruct => BSTree_Destructor_I , BSTree_Destructor_II ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the tree. <br> !  **Usage**: <br> !   --->    CALL Tree%Insert(KeyVal) <br> PROCEDURE :: Insert => BSTree_Insert !> **Type-Bound Subroutine**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Remove(KeyVal) <br> !   --->    IF (.NOT.Tree%Remove(KeyVal)) DoSomething <br> PROCEDURE :: Remove => BSTree_Remove !> **Type-Bound Subroutine**: RemoveMin <br> !  **Purpose**:  To remove the smallest key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not.  Optionally, the smallest key and its associated value can be retrieved. <br> !  **Usage**: <br> !   --->    Flag = Tree%RemoveMin() <br> !   --->    IF (.NOT.Tree%RemoveMin(KeyVal)) DoSomething <br> PROCEDURE :: RemoveMin => BSTree_RemoveMin !> **Type-Bound Subroutine**: RemoveMax <br> !  **Purpose**:  To remove the largest key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not.  Optionally, the largest key and its associated value can be retrieved. <br> !  **Usage**: <br> !   --->    Flag = Tree%RemoveMax() <br> !   --->    IF (.NOT.Tree%RemoveMax(KeyVal)) DoSomething <br> PROCEDURE :: RemoveMax => BSTree_RemoveMax ! ------------------------------------------------------- ! -----           tree-traversing procedures        ----- ! ------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration (at a node with the smallest key) and return a flag !                indicating whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Tree%StartFirst() <br> !   --->    IsEmpty = Tree%StartFirst(FirstKeyVal) <br> PROCEDURE :: StartFirst => BSTree_Move2First !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag indicating whether !                the cursor pointer has reached the end of the tree or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Tree%MoveForward() <br> !   --->    IsTheEnd = Tree%MoveForward(NextKeyVal) <br> PROCEDURE :: MoveForward => BSTree_Move2NextPair !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order (at a node with the largest key) !                and return a flag indicating whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Tree%StartLast() <br> !   --->    IsEmpty = Tree%StartLast(LastKeyVal) <br> PROCEDURE :: StartLast => BSTree_Move2Last !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous key-value pair and return a flag indicating whether !                the cursor pointer has reached the end of the tree or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Tree%MoveBackward() <br> !   --->    IsTheEnd = Tree%MoveBackward(PrevKeyVal) <br> PROCEDURE :: MoveBackward => BSTree_Move2PrevPair ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%IsEmpty() <br> !   --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => BSTree_IsEmpty !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the tree.  Return true if the specified key !                is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Tree%Contain(KeyVal) <br> !   --->    IF (.NOT.Tree%Contain(KeyVal)) DoSomething PROCEDURE :: Contain => BSTree_FindKey !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the tree (the number of key-value pair stored in the tree). <br> !  **Usage**: <br> !   --->    TreeSize = Tree%GetSize() PROCEDURE :: GetSize => BSTree_GetSize !> **Type-Bound Function**: GetRangeSize <br> !  **Purpose**:  To return the number of keys between *KeyLo* (inclusive) !                and *KeyHi* (inclusive). <br> !  **Usage**: <br> !   --->    RangeSize = Tree%GetRangeSize(KeyValLo, KeyValHi) PROCEDURE :: GetRangeSize => BSTree_GetSize_Range !> **Type-Bound Function**: GetMinKey <br> !  **Purpose**:  To get the smallest key (and a value associated with it) in the tree. !                Also, return a flag indicating whether the key is successfully retrieved !                or not.  If the tree is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Tree%GetMinKey(KeyVal) <br> !   --->    IF (.NOT.Tree%GetMinKey(KeyVal)) DoSomething PROCEDURE :: GetMinKey => BSTree_GetSmallestKey !> **Type-Bound Function**: GetMaxKey <br> !  **Purpose**:  To get the largest key (and a value associated with it) in the tree. !                Also, return a flag indicating whether the key is successfully retrieved !                or not.  If the tree is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Tree%GetMaxKey(KeyVal) <br> !   --->    IF (.NOT.Tree%GetMaxKey(KeyVal)) DoSomething PROCEDURE :: GetMaxKey => BSTree_GetLargestKey !> **Type-Bound Subroutine**: GetKeys <br> !  **Purpose**:  To return all keys (in the tree or in the specified range) and !                their associated values. <br> !  **Usage**: <br> !   ! return all keys in the tree <br> !   --->    CALL Tree%GetKeys(KeyVals) <br> !   ! return all keys in the specified range <br> !   --->    CALL Tree%GetKeys(LoKeyVal, HiKeyVal, KeyVals) <br> GENERIC :: GetKeys => BSTree_GetKeys_Range , BSTree_GetKeys_All !> **Type-Bound Function**: Floor <br> !  **Purpose**:  To get the largest key (and a value associated with it) in the tree !                less than or equal to the given key.  Also, return a flag indicating !                whether the floor key is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Floor(KeyValIn, KeyValOut) <br> !   --->    IF (.NOT.Tree%Floor(KeyValIn, KeyValOut)) DoSomething PROCEDURE :: Floor => BSTree_Floor !> **Type-Bound Function**: Ceiling <br> !  **Purpose**:  To get the smallest key (and a value associated with it) in the tree !                greater than or equal to the given key.  Also, return a flag indicating !                whether the ceiling key is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Ceiling(KeyValIn, KeyValOut) <br> !   --->    IF (.NOT.Tree%Ceiling(KeyValIn, KeyValOut)) DoSomething PROCEDURE :: Ceiling => BSTree_Ceiling !> **Type-Bound Subroutine**: Select <br> !  **Purpose**:  To get the key (and its associated value) of the specified rank where the !                applicable range of rank is between 0 and TableSize-1. Also, return a flag !                indicating whether the ranked key is successfully retrieved or not. <br> !   --->    Flag = Tree%Select(Rank, KeyVal) <br> !   --->    IF (.NOT.Tree%Select(Rank, KeyVal)) DoSomething PROCEDURE :: Select => BSTree_Select !> **Type-Bound Function**: GetRank <br> !  **Purpose**:  To return the number of keys in the tree strictly less than the given key. <br> !  **Usage**: <br> !   --->    KeyRank = Tree%GetRank(KeyVal) PROCEDURE :: GetRank => BSTree_Rank !> **Type-Bound Function**: Check <br> !  **Purpose**:  To check integrity of the BST data structure. <br> !  **Usage**: <br> !   --->    Flag = Tree%Check() <br> !   --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething PROCEDURE :: Check => BSTree_CheckBST ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the tree. FINAL :: BSTree_Finalizer ! --------------------------------------------------------------------- END TYPE TreeComparable","tags":"","loc":"type\\treecomparable.html"},{"title":"BaseSymTable – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends( BaseCollection ) :: BaseSymTable The BaseSymTable type is an abstract collection type that defines an API for\n a symbol table, which is a collection that associates a value with a key . It is important to note that, by design, a concrete collection type that extends\n from the BaseSymTable type only stores entries of one specific key type and one\n specific value type.  To store entries of another key and/or value types, the\n collection must be cleared and/or destructed. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. subroutine IfaceDestroy(Collection) Prototype IfaceDestroy is an interface for a procedure to destruct the collection where items\n are all removed first (this operation is essentially the same as that of the Clear method) and the storage of those items are then freed.   For the second operation,\n this may also be done by the Clear method for some collections.  However, for others\n (such as dynamic-array-based collections), this must only be done by this procedure. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: Collection collection object procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. function IfaceSize(Collection) result(Size) Prototype IfaceSize is an interface for a procedure to get the current size of the collection,\n  which represents the number of items currently stored in the collection. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) collection size generic, public :: Construct => CopyCollection subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. function IfaceStartFirst(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) Prototype IfaceStartFirst is an interface for a procedure to move to the first (starting)\n pair data in a symbol table.  It is provided for an iteration over all key-value\n pairs in a symbol table. For an ordered symbol table, the first pair data normally means the key-value pair\n with the smallest key.  For an unordered symbol table, the first pair data can be\n any key-value pair. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection is empty or not procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. function IfaceMoveNext(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) Prototype IfaceMoveNext is an interface for a procedure to move to the next pair data in a symbol\n table.  It is provided for an iteration over all key-value pairs in a symbol table. For an ordered symbol table, the next pair data normally indicates the key-value pair\n with the so-called successor key.  For an unordered symbol table, the next pair data may\n be any key-value pair. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the end of the collection is encountered or not procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified key-value pair to the\n  collection. subroutine IfaceInsert(Collection, Key, Value) Prototype IfaceInsert is an interface for a procedure to add a key-value pair into a symbol\n table.  When implementing this procedure, a symbol table should only allow one value\n being associated with each key (i.e. no duplicate keys in the table).  This means that\n when a user puts a key-value pair into a table already containing that key (and its\n associated value), the new value should then replace the old one.  These conventions\n define the associative array abstraction, where we can think of a symbol table as being\n just like an array, where keys are indices and values are array entries. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the value to be added to the collection procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current key-value pair from the\n  collection.  This method is intended to be employed in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of\n  those methods and then calling this one will result in a removal of the current\n  key-value pair of the iteration (i.e. the same key-value pair that can be obtained\n  via the StartFirst and MoveForward methods). subroutine IfaceDelete(Collection) Prototype IfaceDelete is an interface for a procedure to delete the current key-value pair\n from a symbol table.  This procedure is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to either method\n and then calling this procedure will result in a removal of the current key-value\n pair of the iteration (i.e. the same key-value pair that can be retrieved via those\n iteration methods). Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object procedure(IfaceRemove), public, deferred :: Remove Remove is a deferred procedure to remove the specified key (and its associated\n  value) from the collection. function IfaceRemove(Collection, Key) result(Success) Prototype IfaceRemove is an interface for a procedure to delete the specified key (and its\n associated value) from a symbol table.  Also, return a flag indicating whether the\n key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure(IfaceContain), public, deferred :: Contain Contain is a deferred procedure to check whether the specified key is in the\n  collection or not. function IfaceContain(Collection, Key) result(Found) Prototype IfaceContain is an interface for a procedure to check whether the specified key is in\n a symbol table or not.  Return true if the key is found.  Otherwise, return false. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure(IfaceGetVal), public, deferred :: GetValue GetValue is a deferred procedure to get a value associated with the specified key\n  in the collection. function IfaceGetVal(Collection, Key, Value, ValCopy) result(Success) Prototype IfaceGetVal is an interface for a procedure to obtain a value associated with the\n specified key in a symbol table.  Also, return a flag indicating whether the value\n is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol-table object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the value is successfully retrieved or not. procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all key-value pairs from\n  the collection. function IfaceToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) Prototype IfaceToArray is an interface for a procedure to get and remove all key-value pairs\n  from the collection.  Also, return a flag indicating whether the items are successfully\n  removed or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection iterable collection object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all keys and/or all values (without\n  removing them) from the collection. function IfaceGetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) Prototype IfaceGetAll is an interface for a procedure to get all keys and/or all values from\n  the collection.  Also, return a flag indicating whether the keys (and/or values) are\n  successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection iterable collection object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseSymTable_ClearEntries(Collection) To remove all of the pair data items from the collection. This routine provides a basic implementation of the Clear deferred procedure required by the BaseCollection class.\n This routine should be overridden if a better implementation\n is available. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid Source Code TYPE , ABSTRACT , EXTENDS ( BaseCollection ) :: BaseSymTable PRIVATE CLASS ( * ), ALLOCATABLE :: KeyMold CLASS ( * ), ALLOCATABLE :: ValMold CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *StartFirst* is a deferred procedure to start the *forward* iteration. <br> PROCEDURE ( IfaceStartFirst ), DEFERRED :: StartFirst !> *MoveForward* is a deferred procedure to move to the next iteration. <br> PROCEDURE ( IfaceMoveNext ), DEFERRED :: MoveForward !> *Insert* is a deferred procedure to insert the specified key-value pair to the !   collection. <br> PROCEDURE ( IfaceInsert ), DEFERRED :: Insert !> *Delete* is a deferred procedure to delete the current key-value pair from the !   collection.  This method is intended to be employed in conjunction with the !   *StartFirst* and *MoveForward* methods.  Therefore, after the call to one of !   those methods and then calling this one will result in a removal of the current !   key-value pair of the iteration (i.e. the same key-value pair that can be obtained !   via the *StartFirst* and *MoveForward* methods). <br> PROCEDURE ( IfaceDelete ), DEFERRED :: Delete !> *Remove* is a deferred procedure to remove the specified key (and its associated !   value) from the collection. <br> PROCEDURE ( IfaceRemove ), DEFERRED :: Remove !> *Contain* is a deferred procedure to check whether the specified key is in the !   collection or not. <br> PROCEDURE ( IfaceContain ), DEFERRED :: Contain !> *GetValue* is a deferred procedure to get a value associated with the specified key !   in the collection. <br> PROCEDURE ( IfaceGetVal ), DEFERRED :: GetValue !> *ToArray* is a deferred procedure to retrieve and remove all key-value pairs from !   the collection. <br> PROCEDURE ( IfaceToArray ), DEFERRED :: ToArray !> *GetAll* is a deferred procedure to retrieve all keys and/or all values (without !   removing them) from the collection. <br> PROCEDURE ( IfaceGetAll ), DEFERRED :: GetAll ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() !  **Note**: The *Clear* method provided by the *BaseSymTable* type is !       a simple implementation.   It can be overridden by a better and !       more efficient implementation. PROCEDURE :: Clear => BaseSymTable_ClearEntries !> **Type-Bound Function**: GetKeyPtr <br> !  **Purpose**:  To get a pointer to a key stored in a symbol table.  The pointer is !       intended to be used as a mold for the key (i.e. to provide type of the stored !       keys).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    KeyPtr => Collection%GetKeyPtr() PROCEDURE :: GetKeyPtr => BaseSymTable_GetKeyPtr !> **Type-Bound Function**: GetValPtr <br> !  **Purpose**:  To get a pointer to a value stored in a symbol table.  The pointer is !       intended to be used as a mold for the value (i.e. to provide type of the stored !       values).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    ValPtr => Collection%GetValPtr() PROCEDURE :: GetValPtr => BaseSymTable_GetValPtr ! --------------------------------------------------------------------- ! -----       Public Procedures To Be Used Internally             ----- ! --------------------------------------------------------------------- !> *SetMolds* is a procedure to set molds of stored keys and values.  This procedure is !   intended to be used only by a subtype of the *BaseSymTable* type, not by a user. PROCEDURE :: SetMolds => BaseSymTable_SetMolds !> *SetMolds* is a procedure to free molds of stored keys and values.  This procedure is !   intended to be used only by a subtype of the *BaseSymTable* type, not by a user. PROCEDURE :: FreeMolds => BaseSymTable_FreeMolds !> *IsKeyOrdered* is a procedure to check whether the specified key is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseSymTable* type, not by !   a user. PROCEDURE :: IsKeyValid => BaseSymTable_IsKeyValid !> *IsValOrdered* is a procedure to check whether the specified value is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseSymTable* type, not by !   a user. PROCEDURE :: IsValValid => BaseSymTable_IsValValid ! --------------------------------------------------------------------- END TYPE BaseSymTable","tags":"","loc":"type\\basesymtable.html"},{"title":"TreeInteger8B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeInteger8B TreeInteger8B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeInteger8B ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt64), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree type( ListInteger8B ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree TreeInteger8B object integer(kind=kInt64), intent(in) :: Low low key integer(kind=kInt64), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Low low key integer(kind=kInt64), intent(in) :: High high key type( ListInteger8B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree type( ListInteger8B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: InKey input key integer(kind=kInt64), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: InKey input key integer(kind=kInt64), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank integer(kind=kInt64), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree integer(kind=kInt64), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeInteger8B ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treeinteger8b.html"},{"title":"PQInteger8B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQInteger8B The PQInteger8B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQInteger8B ), intent(inout) :: PQ PQInteger8B object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt64), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQInteger8B object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt64), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt64), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt64), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(in) :: PQ PQInteger8B object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(in) :: PQ PQInteger8B object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQInteger8B ), intent(inout) :: PQ PQInteger8B object integer(kind=kInt64), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqinteger8b.html"},{"title":"StackArray – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(BaseDynArr) :: StackArray Description : The StackArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a LIFO stack. Usage Overview : The StackArray type is a stack collection type that provides common operations of a\n  LIFO stack.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n        or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Push method - method to insert an item at the top (end) of the collection, (2.2) Pop method - method to get and remove the top (last) item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekTop method - method to retrieve the top (last) item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalization Procedures final :: StackArray_Finalize To perform finalization of the object. private  subroutine StackArray_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( StackArray ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) private  subroutine BaseDynArr_CreateEmpty(Collection, InitCap, IncSize, Shrink) To create an empty collection. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: InitCap initial size of the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray private  interface QueueArray_CopyCollection() Arguments None private  subroutine BaseDynArr_CreateByArray(Collection, N, Items, IncSize, Shrink) To create a collection from an array of items. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (:) the items to be added to the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: CopyCollection => StackArray_CopyCollection Use the Construct method to create a collection from another collection. interface private module subroutine StackArray_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => StackArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() interface private module subroutine StackArray_ClearItems(Collection) To remove all of the items from the collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object procedure, public :: Destruct => StackArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine StackArray_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object procedure, public :: GetSize => StackArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function StackArray_GetSize(Collection) result(Size) To get the collection size (number of items in the collection). Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => StackArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function StackArray_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => StackArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function StackArray_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => StackArray_AddElm Use the Push method in place of the Insert method to add an item to the stack. interface private module subroutine StackArray_AddElm(Collection, Item) To insert the specified item at the top (end) of the collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => StackArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine StackArray_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object procedure, public :: ToArray => StackArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function StackArray_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => StackArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function StackArray_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the top (end) of the collection. Usage : --->    CALL Collection%Push(Item) private  interface StackArray_AddElm() Arguments None procedure, public :: Pop => StackArray_Pop Type-Bound Function : Pop Purpose :  To get and remove the top (last) item of the collection. Also, return a\n               flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething interface private module function StackArray_Pop(Collection, Item, ItemCopy) result(Success) To get and remove the top (last) item of the collection.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekTop => StackArray_PeekTop Type-Bound Function : PeekTop Purpose :  To get the top (last) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething interface private module function StackArray_PeekTop(Collection, Item, ItemCopy) result(Success) To get the top (last) item (without removing it from the collection). Also,\n return a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => StackArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine StackArray_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => StackArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function StackArray_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => StackArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine StackArray_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Obj procedure, public :: ToString => StackArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function StackArray_ToString(Obj) result(Str) To get a string representation of the object. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => StackArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function StackArray_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: Offset => StackArray_Offset This procedure is intended for internal uses only. interface private module function StackArray_Offset(Collection) result(First) To get an index pointing to the first item. Arguments Type Intent Optional Attributes Name class( StackArray ), intent(inout) :: Collection collection object Return Value integer(kind=kInt32) first index Source Code TYPE , EXTENDS ( BaseDynArr ) :: StackArray PRIVATE !> pointer to top (last) item of the stack tIndex :: Top = 0_kIndex !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to create a collection from another collection. PROCEDURE :: CopyCollection => StackArray_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => StackArray_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => StackArray_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => StackArray_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => StackArray_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => StackArray_Move2NextElm !> Use the *Push* method in place of the *Insert* method to add an item to the stack. PROCEDURE :: Insert => StackArray_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => StackArray_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => StackArray_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => StackArray_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the top (end) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top (last) item of the collection. Also, return a !                flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething PROCEDURE :: Pop => StackArray_Pop !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the top (last) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething PROCEDURE :: PeekTop => StackArray_PeekTop ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => StackArray_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => StackArray_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => StackArray_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StackArray_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => StackArray_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseDynArr Type          ----- ! --------------------------------------------------------------------- !> This procedure is intended for internal uses only. PROCEDURE :: Offset => StackArray_Offset ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: StackArray_Finalize ! --------------------------------------------------------------------- END TYPE StackArray","tags":"","loc":"type\\stackarray.html"},{"title":"QueueArray – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends(BaseDynArr) :: QueueArray Description : The QueueArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a FIFO queue. Usage Overview : The QueueArray type is a queue collection type that provides common operations of a\n  FIFO queue.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n         or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Enqueue method - method to insert an item to the end of the collection, (2.2) Dequeue method - method to get and remove the first item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalization Procedures final :: QueueArray_Finalize To perform finalization of the object. private  subroutine QueueArray_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( QueueArray ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) private  subroutine BaseDynArr_CreateEmpty(Collection, InitCap, IncSize, Shrink) To create an empty collection. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: InitCap initial size of the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray private  interface QueueArray_CopyCollection() Arguments None private  subroutine BaseDynArr_CreateByArray(Collection, N, Items, IncSize, Shrink) To create a collection from an array of items. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (:) the items to be added to the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. interface private module subroutine QueueArray_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() interface private module subroutine QueueArray_ClearItems(Collection) To remove all of the items from the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueArray_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueArray_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueArray_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueArray_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueArray_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueArray_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueArray_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueArray_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) private  interface QueueArray_AddElm() Arguments None procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueArray_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueArray_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueArray_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueArray_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueArray_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Obj procedure, public :: ToString => QueueArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function QueueArray_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueArray_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. interface private module function QueueArray_Offset(Collection) result(First) To get an index pointing to the first item. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object Return Value integer(kind=kInt32) first index Source Code TYPE , EXTENDS ( BaseDynArr ) :: QueueArray PRIVATE !> pointer to first item of the queue tIndex :: First = 1_kIndex !> pointer to next to last item of the queue (i.e. the next available slot) tIndex :: Last = 1_kIndex !> size of the collection (number of items) tIndex :: Size = 0_kIndex !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to create a collection from another collection. PROCEDURE :: CopyCollection => QueueArray_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => QueueArray_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => QueueArray_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => QueueArray_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => QueueArray_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => QueueArray_Move2NextElm !> Use the *Enqueue* method in place of the *Insert* method to add an item to the queue. PROCEDURE :: Insert => QueueArray_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => QueueArray_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => QueueArray_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => QueueArray_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Enqueue <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Enqueue(Item) GENERIC :: Enqueue => Insert !> **Type-Bound Function**: Dequeue <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Dequeue(Item) <br> !   --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething PROCEDURE :: Dequeue => QueueArray_Dequeue !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekFirst(Item) <br> !   --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => QueueArray_PeekFirst ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => QueueArray_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => QueueArray_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => QueueArray_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => QueueArray_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => QueueArray_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseDynArr Type          ----- ! --------------------------------------------------------------------- !> This procedure is intended for internal uses only. PROCEDURE :: Offset => QueueArray_Offset ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: QueueArray_Finalize ! --------------------------------------------------------------------- END TYPE QueueArray","tags":"","loc":"type\\queuearray.html"},{"title":"DequeArray – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( QueueArray ) :: DequeArray Description : The DequeArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a double-ended queue (deque).   It can be used as a\n  FIFO queue or a LIFO stack as well. Usage Overview : The DequeArray type is a deque collection type that provides common operations of a\n  double-ended queue (deque).  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n         or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) AddFirst method - method to insert an item to the front of the collection, (2.2) AddLast method - method to insert an item to the end of the collection, (2.3) RemoveFirst method - method to get and remove the first item of the collection, (2.4) RemoveLast method - method to get and remove the last item of the collection, (2.5) Clear method - method to remove all items from the collection. (2.6) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) PeekLast method - method to retrieve the last item of the collection, (3.3) GetSize method - method to get the collection size (number of items stored), (3.4) IsEmpty method - method to check whether the collection is empty or not. (3.5) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item, (4.3) StartLast method - method to start a backward iteration over items, (4.4) MoveBackward method - method to move backward to the previous item. The DequeArray type also supports the usual Enqueue , Dequeue and PeekFirst operations of a FIFO queue as well as the usual Push , Pop and PeekTop operations\n  of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be\n  used in place of insert , remove , peek operations of a deque as desired. Finalization Procedures final :: DequeArray_Finalize To perform finalization of the object. private  subroutine DequeArray_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DequeArray ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) private  subroutine BaseDynArr_CreateEmpty(Collection, InitCap, IncSize, Shrink) To create an empty collection. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: InitCap initial size of the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray private  interface QueueArray_CopyCollection() Arguments None private  subroutine BaseDynArr_CreateByArray(Collection, N, Items, IncSize, Shrink) To create a collection from an array of items. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (:) the items to be added to the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. interface private module subroutine QueueArray_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() interface private module subroutine QueueArray_ClearItems(Collection) To remove all of the items from the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueArray_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueArray_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueArray_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueArray_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueArray_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueArray_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueArray_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueArray_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Enqueue => Insert private  interface QueueArray_AddElm() Arguments None procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueArray_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueArray_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueArray_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueArray_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueArray_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Obj procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueArray_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. interface private module function QueueArray_Offset(Collection) result(First) To get an index pointing to the first item. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object Return Value integer(kind=kInt32) first index procedure, public :: StartLast => DequeArray_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : see MoveBackward procedure. interface private module function DequeArray_Move2LastElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the last element in the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the last element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DequeArray_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the collection in reverse\n  order. ! start backward iteration (from the last item)\n  IsTheEnd = Collection%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward(CurrItem)\n  END DO interface private module function DequeArray_Move2PrevElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the previous element in the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the previous element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: AddFirst => DequeArray_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) interface private module subroutine DequeArray_AddFirst(Collection, Item) To insert the specified item at the start of the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) private  interface QueueArray_AddElm() Arguments None generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething private  interface QueueArray_Dequeue() Arguments None procedure, public :: RemoveLast => DequeArray_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection. Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething interface private module function DequeArray_RemoveLast(Collection, Item, ItemCopy) result(Success) To get and remove the last item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekLast => DequeArray_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection). Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething interface private module function DequeArray_PeekLast(Collection, Item, ItemCopy) result(Success) To get the last item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) private  interface QueueArray_AddElm() Arguments None generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection. Also, return a\n               flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething private  interface DequeArray_RemoveLast() Arguments None generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething private  interface DequeArray_PeekLast() Arguments None procedure, public :: ToString => DequeArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function DequeArray_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE Source Code TYPE , EXTENDS ( QueueArray ) :: DequeArray CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => DequeArray_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return !                a flag indicating whether the cursor pointer has reached the !                end of the collection or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse across the collection !   in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Collection%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward() !       ! check whether we reach the end of the collection or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the collection in reverse !   order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Collection%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DequeArray_Move2PrevElm !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddFirst(Item) PROCEDURE :: AddFirst => DequeArray_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddLast(Item) GENERIC :: AddLast => Insert !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveFirst(Item) <br> !   --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething GENERIC :: RemoveFirst => Dequeue !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the collection. Also, return a flag !                indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveLast(Item) <br> !   --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DequeArray_RemoveLast !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the collection). Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekLast(Item) <br> !   --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DequeArray_PeekLast ! --------------------------------------------------------------------- ! -----             Redefined Stack Operations                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection. Also, return a !                flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething GENERIC :: Pop => RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething GENERIC :: PeekTop => PeekLast ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => DequeArray_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: DequeArray_Finalize ! --------------------------------------------------------------------- END TYPE DequeArray","tags":"","loc":"type\\dequearray.html"},{"title":"ListArray – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( DequeArray ) :: ListArray Description : The ListArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a list. Usage Overview : The ListArray type provides insert, remove and peek operations at a specified index\n  where the index must be between 1 and the collection size.  The ListArray type is\n  a subtype of the DequeArray type; therefore, all operations available for the DequeArray type are also available for the ListArray type.  As a result, it can\n  thus be used as a deque, a FIFO queue or a LIFO stack. Finalization Procedures final :: ListArray_Finalize To perform finalization of the object. private  subroutine ListArray_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListArray ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) private  subroutine BaseDynArr_CreateEmpty(Collection, InitCap, IncSize, Shrink) To create an empty collection. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: InitCap initial size of the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray private  interface QueueArray_CopyCollection() Arguments None private  subroutine BaseDynArr_CreateByArray(Collection, N, Items, IncSize, Shrink) To create a collection from an array of items. Arguments Type Intent Optional Attributes Name class(BaseDynArr), intent(inout) :: Collection BaseDynArr object integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (:) the items to be added to the collection integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the collection when it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. interface private module subroutine QueueArray_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) from the given collection (Other). Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() interface private module subroutine QueueArray_ClearItems(Collection) To remove all of the items from the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() interface private module subroutine QueueArray_Destroy(Collection) To destruct the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() interface private module function QueueArray_GetSize(Collection) result(Size) To get the number of items stored in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) number of items procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) interface private module function QueueArray_Move2FirstElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the first element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the first element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the first element is available. procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. interface private module function QueueArray_Move2NextElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next element in the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the next element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. interface private module subroutine QueueArray_AddElm(Collection, Item) To insert the specified item at the end of the collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). interface private module subroutine QueueArray_DelElm(Collection) To delete the current item from a collection. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething interface private module function QueueArray_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (:) the items to be retrieved and removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething interface private module function QueueArray_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Items (1:) the items to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Enqueue => Insert private  interface QueueArray_AddElm() Arguments None procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething interface private module function QueueArray_Dequeue(Collection, Item, ItemCopy) result(Success) To get and remove the first item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully removed. procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething interface private module function QueueArray_PeekFirst(Collection, Item, ItemCopy) result(Success) To get the first item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) interface private module subroutine QueueArray_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething interface private module function QueueArray_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() interface private module subroutine QueueArray_MemFree(Obj) To free memory of the object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Obj procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() interface private module function QueueArray_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(in) :: Obj Return Value integer(kind=kInt32) procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. interface private module function QueueArray_Offset(Collection) result(First) To get an index pointing to the first item. Arguments Type Intent Optional Attributes Name class( QueueArray ), intent(inout) :: Collection collection object Return Value integer(kind=kInt32) first index procedure, public :: StartLast => DequeArray_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : see MoveBackward procedure. interface private module function DequeArray_Move2LastElm(Collection, Item, ItemCopy) result(IsEmpty) To move to the last element in the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the last element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no element or not - true if the collection is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DequeArray_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the collection in reverse\n  order. ! start backward iteration (from the last item)\n  IsTheEnd = Collection%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward(CurrItem)\n  END DO interface private module function DequeArray_Move2PrevElm(Collection, Item, ItemCopy) result(IsTheEnd) To move to the previous element in the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout), optional :: Item the previous element as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the collection occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: AddFirst => DequeArray_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) interface private module subroutine DequeArray_AddFirst(Collection, Item) To insert the specified item at the start of the collection. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection generic, public :: AddLast => Insert private  interface QueueArray_AddElm() Arguments None generic, public :: RemoveFirst => Dequeue private  interface QueueArray_Dequeue() Arguments None procedure, public :: RemoveLast => DequeArray_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection. Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething interface private module function DequeArray_RemoveLast(Collection, Item, ItemCopy) result(Success) To get and remove the last item of the collection.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(inout) :: Collection collection object class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekLast => DequeArray_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection). Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething interface private module function DequeArray_PeekLast(Collection, Item, ItemCopy) result(Success) To get the last item (without removing it from the collection). Also, return\n a flag indicating whether the item is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( DequeArray ), intent(in) :: Collection collection object class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. generic, public :: Push => Insert private  interface QueueArray_AddElm() Arguments None generic, public :: Pop => RemoveLast private  interface DequeArray_RemoveLast() Arguments None generic, public :: PeekTop => PeekLast private  interface DequeArray_PeekLast() Arguments None procedure, public :: AddAt => ListArray_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where the index\n      must be between 1 and the collection size. Also, return a flag indicating\n      whether the item is successfully added. Usage : --->    Success = Collection%AddAt(Index, Item) --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething interface private module function ListArray_AddAt(Collection, Index, Item) result(Success) To insert the specified item at the specified position in the collection. Arguments Type Intent Optional Attributes Name class( ListArray ), intent(inout) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to add the item class(*), intent(in) :: Item the item to be added to the collection Return Value logical flag indicating whether the item is successfully added or not. procedure, public :: RemoveAt => ListArray_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where the index\n      must be between 1 and the collection size. Also, return a flag indicating\n      whether the item is successfully removed. Usage : --->    Success = Collection%RemoveAt(Index, Item) --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething interface private module function ListArray_RemoveAt(Collection, Index, Item, ItemCopy) result(Success) To get and remove the item at the specified position.  Also, return a flag\n indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListArray ), intent(inout) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to retrieve and remove the item class(*), intent(inout) :: Item the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved and removed. procedure, public :: PeekAt => ListArray_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the collection) at the\n      specified index where the index must be between 1 and the collection size.\n      Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekAt(Index, Item) --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething interface private module function ListArray_PeekAt(Collection, Index, Item, ItemCopy) result(Success) To retrieve the item at the specified position (without removing it from the\n collection). Also, return a flag indicating whether the item is successfully\n retrieved or not. Arguments Type Intent Optional Attributes Name class( ListArray ), intent(in) :: Collection collection object integer(kind=kInt32), intent(in) :: Index index indicating the position in the collection to retrieve the item class(*), intent(inout) :: Item the item to be retrieved from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the item is successfully retrieved or not. procedure, public :: ToString => ListArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() interface private module function ListArray_ToString(Obj) result(Str) To get the string representation of the object. Arguments Type Intent Optional Attributes Name class( ListArray ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE Source Code TYPE , EXTENDS ( DequeArray ) :: ListArray CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where the index !       must be between 1 and the collection size. Also, return a flag indicating !       whether the item is successfully added. <br> !  **Usage**: <br> !   --->    Success = Collection%AddAt(Index, Item) <br> !   --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => ListArray_AddAt !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where the index !       must be between 1 and the collection size. Also, return a flag indicating !       whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => ListArray_RemoveAt !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the collection) at the !       specified index where the index must be between 1 and the collection size. !       Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => ListArray_PeekAt ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListArray_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListArray_Finalize ! --------------------------------------------------------------------- END TYPE ListArray","tags":"","loc":"type\\listarray.html"},{"title":"HTabInteger2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabInteger2B The HTabInteger2B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabInteger2B object. Arguments Type Intent Optional Attributes Name type( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt32), intent(in) :: N number of key-value pairs integer(kind=kInt16), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabInteger2B , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(in) :: Table HTabInteger2B object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(in) :: Table HTabInteger2B object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object integer(kind=kInt16), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabInteger2B ), intent(inout) :: Table HTabInteger2B object type( ListInteger2B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabinteger2b.html"},{"title":"DArrRealQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrRealQP DArrRealQP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kQuad) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrRealQP ), intent(inout) :: Container DArrRealQP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kQuad), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealQP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kQuad), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container DArrRealQP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container DArrRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items real(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(inout) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrRealQP ), intent(in) :: Container DArrRealQP object real(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrrealqp.html"},{"title":"PQBinHeap – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseCollection ) :: PQBinHeap The PQBinHeap type is a collection type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQBinHeap_Finalizer To perform finalization of the object. private  subroutine PQBinHeap_Finalizer(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQBinHeap ), intent(inout) :: Collection collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: CopyCollection => PQBinHeap_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine PQBinHeap_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => PQBinHeap_Clear Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() private  subroutine PQBinHeap_Clear(Collection) To clear the PQBinHeap object. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection procedure, public :: Destruct => PQBinHeap_Destruct Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. private  subroutine PQBinHeap_Destruct(Collection) To destruct PQBinHeap object. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection procedure, public :: GetSize => PQBinHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function PQBinHeap_GetSize(Collection) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(in) :: Collection collection Return Value integer(kind=kInt32) size (number of keys) procedure, public :: CreateEmpty => PQBinHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                         ! use default options --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options private  subroutine PQBinHeap_CreateEmpty(Collection, InitCap, Mold, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(out) :: Collection collection integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue class(*), intent(in), optional :: Mold key mold logical, intent(in), optional :: MinPQ If present and true, the priority queue is a MinPQ. Otherwise, the priority queue is a MaxPQ. integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , PQBinHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL Collection%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQBinHeap_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine PQBinHeap_ConstructorByArray(Collection, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of keys class(*), intent(in) :: Keys (1:N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Insert => PQBinHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL Collection%Insert(Key) private  subroutine PQBinHeap_InsertKey(Collection, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection class(*), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQBinHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function PQBinHeap_RemoveKey(Collection, HPKey) result(Success) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection class(*), intent(inout) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key is successfully retrieved and removed or not. procedure, public :: Peek => PQBinHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%Peek(Key) --->    IF (.NOT.Collection%Peek(Key)) DoSomething private  function PQBinHeap_PeekKey(Collection, HPKey) result(Success) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection class(*), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key is successfully retrieved or not. procedure, public :: ToArray => PQBinHeap_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething private  function PQBinHeap_ToArray(Collection, Keys) result(Success) To get and remove all keys from the collection.  Also, return\na flag indicating whether the keys are successfully removed. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection PQBinHeap object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection Return Value logical flag indicating whether the keys are successfully retrieved and removed. procedure, public :: GetAll => PQBinHeap_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething private  function PQBinHeap_GetAll(Collection, Keys) result(Success) To get all keys (without removing them) from the collection.  Also,\nreturn a flag indicating whether the keys are successfully retrieved. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection PQBinHeap object class(*), intent(inout) :: Keys (1:) the keys to be retrieved from the collection Return Value logical flag indicating whether the keys are successfully retrieved. procedure, public :: StartFirst => PQBinHeap_Move2FirstKey Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) private  function PQBinHeap_Move2FirstKey(Collection, Key) result(IsEmpty) To move to the first (starting) key in a collection. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the first item as output if requested (and available) Return Value logical a flag indicating whether the table contains key or not - true if the table is empty. - otherwise the first key is available. procedure, public :: MoveForward => PQBinHeap_Move2NextKey Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. private  function PQBinHeap_Move2NextKey(Collection, Key) result(IsTheEnd) To move to the next key in a collection. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the next item as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next key is NOT available. - otherwise next key is available. procedure, public :: Copy => PQBinHeap_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine PQBinHeap_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => PQBinHeap_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function PQBinHeap_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => PQBinHeap_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine PQBinHeap_MemFree(Obj) To free memory of the PQBinHeap object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(inout) :: Obj procedure, public :: ToString => PQBinHeap_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function PQBinHeap_ToString(Obj) result(Str) To get the name of the PQBinHeap type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => PQBinHeap_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function PQBinHeap_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( PQBinHeap ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseCollection ) :: PQBinHeap PRIVATE !> pointer to the last item of the priority queue tIndex :: Last = 0_kIndex !> flag indicating whether the priority queue is implemented as a maximum or a minimum PQ tLogical :: Min = FalseVal !> incremental size of the collection when the collection is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16_kIndex !> flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> stored keys in the priority queue. TYPE ( KeyOrdered ), ALLOCATABLE :: Keys (:) !> memory pool of stored items TYPE ( MemoryPool ) :: KeyPool !> key mold providing the type of stored keys CLASS ( * ), ALLOCATABLE :: Mold !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Private Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Growing => PQBinHeap_Growing PROCEDURE , PRIVATE :: Shrinking => PQBinHeap_Shrinking PROCEDURE , PRIVATE :: SinkDown => PQBinHeap_ReHeapify_TopDown PROCEDURE , PRIVATE :: SwimUp => PQBinHeap_ReHeapify_BottomUp PROCEDURE , PRIVATE :: IsKeyValid => PQBinHeap_IsKeyValid PROCEDURE , PRIVATE :: SwapKeys => PQBinHeap_SwapKeys PROCEDURE , PRIVATE :: PQBinHeap_ConstructorByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => PQBinHeap_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => PQBinHeap_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => PQBinHeap_Destruct !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => PQBinHeap_GetSize ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap)                         ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold <br> !   --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options <br> PROCEDURE :: CreateEmpty => PQBinHeap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL Collection%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> GENERIC :: Construct => PQBinHeap_ConstructorByArray !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key) <br> PROCEDURE :: Insert => PQBinHeap_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => PQBinHeap_RemoveKey !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%Peek(Key) <br> !   --->    IF (.NOT.Collection%Peek(Key)) DoSomething PROCEDURE :: Peek => PQBinHeap_PeekKey !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => PQBinHeap_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => PQBinHeap_GetAll !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) PROCEDURE :: StartFirst => PQBinHeap_Move2FirstKey !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => PQBinHeap_Move2NextKey ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => PQBinHeap_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => PQBinHeap_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => PQBinHeap_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => PQBinHeap_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => PQBinHeap_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQBinHeap_Finalizer ! --------------------------------------------------------------------- END TYPE PQBinHeap","tags":"","loc":"type\\pqbinheap.html"},{"title":"ListRealDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListRealDP ListRealDP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kDouble) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListRealDP ), intent(inout) :: List ListRealDP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kDouble), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListRealDP object. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kDouble), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node real(kind=kDouble), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(in) :: List ListRealDP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(in) :: List ListRealDP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(in) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(in) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(inout) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealDP ), intent(in) :: List ListRealDP object real(kind=kDouble), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listrealdp.html"},{"title":"TreeInteger1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeInteger1B TreeInteger1B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeInteger1B ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt8), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree type( ListInteger1B ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree TreeInteger1B object integer(kind=kInt8), intent(in) :: Low low key integer(kind=kInt8), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Low low key integer(kind=kInt8), intent(in) :: High high key type( ListInteger1B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree type( ListInteger1B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: InKey input key integer(kind=kInt8), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: InKey input key integer(kind=kInt8), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank integer(kind=kInt8), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree integer(kind=kInt8), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeInteger1B ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treeinteger1b.html"},{"title":"DArrInteger1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrInteger1B DArrInteger1B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt8) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt8), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger1B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt8), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt8), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container DArrInteger1B object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container DArrInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt8), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(inout) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger1B ), intent(in) :: Container DArrInteger1B object integer(kind=kInt8), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrinteger1b.html"},{"title":"DArrLogical – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrLogical DArrLogical is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is LOGICAL . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrLogical ), intent(inout) :: Container DArrLogical object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object integer(kind=kInt32), intent(in) :: N number of items logical, intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrLogical class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items logical, intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items logical, intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container DArrLogical object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container DArrLogical object logical, intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container DArrLogical object logical, intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container DArrLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items logical, intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(inout) :: Container DArrLogical object logical, intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrLogical ), intent(in) :: Container DArrLogical object logical, intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrlogical.html"},{"title":"TreeRealQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeRealQP TreeRealQP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeRealQP ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys real(kind=kQuad), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree type( ListRealQP ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree TreeRealQP object real(kind=kQuad), intent(in) :: Low low key real(kind=kQuad), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Low low key real(kind=kQuad), intent(in) :: High high key type( ListRealQP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree type( ListRealQP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: InKey input key real(kind=kQuad), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: InKey input key real(kind=kQuad), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank real(kind=kQuad), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree real(kind=kQuad), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeRealQP ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treerealqp.html"},{"title":"DArrInteger8B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrInteger8B DArrInteger8B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt64) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt64), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger8B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt64), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt64), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container DArrInteger8B object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container DArrInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt64), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(inout) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger8B ), intent(in) :: Container DArrInteger8B object integer(kind=kInt64), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrinteger8b.html"},{"title":"ListLogical – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListLogical ListLogical is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is LOGICAL . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListLogical ), intent(inout) :: List ListLogical object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object integer(kind=kInt32), intent(in) :: N number of items logical, intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListLogical object. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items logical, intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node logical, intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items logical, intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(in) :: List ListLogical object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(in) :: List ListLogical object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(in) :: List ListLogical object logical, intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(in) :: List ListLogical object logical, intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items logical, intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(inout) :: List ListLogical object logical, intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListLogical ), intent(in) :: List ListLogical object logical, intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listlogical.html"},{"title":"HTabRealDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabRealDP The HTabRealDP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabRealDP object. Arguments Type Intent Optional Attributes Name type( HTabRealDP ), intent(inout) :: Table HTabRealDP object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object integer(kind=kInt32), intent(in) :: N number of key-value pairs real(kind=kDouble), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabRealDP , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(in) :: Table HTabRealDP object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(in) :: Table HTabRealDP object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object real(kind=kDouble), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabRealDP ), intent(inout) :: Table HTabRealDP object type( ListRealDP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabrealdp.html"},{"title":"BaseCollection – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, ABSTRACT, extends(Object) :: BaseCollection The BaseCollection type is an abstract collection type that defines\n an API for various common operations.  Some operations are deferred\n while others (with default implementation) can be overridden. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfaceClear), public, deferred :: Clear Clear is a deferred procedure to remove all items from the collection. subroutine IfaceClear(Collection) Prototype IfaceClear is an interface for a procedure to remove all items from the collection. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: Collection collection object procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. subroutine IfaceDestroy(Collection) Prototype IfaceDestroy is an interface for a procedure to destruct the collection where items\n are all removed first (this operation is essentially the same as that of the Clear method) and the storage of those items are then freed.   For the second operation,\n this may also be done by the Clear method for some collections.  However, for others\n (such as dynamic-array-based collections), this must only be done by this procedure. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: Collection collection object procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. function IfaceSize(Collection) result(Size) Prototype IfaceSize is an interface for a procedure to get the current size of the collection,\n  which represents the number of items currently stored in the collection. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value integer(kind=kInt32) collection size generic, public :: Construct => CopyCollection Type-Bound Subroutine : Construct Purpose :  To construct a new collection. Usage : ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) subroutine IfaceCreate(This, Other, ItemCopy, ValCopy) Prototype IfaceCreate is an interface for a procedure to creates a new collection (This) with\n the same items as the given collection (Other).  In essence, this is a constructor\n that allows the user to copy items from any collection. It should be noted that this procedure is slightly different from the Copy method\n inherited from the Object type such that types of This and Other collections\n can be different whereas types of SrcObj and DstObj objects must be the same. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(inout) :: This collection to be created class( BaseCollection ), intent(inout) :: Other collection to be copied from procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. Source Code TYPE , ABSTRACT , EXTENDS ( Object ) :: BaseCollection CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyCollection* is a deferred procedure to construct a new collection from another !   collection.  Use the *Construct* method in place of this method. <br> PROCEDURE ( IfaceCreate ), DEFERRED :: CopyCollection !> *Clear* is a deferred procedure to remove all items from the collection. <br> PROCEDURE ( IfaceClear ), DEFERRED :: Clear !> *Destruct* is a deferred procedure to remove all items from the collection and free !   memory storage of items stored in the collection. <br> PROCEDURE ( IfaceDestroy ), DEFERRED :: Destruct !> *GetSize* is a deferred procedure to get the current size of the collection. PROCEDURE ( IfaceSize ), DEFERRED :: GetSize ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection. <br> !  **Usage**: <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => CopyCollection !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => BaseCollection_IsEmpty ! --------------------------------------------------------------------- END TYPE BaseCollection","tags":"","loc":"type\\basecollection.html"},{"title":"PQRealQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQRealQP The PQRealQP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQRealQP ), intent(inout) :: PQ PQRealQP object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object integer(kind=kInt32), intent(in) :: N number of keys real(kind=kQuad), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQRealQP object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object real(kind=kQuad), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object real(kind=kQuad), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object real(kind=kQuad), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(in) :: PQ PQRealQP object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(in) :: PQ PQRealQP object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealQP ), intent(inout) :: PQ PQRealQP object real(kind=kQuad), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqrealqp.html"},{"title":"PQMinMax – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseCollection ) :: PQMinMax The PQMinMax type is a collection type that employs an ordered array implementation\n to provide common operations for a generalized priority queue. Finalization Procedures final :: PQMinMax_Finalizer To perform finalization of the object. private  subroutine PQMinMax_Finalizer(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQMinMax ), intent(inout) :: Collection collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: CopyCollection => PQMinMax_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine PQMinMax_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => PQMinMax_Clear Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() private  subroutine PQMinMax_Clear(Collection) To clear the PQMinMax object. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection procedure, public :: Destruct => PQMinMax_Destruct Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. private  subroutine PQMinMax_Destruct(Collection) To destruct PQMinMax object. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection procedure, public :: GetSize => PQMinMax_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function PQMinMax_GetSize(Collection) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(in) :: Collection collection Return Value integer(kind=kInt32) size (number of keys) procedure, public :: CreateEmpty => PQMinMax_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                         ! use default options --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options private  subroutine PQMinMax_CreateEmpty(Collection, InitCap, Mold, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(out) :: Collection collection integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue class(*), intent(in), optional :: Mold key mold logical, intent(in), optional :: MinPQ If present and true, the priority queue is a MinPQ. Otherwise, the priority queue is a MaxPQ. integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink flag to shrink the collection capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => CopyCollection , PQMinMax_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL Collection%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQMinMax_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine PQMinMax_ConstructorByArray(Collection, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of keys class(*), intent(in) :: Keys (1:N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Insert => PQMinMax_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL Collection%Insert(Key) private  subroutine PQMinMax_InsertKey(Collection, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: RemoveMin => PQMinMax_RemoveMinKey Type-Bound Function : RemoveMin Purpose :  To retrieve and remove the minimum key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%RemoveMin(MinKey) --->    IF (.NOT.Collection%RemoveMin(MinKey)) DoSomething private  function PQMinMax_RemoveMinKey(Collection, HPKey) result(Success) To retrieve and remove the minimum key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout) :: HPKey the minimum key Return Value logical flag indicating whether the specified key is successfully retrieved and removed or not. procedure, public :: RemoveMax => PQMinMax_RemoveMaxKey Type-Bound Function : RemoveMax Purpose :  To retrieve and remove the maximum key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%RemoveMax(MaxKey) --->    IF (.NOT.Collection%RemoveMax(MaxKey)) DoSomething private  function PQMinMax_RemoveMaxKey(Collection, HPKey) result(Success) To retrieve and remove the maximum key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout) :: HPKey the maximum key Return Value logical flag indicating whether the specified key is successfully retrieved and removed or not. procedure, public :: PeekMin => PQMinMax_PeekMinKey Type-Bound Function : PeekMin Purpose :  To retrieve the minimum key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%PeekMin(MinKey) --->    IF (.NOT.Collection%PeekMin(MinKey)) DoSomething private  function PQMinMax_PeekMinKey(Collection, HPKey) result(Success) To retrieve the minimum key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(out) :: HPKey the minimum key Return Value logical flag indicating whether the specified key is successfully retrieved or not. procedure, public :: PeekMax => PQMinMax_PeekMaxKey Type-Bound Function : PeekMax Purpose :  To retrieve the maximum key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%PeekMax(MaxKey) --->    IF (.NOT.Collection%PeekMax(MaxKey)) DoSomething private  function PQMinMax_PeekMaxKey(Collection, HPKey) result(Success) To retrieve the maximum key from the priority queue.  Also, return\n a flag indicating whether the key is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(out) :: HPKey the maximum key Return Value logical flag indicating whether the specified key is successfully retrieved or not. procedure, public :: ToArray => PQMinMax_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items, IsDescend=.TRUE.)) DoSomething private  function PQMinMax_ToArray(Collection, Keys, IsDescend) result(Success) To get and remove all keys from the collection.  Also, return\na flag indicating whether the keys are successfully removed. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection PQMinMax object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection logical, intent(in), optional :: IsDescend If present and true, return the keys in descending order. Otherwise, return the keys in ascending order. Return Value logical flag indicating whether the keys are successfully retrieved and removed. procedure, public :: GetAll => PQMinMax_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items, IsDescend=.TRUE.)) DoSomething private  function PQMinMax_GetAll(Collection, Keys, IsDescend) result(Success) To get all keys (without removing them) from the collection.  Also,\nreturn a flag indicating whether the keys are successfully retrieved. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection PQMinMax object class(*), intent(inout) :: Keys (1:) the keys to be retrieved from the collection logical, intent(in), optional :: IsDescend If present and true, return the keys in descending order. Otherwise, return the keys in ascending order. Return Value logical flag indicating whether the keys are successfully retrieved. procedure, public :: StartMin => PQMinMax_Move2MinKey Type-Bound Function : StartMin Purpose :  To start the ascending iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartMin() --->    IsEmpty = Collection%StartMin(MinKey) private  function PQMinMax_Move2MinKey(Collection, Key) result(IsEmpty) To move to the minimum (starting) key in a collection. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the minimum key as output if requested (and available) Return Value logical a flag indicating whether the table contains key or not - true if the table is empty. - otherwise the minimu key is available. procedure, public :: StartMax => PQMinMax_Move2MaxKey Type-Bound Function : StartMax Purpose :  To start the descending iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartMax() --->    IsEmpty = Collection%StartMax(MaxKey) private  function PQMinMax_Move2MaxKey(Collection, Key) result(IsEmpty) To move to the maximum (starting) key in a collection. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the maximum key as output if requested (and available) Return Value logical a flag indicating whether the table contains key or not - true if the table is empty. - otherwise the maximum key is available. procedure, public :: MoveUp => PQMinMax_MoveUpNext Type-Bound Function : MoveUp Purpose :  To move to the next iteration in ascending order and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : --->    IsTheEnd = Collection%MoveUp() --->    IsTheEnd = Collection%MoveUp(NextKey) private  function PQMinMax_MoveUpNext(Collection, Key) result(IsTheEnd) To move to the next key in an ascending order in a collection. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the next item as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next key is NOT available. - otherwise next key is available. procedure, public :: MoveDown => PQMinMax_MoveDownNext Type-Bound Function : MoveDown Purpose :  To move to the next iteration in descending order and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : --->    IsTheEnd = Collection%MoveDown() --->    IsTheEnd = Collection%MoveDown(NextKey) private  function PQMinMax_MoveDownNext(Collection, Key) result(IsTheEnd) To move to the next key in an descending order in a collection. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Key the next item as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next key is NOT available. - otherwise next key is available. procedure, public :: Copy => PQMinMax_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine PQMinMax_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => PQMinMax_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function PQMinMax_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => PQMinMax_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine PQMinMax_MemFree(Obj) To free memory of the PQMinMax object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(inout) :: Obj procedure, public :: ToString => PQMinMax_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function PQMinMax_ToString(Obj) result(Str) To get the name of the PQMinMax type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => PQMinMax_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function PQMinMax_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( PQMinMax ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseCollection ) :: PQMinMax PRIVATE !> pointer to the last item of the priority queue tIndex :: Last = 0_kIndex !> flag indicating whether the priority queue is implemented as a maximum or a minimum PQ tLogical :: Min = FalseVal !> incremental size of the collection when the collection is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16_kIndex !> flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> stored keys in the priority queue. TYPE ( KeyOrdered ), ALLOCATABLE :: Keys (:) !> memory pool of stored items TYPE ( MemoryPool ) :: KeyPool !> key mold providing the type of stored keys CLASS ( * ), ALLOCATABLE :: Mold !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Private Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Growing => PQMinMax_Growing PROCEDURE , PRIVATE :: Shrinking => PQMinMax_Shrinking PROCEDURE , PRIVATE :: IsKeyValid => PQMinMax_IsKeyValid PROCEDURE , PRIVATE :: SwapKeys => PQMinMax_SwapKeys PROCEDURE , PRIVATE :: PQMinMax_ConstructorByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => PQMinMax_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => PQMinMax_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => PQMinMax_Destruct !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => PQMinMax_GetSize ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap)                         ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold <br> !   --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options <br> PROCEDURE :: CreateEmpty => PQMinMax_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL Collection%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> GENERIC :: Construct => PQMinMax_ConstructorByArray !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key) <br> PROCEDURE :: Insert => PQMinMax_InsertKey !> **Type-Bound Function**: RemoveMin <br> !  **Purpose**:  To retrieve and remove the minimum key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMin(MinKey) <br> !   --->    IF (.NOT.Collection%RemoveMin(MinKey)) DoSomething PROCEDURE :: RemoveMin => PQMinMax_RemoveMinKey !> **Type-Bound Function**: RemoveMax <br> !  **Purpose**:  To retrieve and remove the maximum key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMax(MaxKey) <br> !   --->    IF (.NOT.Collection%RemoveMax(MaxKey)) DoSomething PROCEDURE :: RemoveMax => PQMinMax_RemoveMaxKey !> **Type-Bound Function**: PeekMin <br> !  **Purpose**:  To retrieve the minimum key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%PeekMin(MinKey) <br> !   --->    IF (.NOT.Collection%PeekMin(MinKey)) DoSomething PROCEDURE :: PeekMin => PQMinMax_PeekMinKey !> **Type-Bound Function**: PeekMax <br> !  **Purpose**:  To retrieve the maximum key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%PeekMax(MaxKey) <br> !   --->    IF (.NOT.Collection%PeekMax(MaxKey)) DoSomething PROCEDURE :: PeekMax => PQMinMax_PeekMaxKey !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items, IsDescend=.TRUE.)) DoSomething PROCEDURE :: ToArray => PQMinMax_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items, IsDescend=.TRUE.)) DoSomething PROCEDURE :: GetAll => PQMinMax_GetAll !> **Type-Bound Function**: StartMin <br> !  **Purpose**:  To start the *ascending* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartMin() <br> !   --->    IsEmpty = Collection%StartMin(MinKey) PROCEDURE :: StartMin => PQMinMax_Move2MinKey !> **Type-Bound Function**: StartMax <br> !  **Purpose**:  To start the *descending* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartMax() <br> !   --->    IsEmpty = Collection%StartMax(MaxKey) PROCEDURE :: StartMax => PQMinMax_Move2MaxKey !> **Type-Bound Function**: MoveUp <br> !  **Purpose**:  To move to the next iteration in ascending order and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveUp() <br> !   --->    IsTheEnd = Collection%MoveUp(NextKey) <br> PROCEDURE :: MoveUp => PQMinMax_MoveUpNext !> **Type-Bound Function**: MoveDown <br> !  **Purpose**:  To move to the next iteration in descending order and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveDown() <br> !   --->    IsTheEnd = Collection%MoveDown(NextKey) <br> PROCEDURE :: MoveDown => PQMinMax_MoveDownNext ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => PQMinMax_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => PQMinMax_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => PQMinMax_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => PQMinMax_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => PQMinMax_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQMinMax_Finalizer ! --------------------------------------------------------------------- END TYPE PQMinMax","tags":"","loc":"type\\pqminmax.html"},{"title":"ListRealSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListRealSP ListRealSP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kSingle) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListRealSP ), intent(inout) :: List ListRealSP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kSingle), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListRealSP object. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kSingle), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node real(kind=kSingle), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(in) :: List ListRealSP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(in) :: List ListRealSP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(in) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(in) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(inout) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealSP ), intent(in) :: List ListRealSP object real(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listrealsp.html"},{"title":"ListCharacter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListCharacter ListCharacter is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is CHARACTER . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListCharacter ), intent(inout) :: List ListCharacter object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object integer(kind=kInt32), intent(in) :: N number of items character(len=*), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListCharacter object. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=*), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=*), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items character(len=*), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node character(len=:), intent(out), optional, ALLOCATABLE :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items character(len=:), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), optional, ALLOCATABLE :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(in) :: List ListCharacter object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(in) :: List ListCharacter object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(in) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(in) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items character(len=:), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=*), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=*), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(inout) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCharacter ), intent(in) :: List ListCharacter object character(len=:), intent(out), ALLOCATABLE :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listcharacter.html"},{"title":"PQRealSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQRealSP The PQRealSP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQRealSP ), intent(inout) :: PQ PQRealSP object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object integer(kind=kInt32), intent(in) :: N number of keys real(kind=kSingle), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQRealSP object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object real(kind=kSingle), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object real(kind=kSingle), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object real(kind=kSingle), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(in) :: PQ PQRealSP object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(in) :: PQ PQRealSP object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealSP ), intent(inout) :: PQ PQRealSP object real(kind=kSingle), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqrealsp.html"},{"title":"TreeSet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseIterable ) :: TreeSet The TreeSet type is a collection type that utilizes a balanced BST implementation\n to provide common operations for an ordered set.  The TreeSet type employs the IntrusiveRBTree type as its component to store SetNode objects.  As an intrusive\n BST container, the IntrusiveRBTree type provides common binary-search-tree operations\n without a memory management task.  The memory management task of the inserted SetNode objects is handled by the TreeSet type. The TreeSet type is a subtype of the BaseIterable type.  Thus, it implements all\n deferred procedures required by the BaseIterable type and all its super classes.  As\n a set container, the TreeSet type does not allow duplicated items.  Also, the TreeSet type, as an ordered set, provides an ordered iteration over its stored items, which are\n sorted according to the natural ordering of its items.  It can be traversed in either\n ascending or descending order. Because the IntrusiveRBTree type is a subtype of the IntrusiveAVLTree type, the WrkTree component can be employed as a red-black tree or an AVL tree.  Therefore, the TreeSet type allows a user to specify which type of binary-search tree implementation\n to be used.  By default, the red-black tree implementation is used.  The user can call the UseAVLTree method to change to AVL tree implementation.  The UseAVLTree method must\n be called before inserting an object into the set (i.e when the set is empty).  Otherwise,\n the red-black tree implementation is employed. Finalization Procedures final :: TreeSet_Finalize To perform finalization of the hash set. private  subroutine TreeSet_Finalize(Collection) To perform finalization of the collection. Arguments Type Intent Optional Attributes Name type( TreeSet ), intent(inout) :: Collection collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => TreeSet_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine TreeSet_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => TreeSet_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() private  subroutine TreeSet_ClearItems(Collection) To free components of the items from the set. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection procedure, public :: Destruct => TreeSet_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine TreeSet_Destroy(Collection) To destruct the set. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection procedure, public :: GetSize => TreeSet_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function TreeSet_GetSize(Collection) result(Size) To return the number of items currently in the hash set. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(in) :: Collection collection Return Value integer(kind=kInt32) the number of items procedure, public :: StartFirst => TreeSet_Move2FirstItem Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) private  function TreeSet_Move2FirstItem(Collection, Item, ItemCopy) result(IsEmpty) To move to the first (starting) item in a collection.   For the hash set, which is\n an unordered set, the starting item is the first item found in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Item the first item as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the table contains no item or not - true if the table is empty. - otherwise the first item is available. procedure, public :: MoveForward => TreeSet_Move2NextItem Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. private  function TreeSet_Move2NextItem(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next item in a collection.  For the hash set, which is an unordered set,\n the next item is a item inserted in the first non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either by an insertion\n or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Item the next item as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next item is NOT available. - otherwise next item is available. procedure, public :: StartLast => TreeSet_Move2LastItem Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order and return a flag\n               indicating whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartLast() --->    IsEmpty = Collection%StartLast(LastItem) private  function TreeSet_Move2LastItem(Collection, Item) result(IsEmpty) To move to the last (starting in a reversed order) item in a symbol table. For the TreeSet , which is an ordered symbol table, the starting item in a reversed order\n is the item with greatest key. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Item the greatest key as output if requested (and available) Return Value logical a flag indicating whether the collection contains no item or not - true if the collection is empty. - otherwise the first item is available. procedure, public :: MoveBackward => TreeSet_Move2PrevItem Type-Bound Function : MoveBackward Purpose :  To move to the previous item and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveBackward() --->    IsTheEnd = Collection%MoveBackward(PrevItem) private  function TreeSet_Move2PrevItem(Collection, Item) result(IsTheEnd) To move to the previous item in a symbol table.  For the TreeSet , which is an\n ordered symbol table,  the previous item is the so-called predecessor item. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Item the previous key as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next item is NOT available. - otherwise next item is available. procedure, public :: Insert => TreeSet_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified item to the collection. Usage : --->    CALL Collection%Insert(Item) private  subroutine TreeSet_Insert(Collection, Item) To add an item into the hash set.  If the specified item is already stored\n in the set, report severe error and return immediately. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be inserted procedure, public :: Delete => TreeSet_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine TreeSet_Delete(Collection) To delete a item of the current iteration from a collection. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection symbol-table collection object procedure, public :: ToArray => TreeSet_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n      indicating whether the items are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething private  function TreeSet_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection TreeSet object class(*), intent(inout) :: Items (:) the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => TreeSet_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are successfully retrieved or not. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething private  function TreeSet_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are successfully retrieved. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection TreeSet object class(*), intent(inout) :: Items (1:) the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. generic, public :: Construct => CopyCollection , TreeSet_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine TreeSet_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine TreeSet_CreateByArray(Collection, N, Items) To create a table from an array of items. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (N) the items to be added to the set procedure, public :: Contain => TreeSet_Contain Type-Bound Function : Contain Purpose :  To find the specified item in the collection.  Return true if\n               the specified item is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Item) --->    IF (.NOT.Collection%Contain(Item)) DoSomething private  function TreeSet_Contain(Collection, Item) result(Found) To check whether the specified item is currently stored in a collection. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be looked for Return Value logical flag indicating whether the specified item is found or not. procedure, public :: Remove => TreeSet_Remove Type-Bound Function : Remove Purpose :  To remove the specified item from the collection.  Also, return a flag\n               indicating whether the item is successfully removed or not. Usage : --->    Flag = Collection%Remove(Item) --->    IF (.NOT.Collection%Remove(Item)) DoSomething private  function TreeSet_Remove(Collection, Item) result(Flag) To remove the specified item (and its associated value) from a collection.  Also,\n return a flag indicating whether the item is successfully removed or not. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be removed Return Value logical flag indicating whether the specified item and its associated\n value are successfully removed or not. procedure, public :: UseAVLTree => TreeSet_UseAVLTree Type-Bound Subroutine : UseAVLTree Purpose :  To set the working tree component to work as an AVL tree. Usage : --->    CALL Collection%UseAVLTree() Note : The collection must be empty when calling this method. private  subroutine TreeSet_UseAVLTree(Collection) To set the IsRBTree component to false. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection object procedure, public :: UseRBTree => TreeSet_UseRBTree Type-Bound Subroutine : UseRBTree Purpose :  To set the working tree component to work as an red-black RB tree. Usage : --->    CALL Collection%UseRBTree() Note : The collection must be empty when calling this method. private  subroutine TreeSet_UseRBTree(Collection) To set the IsRBTree component to true. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Collection collection object procedure, public :: Copy => TreeSet_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine TreeSet_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => TreeSet_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function TreeSet_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => TreeSet_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine TreeSet_MemFree(Obj) To free memory of the TreeSet object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(inout) :: Obj procedure, public :: ToString => TreeSet_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function TreeSet_ToString(Obj) result(Str) To get the name of the TreeSet type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => TreeSet_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function TreeSet_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( TreeSet ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseIterable ) :: TreeSet PRIVATE !> a flag indicating whether to use the red-black tree implementation !  or the AVL tree implementation tLogical :: IsRBTree = TrueVal !% a working binary-search tree TYPE ( IntrusiveRBTree ) :: WrkTree !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindItem <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindItem(Item) <br> !   --->    IF (.NOT.Collection%FindItem(Item)) DoSomething PROCEDURE , PRIVATE :: FindItem => TreeSet_FindItem !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: TreeSet_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => TreeSet_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => TreeSet_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => TreeSet_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => TreeSet_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => TreeSet_Move2FirstItem !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => TreeSet_Move2NextItem !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order and return a flag !                indicating whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartLast() <br> !   --->    IsEmpty = Collection%StartLast(LastItem) <br> PROCEDURE :: StartLast => TreeSet_Move2LastItem !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous item and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveBackward() <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevItem) <br> PROCEDURE :: MoveBackward => TreeSet_Move2PrevItem !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified item to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Item) <br> PROCEDURE :: Insert => TreeSet_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => TreeSet_Delete !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !       indicating whether the items are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => TreeSet_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => TreeSet_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => TreeSet_CreateByArray !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Item) <br> !   --->    IF (.NOT.Collection%Contain(Item)) DoSomething PROCEDURE :: Contain => TreeSet_Contain !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified item from the collection.  Also, return a flag !                indicating whether the item is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Item) <br> !   --->    IF (.NOT.Collection%Remove(Item)) DoSomething PROCEDURE :: Remove => TreeSet_Remove !> **Type-Bound Subroutine**: UseAVLTree <br> !  **Purpose**:  To set the working tree component to work as an AVL tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseAVLTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseAVLTree => TreeSet_UseAVLTree !> **Type-Bound Subroutine**: UseRBTree <br> !  **Purpose**:  To set the working tree component to work as an red-black RB tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseRBTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseRBTree => TreeSet_UseRBTree ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TreeSet_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TreeSet_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TreeSet_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TreeSet_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TreeSet_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash set. FINAL :: TreeSet_Finalize ! --------------------------------------------------------------------- END TYPE TreeSet","tags":"","loc":"type\\treeset.html"},{"title":"PQCharacter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQCharacter The PQCharacter type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQCharacter ), intent(inout) :: PQ PQCharacter object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL PQ%CreateEmpty(CharLen, InitCap)            ! use default options --->    CALL PQ%CreateEmpty(72, 32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL PQ%CreateEmpty(72, 32, IncSize=16)          ! specify incremental size --->    CALL PQ%CreateEmpty(72, 32, Shrink=.TRUE.)       ! specify shrinking --->    CALL PQ%CreateEmpty(72, 32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, CharLen, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object integer(kind=kInt32), intent(in) :: CharLen length of character string integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object integer(kind=kInt32), intent(in) :: N number of keys character(kind=kChar, len=*), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQCharacter object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object character(kind=kChar, len=*), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object character(kind=kChar, len=PQ), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(in) :: PQ PQCharacter object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(in) :: PQ PQCharacter object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQCharacter ), intent(inout) :: PQ PQCharacter object character(kind=kChar, len=PQ), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. Source Code TYPE PQCharacter PRIVATE !% pointer to last item of the priority queue tIndex :: Last = 0_kIndex !% incremental size of priority queue if it is full tIndex :: IncSize = 16_kIndex !% flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> flag indicating whether the priority queue is implemented as !  a maximum PQ or a minimum PQ. <br> !  default -> a maximum PQ. tLogical :: Min = FalseVal !% stored keys in the priority queue. tCharAlloc :: Keys (:) !% length of character string tIndex :: CharLen = 80_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Public Procedures                    ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%CreateEmpty(CharLen, InitCap)            ! use default options  <br> !   --->    CALL PQ%CreateEmpty(72, 32, MinPQ=.TRUE.)        ! use min-priority queue <br> !   --->    CALL PQ%CreateEmpty(72, 32, IncSize=16)          ! specify incremental size <br> !   --->    CALL PQ%CreateEmpty(72, 32, Shrink=.TRUE.)       ! specify shrinking <br> !   --->    CALL PQ%CreateEmpty(72, 32, .TRUE., 16, .TRUE.)  ! specify all options <br> PROCEDURE :: CreateEmpty => PQHeap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL PQ%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> PROCEDURE :: Construct => PQHeap_ConstructorByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all stored keys and free all memory currently used by the priority !       queue.  Optionally, stored keys can be retrieved. <br> !  **Usage**: <br> !   --->    CALL PQ%Destruct() <br> !   --->    CALL PQ%Destruct(StoredKeys) <br> PROCEDURE :: Destruct => PQHeap_Destructor ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%Insert(Key) <br> PROCEDURE :: Insert => PQHeap_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Remove(Key) <br> !   --->    IF (.NOT.PQ%Remove(Key)) DoSomething PROCEDURE :: Remove => PQHeap_RemoveKey ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the priority queue is empty or not. <br> !  **Usage**: <br> !   --->    Flag = PQ%IsEmpty() <br> !   --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => PQHeap_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (number of stored keys) of the priority queue. <br> !  **Usage**: <br> !   --->    Size = PQ%GetSize() PROCEDURE :: GetSize => PQHeap_GetSize !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Peek(Key) <br> !   --->    IF (.NOT.PQ%Peek(Key)) DoSomething PROCEDURE :: Peek => PQHeap_PeekKey ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQHeap_Finalizer ! --------------------------------------------------------------------- END TYPE PQCharacter","tags":"","loc":"type\\pqcharacter.html"},{"title":"HTabRealQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabRealQP The HTabRealQP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabRealQP object. Arguments Type Intent Optional Attributes Name type( HTabRealQP ), intent(inout) :: Table HTabRealQP object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object integer(kind=kInt32), intent(in) :: N number of key-value pairs real(kind=kQuad), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabRealQP , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(in) :: Table HTabRealQP object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(in) :: Table HTabRealQP object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object real(kind=kQuad), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabRealQP ), intent(inout) :: Table HTabRealQP object type( ListRealQP ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabrealqp.html"},{"title":"ListInteger8B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListInteger8B ListInteger8B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt64) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListInteger8B ), intent(inout) :: List ListInteger8B object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt64), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListInteger8B object. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt64), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node integer(kind=kInt64), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt64), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(in) :: List ListInteger8B object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(in) :: List ListInteger8B object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(in) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(in) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt64), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(inout) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger8B ), intent(in) :: List ListInteger8B object integer(kind=kInt64), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listinteger8b.html"},{"title":"HashList – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseSymTable ) :: HashList The HashList type is a collection type that employs a separate-chaining hash table\n implementation to provide common operations for an unordered symbol table.  The HashList type utilizes the IntrusiveHashList type as its component to store TabNode objects.\n As an intrusive container, the IntrusiveHashList type provides common operations for\n hash table without a memory management task.  The memory management task of the inserted TabNode objects is handled by the HashList type. As an unordered symbol table, the HashList type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the HashList type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalization Procedures final :: HashList_Finalize To perform finalization of the object. private  subroutine HashList_Finalize(Collection) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( HashList ), intent(inout) :: Collection Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function BaseCollection_IsEmpty(Collection) result(Flag) To check whether the collection is currently empty or not. Arguments Type Intent Optional Attributes Name class( BaseCollection ), intent(in) :: Collection collection object Return Value logical true if the collection currently contains no item. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. private  subroutine BaseSymTable_ClearEntries(Collection) To remove all of the pair data items from the collection. This routine provides a basic implementation of the Clear deferred procedure required by the BaseCollection class.\n This routine should be overridden if a better implementation\n is available. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() private  function BaseSymTable_GetKeyPtr(Collection) result(Key) To get a pointer to a key stored in a symbol table.  The pointer is intended to be\n used as a mold for the key (i.e. provides type of the stored keys).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored key procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() private  function BaseSymTable_GetValPtr(Collection) result(Val) To get a pointer to a value stored in a symbol table.  The pointer is intended to be\n used as a mold for the value (i.e. provides type of the stored values).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(in), TARGET :: Collection symbol table Return Value class(*), POINTER pointer to a stored value procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_SetMolds(Collection, KeyMold, ValMold) To set the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in), optional :: KeyMold mold for stored keys class(*), intent(in), optional :: ValMold mold for stored values procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. private  subroutine BaseSymTable_FreeMolds(Collection) To free the \"KeyMold\" and \"ValMold\" components. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsKeyValid(Collection, Key, IsOrderedKey) result(Valid) To check whether the type of specified key is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Key the key to be checked logical, intent(in) :: IsOrderedKey true if the specified key must be an ordered key; false if the specified key is an unordered key. Return Value logical true if type of the specified key is valid procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. private  function BaseSymTable_IsValValid(Collection, Val) result(Valid) To check whether the type of specified value is valid or not. Arguments Type Intent Optional Attributes Name class( BaseSymTable ), intent(inout) :: Collection symbol table class(*), intent(in) :: Val value to be checked Return Value logical true if type of the specified value is valid procedure, public :: CopyCollection => HashList_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine HashList_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Destruct => HashList_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine HashList_Destroy(Collection) To destruct the collection. This is a deferred procedure by the BaseCollection class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection HashList object procedure, public :: GetSize => HashList_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function HashList_GetSize(Collection) result(Size) To get the number of items in the collection.\n This is a deferred procedure inherited from the BaseCollection type. Arguments Type Intent Optional Attributes Name class( HashList ), intent(in) :: Collection Return Value integer(kind=kInt32) procedure, public :: StartFirst => HashList_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) private  function HashList_Move2FirstPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsEmpty) To move to the first (starting) pair data in a symbol table.\n For the HashList , which is an unordered symbol table,\n the starting pair is the first pair inserted. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional :: Value the first value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the collection contains no pair data or not - true if the collection is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashList_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) private  function HashList_Move2NextPair(Collection, Key, Value, KeyCopy, ValCopy) result(IsTheEnd) To move to the next pair data in a symbol table.\n For the HashList , which is an unordered symbol table,\n the next pair is the pair inserted after the previous one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(inout), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional :: Value the next value as output if requested (and available) procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the\n collection occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => HashList_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) private  subroutine HashList_Insert(Collection, Key, Value) To add a key-value pair into a symbol table.  If the specified key is already\n stored in the table, replace the old value with the new one. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be added to the collection class(*), intent(in) :: Value the associated value to be added to the collection procedure, public :: Delete => HashList_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). private  subroutine HashList_Delete(Collection) To delete a key-value pair from a symbol table.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward procedures.\n Therefore, after the call to either procedure and then calling this procedure\n will result in a removal of the current key-value pair of the iteration (i.e.\n the same key-value pair that can be retrieved via those Move procedures). This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object procedure, public :: Remove => HashList_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething private  function HashList_Remove(Collection, Key) result(Flag) To delete the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be removed from the collection Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: Contain => HashList_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething private  function HashList_Contain(Collection, Key) result(Found) To check whether the specified key is currently stored in a symbol table. This is a deferred procedure by the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashList_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething private  function HashList_GetValue(Collection, Key, Value, ValCopy) result(Flag) To get a value associated with the specified key in a symbol table.\n Also, return a flag indicating whether the key-value pair is successfully\n found or not. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection symbol-table collection object class(*), intent(in) :: Key the key to be looked for in the collection class(*), intent(inout) :: Value the value associated with the specified key procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: ToArray => HashList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething private  function HashList_ToArray(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get and remove all key-value pairs from the collection.  Also, return a flag\n indicating whether the pairs are successfully retrieved and removed or not. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection HashList object class(*), intent(inout) :: Keys (:) the keys to be retrieved and removed from the collection class(*), intent(inout) :: Values (:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => HashList_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething private  function HashList_GetAll(Collection, Keys, Values, KeyCopy, ValCopy) result(Success) To get all keys and/or all values (without removing them) from the collection.  Also,\n return a flag indicating whether the keys and/or values are successfully retrieved. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection HashList object class(*), intent(inout), optional :: Keys (1:) the keys to be retrieved and removed from the collection class(*), intent(inout), optional :: Values (1:) the values associated with the keys procedure(IfacePolyCopy), optional :: KeyCopy a procedure to copy stored keys for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: CreateEmpty => HashList_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()            ! use default options --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity private  subroutine HashList_CreateEmpty(Collection, InitCap) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table generic, public :: Construct => CopyCollection , HashList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine HashList_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other). This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseSymTable class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items (or keys) for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine HashList_CreateByArray(Collection, N, Keys, Values) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of key-value pairs class(*), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table procedure, public :: Copy => HashList_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine HashList_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Note :  SrcObj must be in the HashList class. Arguments Type Intent Optional Attributes Name class( HashList ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => HashList_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function HashList_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashList ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => HashList_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine HashList_MemFree(Obj) To free memory of the HashList object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashList ), intent(inout) :: Obj procedure, public :: ToString => HashList_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function HashList_ToString(Obj) result(Str) To get the name of the HashList type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashList ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => HashList_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function HashList_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( HashList ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseSymTable ) :: HashList PRIVATE ! a working hash table TYPE ( IntrusiveHashList ) :: WrkTab !> memory pool of hash-list nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashList_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashList_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashList_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => HashList_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: HashList_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashList_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashList_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashList_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashList_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashList_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashList_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => HashList_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashList_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashList_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashList_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashList_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashList_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()            ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity <br> PROCEDURE :: CreateEmpty => HashList_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) <br> GENERIC :: Construct => HashList_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashList_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashList_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashList_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashList_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashList_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: HashList_Finalize ! --------------------------------------------------------------------- END TYPE HashList","tags":"","loc":"type\\hashlist.html"},{"title":"HTabInteger8B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: HTabInteger8B The HTabInteger8B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalization Procedures final :: HashTable_Finalize To perform finalization of the hash table. private  subroutine HashTable_Finalize(Table) To perform finalization of the HTabInteger8B object. Arguments Type Intent Optional Attributes Name type( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashTable_CreateEmpty(Table, InitCap, LoadFactor, ProbAlgo, HashCalc) To create an empty hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) private  subroutine HashTable_CreateByArray(Table, N, Keys, Values, LoadFactor, ProbAlgo, HashCalc) To create a table from an array of key-value pairs. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt32), intent(in) :: N number of key-value pairs integer(kind=kInt64), intent(in) :: Keys (N) the keys to be added to the table class(*), intent(in) :: Values (N) the associated values to be added to the table real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the key;\n if not present, use default hash function. procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() private  subroutine HashTable_ClearItems(Table) To free components of the items from the table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. private  subroutine HashTable_Destroy(Table) To destruct the table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) private  subroutine HashTable_Insert(Table, Key, Value) To add a key-value pair into the hash table.  If the specified key\n is already stored in the table, replace the old value with the\n new one. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(in) :: Key key to be inserted class(*), intent(in) :: Value associated value procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething private  function HashTable_Remove(Table, Key, Value) result(Flag) To remove the specified key (and its associated value) from a symbol\n table.  Also, return a flag indicating whether the key-value pair is\n successfully removed or not.  Optionally, retrieve the associated\n value if the key exists in the table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(in) :: Key key to be removed class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) private  function HashTable_Move2FirstPair(Table, Key, Value) result(IsEmpty) To move to the first (starting) pair data in a hash table.   For the hash table,\n which is an unordered symbol table, the starting pair is the first pair found\n in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(out), optional :: Key the first key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the first value as output if requested (and available) Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. private  function HashTable_Move2NextPair(Table, Key, Value) result(IsTheEnd) To move to the next pair data in a symbol table.  For the HTabInteger8B , which\n is an unordered symbol table,  the next pair is a pair inserted in the first\n non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either\n by an insertion or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(out), optional :: Key the next key as output if requested (and available) class(*), intent(inout), optional, ALLOCATABLE :: Value the next value as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing private  function HashTable_IsEmpty(Table) result(Flag) To check whether the hash table is empty or not. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(in) :: Table HTabInteger8B object Return Value logical true if the table is empty procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() private  function HashTable_GetSize(Table) result(Size) To return the number of keys currently in the hash table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(in) :: Table HTabInteger8B object Return Value integer(kind=kInt32) the number of keys procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething private  function HashTable_Contain(Table, Key) result(Found) To check whether the specified key is currently stored in a symbol table. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(in) :: Key key to be looked for Return Value logical flag indicating whether the specified key is found or not. procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething private  function HashTable_GetValue(Table, Key, Value) result(Flag) To retrieve the associated value of the specified key.  Also, return\n a flag indicating whether the value is successfully retrieved or not. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object integer(kind=kInt64), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the value is successfully retrieved or not. procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue) private  subroutine HashTable_GetAllKeys(Table, KeyQ, ValueQ) To return all keys in the table and optionally all associated values. Arguments Type Intent Optional Attributes Name class( HTabInteger8B ), intent(inout) :: Table HTabInteger8B object type( ListInteger8B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue","tags":"","loc":"type\\htabinteger8b.html"},{"title":"DArrInteger4B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrInteger4B DArrInteger4B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt32) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt32), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger4B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt32), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt32), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container DArrInteger4B object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt32), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(inout) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger4B ), intent(in) :: Container DArrInteger4B object integer(kind=kInt32), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrinteger4b.html"},{"title":"ListInteger2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListInteger2B ListInteger2B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt16) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListInteger2B ), intent(inout) :: List ListInteger2B object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt16), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListInteger2B object. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt16), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node integer(kind=kInt16), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt16), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(in) :: List ListInteger2B object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(in) :: List ListInteger2B object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(in) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(in) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt16), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(inout) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger2B ), intent(in) :: List ListInteger2B object integer(kind=kInt16), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listinteger2b.html"},{"title":"TreeInteger4B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeInteger4B TreeInteger4B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeInteger4B ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt32), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree type( ListInteger4B ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree TreeInteger4B object integer(kind=kInt32), intent(in) :: Low low key integer(kind=kInt32), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Low low key integer(kind=kInt32), intent(in) :: High high key type( ListInteger4B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree type( ListInteger4B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: InKey input key integer(kind=kInt32), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: InKey input key integer(kind=kInt32), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank integer(kind=kInt32), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeInteger4B ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treeinteger4b.html"},{"title":"DArrCmpxSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrCmpxSP DArrCmpxSP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kSingle) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kSingle), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxSP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kSingle), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container DArrCmpxSP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container DArrCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(inout) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxSP ), intent(in) :: Container DArrCmpxSP object complex(kind=kSingle), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrcmpxsp.html"},{"title":"ListCmpxSP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListCmpxSP ListCmpxSP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kSingle) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListCmpxSP ), intent(inout) :: List ListCmpxSP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kSingle), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListCmpxSP object. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kSingle), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node complex(kind=kSingle), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(in) :: List ListCmpxSP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(in) :: List ListCmpxSP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(in) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(in) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items complex(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(inout) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListCmpxSP ), intent(in) :: List ListCmpxSP object complex(kind=kSingle), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listcmpxsp.html"},{"title":"ListInteger4B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListInteger4B ListInteger4B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt32) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListInteger4B ), intent(inout) :: List ListInteger4B object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt32), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListInteger4B object. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt32), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node integer(kind=kInt32), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt32), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(in) :: List ListInteger4B object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(in) :: List ListInteger4B object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(in) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(in) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt32), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(inout) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger4B ), intent(in) :: List ListInteger4B object integer(kind=kInt32), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listinteger4b.html"},{"title":"DArrCmpxQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrCmpxQP DArrCmpxQP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kQuad) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object integer(kind=kInt32), intent(in) :: N number of items complex(kind=kQuad), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxQP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kQuad), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container DArrCmpxQP object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container DArrCmpxQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items complex(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(inout) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrCmpxQP ), intent(in) :: Container DArrCmpxQP object complex(kind=kQuad), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrcmpxqp.html"},{"title":"ListInteger1B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListInteger1B ListInteger1B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt8) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListInteger1B ), intent(inout) :: List ListInteger1B object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt8), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListInteger1B object. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt8), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node integer(kind=kInt8), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt8), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(in) :: List ListInteger1B object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(in) :: List ListInteger1B object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(in) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(in) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items integer(kind=kInt8), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(inout) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListInteger1B ), intent(in) :: List ListInteger1B object integer(kind=kInt8), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listinteger1b.html"},{"title":"TreeCharacter – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeCharacter TreeCharacter is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeCharacter ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys character(len=*), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree type( ListCharacter ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), optional, ALLOCATABLE :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree TreeCharacter object character(len=*), intent(in) :: Low low key character(len=*), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), ALLOCATABLE :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=:), intent(out), ALLOCATABLE :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Low low key character(len=*), intent(in) :: High high key type( ListCharacter ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree type( ListCharacter ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: InKey input key character(len=:), intent(out), ALLOCATABLE :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: InKey input key character(len=:), intent(out), ALLOCATABLE :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank character(len=:), intent(out), ALLOCATABLE :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree character(len=*), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeCharacter ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treecharacter.html"},{"title":"ListRealQP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ListRealQP ListRealQP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kQuad) . Finalization Procedures final :: LinkedList_Finalizer To perform finalization of the container. private  subroutine LinkedList_Finalizer(List) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( ListRealQP ), intent(inout) :: List ListRealQP object Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items private  subroutine LinkedList_CreateByArray(List, N, Items) To construct a list from an array of item. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object integer(kind=kInt32), intent(in) :: N number of items real(kind=kQuad), intent(in) :: Items (N) an array of items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. private  subroutine LinkedList_Destructor(List) To destruct ListRealQP object. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) private  subroutine LinkedList_AddFirst(List, Item) To add a item at the head of the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething private  function LinkedList_AddAt(List, Index, Item) result(Flag) To insert the given item at the specified index where the index must be\n between 1 and the list size.  Also, return a flag indicating whether the\n item is successfully added. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kQuad), intent(in) :: Item the item to be added to the list Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item private  subroutine LinkedList_Remove(List, First, Item) To remove a node from the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object logical, intent(in), optional :: First location flag where the node is removed - true (by default) if want to remove the first node - false if want to remove the last node real(kind=kQuad), intent(out), optional :: Item item of the removed node if requested procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething private  function LinkedList_RemoveAt(List, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the list size.   Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). private  subroutine LinkedList_Delete(List) To delete an item from the list.  This procedure is intended to be used\n in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward ).  Therefore, after the call to one of\n these methods and then calling this procedure will result in a removal\n of the current item of the iteration (i.e. the same item that can be\n retrieved via those methods). If the cursor pointer is not associated, nothing happens.  This usually\n means that the list is empty or this procedure is called before those\n iteration methods. This procedure provides a way to remove items in the middle of the list\n without knowing specific locations of the items.  The user would perform\n an iteration over the list by calling those iteration methods.  While in\n the middle of the iteration, if the interested items are found, they can\n be removed from the list by this procedure. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() private  subroutine LinkedList_ClearItems(List) To free up memory of the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething private  function LinkedList_ToArray(List, Items) result(Flag) To get and remove all items from the list.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(inout), ALLOCATABLE :: Items (:) the item to be removed from the list Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() private  subroutine LinkedList_RemoveDuplicates(List) To remove nodes with duplicated items from the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. private  function LinkedList_Move2FirstElm(List, Item) result(IsEmpty) To move to the head node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out), optional :: Item first item Return Value logical true if the list is empty procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list. ! start forward iteration (from the first item)\n  IsTheEnd = List%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward(CurrItem)\n  END DO private  function LinkedList_Move2NextElm(List, Item) result(IsTheEnd) To move (forward) to the next node in the list and return a flag indicating\n whether the cursor pointer has reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out), optional :: Item item of the next node Return Value logical true if the cursor has reached the end of the list procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. private  function LinkedList_Move2LastElm(List, Item) result(IsEmpty) To move to the tail node of the list and return\n a flag indicating whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out), optional :: Item last item Return Value logical true if the list is empty procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the list in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = List%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward(CurrItem)\n  END DO private  function LinkedList_Move2PrevElm(List, Item) result(IsTheEnd) To move backward to the next node (i.e. to the so-called previous node)\n in the list and return a flag indicating whether the cursor pointer has\n reached the end of the list or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out), optional :: Item item of the previous node Return Value logical true if the cursor has reached the end of the list procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing private  function LinkedList_IsEmpty(List) result(Flag) To check whether the list is empty or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(in) :: List ListRealQP object Return Value logical true if the list is empty procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() private  function LinkedList_GetSize(List) result(Size) To get size of the list (a number of nodes). Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(in) :: List ListRealQP object Return Value integer(kind=kInt32) list size (number of nodes) procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething private  function LinkedList_PeekFirst(List, Item) result(Flag) To retrieve the item stored at the first node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(in) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(in) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething private  function LinkedList_PeekAt(List, Index, Item) result(Flag) To get the item (without removing it from the list) at the specified index\n where the index must be between 1 and the list size.  Also, return\n a flag indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object integer(kind=kInt32), intent(in) :: Index the one-based index into the list's items real(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething private  function LinkedList_GetAllItems(List, Items) result(Flag) To get all items (without removing them) from the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out), ALLOCATABLE :: Items (:) an allocatable array of items Return Value logical flag indicating whether the items are successfully retrieved. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function LinkedList_RemoveFirst(List, Item) result(Flag) To get and remove the first item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine LinkedList_AddLast(List, Item) To add a item at the tail of the list. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(in) :: Item item to be added to the list procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function LinkedList_RemoveLast(List, Item) result(Flag) To get and remove the last item of the list.  Also, return\n a flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(inout) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be removed from the list Return Value logical flag indicating whether the item is successfully removed. - true if the list is NOT empty.\n- false if the list is empty. procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function LinkedList_PeekLast(List, Item) result(Flag) To retrieve the item stored at the last node without removing it from the list.\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( ListRealQP ), intent(in) :: List ListRealQP object real(kind=kQuad), intent(out) :: Item the item to be retrieved from the list Return Value logical flag indicating whether the item is available. - true if the list is NOT empty.\n- false if the list is empty.","tags":"","loc":"type\\listrealqp.html"},{"title":"TreeInteger2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: TreeInteger2B TreeInteger2B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalization Procedures final :: BSTree_Finalizer To perform finalization of the tree. private  subroutine BSTree_Finalizer(Tree) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( TreeInteger2B ), intent(inout) :: Tree tree Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) private  subroutine BSTree_ConstructByArray(Tree, N, Keys, Values) To construct a tree based on specified arrays. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: N number of keys integer(kind=kInt16), intent(in) :: Keys (N) an array of keys class(*), intent(in) :: Values (N) an array of associated values generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) private  subroutine BSTree_Destructor_I(Tree) To destruct a tree. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree private  subroutine BSTree_Destructor_II(Tree, KeyQ, ValueQ) To destruct a tree and get its pair data. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree type( ListInteger2B ), intent(out) :: KeyQ a queue of stored keys type( ListAnyType ), intent(out) :: ValueQ a queue of stored values procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) private  subroutine BSTree_Insert(Tree, Key, Value) To insert the given key-value pair into the tree.\n If the tree already contains the specified key, the\n old value is replaced with the new one. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Key key to be inserted class(*), intent(in) :: Value value to be inserted procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething private  function BSTree_Remove(Tree, Key, Value) result(Flag) To remove the specified key and its associated value from the tree.\n Optionally, to retrieve the associated value of the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Key key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething private  function BSTree_RemoveMin(Tree, Key, Value) result(Flag) To remove the smallest key and its associated value from the tree.\n Optionally, to retrieve the smallest key and its the associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething private  function BSTree_RemoveMax(Tree, Key, Value) result(Flag) To remove the largest key and its associated value from the tree.\n Optionally, to retrieve the largest key and its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) private  function BSTree_Move2First(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with smallest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key the smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) private  function BSTree_Move2NextPair(Tree, Key, Value) result(EndOfTree) To move to the next node in inorder traversal (and optionally to retrieve\n the key and value of the next node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key key of the next node class(*), intent(out), optional, ALLOCATABLE :: Value value of the next node Return Value logical true if the current iteration node is  at the end of tree (i.e. the next node does not exist). procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) private  function BSTree_Move2Last(Tree, Key, Value) result(EmptyTree) To restart the iteration at the node with largest key (and optionally to retrieve\n the key and value of that node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key the largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical true if the tree is empty procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) private  function BSTree_Move2PrevPair(Tree, Key, Value) result(EndOfTree) To move to the previous node in inorder traversal (and optionally to retrieve\n the key and value of the previous node if requested). Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out), optional :: Key key of the previous node class(*), intent(out), optional, ALLOCATABLE :: Value value of the previous node Return Value logical true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing private  function BSTree_IsEmpty(Tree) result(Flag) To check whether the tree is empty or not. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(in) :: Tree tree Return Value logical true if the tree is empty procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething private  function BSTree_FindKey(Tree, Key, KeyNode) result(Found) To find the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Key the key to be looked for type(RedBlackNode), intent(out), optional, POINTER :: KeyNode the node containing the specified key Return Value logical true if the key found procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() private  function BSTree_GetSize(Tree) result(Size) To get size of the tree. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(in) :: Tree tree Return Value integer(kind=kInt32) size of the tree procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) private  function BSTree_GetSize_Range(Tree, Low, High) result(Size) To get the number of keys in the tree in the given range. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree TreeInteger2B object integer(kind=kInt16), intent(in) :: Low low key integer(kind=kInt16), intent(in) :: High high key Return Value integer(kind=kInt32) size of the tree procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething private  function BSTree_GetValue(Tree, Key, Value) result(Found) To retrieve value associated with the specified key. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Key key to be looked for class(*), intent(out), ALLOCATABLE :: Value value associated with the key Return Value logical true if the key and its associated value found; false if the key is not in the tree. procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething private  function BSTree_GetSmallestKey(Tree, Key, Value) result(Flag) To return the smallest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out) :: Key smallest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething private  function BSTree_GetLargestKey(Tree, Key, Value) result(Flag) To return the largest key in the tree and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(out) :: Key largest key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) private  subroutine BSTree_GetKeys_Range(Tree, Low, High, KeyQ, ValueQ) To return all keys in the tree in the given range and optionally also\n return all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Low low key integer(kind=kInt16), intent(in) :: High high key type( ListInteger2B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue private  subroutine BSTree_GetKeys_All(Tree, KeyQ, ValueQ) To return all keys in the tree and optionally all associated values. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree type( ListInteger2B ), intent(out) :: KeyQ key queue type( ListAnyType ), intent(out), optional :: ValueQ value queue procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Floor(Tree, InKey, OutKey, Value) result(Flag) To return the largest key in the tree less than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: InKey input key integer(kind=kInt16), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething private  function BSTree_Ceiling(Tree, InKey, OutKey, Value) result(Flag) To return the smallest key in the tree greater than or equal to the given key\n and optionally its associated value. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: InKey input key integer(kind=kInt16), intent(out) :: OutKey output key class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething private  function BSTree_Select(Tree, Rank, Key, Value) result(Flag) To return the key in the tree of a given rank.\n This key has the property that there are rank keys in\n the tree that are smaller. In other words, this key is the\n (rank+1)st smallest key in the tree. Note: applicable range of rank is between 0 and tree_size-1.\n      (this rank number is zero-based). Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt32), intent(in) :: Rank rank integer(kind=kInt16), intent(out) :: Key key of the given rank class(*), intent(out), optional, ALLOCATABLE :: Value associated value Return Value logical flag indicating whether the key-value pair is found or not. procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) private  function BSTree_Rank(Tree, Key) result(Rank) To return the number of keys in the tree strictly less than the given key. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree integer(kind=kInt16), intent(in) :: Key key Return Value integer(kind=kInt32) rank of key procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething private  function BSTree_CheckBST(Tree) result(Flag) To check integrity of BST data structure. Arguments Type Intent Optional Attributes Name class( TreeInteger2B ), intent(inout) :: Tree tree Return Value logical flag for integrity","tags":"","loc":"type\\treeinteger2b.html"},{"title":"HashSet – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public, extends( BaseIterable ) :: HashSet The HashSet type is a collection type that employs an open-addressing hash table\n implementation to provide common operations for an unordered set.  It makes no\n guarantees as to the iteration order of the set; in particular, it does not guarantee\n that the order will remain constant over time. Finalization Procedures final :: HashSet_Finalize To perform finalization of the hash set. private  subroutine HashSet_Finalize(Collection) To perform finalization of the collection. Arguments Type Intent Optional Attributes Name type( HashSet ), intent(inout) :: Collection collection Type-Bound Procedures procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() private  function BaseIterable_GetItemPtr(Collection) result(Val) To get a pointer to an item stored in a collection.  The pointer is intended to be\n used as a mold for the item (i.e. provides type of the stored items).  Return null\n pointer if the table is empty. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(in), TARGET :: Collection collection Return Value class(*), POINTER pointer to a stored item procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_SetMold(Collection, Mold) To set the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Mold mold for stored items procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. private  subroutine BaseIterable_FreeMold(Collection) To free the \"Mold\" component. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. private  function BaseIterable_IsItemValid(Collection, Item) result(Valid) To check whether the type of specified item is valid or not. Arguments Type Intent Optional Attributes Name class( BaseIterable ), intent(inout) :: Collection collection object class(*), intent(in) :: Item the item to be added to the collection Return Value logical true if type of the specified item is valid procedure, public :: CopyCollection => HashSet_CopyCollection Use the Construct method to construct the collection from another collection. private  subroutine HashSet_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). procedure, public :: Clear => HashSet_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() private  subroutine HashSet_ClearItems(Collection) To free components of the items from the set. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection procedure, public :: Destruct => HashSet_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() private  subroutine HashSet_Destroy(Collection) To destruct the set. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection procedure, public :: GetSize => HashSet_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() private  function HashSet_GetSize(Collection) result(Size) To return the number of items currently in the hash set. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: Collection collection Return Value integer(kind=kInt32) the number of items procedure, public :: IsEmpty => HashSet_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing private  function HashSet_IsEmpty(Collection) result(Flag) To check whether the hash set is empty or not. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: Collection collection Return Value logical true if the set is empty procedure, public :: StartFirst => HashSet_Move2FirstItem Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) private  function HashSet_Move2FirstItem(Collection, Item, ItemCopy) result(IsEmpty) To move to the first (starting) pair data in a collection.   For the hash set, which is\n an unordered set, the starting pair is the first pair found in the non-empty bucket. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Item the first item as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the table contains no pair data or not - true if the table is empty. - otherwise the first pair data is available. procedure, public :: MoveForward => HashSet_Move2NextItem Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. private  function HashSet_Move2NextItem(Collection, Item, ItemCopy) result(IsTheEnd) To move to the next pair data in a collection.  For the hash set, which is an unordered set,\n the next pair is a pair inserted in the first non-empty bucket after the previous one. The routine will report an error if an alteration to stored item(s) (either by an insertion\n or a removal) has been occurred during current iteration. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection class(*), intent(inout), optional :: Item the next item as output if requested (and available) procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical a flag indicating whether the move to the end of the table occurs or not - true if next pair data is NOT available. - otherwise next pair data is available. procedure, public :: Insert => HashSet_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified item to the collection. Usage : --->    CALL Collection%Insert(Item) private  subroutine HashSet_Insert(Collection, Item) To add an item into the hash set.  If the specified item is already stored\n in the set, report severe error and return immediately. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be inserted procedure, public :: Delete => HashSet_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine HashSet_Delete(Collection) To delete a item of the current iteration from a collection. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection symbol-table collection object procedure, public :: ToArray => HashSet_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n      indicating whether the items are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething private  function HashSet_ToArray(Collection, Items, ItemCopy) result(Success) To get and remove all items from the collection.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection HashSet object class(*), intent(inout) :: Items (:) the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved and removed. procedure, public :: GetAll => HashSet_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are successfully retrieved or not. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething private  function HashSet_GetAll(Collection, Items, ItemCopy) result(Success) To get all items (without removing them) from the collection.  Also,\n return a flag indicating whether the items are successfully retrieved. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection HashSet object class(*), intent(inout) :: Items (1:) the item to be removed from the collection procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored items for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). Return Value logical flag indicating whether the items are successfully retrieved. procedure, public :: CreateEmpty => HashSet_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                                     ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                           ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)                       ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                           ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt)           ! specify hash function --->    CALL Table%CreateEmpty(ItemCopy=CopyProc)                    ! specify copy procedure --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt, CopyProc) ! specify all options Note1 : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. private  subroutine HashSet_CreateEmpty(Collection, InitCap, LoadFactor, ProbAlgo, HashCalc, ItemCopy) To create an empty hash set. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in), optional :: InitCap initial capacity of the hash set real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the item; if not present, use default one. procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored data for a derived type not in the Object class;\n required if the type of items to be stored has allocatable/pointer component(s). generic, public :: Construct => CopyCollection , HashSet_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional arguments (see the CreateEmpy method) --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) private  subroutine HashSet_CopyCollection(This, Other, ItemCopy, ValCopy) To creates a new collection (This) with the same items as the given collection (Other).\n This is a deferred procedure by the BaseCollection class. Note :  Other must be in the BaseIterable class. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: This collection object to be created class( BaseCollection ), intent(inout) :: Other collection object to be copied procedure(IfacePolyCopy), optional :: ItemCopy a helper procedure to copy stored items for a derived type not in the Object class;\n required if the derived type has allocatable/pointer component(s). procedure(IfacePolyCopy), optional :: ValCopy a helper procedure to copy stored values for a derived type not in the Object class; required if the derived type has allocatable/pointer component(s). private  subroutine HashSet_CreateByArray(Collection, N, Items, LoadFactor, ProbAlgo, HashCalc, ItemCopy) To create a table from an array of items. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection integer(kind=kInt32), intent(in) :: N number of items class(*), intent(in) :: Items (N) the items to be added to the set real(kind=kDouble), intent(in), optional :: LoadFactor load factor integer(kind=kInt32), intent(in), optional :: ProbAlgo probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) procedure(HashFunc), optional :: HashCalc hash function to compute the hash value of the item; if not present, use default one. procedure(IfacePolyCopy), optional :: ItemCopy a procedure to copy stored data for a derived type not in the Object class; required if\n the type of specified items to be stored has allocatable/pointer component(s). procedure, public :: Contain => HashSet_Contain Type-Bound Function : Contain Purpose :  To find the specified item in the collection.  Return true if\n               the specified item is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Item) --->    IF (.NOT.Collection%Contain(Item)) DoSomething private  function HashSet_Contain(Collection, Item) result(Found) To check whether the specified item is currently stored in a collection. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be looked for Return Value logical flag indicating whether the specified item is found or not. procedure, public :: Remove => HashSet_Remove Type-Bound Function : Remove Purpose :  To remove the specified item from the collection.  Also, return a flag\n               indicating whether the item is successfully removed or not. Usage : --->    Flag = Collection%Remove(Item) --->    IF (.NOT.Collection%Remove(Item)) DoSomething private  function HashSet_Remove(Collection, Item) result(Flag) To remove the specified item (and its associated value) from a collection.  Also,\n return a flag indicating whether the item is successfully removed or not. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Collection collection class(*), intent(in) :: Item item to be removed Return Value logical flag indicating whether the specified item and its associated\n value are successfully removed or not. procedure, public :: Copy => HashSet_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) private  subroutine HashSet_Copy(SrcObj, DstObj, IsDeep) To copy the source object to the destination object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: SrcObj source object class(Object), intent(out) :: DstObj destination object logical, intent(in), optional :: IsDeep Flag indicating whether to perform deep copy or shallow copy. - If present and true, perform a deep copy. - If present and false, perform a shallow copy. - If not present, perform either a shallow or a deep copy that is naturally most\n   suitable for the object's components. procedure, public :: IsEqualTo => HashSet_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething private  function HashSet_IsEqualTo(LhsObj, RhsObj) result(Flag) To check whether LhsObj and RhsObj are equal or not.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: LhsObj an object class(Object), intent(in) :: RhsObj another object Return Value logical true if both objects are equal procedure, public :: MemFree => HashSet_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() private  subroutine HashSet_MemFree(Obj) To free memory of the HashSet object.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(inout) :: Obj procedure, public :: ToString => HashSet_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() private  function HashSet_ToString(Obj) result(Str) To get the name of the HashSet type.\n This is a deferred procedure inherited from the Object type. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: Obj Return Value character(kind=kChar, len=:), ALLOCATABLE procedure, public :: HashCode => HashSet_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() private  function HashSet_HashCode(Obj) result(Code) To compute hash code for this object. Arguments Type Intent Optional Attributes Name class( HashSet ), intent(in) :: Obj Return Value integer(kind=kInt32) Source Code TYPE , EXTENDS ( BaseIterable ) :: HashSet PRIVATE !% current capacity of the hash set tIndex :: Capacity = DefaultCapacity !% working table items used to store items TYPE ( SetItem ), ALLOCATABLE :: Items (:) !% current index into the working items (used for iteration purpose) tIndex :: Indx = 0_kIndex !% the number of items not yet visited (used for iteration purpose) tIndex :: ItemLeft = 0_kIndex !% current modification count (used for iteration purpose) tIndex :: IterModCount = 0_kIndex !% load factor tRealDP :: LoadFactor = DefaultLoadFactor !% threshold for resizing tIndex :: Threshold = 0_kIndex !% modification count tIndex :: ModCount = 0_kIndex !% the total number of used buckets inside the hash set (including cells marked as deleted). tIndex :: UsedBuckets = 0_kIndex !% the total number of unique items currently inside the hash set. tIndex :: ItemCount = 0_kIndex !% probing algorithm tSInt32 :: ProbAlgo = LinearProbing !% index for double hashing tHash :: HashIndx = 0_kIndex !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool !> pointer to a hash function PROCEDURE ( HashFunc ), NOPASS , POINTER :: HashCalc => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: ItemCopy => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindItem <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindItem(Item) <br> !   --->    IF (.NOT.Collection%FindItem(Item)) DoSomething PROCEDURE , PRIVATE :: FindItem => HashSet_FindItem !> **Type-Bound Subroutine**: Resize <br> !  **Purpose**:  To resize the collection to the specified capacity. <br> !  **Usage**: <br> !   --->    CALL Collection%Resize(64) PROCEDURE , PRIVATE :: Resize => HashSet_Resize !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: HashSet_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashSet_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => HashSet_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashSet_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashSet_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => HashSet_IsEmpty ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => HashSet_Move2FirstItem !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => HashSet_Move2NextItem !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified item to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Item) <br> PROCEDURE :: Insert => HashSet_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => HashSet_Delete !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !       indicating whether the items are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => HashSet_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => HashSet_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()                                     ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)                           ! specify initial capacity <br> !   --->    CALL Table%CreateEmpty(LoadFactor=0.5)                       ! specify load factor <br> !   --->    CALL Table%CreateEmpty(ProbAlgo=2)                           ! specify probing algorithm <br> !   --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt)           ! specify hash function <br> !   --->    CALL Table%CreateEmpty(ItemCopy=CopyProc)                    ! specify copy procedure <br> !   --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt, CopyProc) ! specify all options <br> !  **Note1**: Any suitable hash function routine from the *ModBase_SimpleHash32*, !       *ModBase_SimpleHash64*, *ModBase_ReferenceHash32*, *ModBase_ReferenceHash64* !       *ModBase_OptimalHash32*, and *ModBase_OptimalHash64* modules can be used to !       specify the *HashCal* argument.  The term *suitable* means that any routine !       that has exactly the same interface as the *HashFunc* abstract function !       is the suitable one.  <br> !  **Note2**: Depending on a type of indices defined in the '*Macro - Basic Definitions.f90*' !       file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices !       while a 64-bit hash-function routine is a suitable one for 64-bit integer indices. !       This is a compile-time choice.  <br> PROCEDURE :: CreateEmpty => HashSet_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection and specify the optional arguments (see the *CreateEmpy* method) <br> !   --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => HashSet_CreateByArray !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Item) <br> !   --->    IF (.NOT.Collection%Contain(Item)) DoSomething PROCEDURE :: Contain => HashSet_Contain !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified item from the collection.  Also, return a flag !                indicating whether the item is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Item) <br> !   --->    IF (.NOT.Collection%Remove(Item)) DoSomething PROCEDURE :: Remove => HashSet_Remove ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashSet_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashSet_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashSet_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashSet_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashSet_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash set. FINAL :: HashSet_Finalize ! --------------------------------------------------------------------- END TYPE HashSet","tags":"","loc":"type\\hashset.html"},{"title":"DArrInteger2B – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: DArrInteger2B DArrInteger2B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt16) . Finalization Procedures final :: DynArr_Finalizer To perform finalization of the container. private  subroutine DynArr_Finalizer(Container) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) private  subroutine DynArr_CreateEmpty(Container, InitCap, IncSize, Shrink) To create an empty container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt32), intent(in) :: InitCap initial size of the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) private  subroutine DynArr_CreateByArray(Container, N, Items, IncSize, Shrink) To create a container from an array of items. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt32), intent(in) :: N number of items integer(kind=kInt16), intent(in) :: Items (N) the items to be added to the container integer(kind=kInt32), intent(in), optional :: IncSize incremental size of the container when it is full logical, intent(in), optional :: Shrink flag to shrink the container capacity - true if want to reduce capacity when the size is less than a quarter of the capacity. - otherwise, the capacity stays the same. - default is false. procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger2B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. private  subroutine DynArr_Destroy(Container) To destruct the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) private  subroutine DynArr_AddFirst(Container, Item) To insert the specified item at the front of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(in) :: Item the item to be added to the container procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(in) :: Item the item to be added to the container procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething private  function DynArr_AddAt(Container, Index, Item) result(Flag) To insert the specified item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully added. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt16), intent(in) :: Item the item to be added to the container Return Value logical flag indicating whether the item is successfully added. - true if the item is successfully added.\n- false if the item is NOT successfully added. procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething private  function DynArr_RemoveAt(Container, Index, Item) result(Flag) To get and remove the item at the specified index where the index must be\n between 1 and the container size.  Also, return a flag indicating whether\n the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt16), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the item is successfully removed.\n- false if the item is NOT successfully removed. procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). private  subroutine DynArr_Delete(Container) To delete an item from a container.  This procedure is intended\n to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of the methods and then\n calling this procedure will result in a removal of the current item\n of the iteration (i.e. the same item that can be retrieved via those\n methods). Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() private  subroutine DynArr_ClearItems(Container) To remove all of the items from the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething private  function DynArr_ToArray(Container, Items) result(Flag) To get and remove all items from the container.  Also, return\n a flag indicating whether the items are successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are successfully removed.\n- false if the items are NOT successfully removed. procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. private  function DynArr_Move2FirstElm(Container, Item) result(IsEmpty) To move to the front (first) element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout), optional :: Item the first element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the first element is available. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container. ! start forward iteration (from the first item)\n  IsTheEnd = Container%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward(CurrItem)\n  END DO private  function DynArr_Move2NextElm(Container, Item) result(IsTheEnd) To move (backward) to the next element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout), optional :: Item the next element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if next element is NOT available. - otherwise next element is available. procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. private  function DynArr_Move2LastElm(Container, Item) result(IsEmpty) To move to the last element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout), optional :: Item the last element as output if requested (and available) Return Value logical a flag indicating whether the container contains no element or not - true if the container is empty. - otherwise the last element is available. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to iterate over the container in reverse order. ! start backward iteration (from the last item)\n  IsTheEnd = Container%StartLast(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward(CurrItem)\n  END DO private  function DynArr_Move2PrevElm(Container, Item) result(IsTheEnd) To move to the previous element in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout), optional :: Item the previous element as output if requested (and available) Return Value logical a flag indicating whether the move to the end of the container occurs or not - true if previous element is NOT available. - otherwise previous element is available. procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() private  function DynArr_GetSize(Container) result(Size) To get the number of items in the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container Return Value integer(kind=kInt32) procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing private  function DynArr_IsEmpty(Container) result(Flag) To check whether the container is currently empty or not. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container DArrInteger2B object Return Value logical true if the container currently contains no item. procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething private  function DynArr_PeekFirst(Container, Item) result(Flag) To get the front (first) item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething private  function DynArr_PeekAt(Container, Index, Item) result(Flag) To get the item (without removing it from the container) at the specified index\n where the index must be between 1 and the container size.  Also, return a flag\n indicating whether the item is available or not. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container DArrInteger2B object integer(kind=kInt32), intent(in) :: Index the one-based index into the container's items integer(kind=kInt16), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the item is available.\n- false if the item is NOT available. procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething private  function DynArr_GetAll(Container, Items) result(Flag) To get all items (without removing them) from the container.  Also,\n return a flag indicating whether the items are available. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(out), ALLOCATABLE :: Items (:) the item to be removed from the container Return Value logical flag indicating whether the items are successfully removed. - true if the items are available.\n- false if the items are NOT available. procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(in) :: Item the item to be added to the container procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . private  function DynArr_RemoveFirst(Container, Item) result(Flag) To get and remove the first item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . private  subroutine DynArr_AddLast(Container, Item) To insert the specified item at the end of the container. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(in) :: Item the item to be added to the container procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . private  function DynArr_RemoveLast(Container, Item) result(Flag) To get and remove the last item of the container.  Also, return\na flag indicating whether the item is successfully removed. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(inout) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be removed from the container Return Value logical flag indicating whether the item is successfully removed. - true if the container is NOT empty.\n- false if the container is empty. procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast . private  function DynArr_PeekLast(Container, Item) result(Flag) To get the last item (without removing it from the container).\n Also, return a flag indicating whether the item is available. Arguments Type Intent Optional Attributes Name class( DArrInteger2B ), intent(in) :: Container DArrInteger2B object integer(kind=kInt16), intent(inout) :: Item the item to be retrieved from the container Return Value logical flag indicating whether the item is available. - true if the container is NOT empty.\n- false if the container is empty.","tags":"","loc":"type\\darrinteger2b.html"},{"title":"PQRealDP – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: PQRealDP The PQRealDP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalization Procedures final :: PQHeap_Finalizer To perform finalization of the object. private  subroutine PQHeap_Finalizer(PQ) To perform finalization of the object. Arguments Type Intent Optional Attributes Name type( PQRealDP ), intent(inout) :: PQ PQRealDP object Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options private  subroutine PQHeap_CreateEmpty(PQ, InitCap, MinPQ, IncSize, Shrink) To create an empty priority queue. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object integer(kind=kInt32), intent(in) :: InitCap initial size of priority queue logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) private  subroutine PQHeap_ConstructorByArray(PQ, N, Keys, MinPQ, IncSize, Shrink) To construct a priority queue from an array of key. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object integer(kind=kInt32), intent(in) :: N number of keys real(kind=kDouble), intent(in) :: Keys (N) key array logical, intent(in), optional :: MinPQ true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ integer(kind=kInt32), intent(in), optional :: IncSize incremental size of priority queue if it is full logical, intent(in), optional :: Shrink true if want to reduce capacity when size is less than a quarter of the capacity;\n default is false. procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) private  subroutine PQHeap_Destructor(PQ, Keys) To destruct PQRealDP object and get its keys if requested. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object real(kind=kDouble), intent(out), optional, ALLOCATABLE :: Keys (:) array of keys procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) private  subroutine PQHeap_InsertKey(PQ, NewKey) To add a new key to the top (or bottom) of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object real(kind=kDouble), intent(in) :: NewKey new key to be added to the priority queue procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething private  function PQHeap_RemoveKey(PQ, HPKey) result(Flag) To retrieve and remove the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object real(kind=kDouble), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not. procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing private  function PQHeap_IsEmpty(PQ) result(Flag) To check whether the priority queue is empty or not. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(in) :: PQ PQRealDP object Return Value logical true if the priority queue is empty procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() private  function PQHeap_GetSize(PQ) result(Size) To get size of the priority queue. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(in) :: PQ PQRealDP object Return Value integer(kind=kInt32) size (number of keys) procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething private  function PQHeap_PeekKey(PQ, HPKey) result(Flag) To retrieve the highest-priority key from the priority queue.  Also, return\n a flag indicating whether the key-value pair is successfully removed or not. Arguments Type Intent Optional Attributes Name class( PQRealDP ), intent(inout) :: PQ PQRealDP object real(kind=kDouble), intent(out) :: HPKey the highest-priority key Return Value logical flag indicating whether the specified key and its associated\n value are successfully removed or not.","tags":"","loc":"type\\pqrealdp.html"},{"title":"MClass_ListTable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListTable type and its supporting routines and data type.  The ListTable type is a collection type that employs a linked-list implementation to provide\n  common operations for an unordered symbol table. The ListTable type uses the KeyUnordered type to store its keys and the GenData type\n  to store its values.  Therefore, it can be used to store key-value pairs of any data types\n  (except the LOGICAL type for the keys).  Like other collection types, however, it must\n  be employed to store key-value pairs of only specific key type and one specific value type.\n  To store key-value pairs of another key type (or another value type), it must be destructed\n  before inserting items of different key type (or different value type). As a symbol table, the ListTable type does not allow duplicated keys.  Therefore, if an\n  inserted key is equal to a key stored in the table, an associated value of the stored key\n  is replaced by an associated value of the inserted key.  Although the ListTable type is\n  an unordered symbol table, it provides an ordered iteration over its stored key-value items\n  where its iteration ordering is normally the order in which keys were inserted into the table\n  (i.e. insertion order). Technically, the ListTable type employs a doubly-linked list implementation to provide common\n  operations for an unordered symbol table.  The ListTable type uses the IntrusiveLinearList type as its component to store its list nodes.  The IntrusiveLinearList type, as an intrusive\n  list container, provides common linked-list operations without a memory management task.  The\n  memory management task of the inserted list nodes is handled by the ListTable type. Uses MClass_BaseNodePool MBase_MemHandlers MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MBase_ByteUtil MClass_BaseSymTable MClass_BaseCollection MClass_GenData MClass_KeyUnordered MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_IntrusiveLinkedLists MClass_Object Derived Types type, public, extends( BaseSymTable ) :: ListTable The ListTable type is a collection type that employs a linked-list implementation to\n provide common operations for an unordered symbol table.  The ListTable type employs\n the IntrusiveLinearList type as its component to store TabNode objects.  As an\n intrusive container, the IntrusiveLinearList type provides common linked-list operations\n without a memory management task.  The memory management task of the inserted TabNode objects is handled by the ListTable type. As an unordered symbol table, the ListTable type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the ListTable type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalizations Procedures final :: ListTable_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: CopyCollection => ListTable_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Destruct => ListTable_Destroy Destruct is a procedure deferred by the BaseCollection type. Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => ListTable_GetSize GetSize is a procedure deferred by the BaseCollection type. Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => ListTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => ListTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) procedure, public :: Insert => ListTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) procedure, public :: Delete => ListTable_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Remove => ListTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Contain => ListTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething procedure, public :: GetValue => ListTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething procedure, public :: ToArray => ListTable_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething procedure, public :: GetAll => ListTable_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething generic, public :: Construct => CopyCollection , ListTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Copy => ListTable_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => ListTable_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => ListTable_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => ListTable_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => ListTable_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_listtable.html"},{"title":"MClass_HTabRealSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabRealSP type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabRealSP type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabRealSP type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabRealSP type uses the Fortran intrinsic REAL(KIND=kSingle) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabRealSP type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabRealSP type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabRealSP The HTabRealSP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabrealsp.html"},{"title":"MClass_DArrRealSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrRealSP type and related routines.\n  The DArrRealSP type is a container with REAL(KIND=kSingle) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrRealSP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrRealSP DArrRealSP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kSingle) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealSP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrrealsp.html"},{"title":"MClass_ListObject – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListObject type and related routines.\n  The ListObject type is a container with CLASS(Object) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation.  All derived types extending from the Object type can be\n  used with this container. It should be noted that although the ListObject type allows items with\n  different types (any derived types that are in the Object class) to be\n  stored in different nodes of the same container, a user must be extremely\n  careful when retrieving the items with different types from the container.\n  The type specified for an output argument must match the type of an item\n  stored in a particular node of the container.  Otherwise, the user would\n  not be able to retrieve the item for that specific routine. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListObject type but utilizes a different implementation.\n  Also, unlike the ListObject type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_MemHandlers MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: ListObject ListObject is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is a derived type in the Object class (i.e. the Object type or its subtypes). Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething Important Note : This operation will not be successful if items stored\n  in different nodes have different types. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: SameType => LinkedList_SameType Type-Bound Function : SameType Purpose :  To check whether all stored items have the same type or not. Usage : --->    Flag = List%SameType() --->    IF (.NOT.List%SameType()) DoSomeThing procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething Important Note : This operation will not be successful if items stored\n  in different nodes have different types. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listobject.html"},{"title":"MClass_DArrRealDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrRealDP type and related routines.\n  The DArrRealDP type is a container with REAL(KIND=kDouble) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrRealDP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrRealDP DArrRealDP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kDouble) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealDP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrrealdp.html"},{"title":"MClass_DArrObject – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrObject type and related routines.\n  The DArrObject type is a container with CLASS(Object) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array.  All derived types extending from the Object type can be used with this container. Unlike the ListObject type,\n  the DArrObject type does not allow items with different types to be stored\n  in the same container.  The DArrObject type requires a user to specify the\n  type of items to be stored via the Mold argument when an empty container is\n  created.  Alternatively, the user may implicitly specify the type of items to be\n  stored via the Items argument when a container is constructed from an array\n  of items.  Also, it is important to note that the type of an item specified in\n  all other routines must be the same as the type of stored items of the container.\n  Otherwise, the container may not behave as expected. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrObject type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the ModBase_DynamicArrays module instead of using this module directly. Uses MBase_MemHandlers MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: DArrObject DArrObject is a container type that employs a dynamic-array implementation\n to provide common operations for a list container.  It can also represent other\n forms of containers including a LIFO stack, a FIFO queue and a double-ended queue\n (deque).  The type of items stored in this container is a derived type in the Object class (i.e. the Object type or its subtypes). Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity and type of items to be stored --->    CALL Container%CreateEmpty(25, Mold) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, Mold, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Mold, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DynArr class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrobject.html"},{"title":"MClass_PQHeap – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQHeap type and its related routines.  The PQHeap type is a priority-queue container where the type of its stored keys is in the Comparable class (i.e. a concrete subtype of the Comparable type).  It uses\n  a binary heap implementation to order its stored keys. The PQHeap type can represent either a max-priority queue or a min-priority\n  queue.  By default, it represents the max-priority queue but a user can specify\n  the MinPQ argument to true so that it represents the min-priority queue instead. It should be noted that the PQHeap type does not allow keys with different types\n  to be stored in the same container.  The PQHeap type requires a user to specify\n  the type of keys to be stored via the Mold argument when an empty container is\n  created.  Alternatively, the user may implicitly specify the type of keys to be\n  stored via the Keys argument when a container is constructed from an array of\n  keys.  Also, it is important to note that the type of a key specified in all other\n  routines must be the same as the type of stored keys of the container.  Otherwise,\n  the container may not behave as expected. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_Common MClass_Comparable Derived Types type, public :: PQ_Heap The PQ_Heap type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap, Mold)                   ! use default options --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)          ! use min-priority queue --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)            ! specify incremental size --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)         ! specify shrinking --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE.)    ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqheap.html"},{"title":"MClass_DArrCmpxDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrCmpxDP type and related routines.\n  The DArrCmpxDP type is a container with COMPLEX(KIND=kDouble) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrCmpxDP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrCmpxDP DArrCmpxDP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kDouble) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxDP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrcmpxdp.html"},{"title":"MClass_PQInteger2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQInteger2B type and its related routines.\n  The PQInteger2B type is a priority-queue container with INTEGER(KIND=kInt16) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQInteger2B type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQInteger2B The PQInteger2B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqinteger2b.html"},{"title":"MClass_DArrCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrCharacter type and related routines.\n  The DArrCharacter type is a container with CHARACTER as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrCharacter type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrCharacter DArrCharacter is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is CHARACTER . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified character length and initial capacity --->    CALL Container%CreateEmpty(80, 25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(80, 25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(80, 25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCharacter class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrcharacter.html"},{"title":"MClass_ListCmpxQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListCmpxQP type and related routines.\n  The ListCmpxQP type is a container with COMPLEX(KIND=kQuad) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListCmpxQP type but utilizes a different implementation.\n  Also, unlike the ListCmpxQP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListCmpxQP ListCmpxQP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kQuad) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listcmpxqp.html"},{"title":"MClass_HTabInteger1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabInteger1B type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabInteger1B type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabInteger1B type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabInteger1B type uses the Fortran intrinsic INTEGER(KIND=kInt8) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabInteger1B type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabInteger1B type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabInteger1B The HTabInteger1B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabinteger1b.html"},{"title":"MClass_HTabCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabCharacter type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabCharacter type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabCharacter type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabCharacter type uses the Fortran intrinsic CHARACTER type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabCharacter type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabCharacter type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common iso_fortran_env MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabCharacter The HTabCharacter type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabcharacter.html"},{"title":"MClass_HTabObject – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabObject type, and its related routines.   The HTabObject type is a container type that employs an open-addressing hash table\n  implementation to provide common operations for an unordered symbol table.  As a\n  symbol table, the HTabObject type uses the Object derived type to store the\n  keys and their associated values.  Unlike other hash-table containers, the HTabObject type uses a user-defined type in the Object class to represent\n  a key-value pair and requires only one argument (instead of two) when inserting\n  or retrieving the key and its associated value. It should be noted that a user must be careful when implementing a user-defined\n  concrete subtype of the Object type.  The HTabObject type employs the\n  assignment statement copy data of the key-value object.  It also utilizes the\n  relational operators (e.g. ==) to compare keys of the key-value objects.  Moreover,\n  in order to compute indices of buckets used to store the specified key-value object,\n  it uses the HashCode method to compute the hash value of the specified key.  These\n  imply that the user should implement the deferred CopyAssign procedure where both\n  key and value components are copied from the source object to the destination object\n  whereas, when implemented, the deferred CompareTo and ComputeHashValue procedures\n  should be dependent on its key component only. It is also worth mentioning that the HTabObject type does not allow key-value objects\n  of different types to be stored in the same container.  The HTabObject type requires\n  a user to specify the type of user-defined key-value objects to be stored via arguments\n  specified during the creation of a container.  Also, the type of a user-define key-value\n  object specified in all other routines must be the same as the type of stored objects of\n  the container. Otherwise, the container may not behave as expected. Unlike the list-based and tree-based types, which can be used instantly by inserting\n  objects into a container, the HTabObject type requires an explicit construction before\n  using other provided operations.  There are two methods provided to create the container.\n  The CreateEmpty method constructs an empty table with optional multiple arguments\n  (including an initial capacity, a load factor, a probing algorithm, and a hash function\n  used to compute a hash code of a key) whereas the Construct method constructs a table\n  from an array of key-value pairs. As a symbol table, the HTabObject type does not allow duplicated keys.  Therefore, if\n  an inserted key is equal to a key stored in the table, an associated value of the stored\n  key is replaced by an associated value of the inserted key. Technically, the HTabObject type employs the open-addressing as a collision resolution\n  technique where the hash resolution is performed through probing.  It provides three probing\n  algorithms: linear probing, quadratic probing and double hashing.  By default, the linear\n  probing algorithm is used.  However, a user can specify other probing algorithm during the\n  construction of the container. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding MClass_Object Derived Types type, public :: HTabObject The HTabObject type is a table type that employs an open-addressing hash table\n implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty(NulObj, DelObj)                  ! use default options --->    CALL Table%CreateEmpty(NulObj, DelObj, InitCap=25)      ! specify initial capacity --->    CALL Table%CreateEmpty(NulObj, DelObj, LoadFactor=0.5)  ! specify load factor --->    CALL Table%CreateEmpty(NulObj, DelObj, ProbAlgo=2)      ! specify probing algorithm --->    CALL Table%CreateEmpty(NulObj, DelObj, 30, 0.75, 3)     ! specify all options Important Note : A user is required to specify two user-defined key-value pair objects to represent a null\n object and a deleted object where these two objects are not the same one when compared using\n the operator == .  Also, these two objects should never be specified in any operations other\n than the construction operations. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key-value array. Usage : ! use default options --->    CALL Table%Construct(40, KeyValArr, NulObj, DelObj) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyValArr, NulObj, DelObj, LoadFactor, ProbAlgo) Important Note : A user is required to specify two user-defined key-value pair objects to represent a null\n object and a deleted object where these two objects are not the same one when compared using\n the operator == .  Also, these two objects should never be specified in any operations other\n than the construction operations. procedure, public :: Clear => HashTable_ClearBuckets Type-Bound Subroutine : Clear Purpose :  To free components of the buckets from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(KeyVal) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not. Usage : --->    Flag = Table%Remove(KeyVal) --->    IF (.NOT.Table%Remove(KeyVal)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKeyVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKeyVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(KeyVal) --->    IF (.NOT.Table%Contain(KeyVal)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all key-value pairs. Usage : --->    CALL Tree%GetKeys(KeyValQueue)","tags":"","loc":"module\\mclass_htabobject.html"},{"title":"MClass_OrderedSymTable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the OrderedSymTable type and its related routines.  The OrderedSymTable type is an abstract type representing an ordered symbol table, which is a collection containing\n  key-value pairs that keeps the keys in order. The OrderedSymTable type is a subtype of the BaseSymTable type and thus inherits all methods\n  of the BaseSymTable type and all its super classes.  The OrderedSymTable type provides an\n  expanded API that defines numerous natural and useful operations involving relative key order. It is important to note that checking the key equality is usually sufficient for an unordered\n  symbol table.  However, for an ordered symbol table, the comparison between keys should provide\n  a total ordering on all the keys.  This means that although all Fortran intrinsic types (with\n  the exception of the LOGICAL type) can be used as a type of the key in an unordered symbol\n  table, only CHARACTER , INTEGER and REAL types can be used as a type of the key in an\n  ordered symbol table.  To use a derived type as a type of the key, any derived types are allowed\n  for an unordered symbol table.  However, for an ordered symbol table, only derived types that\n  are in the Comparable class are allowed. Uses MClass_GenData MBase_Common MClass_BaseSymTable Derived Types type, public, extends( BaseSymTable ) :: OrderedSymTable The OrderedSymTable type is an abstract collection type that defines an API for an\n ordered symbol table. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. generic, public :: Construct => CopyCollection Type-Bound Subroutine : Construct Purpose :  To construct a new collection. Usage : ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified key-value pair to the\n  collection. procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current key-value pair from the\n  collection.  This method is intended to be employed in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of\n  those methods and then calling this one will result in a removal of the current\n  key-value pair of the iteration (i.e. the same key-value pair that can be obtained\n  via the StartFirst and MoveForward methods). procedure(IfaceRemove), public, deferred :: Remove Remove is a deferred procedure to remove the specified key (and its associated\n  value) from the collection. procedure(IfaceContain), public, deferred :: Contain Contain is a deferred procedure to check whether the specified key is in the\n  collection or not. procedure(IfaceGetVal), public, deferred :: GetValue GetValue is a deferred procedure to get a value associated with the specified key\n  in the collection. procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all key-value pairs from\n  the collection. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all keys and/or all values (without\n  removing them) from the collection. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure(IfaceMinKey), public, deferred :: GetMinKey GetMinKey is a deferred procedure to get the smallest key (and optionally a value\n  associated with it) in a symbol table. procedure(IfaceMaxKey), public, deferred :: GetMaxKey GetMaxKey is a deferred procedure to get the largest key (and optionally a value\n  associated with it) in a symbol table. procedure(IfaceFloor), public, deferred :: Floor Floor is a deferred procedure to get the largest key (and optionally a value\n  associated with it) in a symbol table less than or equal to the given key. procedure(IfaceCeiling), public, deferred :: Ceiling Ceiling is a deferred procedure to get the smallest key (and optionally a value\n  associated with it) in a symbol table greater than or equal to the given key. procedure(IfaceRank), public, deferred :: GetRank GetRank is a deferred procedure to return the number of keys in the symbol table\n  strictly less than the given key. procedure(IfaceSelect), public, deferred :: Select Select is a deferred procedure to get the key (and optionally its associated value) of\n  the specified rank where the applicable range of rank is between 0 and TableSize-1. procedure(IfaceDelMin), public, deferred :: RemoveMin RemoveMin is a deferred procedure to remove the smallest key (and a value associated\n  with it) from a symbol table. procedure(IfaceDelMax), public, deferred :: RemoveMax RemoveMax is a deferred procedure to remove the largest key (and a value associated\n  with it) from a symbol table. procedure(IfaceRangeSize), public, deferred :: GetRangeSize GetRangeSize is a deferred procedure to return the number of keys between KeyLo (inclusive) and KeyHi (inclusive).","tags":"","loc":"module\\mclass_orderedsymtable.html"},{"title":"MClass_ListAnyType – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListAnyType type and related routines. The ListAnyType type is a container with an unlimited polymorphic type\n  (i.e. CLASS( ) ) as the type of its stored items.  It employs a\n  conventional doubly-linked list implementation.  Any data types can\n  be used with this container. Similar to other classes of the linked list container, the ListAnyType type allows items with different types to be stored in different nodes\n  of the same container.  However, unlike other classes, to retrieve the\n  stored items, a user must specify an allocatable unlimited polymorphic\n  type as an output argument.  Therefore, when the user uses the output\n  item(s), the SELECT TYPE construct must be used to select a type\n  that is suitable for a particular item. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListAnyType type but utilizes a different implementation.\n  Similar to the ListAnyType* type, these container types are designed as\n  generic containers that can be used to store various data types providing\n  that the size (in bytes) of the data to be stored is known at compile time. Uses MBase_MemHandlers MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: ListAnyType ListAnyType is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container can be any data type. Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items, MakeCopy) --->    IF (.NOT.List%ToArray(Items), MakeCopy) DoSomething Important Note : This operation will not be successful if items stored in\n  different nodes have different types.  Also, a user must supply a procedure\n  to make a copy of an item for the specific type of stored items. procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates(Compare) Important Note : A user must supply a procedure to compare items stored\n  in the list. procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: SameType => LinkedList_SameType Type-Bound Function : SameType Purpose :  To check whether all stored items have the same type or not. Usage : --->    Flag = List%SameType() --->    IF (.NOT.List%SameType()) DoSomeThing procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething Important Note : The specified type of item to be retrieved must match that\n  of an item stored in the list. procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items, MakeCopy) --->    IF (.NOT.List%GetAll(Items), MakeCopy) DoSomething Important Note : This operation will not be successful if items stored in\n  different nodes have different types.  Also, a user must supply a procedure\n  to make a copy of an item for the specific type of stored items. procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listanytype.html"},{"title":"MClass_PQInteger1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQInteger1B type and its related routines.\n  The PQInteger1B type is a priority-queue container with INTEGER(KIND=kInt8) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQInteger1B type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQInteger1B The PQInteger1B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqinteger1b.html"},{"title":"MClass_PQBasic – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQBasic type and its related routines.  The PQBasic type is a priority-queue container where the type of its stored keys is in the Comparable class (i.e. a concrete subtype of the Comparable type).  It uses\n  an elementary implementation where its array representation can be unordered or\n  ordered.  By default, its array representation is ordered where a sorting\n  algorithm is employed to order its stored keys. Functionally, the PQBasic type is exactly the same as the PQHeap type.  They\n  only differs in their internal implementations where the PQBasic type can use\n  any sorting algorithm from the MBase_SortAscend and MBase_SortDescend modules while the PQHeap type uses a binary heap (i.e. essentially heap sort)\n  to order its stored keys.  The sorting algorithms for the PQBasic type are\n  optionally specified when the container is created. See the MClass_PQHeap module for more\n  explanations about its functionalities and limitations, which are the same as\n  those of the PQBasic type. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. See the MBase_SortDescend module for routines that perform sorting of an array in a descending order, and see the MBase_SortAscend module for\n  routines that perform sorting of an array in an ascending order. Uses MBase_ErrHandlers MBase_SortAscend MClass_Comparable MBase_SortDescend MBase_Common Derived Types type, public :: PQ_Basic The PQ_Basic type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQBasic_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQBasic_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap, Mold)                 ! use default options --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, Mold, Unordered=.TRUE.)    ! specify unordered PQ --->    CALL Table%CreateEmpty(32, Mold, SortAscend=WiseSort) ! specify ascending sorting algorithm --->    CALL Table%CreateEmpty(32, Mold, SortDescend=TimSort) ! specify descending sorting algorithm ! specify all options --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE., .TRUE., RustSort, IntroSort) procedure, public :: Construct => PQBasic_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink, Unordered, SortAscend, SortDescend) procedure, public :: Destruct => PQBasic_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQBasic_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQBasic_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQBasic_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQBasic_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQBasic_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqbasic.html"},{"title":"MClass_TreeRealSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeRealSP type and its related helper type and routines.\n  The TreeRealSP type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeRealSP type uses the Fortran intrinsic REAL(KIND=kSingle) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeRealSP type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeRealSP type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeRealSP type but utilizes\n  a different implementation.  Also, unlike the TreeRealSP type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeRealSP TreeRealSP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treerealsp.html"},{"title":"MClass_LinkedLists – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains linked-list-based collection types and their related routines.\n  A linked-list-based type is a collection type that employs a linked list implementation. Available collection types based on the linked list concept include: - the StackLinked type that represents a last-in-first-out (LIFO) stack, - the QueueLinked type that represents a first-in-first-out (FIFO) queue, - the DequeLinked type that represents a double-ended queue (deque). - the ListLinked type that represents a list where an item can be added, removed or\n    retrieved at the (valid) specified index. Usage Notes : - Unlike the dynamic-array-based types, the linked-list-based types commonly do not\n    require an explicit construction.  Items can be added via the Construction method\n    or an insertion method.  Therefore, the CreateEmpty method used to construct an empty\n    collection is deemed unnecessary and thus NOT provided. - Other than that, all operations provided are the same for both groups of collections. Important Notes : (1) By design, similar to the dynamic-array-based types, although all linked-list-based types are generic containers that can be used to store items of any data types, they\n      must be employed to store items of only one particular data type.  To store items of\n      another data type, they must be cleared and/or destructed before inserting items of\n      different data type. (2) To be able to successfully retrieve stored items, the specified output item must have\n      the same (concrete) type as that of stored items. (3) Additionally, if type of the stored items is a derived one that is NOT in the Object class and this type has allocatable and/or pointer components, a user must specify the\n      optional ItemCopy argument when trying to retrieve the stored items.  The ItemCopy argument is a user-defined procedure to copy an unlimited polymorphic entity.  It must\n      must provide a type-guard statement to check the compatibility of concrete types of its\n      arguments.  It must also handle the storage allocation (and/or the assignment) of those\n      allocatable (and/or pointer) components as appropriate. Implementation Notes : - Unlike conventional implementation, all linked-list-based types provided in this module\n    employ the IntrusiveLinearList type, which is an intrusive doubly-linked list container type that\n    performs common linked-list operations without a memory management task. - As a result, the linked-list-based types mostly handle the memory management task while\n    common operations of a linked list are relegated to the IntrusiveLinearList type, which\n    is declared as a private component of the linked-list-based collection types. - The implementation here in this module (and its submodules) is intended to illustrate the\n    usage of an intrusive container type. Uses MClass_BaseNodePool MBase_MemHandlers MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MBase_ByteUtil MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_IntrusiveLinkedLists MClass_Object Derived Types type, public, extends( BaseIterable ) :: QueueLinked Description : The QueueLinked type is a collection type that employs a linked-list implementation\n  to provide common operations for a FIFO queue. Usage Overview : The QueueLinked type is a queue collection type that provides common operations of\n  a FIFO queue.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items or from another collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Enqueue method - method to insert an item to the end of the collection, (2.2) Dequeue method - method to get and remove the first item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalizations Procedures final :: QueueLinked_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => QueueLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() type, public, extends( QueueLinked ) :: StackLinked Description : The StackLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a LIFO stack. Usage Overview : The StackLinked type is a stack collection type that provides common operations of\n  a LIFO stack.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items another or from collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Push method - method to insert an item at the top of the collection, (2.2) Pop method - method to get and remove the top (last) item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekTop method - method to retrieve the top (last) item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Note : Since the StackLinked type is a subtype of the QueueLinked type, it can also\n           be used as a FIFO queue. Finalizations Procedures final :: StackLinked_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) procedure, public :: Pop => StackLinked_Pop Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething procedure, public :: PeekTop => StackLinked_PeekTop Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: ToString => StackLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() type, public, extends( QueueLinked ) :: DequeLinked Description : The DequeLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a double-ended queue (deque).  It can be used as a FIFO\n  queue or a LIFO stack as well. Usage Overview : The DequeLinked type is a deque collection type that provides common operations of\n  a double-ended queue (deque).  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of\n         items or from another collection, (1.2) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) AddFirst method - method to insert an item to the front of the collection, (2.2) AddLast method - method to insert an item to the end of the collection, (2.3) RemoveFirst method - method to get and remove the first item of the collection, (2.4) RemoveLast method - method to get and remove the last item of the collection, (2.5) Clear method - method to remove all items from the collection. (2.6) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) PeekLast method - method to retrieve the last item of the collection, (3.3) GetSize method - method to get the collection size (number of items stored), (3.4) IsEmpty method - method to check whether the collection is empty or not. (3.5) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item, (4.3) StartLast method - method to start a backward iteration over items, (4.4) MoveBackward method - method to move backward to the previous item. Note : The DequeArray type also supports the usual Enqueue , Dequeue and PeekFirst operations of a FIFO queue as well as the usual Push , Pop and PeekTop operations\n      of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be\n      used in place of insert , remove , peek operations of a deque as desired. Finalizations Procedures final :: DequeLinked_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: StartLast => DequeLinked_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating whether\n               the collection is empty or not. Usage :  See the MoveBackward method. procedure, public :: MoveBackward => DequeLinked_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: AddFirst => DequeLinked_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DequeLinked_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection.  Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething procedure, public :: PeekLast => DequeLinked_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection).  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: ToString => DequeLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() type, public, extends( DequeLinked ) :: ListLinked Description : The ListLinked type is a collection type that employs a linked-list implementation to\n  provide common operations for a list. Usage Overview : The ListLinked type provides insert, remove and peek operations at a specified index\n  where the index must be between 1 and the collection size.  The ListLinked type is a\n  subtype of the DequeLinked type; therefore, all operations available for the DequeLinked type are also available for the ListLinked type.  Furthermore, it thus\n  can be used as a deque, a FIFO queue or a LIFO stack. Finalizations Procedures final :: ListLinked_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => QueueLinked_CopyCollection Use the Construct method in place of the CopyCollection method to\n create a collection from another collection. procedure, public :: Destruct => QueueLinked_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory of items stored\n               in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueLinked_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueLinked_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueLinked_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether the\n               cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueLinked_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueLinked_DelElm Type-Bound Subroutine : Delete Purpose :  To delete an item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueLinked_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueLinked_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also,\n               return a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Construct => CopyCollection , QueueLinked_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueLinked_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueLinked_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueLinked_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueLinked_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueLinked_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: HashCode => QueueLinked_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: StartLast => DequeLinked_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating whether\n               the collection is empty or not. Usage :  See the MoveBackward method. procedure, public :: MoveBackward => DequeLinked_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: AddFirst => DequeLinked_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DequeLinked_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection.  Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething procedure, public :: PeekLast => DequeLinked_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection).  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection.  Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: AddAt => ListLinked_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where the index must\n               be between 1 and the collection size.  Also, return a flag indicating\n               whether the item is successfully added. Usage : --->    Success = Collection%AddAt(Index, Item) --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething procedure, public :: RemoveAt => ListLinked_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where the index must be\n               between 1 and the collection size.  Also, return a flag indicating whether\n               the item is successfully removed. Usage : --->    Success = Collection%RemoveAt(Index, Item) --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething procedure, public :: PeekAt => ListLinked_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the collection) at the specified\n               index where the index must be between 1 and the collection size.  Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekAt(Index, Item) --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething procedure, public :: ToString => ListLinked_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString()","tags":"","loc":"module\\mclass_linkedlists.html"},{"title":"MClass_HashTree – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HashTree type and its supporting routines and data type.\n  The HashTree type is a collection type that employs a separate-chaining hash table\n  implementation to provide common operations for an unordered symbol table. The HashTree type uses the KeyOrdered type to store its keys and the GenData type to store its values.  Therefore, it can be used to store comparable keys and\n  values of any data types.  Allowed types of comparable keys include the CHARACTER , INTEGER and REAL intrinsic types as well as any derived type that is in the Comparable class.  Like other collection types, however, it must be employed to store\n  key-value pairs of only specific key type and one specific value type.  To store pairs\n  of another key type (and/or another value type), it must be destructed before inserting\n  items of different key type (or different value type). As a symbol table, the HashTree type does not allow duplicated keys.  Therefore, if\n  an inserted key is equal to a key stored in the table, an associated value of the stored\n  key is replaced by an associated value of the inserted key.  As an unordered symbol\n  table, the HashTree type makes no guarantees as to the iteration order of the table.\n  In particular, it does not guarantee that the order will remain the same over time. Technically, the HashTree type utilizes the IntrusiveHashTree type as its component\n  to store its hash-tree nodes.  As an intrusive container, the IntrusiveHashTree type,\n  which is based on a separate-chaining hash table implementation, provides common hash-table\n  operations without a memory management task.  The memory management task of the inserted\n  hash-tree nodes is handled by the HashTree type. Uses MBase_MemHandlers MClass_CompNodePool MClass_CharBuffer MBase_ErrHandlers MClass_KeyOrdered MBase_ByteUtil MClass_IntrusiveHashTree MClass_Comparable MClass_BaseCollection MClass_GenData MClass_BaseSymTable MBase_Common MBase_SimpleHash64 MClass_MemoryPool MBase_SIntUtil MClass_IntrusiveBSTrees MClass_Object Derived Types type, public, extends( BaseSymTable ) :: HashTree The HashTree type is a collection type that employs a separate-chaining hash table\n implementation to provide common operations for an unordered symbol table.  The HashTree type utilizes the IntrusiveHashTree type as its component to store TabNode objects.\n As an intrusive container, the IntrusiveHashTree type provides common operations for\n hash table without a memory management task.  The memory management task of the inserted TabNode objects is handled by the HashTree type. As an unordered symbol table, the HashTree type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the HashTree type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalizations Procedures final :: HashTree_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: CopyCollection => HashTree_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Destruct => HashTree_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => HashTree_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => HashTree_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) procedure, public :: Insert => HashTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) procedure, public :: Delete => HashTree_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Remove => HashTree_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Contain => HashTree_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething procedure, public :: GetValue => HashTree_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething procedure, public :: ToArray => HashTree_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething procedure, public :: GetAll => HashTree_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething procedure, public :: CreateEmpty => HashTree_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()            ! use default options --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity generic, public :: Construct => CopyCollection , HashTree_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Copy => HashTree_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => HashTree_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => HashTree_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => HashTree_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => HashTree_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_hashtree.html"},{"title":"MClass_BaseIterable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BaseIterable type and its related routines.  The BaseIterable type is an abstract data type extending the BaseCollection type.  It defines two additional\n  methods for an iteration over items stored in a collection.  The StartFirst method is used\n  to start an iteration and the MoveForward method is used to move to the next iteration. Usage : The following code snippet illustrates how to iterate over the collection. ! start forward iteration (from the first item)\n  IsEmpty = Collection%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveForward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO The following code snippet shows another way to traverse across the collection. ! start forward iteration (from the first item)\n  IsTheEnd = Collection%StartFirst(CurrItem)\n  DO WHILE (.NOT.IsTheEnd)\n      DoSomeThing_With_CurrItem...\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveForward(CurrItem)\n  END DO Uses MClass_GenData MBase_Common MClass_BaseCollection Derived Types type, public, extends( BaseCollection ) :: BaseIterable The BaseIterable type is an abstract collection type that defines an API for\n iterable collections, which are collections that can iterate over their items. It is important to note that, by design, a concrete collection type that extends\n from the BaseIterable type only stores items of one specific type.  To store\n items of another type, the collection must be cleared and/or destructed. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. generic, public :: Construct => CopyCollection Type-Bound Subroutine : Construct Purpose :  To construct a new collection. Usage : ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified item to the collection.  This\n  is a default procedure for adding an item to the collection.  For a particular collection,\n  an alias name (e.g. the Push method for a stack or the Enqueue method for a queue)\n  may be used in place of the Insert method. procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current item from the collection.  This\n  method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration (i.e. the same item that\n  can be retrieved via the StartFirst and MoveForward methods). procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all items from the collection. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all items (without removing them) from the\n  collection. procedure, public :: Clear => BaseIterable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseIterable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user.","tags":"","loc":"module\\mclass_baseiterable.html"},{"title":"MClass_PQInteger4B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQInteger4B type and its related routines.\n  The PQInteger4B type is a priority-queue container with INTEGER(KIND=kInt32) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQInteger4B type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQInteger4B The PQInteger4B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqinteger4b.html"},{"title":"MClass_HashMap – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HashMap type and its supporting routines and data type.  The HashMap type is a collection type that employs an open-addressing hash table implementation\n  to provide common operations for an unordered symbol table. Unlike the list-based and tree-based symbol table types, which can be used instantly by\n  inserting objects into a collection, the HashMap type requires an explicit construction\n  before using other provided operations.  There are two methods provided to create the\n  collection.  The CreateEmpty method constructs an empty table with optional multiple\n  arguments (including an initial capacity, a load factor, a probing algorithm, and a hash\n  function used to compute a hash code of a key) whereas the Construct method constructs\n  a table from arrays of keys and values. The HashMap type uses the KeyUnordered type to store its keys and the GenData type\n  to store its values.  Therefore, it can be used to store key-value pairs of any data types\n  (except the LOGICAL type for the keys).  Like other collection types, however, it must\n  be employed to store key-value pairs of only specific key type and one specific value type.\n  To store key-value pairs of another key type (or another value type), it must be destructed\n  before inserting items of different key type (or different value type). As a symbol table, the HashMap type does not allow duplicated keys.  Therefore, if an\n  inserted key is equal to a key stored in the table, an associated value of the stored key\n  is replaced by an associated value of the inserted key.  As an unordered symbol table, the HashMap type makes no guarantees as to the iteration order of the table.  In particular,\n  it does not guarantee that the order will remain the same over time. Technically, the HashMap type employs the open-addressing as a collision resolution\n  technique where the hash resolution is performed through probing.  It provides three probing\n  algorithms: linear probing, quadratic probing and double hashing.  By default, the linear\n  probing algorithm is used.  However, a user can specify other probing algorithm during the\n  construction of the table. Uses MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MBase_ByteUtil MBase_MathUtil MClass_BaseSymTable MClass_BaseCollection MClass_GenData MClass_KeyUnordered MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_Object Derived Types type, public, extends( BaseSymTable ) :: HashMap The HashMap type is a collection type that employs an open-addressing hash table\n implementation to provide common operations for an unordered symbol table.  It makes\n no guarantees as to the iteration order of the symbol table; in particular, it does\n not guarantee that the order will remain constant over time. Finalizations Procedures final :: HashMap_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: CopyCollection => HashMap_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => HashMap_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => HashMap_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. procedure, public :: GetSize => HashMap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: IsEmpty => HashMap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: StartFirst => HashMap_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashMap_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) procedure, public :: Insert => HashMap_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) procedure, public :: Delete => HashMap_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Remove => HashMap_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Contain => HashMap_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething procedure, public :: GetValue => HashMap_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection. Also,\n      return a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething procedure, public :: ToArray => HashMap_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething procedure, public :: GetAll => HashMap_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething procedure, public :: CreateEmpty => HashMap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. generic, public :: Construct => CopyCollection , HashMap_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional arguments (see the CreateEmpy method) --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Copy => HashMap_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => HashMap_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => HashMap_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => HashMap_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => HashMap_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_hashmap.html"},{"title":"MClass_TreeRealDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeRealDP type and its related helper type and routines.\n  The TreeRealDP type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeRealDP type uses the Fortran intrinsic REAL(KIND=kDouble) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeRealDP type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeRealDP type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeRealDP type but utilizes\n  a different implementation.  Also, unlike the TreeRealDP type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeRealDP TreeRealDP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treerealdp.html"},{"title":"MBase_HashTables – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module collectively contains hash-table container types from other modules. It is\n provided so that a user can refer to this module instead of referring to several individual\n modules when various types are needed concurrently. Overview : These hash-table container types are container types that employ a hash table implementation\n to provide common operations for an unordered symbol table.  Technically, all of them employ\n the open-addressing as a collision resolution technique where the hash resolution is performed\n through probing.  They provide three probing algorithms: linear probing, quadratic probing and\n double hashing.  By default, the linear probing algorithm is used.  However, a user can specify\n other probing algorithm during a construction of a table. Each individual type can be used to store key-value pairs for a specific type of keys where the\n allowed types of stored keys include the Fortran intrinsic CHARACTER, INTEGER and REAL types as\n well as any derived type in the Object class.  Most of the hash-table container types (except\n the HTabObject type) utilize an unlimited polymorphic type to store values; therefore, a type\n of inserted values can be any data type.  Unlike other types, the HTabObject type uses the Object type to represent both key and value, and it requires only one argument (instead of\n two) when inserting or retrieving the key and its associated value.  Therefore, its application\n programming interface (API) is slightly different from the API of other hash-table types. Available hash-table-based container types include: - the HTabCharacter type\n   for character string key type, - the HTabInteger1B type\n   for 1-byte (or 8-bit) integer key type, - the HTabInteger2B type\n   for 2-byte (or 16-bit) integer key type, - the HTabInteger4B type\n   for 4-byte (or 32-bit) integer key type, - the HTabInteger8B type\n   for 8-byte (or 64-bit) integer key type, - the HTabRealSP type\n   for single-precision real key type, - the HTabRealDP type\n   for double-precision real key type, - the HTabRealQP type\n   for quadruple-precision real key type, - the HTabObject type for a derived type of key-value pair in the Object class. Each hash-table-based container type represents an unordered symbol table where various common\n operations are provided and can be categorized as follows. (1) Construction and Destruction.  Methods for these operations include: - CreateEmpty method - method to construct an empty container, - Construct method - method to construct a container from arrays of keys and values, and - Destruct method - method to destruct a container by removing all key-value pairs from\n     the container as well as free memory storage occupied by the container. (2) Insertion and Removal.  Methods for these operations include: - Insert method - method to insert a key and its associated value into a container, - Remove method - method to remove a key (and its associated value) from a container, and - Clear method - method to remove all key-value pairs from a container. (3) Retrieval.  A method for this operation is: - GetKeys method - method to retrieve all keys and optionally all their associated values. (4) Inquiry.  Methods for this operation include: - IsEmpty method - method to check whether the container is empty or not, - Contain method - method to check whether the specified key is in the container or not, and - GetSize method - method to get the container size (number of key-value pairs stored). (5) Iteration.  Methods for this operation include: - StartFirst method - method to start a forward iteration over key-value pairs, and - MoveForward method - method to move forward to the next key-value pair. Uses MClass_HTabObject MClass_HTabRealQP MClass_HTabInteger2B MClass_HTabCharacter MClass_HTabInteger1B MClass_HTabInteger8B MClass_HTabRealDP MClass_HTabRealSP MClass_HTabInteger4B","tags":"","loc":"module\\mbase_hashtables.html"},{"title":"MClass_HTabInteger4B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabInteger4B type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabInteger4B type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabInteger4B type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabInteger4B type uses the Fortran intrinsic INTEGER(KIND=kInt32) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabInteger4B type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabInteger4B type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabInteger4B The HTabInteger4B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabinteger4b.html"},{"title":"MClass_TreeTable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeTable type and its supporting routines and data type.  The\n  The TreeTable type is a collection type that employs a balanced binary-search-tree (BST)\n  implementation to provide common operations for an ordered symbol table. The TreeTable type uses the KeyOrdered type to store its keys and the GenData type\n  to store its values.  Therefore, it can be used to store comparable keys and values of any\n  data types.  Allowed types of comparable keys include the CHARACTER , INTEGER and REAL intrinsic types as well as any derived type that is in the Comparable class.  Like other\n  collection types, however, it must be employed to store key-value pairs of only specific\n  key type and one specific value type.  To store key-value pairs of another key type (or\n  another value type), it must be destructed before inserting items of different key type\n  (or different value type). As a symbol table, the TreeTable type does not allow duplicated keys.  Therefore, if an\n  inserted key is equal to a key stored in the table, an associated value of the stored key\n  is replaced by an associated value of the inserted key.  As an ordered symbol table, the TreeTable type provides an ordered iteration over its stored key-value items, which are\n  sorted according to the natural ordering of its keys.  It can be accessed and traversed in\n  either ascending (using the StartFirst method) or descending (using the StartLast method)\n  key order. Technically, the TreeTable type employs a balanced binary search tree (BST) implementation\n  to provide common operations for an ordered symbol table.  The TreeTable type utilizes the IntrusiveRBTree type as its component to store its tree nodes.  The IntrusiveRBTree type,\n  as an intrusive BST container, provides common binary-search-tree operations without a memory\n  management task.  The memory management task of the inserted tree nodes is handled by the TreeTable type. Uses MBase_MemHandlers MClass_CompNodePool MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MClass_KeyOrdered MBase_ByteUtil MClass_BaseSymTable MClass_Comparable MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_OrderedSymTable MClass_IntrusiveBSTrees MClass_Object Derived Types type, public, extends( OrderedSymTable ) :: TreeTable The TreeTable type is a collection type that utilizes a balanced BST implementation to\n  provide common operations for an ordered symbol table.  The TreeTable type uses the IntrusiveRBTree type as its component to store TabNode objects.  As an intrusive\n  BST container, the IntrusiveRBTree type provides common binary-search-tree operations\n  without a memory management task.  The memory management task of the inserted TabNode objects is handled by the TreeTable type. As an ordered symbol table, the TreeTable type is a subtype of the OrderedSymTable type.  Thus, it implements all deferred procedures required by the OrderedSymTable type and all its super classes.  As a symbol table, the TreeTable type does not allow\n  duplicated keys; therefore, if an inserted key is equal to a key stored in the table, an\n  associated value of the stored key is replaced by an associated value of the inserted key. Because the IntrusiveRBTree type is a subtype of the IntrusiveAVLTree type, the WrkTree component can be employed as a red-black tree or an AVL tree.  Therefore, the TreeTable type allows a user to specify which type of binary-search tree implementation\n  to be used.  By default, the red-black tree implementation is used.  The user can call the UseAVLTree method to change to AVL tree implementation.  The UseAVLTree method must\n  be called before inserting an object into the symbol table (i.e when the table is empty).\n  Otherwise, the red-black tree implementation is employed. Finalizations Procedures final :: TreeTable_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: CopyCollection => TreeTable_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => TreeTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => TreeTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => TreeTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => TreeTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => TreeTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) procedure, public :: StartLast => TreeTable_Move2LastPair Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order and return a flag\n               indicating whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartLast() --->    IsEmpty = Collection%StartLast(LastKey) --->    IsEmpty = Collection%StartLast(Value=LastVal) --->    IsEmpty = Collection%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => TreeTable_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveBackward() --->    IsTheEnd = Collection%MoveBackward(PrevKey) --->    IsTheEnd = Collection%MoveBackward(Value=PrevVal) --->    IsTheEnd = Collection%MoveBackward(PrevKey, PrevVal) procedure, public :: Insert => TreeTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) procedure, public :: Delete => TreeTable_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Remove => TreeTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Contain => TreeTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething procedure, public :: GetValue => TreeTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection. Also,\n      return a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething procedure, public :: ToArray => TreeTable_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething procedure, public :: GetAll => TreeTable_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething procedure, public :: GetMinKey => TreeTable_GetMinKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated\n               with it) in a symbol table.  Also, return a flag indicating\n               whether the key is successfully retrieved or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%GetMinKey(Key) --->    IF (.NOT.Collection%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => TreeTable_GetMaxKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated\n               with it) in a symbol table.  Also, return a flag indicating\n               whether the key is successfully retrieved or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%GetMaxKey(Key) --->    IF (.NOT.Collection%GetMaxKey(Key, Value)) DoSomething procedure, public :: Floor => TreeTable_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated\n               with it) in a symbol table less than or equal to the given\n               key.  Also, return a flag indicating whether the floor key\n               is successfully retrieved or not. Usage : --->    Flag = Collection%Floor(KeyIn, KeyOut) --->    IF (.NOT.Collection%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => TreeTable_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated\n               with it) in a symbol table greater than or equal to the given\n               key.  Also, return a flag indicating whether the ceiling key\n               is successfully retrieved or not. Usage : --->    Flag = Collection%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Collection%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: GetRank => TreeTable_GetRank Type-Bound Function : GetRank Purpose :  To return the number of keys in the symbol table strictly\n               less than the given key. Usage : --->    KeyRank = Collection%GetRank(Key) procedure, public :: Select => TreeTable_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the\n               specified rank where the applicable range of rank is between\n               0 and TableSize-1. Also, return a flag indicating whether the\n               ranked key is successfully retrieved or not. --->    Flag = Collection%Select(Rank, Key) --->    IF (.NOT.Collection%Select(Rank, Key, Value)) DoSomething procedure, public :: RemoveMin => TreeTable_RemoveMin Type-Bound Function : RemoveMin Purpose :  To remove the smallest key (and a value associated with it)\n               from a symbol table.  Also, return a flag indicating\n               whether the key is successfully removed or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%RemoveMin() --->    Flag = Collection%RemoveMin(MinKey) --->    Flag = Collection%RemoveMin(Value=MinVal) --->    IF (.NOT.Collection%RemoveMin(MinKey, MinVal)) DoSomething procedure, public :: RemoveMax => TreeTable_RemoveMax Type-Bound Function : RemoveMax Purpose :  To remove the largest key (and a value associated with it)\n               from a symbol table.  Also, return a flag indicating\n               whether the key is successfully removed or not.  If the\n               table is not empty, the returned flag is always true. Usage : --->    Flag = Collection%RemoveMax() --->    Flag = Collection%RemoveMax(MaxKey) --->    Flag = Collection%RemoveMax(Value=MaxVal) --->    IF (.NOT.Collection%RemoveMax(MaxKey, MaxVal)) DoSomething procedure, public :: GetRangeSize => TreeTable_RangeSize Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Collection%GetRangeSize(KeyLo, KeyHi) generic, public :: Construct => CopyCollection , TreeTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: UseAVLTree => TreeTable_UseAVLTree Type-Bound Subroutine : UseAVLTree Purpose :  To set the working tree component to work as an AVL tree. Usage : --->    CALL Collection%UseAVLTree() Note : The collection must be empty when calling this method. procedure, public :: UseRBTree => TreeTable_UseRBTree Type-Bound Subroutine : UseRBTree Purpose :  To set the working tree component to work as an red-black RB tree. Usage : --->    CALL Collection%UseRBTree() Note : The collection must be empty when calling this method. procedure, public :: Check => TreeTable_CheckIntegrity Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething procedure, public :: Copy => TreeTable_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => TreeTable_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => TreeTable_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => TreeTable_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => TreeTable_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_treetable.html"},{"title":"MClass_ListCmpxDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListCmpxDP type and related routines.\n  The ListCmpxDP type is a container with COMPLEX(KIND=kDouble) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListCmpxDP type but utilizes a different implementation.\n  Also, unlike the ListCmpxDP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListCmpxDP ListCmpxDP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kDouble) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listcmpxdp.html"},{"title":"MClass_TreeComparable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeComparable type and its related helper type and routines.\n  The TreeComparable type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeComparable type uses the Comparable derived type to store both the keys and their associated values.\n  Unlike other tree-based containers, the TreeComparable type uses a user-defined type in\n  the Comparable class to represent a key-value pair and requires only one argument (instead\n  of two) when inserting or retrieving the key and its associated value. It is important to note that a user must be careful when implementing a user-defined concrete subtype of the Comparable type.  The TreeComparable type employs the assignment statement\n  copy data of the key-value object and it utilizes the relational operators (e.g. ==, > and <)\n  to compare keys of the key-value objects.  This implies that the user should implement the\n  deferred CopyAssign procedure where both key and value components are copied from the source\n  object to the destination object whereas, when implemented, the deferred CompareTo procedure\n  should be dependent on its key component only.  It is also worth mentioning that only one\n  user-defined type in the Comparable class should be used for one container instance.  If\n  more than one types are inserted into the container, they should all be able to compare to\n  other types.  In this case, additionally, the user must implement the CopyAssign procedure\n  in a way that allows one type to make a copy of another type.  This indicates that all these\n  inserted types must be subtypes of one parent type.  Otherwise, the TreeComparable type would\n  not operate properly and the user will not be able to correctly retrieve a key-value pair from\n  the container. As a symbol table, the TreeComparable type does not allow duplicated keys.  Therefore,\n  if an inserted key-value pair is equal to a key-value pair stored in the table, the stored\n  pair is replaced by the inserted one.  Technically, the TreeComparable type employs a\n  left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeComparable type but utilizes\n  a different implementation.  Also, unlike the TreeComparable type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MClass_Comparable MBase_Common MBase_SIntUtil Derived Types type, public :: TreeComparable TreeComparable is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from an array of key-value pairs. Usage : --->    CALL Tree%Construct(10, KeyValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored key-value pairs. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyValQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(KeyVal) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not. Usage : --->    Flag = Tree%Remove(KeyVal) --->    IF (.NOT.Tree%Remove(KeyVal)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    IF (.NOT.Tree%RemoveMin(KeyVal)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    IF (.NOT.Tree%RemoveMax(KeyVal)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKeyVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKeyVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKeyVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKeyVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the tree is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(KeyVal) --->    IF (.NOT.Tree%Contain(KeyVal)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyValLo, KeyValHi) procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and a value associated with it) in the tree.\n               Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(KeyVal) --->    IF (.NOT.Tree%GetMinKey(KeyVal)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and a value associated with it) in the tree.\n               Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(KeyVal) --->    IF (.NOT.Tree%GetMaxKey(KeyVal)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               their associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(KeyVals) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKeyVal, HiKeyVal, KeyVals) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and a value associated with it) in the tree\n               less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyValIn, KeyValOut) --->    IF (.NOT.Tree%Floor(KeyValIn, KeyValOut)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and a value associated with it) in the tree\n               greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyValIn, KeyValOut) --->    IF (.NOT.Tree%Ceiling(KeyValIn, KeyValOut)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and its associated value) of the specified rank where the\n               applicable range of rank is between 0 and TableSize-1. Also, return a flag\n               indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, KeyVal) --->    IF (.NOT.Tree%Select(Rank, KeyVal)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(KeyVal) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treecomparable.html"},{"title":"MClass_BaseSymTable – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BaseSymTable type and its related routines.  The BaseSymTable type is an abstract data type representing a symbol table, which is a collection that\n  associates a value with a key .  The user can insert key-value pairs into the symbol\n  table with the expectation of later being able to search for the value associated with\n  a given key. The BaseSymTable type extends the BaseCollection type to define additional methods for\n  various common operations of a symbol table.  All other symbol table types (unordered or\n  ordered ones) should extend from this base type. Uses MBase_ErrHandlers MClass_KeyOrdered MClass_BaseCollection MClass_GenData MClass_KeyUnordered MBase_Common Derived Types type, public, extends( BaseCollection ) :: BaseSymTable The BaseSymTable type is an abstract collection type that defines an API for\n a symbol table, which is a collection that associates a value with a key . It is important to note that, by design, a concrete collection type that extends\n from the BaseSymTable type only stores entries of one specific key type and one\n specific value type.  To store entries of another key and/or value types, the\n collection must be cleared and/or destructed. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. generic, public :: Construct => CopyCollection Type-Bound Subroutine : Construct Purpose :  To construct a new collection. Usage : ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure(IfaceStartFirst), public, deferred :: StartFirst StartFirst is a deferred procedure to start the forward iteration. procedure(IfaceMoveNext), public, deferred :: MoveForward MoveForward is a deferred procedure to move to the next iteration. procedure(IfaceInsert), public, deferred :: Insert Insert is a deferred procedure to insert the specified key-value pair to the\n  collection. procedure(IfaceDelete), public, deferred :: Delete Delete is a deferred procedure to delete the current key-value pair from the\n  collection.  This method is intended to be employed in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of\n  those methods and then calling this one will result in a removal of the current\n  key-value pair of the iteration (i.e. the same key-value pair that can be obtained\n  via the StartFirst and MoveForward methods). procedure(IfaceRemove), public, deferred :: Remove Remove is a deferred procedure to remove the specified key (and its associated\n  value) from the collection. procedure(IfaceContain), public, deferred :: Contain Contain is a deferred procedure to check whether the specified key is in the\n  collection or not. procedure(IfaceGetVal), public, deferred :: GetValue GetValue is a deferred procedure to get a value associated with the specified key\n  in the collection. procedure(IfaceToArray), public, deferred :: ToArray ToArray is a deferred procedure to retrieve and remove all key-value pairs from\n  the collection. procedure(IfaceGetAll), public, deferred :: GetAll GetAll is a deferred procedure to retrieve all keys and/or all values (without\n  removing them) from the collection. procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user.","tags":"","loc":"module\\mclass_basesymtable.html"},{"title":"MClass_TreeInteger8B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeInteger8B type and its related helper type and routines.\n  The TreeInteger8B type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeInteger8B type uses the Fortran intrinsic INTEGER(KIND=kInt64) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeInteger8B type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeInteger8B type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeInteger8B type but utilizes\n  a different implementation.  Also, unlike the TreeInteger8B type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeInteger8B TreeInteger8B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treeinteger8b.html"},{"title":"MClass_PQInteger8B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQInteger8B type and its related routines.\n  The PQInteger8B type is a priority-queue container with INTEGER(KIND=kInt64) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQInteger8B type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQInteger8B The PQInteger8B type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqinteger8b.html"},{"title":"MClass_DynamicArrays – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains dynamic-array-based collection types and their related routines.\n  A dynamic-array-based type is a collection type employing a resizable array (or the\n  so-called dynamic array) that can increase or decrease its size depending on the current\n  collection size (number of items contained in the collection) relative to the current\n  collection capacity. Available collection types based on the dynamic-array concept include: - the StackArray type that represents a last-in-first-out (LIFO) stack, - the QueueArray type that represents a first-in-first-out (FIFO) queue, - the DequeArray type that represents a double-ended queue (deque), and - the ListArray type that represents a list where an item can be added, removed or\n    retrieved at the (valid) specified index. Usage Notes : - All dynamic-array-based collection types commonly require an explicit construction\n    before using other provided operations.  There are two methods provided to create a\n    collection.  First, the CreateEmpty method constructs an empty collection with the\n    specified initial capacity.  Second, the Construction method constructs a collection\n    based on the given input (either from an array of items or from another collection). - All available collection types are subtypes of the BaseDynArr abstract type, which is\n    a private type that is only available in this module.  The BaseDynArr type provides\n    the Growing (private) method to expand the collection's capacity and the Shrinking (also private) method to reduce the capacity. When the collection is full (its current size is equal to its current capacity), its\n    capacity is doubled by default.  However, if the IncSize argument is specified during\n    a construction of the collection, the collection's capacity increases by the amount\n    specified (the specified value must be positive) instead of doubling. When the collection's size is reducing due to removing items from the collection, its\n    capacity stays the same by default.  Nevertheless, if the Shrink flag is specified\n    and its value is true during a construction of the collection, the collection's capacity\n    is halved when its current size is one quarter of its capacity. - Instead of using as a deque, the DequeArray type can also be used as a FIFO queue or\n    a LIFO stack. - Instead of using as a list, the ListArray type can also be used as a deque, a FIFO\n    queue or a LIFO stack. Important Notes : (1) By design, although all dynamic-array-based types are generic containers meaning\n      that they can be used to store items of any data types, they must be employed to store\n      items of only one specific data type.  To store items of another data type, they must\n      be cleared and/or destructed before inserting items of different data type. (2) To be able to successfully retrieve stored items, the specified output item must have\n      the same (concrete) type as that of stored items. (3) Additionally, if type of the stored items is a derived one that is NOT in the Object class and this type has allocatable and/or pointer components, a user must specify the\n      optional ItemCopy argument when trying to retrieve the stored items.  The ItemCopy argument is a user-defined procedure to copy an unlimited polymorphic entity.  It must\n      must provide a type-guard statement to check the compatibility of concrete types of its\n      arguments.  It must also handle the storage allocation (and/or the assignment) of those\n      allocatable (and/or pointer) components as appropriate. Uses MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_ByteUtil MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_Object Derived Types type, public, extends(BaseDynArr) :: StackArray Description : The StackArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a LIFO stack. Usage Overview : The StackArray type is a stack collection type that provides common operations of a\n  LIFO stack.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n        or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Push method - method to insert an item at the top (end) of the collection, (2.2) Pop method - method to get and remove the top (last) item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekTop method - method to retrieve the top (last) item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalizations Procedures final :: StackArray_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional incremental size --->    CALL Collection%Construct(25, Arr, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%Construct(25, Arr, Shrink=.TRUE.) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: CopyCollection => StackArray_CopyCollection Use the Construct method to create a collection from another collection. procedure, public :: Clear => StackArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => StackArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => StackArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => StackArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => StackArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => StackArray_AddElm Use the Push method in place of the Insert method to add an item to the stack. procedure, public :: Delete => StackArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => StackArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => StackArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the top (end) of the collection. Usage : --->    CALL Collection%Push(Item) procedure, public :: Pop => StackArray_Pop Type-Bound Function : Pop Purpose :  To get and remove the top (last) item of the collection. Also, return a\n               flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething procedure, public :: PeekTop => StackArray_PeekTop Type-Bound Function : PeekTop Purpose :  To get the top (last) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: Copy => StackArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => StackArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => StackArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => StackArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => StackArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: Offset => StackArray_Offset This procedure is intended for internal uses only. type, public, extends(BaseDynArr) :: QueueArray Description : The QueueArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a FIFO queue. Usage Overview : The QueueArray type is a queue collection type that provides common operations of a\n  FIFO queue.  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n         or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) Enqueue method - method to insert an item to the end of the collection, (2.2) Dequeue method - method to get and remove the first item of the collection, (2.3) Clear method - method to remove all items from the collection. (2.4) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) GetSize method - method to get the collection size (number of items stored), (3.3) IsEmpty method - method to check whether the collection is empty or not. (3.4) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item. Finalizations Procedures final :: QueueArray_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional incremental size --->    CALL Collection%Construct(25, Arr, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%Construct(25, Arr, Shrink=.TRUE.) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => QueueArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. type, public, extends( QueueArray ) :: DequeArray Description : The DequeArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a double-ended queue (deque).   It can be used as a\n  FIFO queue or a LIFO stack as well. Usage Overview : The DequeArray type is a deque collection type that provides common operations of a\n  double-ended queue (deque).  Their operations can be categorized as follows: (1) Construction and destruction.  Methods for these operations include (1.1) Construct method - method to construct the collection either from an array of items\n         or from another collection, (1.2) CreateEmpty method - method to construct an empty collection, (1.3) Destruct method - method to destruct the collection. (2) Insert and remove.  Methods for these operations include (2.1) AddFirst method - method to insert an item to the front of the collection, (2.2) AddLast method - method to insert an item to the end of the collection, (2.3) RemoveFirst method - method to get and remove the first item of the collection, (2.4) RemoveLast method - method to get and remove the last item of the collection, (2.5) Clear method - method to remove all items from the collection. (2.6) ToArray method - method to remove and retrieve all items from the collection. (3) Inquiry.  Methods for these operations include (3.1) PeekFirst method - method to retrieve the first item of the collection, (3.2) PeekLast method - method to retrieve the last item of the collection, (3.3) GetSize method - method to get the collection size (number of items stored), (3.4) IsEmpty method - method to check whether the collection is empty or not. (3.5) GetAll method - method to retrieve all items from the collection. (4) Iteration.  Methods for these operations include (4.1) StartFirst method - method to start a forward iteration over items, (4.2) MoveForward method - method to move forward to the next item, (4.3) StartLast method - method to start a backward iteration over items, (4.4) MoveBackward method - method to move backward to the previous item. The DequeArray type also supports the usual Enqueue , Dequeue and PeekFirst operations of a FIFO queue as well as the usual Push , Pop and PeekTop operations\n  of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be\n  used in place of insert , remove , peek operations of a deque as desired. Finalizations Procedures final :: DequeArray_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional incremental size --->    CALL Collection%Construct(25, Arr, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%Construct(25, Arr, Shrink=.TRUE.) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. procedure, public :: StartLast => DequeArray_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DequeArray_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: AddFirst => DequeArray_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DequeArray_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection. Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething procedure, public :: PeekLast => DequeArray_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection). Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection. Also, return a\n               flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: ToString => DequeArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() type, public, extends( DequeArray ) :: ListArray Description : The ListArray type is a collection type that employs a resizable-array implementation\n  to provide common operations for a list. Usage Overview : The ListArray type provides insert, remove and peek operations at a specified index\n  where the index must be between 1 and the collection size.  The ListArray type is\n  a subtype of the DequeArray type; therefore, all operations available for the DequeArray type are also available for the ListArray type.  As a result, it can\n  thus be used as a deque, a FIFO queue or a LIFO stack. Finalizations Procedures final :: ListArray_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CreateEmpty => BaseDynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty collection. Usage : ! create an empty collection with specified initial capacity --->    CALL Collection%CreateEmpty(25) ! create a collection and specify the optional incremental size --->    CALL Collection%CreateEmpty(25, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => CopyCollection , BaseDynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional incremental size --->    CALL Collection%Construct(25, Arr, IncSize=16) ! create a collection and specify the optional shrink flag --->    CALL Collection%Construct(25, Arr, Shrink=.TRUE.) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: CopyCollection => QueueArray_CopyCollection Use the Construct method to create a collection from another collection. procedure, public :: Clear => QueueArray_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => QueueArray_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => QueueArray_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => QueueArray_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => QueueArray_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => QueueArray_AddElm Use the Enqueue method in place of the Insert method to add an item to the queue. procedure, public :: Delete => QueueArray_DelElm Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => QueueArray_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => QueueArray_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Enqueue => Insert Type-Bound Subroutine : Enqueue Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%Enqueue(Item) procedure, public :: Dequeue => QueueArray_Dequeue Type-Bound Function : Dequeue Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Dequeue(Item) --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething procedure, public :: PeekFirst => QueueArray_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekFirst(Item) --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething procedure, public :: Copy => QueueArray_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => QueueArray_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => QueueArray_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: HashCode => QueueArray_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode() procedure, public :: Offset => QueueArray_Offset This procedure is intended for internal uses only. procedure, public :: StartLast => DequeArray_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DequeArray_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the collection or not. Usage : The following code snippet illustrates how to typically traverse across the collection\n  in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Collection%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Collection%MoveBackward()\n      ! check whether we reach the end of the collection or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: AddFirst => DequeArray_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the collection. Usage : --->    CALL Collection%AddFirst(Item) generic, public :: AddLast => Insert Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the collection. Usage : --->    CALL Collection%AddLast(Item) generic, public :: RemoveFirst => Dequeue Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the collection. Also, return\n               a flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveFirst(Item) --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DequeArray_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the collection. Also, return a flag\n               indicating whether the item is successfully removed. Usage : --->    Success = Collection%RemoveLast(Item) --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething procedure, public :: PeekLast => DequeArray_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the collection). Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekLast(Item) --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething generic, public :: Push => Insert Type-Bound Subroutine : Push Purpose :  To insert the specified item at the end (top) of the collection. Usage : --->    CALL Collection%Push(Item) generic, public :: Pop => RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the last (top) item of the collection. Also, return a\n               flag indicating whether the item is successfully removed. Usage : --->    Success = Collection%Pop(Item) --->    IF (.NOT.Collection%Pop(Item)) DoSomething generic, public :: PeekTop => PeekLast Type-Bound Function : PeekTop Purpose :  To get the last (top) item (without removing it from the collection).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekTop(Item) --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething procedure, public :: AddAt => ListArray_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where the index\n      must be between 1 and the collection size. Also, return a flag indicating\n      whether the item is successfully added. Usage : --->    Success = Collection%AddAt(Index, Item) --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething procedure, public :: RemoveAt => ListArray_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where the index\n      must be between 1 and the collection size. Also, return a flag indicating\n      whether the item is successfully removed. Usage : --->    Success = Collection%RemoveAt(Index, Item) --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething procedure, public :: PeekAt => ListArray_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the collection) at the\n      specified index where the index must be between 1 and the collection size.\n      Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Collection%PeekAt(Index, Item) --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething procedure, public :: ToString => ListArray_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString()","tags":"","loc":"module\\mclass_dynamicarrays.html"},{"title":"MClass_HTabInteger2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabInteger2B type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabInteger2B type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabInteger2B type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabInteger2B type uses the Fortran intrinsic INTEGER(KIND=kInt16) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabInteger2B type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabInteger2B type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabInteger2B The HTabInteger2B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabinteger2b.html"},{"title":"MClass_DArrRealQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrRealQP type and related routines.\n  The DArrRealQP type is a container with REAL(KIND=kQuad) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrRealQP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrRealQP DArrRealQP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kQuad) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrRealQP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrrealqp.html"},{"title":"MClass_PQBinHeap – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQBinHeap type and its related routines.  The PQBinHeap type\n  is a collection type that employs the binary heap implementation to provide common operations\n  for a priority queue.  The PQBinHeap type can be used as either a max-priority queue or a\n  min-priority queue.  By default, it represents the max-priority queue.  However, a user may\n  specify the optional MinPQ argument to true when constructing the collection so that the PQBinHeap type represents the min-priority queue instead. The PQBinHeap type employs the KeyOrdered type to store comparable keys where allowed\n  key types include the CHARACTER , INTEGER and REAL intrinsic types as well as any\n  derived type that is in the Comparable class.  Like other collection types, it must be\n  employed to store keys of only one particular data type.  To store keys of another data\n  type, it must be destructed before inserting keys of different data type. The PQBinHeap type is NOT an ordered collection type because its stored keys are only\n  partially sorted in the so-called heap order, which also depends on the type of the\n  priority queue it represents (i.e. max-priority or min-priority queue).  Therefore, the PQBinHeap type makes no guarantees as to the iteration order of its keys.  In particular,\n  it does not guarantee that the order will remain the same over time. Uses MClass_CompNodePool MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MClass_KeyOrdered MBase_ByteUtil MClass_Comparable MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_Object Derived Types type, public, extends( BaseCollection ) :: PQBinHeap The PQBinHeap type is a collection type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQBinHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: CopyCollection => PQBinHeap_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => PQBinHeap_Clear Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => PQBinHeap_Destruct Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. procedure, public :: GetSize => PQBinHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: CreateEmpty => PQBinHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                         ! use default options --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options generic, public :: Construct => CopyCollection , PQBinHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL Collection%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Insert => PQBinHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL Collection%Insert(Key) procedure, public :: Remove => PQBinHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Peek => PQBinHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%Peek(Key) --->    IF (.NOT.Collection%Peek(Key)) DoSomething procedure, public :: ToArray => PQBinHeap_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => PQBinHeap_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething procedure, public :: StartFirst => PQBinHeap_Move2FirstKey Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) procedure, public :: MoveForward => PQBinHeap_Move2NextKey Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Copy => PQBinHeap_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => PQBinHeap_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => PQBinHeap_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => PQBinHeap_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => PQBinHeap_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_pqbinheap.html"},{"title":"MClass_ListRealDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListRealDP type and related routines.\n  The ListRealDP type is a container with REAL(KIND=kDouble) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListRealDP type but utilizes a different implementation.\n  Also, unlike the ListRealDP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListRealDP ListRealDP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kDouble) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listrealdp.html"},{"title":"MClass_TreeInteger1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeInteger1B type and its related helper type and routines.\n  The TreeInteger1B type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeInteger1B type uses the Fortran intrinsic INTEGER(KIND=kInt8) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeInteger1B type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeInteger1B type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeInteger1B type but utilizes\n  a different implementation.  Also, unlike the TreeInteger1B type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeInteger1B TreeInteger1B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treeinteger1b.html"},{"title":"MClass_DArrInteger1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrInteger1B type and related routines.\n  The DArrInteger1B type is a container with INTEGER(KIND=kInt8) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrInteger1B type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrInteger1B DArrInteger1B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt8) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger1B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrinteger1b.html"},{"title":"MClass_DArrLogical – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrLogical type and related routines.\n  The DArrLogical type is a container with LOGICAL as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrLogical type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrLogical DArrLogical is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is LOGICAL . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrLogical class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrlogical.html"},{"title":"MBase_DoublyLinkedLists – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module collectively contains doubly-linked-list-based types from other modules.\n It is provided so that a user can refer to this module instead of referring to several\n individual modules when various types are needed concurrently. Overview : These doubly-linked-list-based types are container types that employ doubly-linked-list\n implementation.  Each individual type can be used to store items for a specific type\n where the type of stored items is one of Fortran intrinsic types or a derived type in\n the Object class (i.e. the Object type or its subtypes). Available container types are: - the ListCharacter type\n   for character string type, - the ListCmpxSP type\n   for single-precision complex type, - the ListCmpxDP type\n   for double-precision complex type, - the ListCmpxQP type\n   for quadruple-precision complex type, - the ListInteger1B type\n   for 1-byte (or 8-bit) integer type, - the ListInteger2B type\n   for 2-byte (or 16-bit) integer type, - the ListInteger4B type\n   for 4-byte (or 32-bit) integer type, - the ListInteger8B type\n   for 8-byte (or 64-bit) integer type, - the ListLogical type\n   for default logical type, - the ListRealSP type\n   for single-precision real type, - the ListRealDP type\n   for double-precision real type, - the ListRealQP type\n   for quadruple-precision real type, and - the ListObject type\n   for a derived type in the Object class, and - the ListAnyType type\n   for any data type. Each doubly-linked-list-based type can represent various forms of containers including: - the last-in-first-out (LIFO) stack container, - the first-in-first-out (FIFO) queue container, - the double-ended queue (deque) container, and - the list container where an item can be added, removed or retrieved\n   at the (valid) specified index. Each individual type provides various common operations that can be\n categorized as follows. (1) Construction and Destruction.  Methods for these operations include: - Construct method - method to construct the container from\n   an array of items, and - Destruct method - method to destruct the container by removing\n   all items from the container. (2) Insertion and Removal.  Methods for these operations include: - AddFirst method - method to insert an item to the front of the container, - AddLast method - method to insert an item to the end of the container, - AddAt method - method to insert an item at the specified index, - RemoveFirst method - method to get and remove the first item of the container, - RemoveLast method - method to get and remove the last item of the container, - RemoveAt method - method to get and remove an item at the specified index, - Remove method - method to remove (and optionally get) either the last or\n   the first item, - Delete method - method to remove an item at the current iteration while\n   performing an iteration over the container, - Clear method - method to remove all items from the container. - ToArray method - method to retrieve and then remove all items from the container. - RemoveDuplicates method - method to remove duplicated items from the container, - Enqueue method - same as the AddLast method provided when used as a queue, - Dequeue method - same as the RemoveFirst method provided when used as a queue, - Push method - same as the AddLast method provided when used as a stack, and - Pop method - same as the RemoveLast method provided when used as a stack. (3) Retrieval.  Methods for this operation include: - PeekFirst method - method to retrieve the first item of the container, - PeekLast method - method to retrieve the last item of the container, - PeekAt method - method to retrieve the item at the specified index, - PeekTop method - same as the PeekLast method provided when used as a stack, and - GetAll method - method to retrieve all items from the container. (4) Inquiry.  Methods for this operation include: - IsEmpty method - method to check whether the container is empty or not, and - GetSize method - method to get the container size (number of items stored). (5) Iteration.  Methods for this operation include: - StartFirst method - method to start a forward iteration over items, - MoveForward method - method to move forward to the next item, - StartLast method - method to start a backward iteration over items, and - MoveBackward method - method to move backward to the next item. Usage Notes : The doubly-linked-list-based types provided in this module can be considered\n to be the same as those dynamic-array-based types provided in the MBase_DynamicArrays module\n although they employ different implementation.  However, the two groups of\n containers have some subtle differences as discussed below. - Unlike the dynamic-array-based types, all doubly-linked-list-based types\n   commonly do not require an explicit construction.  Items can be added via the Construction method (for an array of items) or they can be added by using\n   one of the insertion methods provided.  Therefore, the CreateEmpty method used\n   to construct an empty container is deemed unnecessary and thus NOT provided. - For doubly-linked-list-based types, the Clear method (which is used to remove\n   all items from the container) is equivalent to the Destruct method (also used\n   to remove all items from the container.  On the other hand, the two methods for\n   the dynamic-array-based types are not equivalent because the Destruct method\n   not only removes all items from the container but also performs deallocation of\n   the Items component used to store items whereas the Clear method only removes\n   all items from the container. Besides methods just discussed above, all other operations provided by both groups\n of containers can be considered to be the same. Uses MClass_ListInteger2B MClass_ListCmpxDP MClass_ListCmpxQP MClass_ListInteger4B MClass_ListRealQP MClass_ListAnyType MClass_ListRealDP MClass_ListObject MClass_ListCharacter MClass_ListInteger8B MClass_ListLogical MClass_ListInteger1B MClass_ListRealSP MClass_ListCmpxSP","tags":"","loc":"module\\mbase_doublylinkedlists.html"},{"title":"MClass_TreeRealQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeRealQP type and its related helper type and routines.\n  The TreeRealQP type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeRealQP type uses the Fortran intrinsic REAL(KIND=kQuad) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeRealQP type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeRealQP type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeRealQP type but utilizes\n  a different implementation.  Also, unlike the TreeRealQP type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeRealQP TreeRealQP is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treerealqp.html"},{"title":"MBase_DynamicArrays – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module collectively contains dynamic-array-based types from other modules.\n It is provided so that a user can refer to this module instead of referring to several\n individual modules when various types are needed concurrently. Overview : These dynamic-array-based types are container types that employ dynamic-array (or\n resizable-array) implementation.  Each individual type can be used to stored items\n for a specific type where the type of stored items is one of Fortran intrinsic types\n or a derived type in the Object class (i.e. the Object type or its subtypes). Available container types are: - the DArrCharacter type\n   for character string type, - the DArrCmpxSP type\n   for single-precision complex type, - the DArrCmpxDP type\n   for double-precision complex type, - the DArrCmpxQP type\n   for quadruple-precision complex type, - the DArrInteger1B type\n   for 1-byte (or 8-bit) integer type, - the DArrInteger2B type\n   for 2-byte (or 16-bit) integer type, - the DArrInteger4B type\n   for 4-byte (or 32-bit) integer type, - the DArrInteger8B type\n   for 8-byte (or 64-bit) integer type, - the DArrLogical type\n   for default logical type, - the DArrRealSP type\n   for single-precision real type, - the DArrRealDP type\n   for double-precision real type, - the DArrRealQP type\n   for quadruple-precision real type, and - the DArrObject type\n   for a derived type in the Object class. Each dynamic-array-based type can represent various forms of containers including: - the last-in-first-out (LIFO) stack container, - the first-in-first-out (FIFO) queue container, - the double-ended queue (deque) container, and - the list container where an item can be added, removed or retrieved\n   at the (valid) specified index. Each individual type provides various common operations that can be\n categorized as follows. (1) Construction and Destruction.  Methods for these operations include: - CreateEmpty method - method to construct an empty container, - Construct method - method to construct the container from\n   an array of items, and - Destruct method - method to destruct the container by removing all\n   items from the container as well as freeing memory of its component used\n   to store items. (2) Insertion and Removal.  Methods for these operations include: - AddFirst method - method to insert an item to the front of the container, - AddLast method - method to insert an item to the end of the container, - AddAt method - method to insert an item at the specified index, - RemoveFirst method - method to get and remove the first item of the container, - RemoveLast method - method to get and remove the last item of the container, - RemoveAt method - method to get and remove an item at the specified index, - Delete method - method to remove an item at the current iteration while\n   performing an iteration over the container, - Clear method - method to remove all items from the container. - ToArray method - method to retrieve and then remove all items from the container. - Enqueue method - same as the AddLast method provided when used as a queue, - Dequeue method - same as the RemoveFirst method provided when used as a queue, - Push method - same as the AddLast method provided when used as a stack, and - Pop method - same as the RemoveLast method provided when used as a stack. (3) Retrieval.  Methods for this operation include: - PeekFirst method - method to retrieve the first item of the container, - PeekLast method - method to retrieve the last item of the container, - PeekAt method - method to retrieve the item at the specified index, - PeekTop method - same as the PeekLast method provided when used as a stack, and - GetAll method - method to retrieve all items from the container. (4) Inquiry.  Methods for this operation include: - IsEmpty method - method to check whether the container is empty or not, and - GetSize method - method to get the container size (number of items stored). (5) Iteration.  Methods for this operation include: - StartFirst method - method to start a forward iteration over items, - MoveForward method - method to move forward to the next item, - StartLast method - method to start a backward iteration over items, and - MoveBackward method - method to move backward to the next item. Usage Notes : The dynamic-array-based types provided in this module can be considered\n to be the same as those doubly-linked-list-based types provided in the MBase_DoublyLinkedLists module\n although they employ different implementation.  However, the two groups of\n containers have some subtle differences as discussed below. - Unlike the doubly-linked-list-based types, all dynamic-array-based types\n   commonly require an explicit construction before using other provided operations.\n   As shown above, there are two methods provided to create a container.  First,\n   the CreateEmpty method constructs an empty container with the specified initial\n   capacity.  Second, the Construction method constructs a container from an array\n   of items. - Also, unlike doubly-linked-list-based types where the Clear method and the Destruct method are considered to be equivalent, the Destruct method of a dynamic-array-based type frees memory of its component used to store items\n   in addition to removing all items from the container (which is the operation\n   of the Clear method).  Therefore, after calling the Destruct method, a user\n   must reconstruct the container (by calling either the Construction or the CreateEmpty method again) before using other operations once more.  Otherwise,\n   the container's behavior may not be as expected (or the program may even crash). Besides methods just discussed above, all other operations provided by both groups\n of containers can be considered to be the same. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy used\n for growing and shrinking a resizable array, which is similar to the strategy\n employed by all dynamic-array-based types provided in this module.  It should\n be noted that all dynamic-array-based types provided in the MClass_DynamicArrays module are functionally similar to those provided in this module.  However, each\n individual type provided in this module can only be used for a specific type of\n items to be stored whereas each individual type in the MClass_DynamicArrays is a generic container that can be used for various types of items to be stored\n providing that the size (in bytes) of the data item to be stored is known at\n compile time. Uses MClass_DArrCmpxQP MClass_DArrInteger1B MClass_DArrInteger8B MClass_DArrCmpxSP MClass_DArrRealSP MClass_DArrRealQP MClass_DArrObject MClass_DArrInteger4B MClass_DArrLogical MClass_DArrCharacter MClass_DArrCmpxDP MClass_DArrInteger2B MClass_DArrRealDP","tags":"","loc":"module\\mbase_dynamicarrays.html"},{"title":"MClass_DArrInteger8B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrInteger8B type and related routines.\n  The DArrInteger8B type is a container with INTEGER(KIND=kInt64) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrInteger8B type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrInteger8B DArrInteger8B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt64) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger8B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrinteger8b.html"},{"title":"MClass_ListLogical – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListLogical type and related routines.\n  The ListLogical type is a container with LOGICAL as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListLogical type but utilizes a different implementation.\n  Also, unlike the ListLogical type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListLogical ListLogical is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is LOGICAL . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listlogical.html"},{"title":"MClass_HTabRealDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabRealDP type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabRealDP type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabRealDP type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabRealDP type uses the Fortran intrinsic REAL(KIND=kDouble) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabRealDP type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabRealDP type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabRealDP The HTabRealDP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabrealdp.html"},{"title":"MClass_BaseCollection – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the BaseCollection type and its related routines.  The BaseCollection type is an abstract data type (ADT) representing a collection, which is a group of objects,\n  known as its items or elements.  Some collections allow duplicate elements while others do not.\n  Some are ordered collections and others are unordered collections. The BaseCollection type defines an application programming interface (API) for various common\n  operations.  All other collection types should extend from this base type. It is important to note that the BaseCollection type is a subtype of the Object type.\n  Therefore, it inherits all deferred procedures required by a subtype of the Object type. Uses MClass_GenData MBase_Common MClass_Object Derived Types type, public, extends(Object) :: BaseCollection The BaseCollection type is an abstract collection type that defines\n an API for various common operations.  Some operations are deferred\n while others (with default implementation) can be overridden. Type-Bound Procedures procedure(IfaceCreate), public, deferred :: CopyCollection CopyCollection is a deferred procedure to construct a new collection from another\n  collection.  Use the Construct method in place of this method. procedure(IfaceClear), public, deferred :: Clear Clear is a deferred procedure to remove all items from the collection. procedure(IfaceDestroy), public, deferred :: Destruct Destruct is a deferred procedure to remove all items from the collection and free\n  memory storage of items stored in the collection. procedure(IfaceSize), public, deferred :: GetSize GetSize is a deferred procedure to get the current size of the collection. generic, public :: Construct => CopyCollection Type-Bound Subroutine : Construct Purpose :  To construct a new collection. Usage : ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing","tags":"","loc":"module\\mclass_basecollection.html"},{"title":"MClass_PQRealQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQRealQP type and its related routines.\n  The PQRealQP type is a priority-queue container with REAL(KIND=kQuad) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQRealQP type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQRealQP The PQRealQP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqrealqp.html"},{"title":"MBase_BalancedTrees – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module collectively contains balanced-tree-based types from other modules.\n It is provided so that a user can refer to this module instead of referring to several\n individual modules when various types are needed concurrently. Overview : These balanced-tree-based types are container types that employ a balanced binary-search-tree\n (BST) implementation to provide common operations for an ordered symbol table.  Specifically,\n all balanced-tree-based types provided here utilize a left-leaning red-black (RB) tree as the\n balanced BST.  Each individual type can be used to store key-value pairs for a specific type\n of keys where the type of stored keys is one of Fortran intrinsic comparable types (i.e.\n CHARACTER, INTEGER and REAL) or a derived type in the Comparable class (i.e. the Comparable type or its subtypes).  Most of the balanced-tree-based types (except the TreeComparable type)\n use an unlimited polymorphic type to store values; therefore, inserted values can have any types.\n Unlike other balanced-tree-based types, the TreeComparable type uses the Comparable type to\n represent a key-value pair and requires only one argument (instead of two) when inserting or\n retrieving the key and its associated value.  Therefore, its application programming interface\n (API) is slightly different from the API of other balanced-tree-based types. Available balanced-tree-based container types include: - the TreeCharacter type\n   for character string key type, - the TreeInteger1B type\n   for 1-byte (or 8-bit) integer key type, - the TreeInteger2B type\n   for 2-byte (or 16-bit) integer key type, - the TreeInteger4B type\n   for 4-byte (or 32-bit) integer key type, - the TreeInteger8B type\n   for 8-byte (or 64-bit) integer key type, - the TreeRealSP type\n   for single-precision real key type, - the TreeRealDP type\n   for double-precision real key type, - the TreeRealQP type\n   for quadruple-precision real key type, - the TreeComparable type for type of key-value pair in Comparable class. Each balanced-tree-based container type represents an ordered symbol table where various common operations\n are provided and can be categorized as follows. (1) Construction and Destruction.  Methods for these operations include: - Construct method - method to construct the container from arrays of keys and values, and - Destruct method - method to destruct the container by removing all key-value pairs from\n     the container. (2) Insertion and Removal.  Methods for these operations include: - Insert method - method to insert a key and its associated value into the container, - Remove method - method to remove a key (and its associated value) from the container, - RemoveMin method - method to remove (and optionally retrieve) the smallest key-value pair, and - RemoveMax method - method to remove (and optionally retrieve) the largest key-value pair. (3) Retrieval.  Methods for this operation include: - GetMinKey method - method to retrieve the smallest key-value pair of the container, - GetMaxKey method - method to retrieve the largest key-value of the container, - GetKeys method - method to retrieve all keys (in the tree or in the specified range) and\n     their associated values, - Floor method - method to retrieve the largest key (and a value associated with it) in the\n     tree less than or equal to the given key. - Ceiling method - method to retrieve the smallest key (and a value associated with it) in\n     the tree greater than or equal to the given key, and - Select method - method to retrieve the key-value pair of the specified rank. (4) Inquiry.  Methods for this operation include: - IsEmpty method - method to check whether the container is empty or not, - Contain method - method to check whether the specified key is in the container or not, - GetSize method - method to get the container size (number of key-value pairs stored), - GetRangeSize method - method to get the number of key-value pairs in the specified range, and - GetRank method - method to get the number of keys in the tree strictly less than the given key. (5) Iteration.  Methods for this operation include: - StartFirst method - method to start a forward iteration over key-value pairs, - MoveForward method - method to move forward to the next key-value pair, - StartLast method - method to start a backward iteration over key-value pairs, and - MoveBackward method - method to move backward to the next key-value pair. Uses MClass_TreeInteger4B MClass_TreeCharacter MClass_TreeInteger2B MClass_TreeInteger1B MClass_TreeRealSP MClass_TreeComparable MClass_TreeInteger8B MClass_TreeRealQP MClass_TreeRealDP","tags":"","loc":"module\\mbase_balancedtrees.html"},{"title":"MClass_PQMinMax – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQMinMax type and its related routines.  The PQMinMax type is\n  a collection type that employs an elementary implementation (where its array representation\n  is ordered using a sorting algorithm) to provide common operations for a priority queue.\n  The PQMinMax type is a generalized priority queue that offers combined operations of a\n  max-priority queue and a min-priority queue. The PQMinMax type employs the KeyOrdered type to store comparable keys where allowed key\n  types include the CHARACTER , INTEGER and REAL intrinsic types as well as any derived\n  type that is in the Comparable class.  Like other collection types, it must be employed to\n  store keys of only one particular data type.  To store keys of another data type, it must be\n  destructed before inserting keys of different data type. As an ordered collection type, the PQMinMax type provides an ordered iteration over its\n  stored keys, which are sorted according to the natural ordering of its keys.  The StartMin method (or the StartMax method) must first be called to start an iteration for an ascending\n  order (or for an descending order).  The MoveUp method (or the MoveDown method) can then\n  be called repeatedly to move to the next keys with lower priorities in the desired order. Uses MClass_CompNodePool MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MClass_KeyOrdered MBase_ByteUtil MClass_Comparable MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_Object Derived Types type, public, extends( BaseCollection ) :: PQMinMax The PQMinMax type is a collection type that employs an ordered array implementation\n to provide common operations for a generalized priority queue. Finalizations Procedures final :: PQMinMax_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: CopyCollection => PQMinMax_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => PQMinMax_Clear Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => PQMinMax_Destruct Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() Note :  This method is NOT equivalent to the Clear method. procedure, public :: GetSize => PQMinMax_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: CreateEmpty => PQMinMax_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                         ! use default options --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options generic, public :: Construct => CopyCollection , PQMinMax_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL Collection%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Insert => PQMinMax_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL Collection%Insert(Key) procedure, public :: RemoveMin => PQMinMax_RemoveMinKey Type-Bound Function : RemoveMin Purpose :  To retrieve and remove the minimum key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%RemoveMin(MinKey) --->    IF (.NOT.Collection%RemoveMin(MinKey)) DoSomething procedure, public :: RemoveMax => PQMinMax_RemoveMaxKey Type-Bound Function : RemoveMax Purpose :  To retrieve and remove the maximum key from the priority queue.  Also,\n      return a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%RemoveMax(MaxKey) --->    IF (.NOT.Collection%RemoveMax(MaxKey)) DoSomething procedure, public :: PeekMin => PQMinMax_PeekMinKey Type-Bound Function : PeekMin Purpose :  To retrieve the minimum key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%PeekMin(MinKey) --->    IF (.NOT.Collection%PeekMin(MinKey)) DoSomething procedure, public :: PeekMax => PQMinMax_PeekMaxKey Type-Bound Function : PeekMax Purpose :  To retrieve the maximum key from the priority queue.  Also, return\n      a flag indicating whether the key is successfully removed or not. Usage : --->    Flag = Collection%PeekMax(MaxKey) --->    IF (.NOT.Collection%PeekMax(MaxKey)) DoSomething procedure, public :: ToArray => PQMinMax_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items, IsDescend=.TRUE.)) DoSomething procedure, public :: GetAll => PQMinMax_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are available. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items, IsDescend=.TRUE.)) DoSomething procedure, public :: StartMin => PQMinMax_Move2MinKey Type-Bound Function : StartMin Purpose :  To start the ascending iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartMin() --->    IsEmpty = Collection%StartMin(MinKey) procedure, public :: StartMax => PQMinMax_Move2MaxKey Type-Bound Function : StartMax Purpose :  To start the descending iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartMax() --->    IsEmpty = Collection%StartMax(MaxKey) procedure, public :: MoveUp => PQMinMax_MoveUpNext Type-Bound Function : MoveUp Purpose :  To move to the next iteration in ascending order and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : --->    IsTheEnd = Collection%MoveUp() --->    IsTheEnd = Collection%MoveUp(NextKey) procedure, public :: MoveDown => PQMinMax_MoveDownNext Type-Bound Function : MoveDown Purpose :  To move to the next iteration in descending order and return a flag\n               indicating whether the cursor pointer has reached the end of the\n               collection or not. Usage : --->    IsTheEnd = Collection%MoveDown() --->    IsTheEnd = Collection%MoveDown(NextKey) procedure, public :: Copy => PQMinMax_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => PQMinMax_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => PQMinMax_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => PQMinMax_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => PQMinMax_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_pqminmax.html"},{"title":"MClass_ListRealSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListRealSP type and related routines.\n  The ListRealSP type is a container with REAL(KIND=kSingle) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListRealSP type but utilizes a different implementation.\n  Also, unlike the ListRealSP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListRealSP ListRealSP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kSingle) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listrealsp.html"},{"title":"MClass_ListCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListCharacter type and related routines.\n  The ListCharacter type is a container with CHARACTER as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListCharacter type but utilizes a different implementation.\n  Also, unlike the ListCharacter type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListCharacter ListCharacter is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is CHARACTER . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listcharacter.html"},{"title":"MClass_PQRealSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQRealSP type and its related routines.\n  The PQRealSP type is a priority-queue container with REAL(KIND=kSingle) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQRealSP type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true  o that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQRealSP The PQRealSP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqrealsp.html"},{"title":"MClass_TreeSet – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeSet type and its supporting routines and data type.\n  The TreeSet type is a collection type that employs a balanced binary-search-tree\n  (BST) implementation to provide common operations for an ordered set.  Like any other\n  set collection types, the TreeSet type does not allow duplicated items. The TreeSet type uses the KeyOrdered type to store comparable items where allowed\n  item types include the CHARACTER , INTEGER and REAL intrinsic types as well as any\n  derived type that is in the Comparable class.  Like other collection types, it must\n  be employed to store items of only one particular data type.  To store items of another\n  data type, it must be destructed before inserting items of different data type. As an ordered set, the TreeSet type provides an ordered iteration over its stored\n  items, which are sorted according to the natural ordering of its items.  It can be\n  accessed and traversed in either ascending (using the StartFirst method) or descending\n  (using the StartLast method) order. Technically, the TreeSet type employs a balanced search tree implementation to provide\n  common operations for an ordered set.  The TreeSet type utilizes the IntrusiveRBTree type as its component to store its tree nodes.  As an intrusive BST container, the IntrusiveRBTree type provides common binary-search-tree operations without a memory\n  management task.  The memory management task of the inserted tree nodes is handled by\n  the TreeSet type. Uses MClass_CompNodePool MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MClass_KeyOrdered MBase_ByteUtil MClass_Comparable MClass_BaseCollection MClass_GenData MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_IntrusiveBSTrees MClass_Object Derived Types type, public, extends( BaseIterable ) :: TreeSet The TreeSet type is a collection type that utilizes a balanced BST implementation\n to provide common operations for an ordered set.  The TreeSet type employs the IntrusiveRBTree type as its component to store SetNode objects.  As an intrusive\n BST container, the IntrusiveRBTree type provides common binary-search-tree operations\n without a memory management task.  The memory management task of the inserted SetNode objects is handled by the TreeSet type. The TreeSet type is a subtype of the BaseIterable type.  Thus, it implements all\n deferred procedures required by the BaseIterable type and all its super classes.  As\n a set container, the TreeSet type does not allow duplicated items.  Also, the TreeSet type, as an ordered set, provides an ordered iteration over its stored items, which are\n sorted according to the natural ordering of its items.  It can be traversed in either\n ascending or descending order. Because the IntrusiveRBTree type is a subtype of the IntrusiveAVLTree type, the WrkTree component can be employed as a red-black tree or an AVL tree.  Therefore, the TreeSet type allows a user to specify which type of binary-search tree implementation\n to be used.  By default, the red-black tree implementation is used.  The user can call the UseAVLTree method to change to AVL tree implementation.  The UseAVLTree method must\n be called before inserting an object into the set (i.e when the set is empty).  Otherwise,\n the red-black tree implementation is employed. Finalizations Procedures final :: TreeSet_Finalize To perform finalization of the hash set. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => TreeSet_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => TreeSet_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => TreeSet_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => TreeSet_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => TreeSet_Move2FirstItem Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => TreeSet_Move2NextItem Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: StartLast => TreeSet_Move2LastItem Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order and return a flag\n               indicating whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartLast() --->    IsEmpty = Collection%StartLast(LastItem) procedure, public :: MoveBackward => TreeSet_Move2PrevItem Type-Bound Function : MoveBackward Purpose :  To move to the previous item and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveBackward() --->    IsTheEnd = Collection%MoveBackward(PrevItem) procedure, public :: Insert => TreeSet_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified item to the collection. Usage : --->    CALL Collection%Insert(Item) procedure, public :: Delete => TreeSet_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => TreeSet_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n      indicating whether the items are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => TreeSet_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are successfully retrieved or not. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething generic, public :: Construct => CopyCollection , TreeSet_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Contain => TreeSet_Contain Type-Bound Function : Contain Purpose :  To find the specified item in the collection.  Return true if\n               the specified item is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Item) --->    IF (.NOT.Collection%Contain(Item)) DoSomething procedure, public :: Remove => TreeSet_Remove Type-Bound Function : Remove Purpose :  To remove the specified item from the collection.  Also, return a flag\n               indicating whether the item is successfully removed or not. Usage : --->    Flag = Collection%Remove(Item) --->    IF (.NOT.Collection%Remove(Item)) DoSomething procedure, public :: UseAVLTree => TreeSet_UseAVLTree Type-Bound Subroutine : UseAVLTree Purpose :  To set the working tree component to work as an AVL tree. Usage : --->    CALL Collection%UseAVLTree() Note : The collection must be empty when calling this method. procedure, public :: UseRBTree => TreeSet_UseRBTree Type-Bound Subroutine : UseRBTree Purpose :  To set the working tree component to work as an red-black RB tree. Usage : --->    CALL Collection%UseRBTree() Note : The collection must be empty when calling this method. procedure, public :: Copy => TreeSet_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => TreeSet_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => TreeSet_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => TreeSet_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => TreeSet_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_treeset.html"},{"title":"MClass_PQCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQCharacter type and its related routines.\n  The PQCharacter type is a priority-queue container with CHARACTER as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQCharacter type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQCharacter The PQCharacter type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL PQ%CreateEmpty(CharLen, InitCap)            ! use default options --->    CALL PQ%CreateEmpty(72, 32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL PQ%CreateEmpty(72, 32, IncSize=16)          ! specify incremental size --->    CALL PQ%CreateEmpty(72, 32, Shrink=.TRUE.)       ! specify shrinking --->    CALL PQ%CreateEmpty(72, 32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqcharacter.html"},{"title":"MClass_HTabRealQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabRealQP type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabRealQP type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabRealQP type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabRealQP type uses the Fortran intrinsic REAL(KIND=kQuad) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabRealQP type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabRealQP type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabRealQP The HTabRealQP type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabrealqp.html"},{"title":"MClass_ListInteger8B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListInteger8B type and related routines.\n  The ListInteger8B type is a container with INTEGER(KIND=kI8B) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListInteger8B type but utilizes a different implementation.\n  Also, unlike the ListInteger8B type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListInteger8B ListInteger8B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt64) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listinteger8b.html"},{"title":"MClass_HashList – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HashList type and its supporting routines and data type.\n  The HashList type is a collection type that employs a separate-chaining hash table\n  implementation to provide common operations for an unordered symbol table. The HashList type uses the KeyUnordered type to store its keys and the GenData type to store its values.  Therefore, it can be used to store key-value pairs of any\n  data types (except the LOGICAL type for the keys).  Like other collection types,\n  however, it must be employed to store key-value pairs of only specific key type and\n  one specific value type.  To store key-value pairs of another key type (or another\n  value type), it must be destructed before inserting items of different key type (or\n  different value type). As a symbol table, the HashList type does not allow duplicated keys.  Therefore, if\n  an inserted key is equal to a key stored in the table, an associated value of the stored\n  key is replaced by an associated value of the inserted key.  As an unordered symbol\n  table, the HashList type makes no guarantees as to the iteration order of the table.\n  In particular, it does not guarantee that the order will remain the same over time. Technically, the HashList type utilizes the IntrusiveHashList type as its component\n  to store its hash-list nodes.  As an intrusive container, the IntrusiveHashList type,\n  which is based on a separate-chaining hash table implementation, provides common hash-table\n  operations without a memory management task.  The memory management task of the inserted\n  hash-list nodes is handled by the HashList type. Uses MClass_BaseNodePool MBase_MemHandlers MClass_IntrusiveHashList MClass_CharBuffer MBase_ErrHandlers MBase_ByteUtil MClass_BaseSymTable MClass_BaseCollection MClass_GenData MClass_KeyUnordered MBase_Common MBase_SimpleHash64 MClass_MemoryPool MBase_SIntUtil MClass_IntrusiveLinkedLists MClass_Object Derived Types type, public, extends( BaseSymTable ) :: HashList The HashList type is a collection type that employs a separate-chaining hash table\n implementation to provide common operations for an unordered symbol table.  The HashList type utilizes the IntrusiveHashList type as its component to store TabNode objects.\n As an intrusive container, the IntrusiveHashList type provides common operations for\n hash table without a memory management task.  The memory management task of the inserted TabNode objects is handled by the HashList type. As an unordered symbol table, the HashList type directly extends the BaseSymTable type and implements all deferred procedures required by the BaseSymTable type and all\n its super classes.  As a symbol table, the HashList type does not allow duplicated keys;\n therefore, if an inserted key is equal to a key stored in the table, an associated value\n of the stored key is replaced by an associated value of the inserted key. Finalizations Procedures final :: HashList_Finalize To perform finalization of the object. Type-Bound Procedures procedure, public :: IsEmpty => BaseCollection_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: Clear => BaseSymTable_ClearEntries Type-Bound Subroutine : Clear Purpose :  To remove all key-value pairs from the collection. Usage : --->    CALL Collection%Clear() Note : The Clear method provided by the BaseSymTable type is\n      a simple implementation.   It can be overridden by a better and\n      more efficient implementation. procedure, public :: GetKeyPtr => BaseSymTable_GetKeyPtr Type-Bound Function : GetKeyPtr Purpose :  To get a pointer to a key stored in a symbol table.  The pointer is\n      intended to be used as a mold for the key (i.e. to provide type of the stored\n      keys).  Return null pointer if the table is empty. Usage : --->    KeyPtr => Collection%GetKeyPtr() procedure, public :: GetValPtr => BaseSymTable_GetValPtr Type-Bound Function : GetValPtr Purpose :  To get a pointer to a value stored in a symbol table.  The pointer is\n      intended to be used as a mold for the value (i.e. to provide type of the stored\n      values).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetValPtr() procedure, public :: SetMolds => BaseSymTable_SetMolds SetMolds is a procedure to set molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: FreeMolds => BaseSymTable_FreeMolds SetMolds is a procedure to free molds of stored keys and values.  This procedure is\n  intended to be used only by a subtype of the BaseSymTable type, not by a user. procedure, public :: IsKeyValid => BaseSymTable_IsKeyValid IsKeyOrdered is a procedure to check whether the specified key is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: IsValValid => BaseSymTable_IsValValid IsValOrdered is a procedure to check whether the specified value is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseSymTable type, not by\n  a user. procedure, public :: CopyCollection => HashList_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Destruct => HashList_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => HashList_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: StartFirst => HashList_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstKey) --->    IsEmpty = Collection%StartFirst(Value=FirstVal) --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashList_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextKey) --->    IsTheEnd = Collection%MoveForward(Value=NextVal) --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) procedure, public :: Insert => HashList_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the collection. Usage : --->    CALL Collection%Insert(Key, Value) procedure, public :: Delete => HashList_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current key-value pair from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to\n one of those methods and then calling this one will result in a removal\n of the current pair data of the iteration (i.e. the same key-value pair\n that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Remove => HashList_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from\n               the collection.  Also, return a flag indicating whether the\n               key-value pair is successfully removed or not. Usage : --->    Flag = Collection%Remove(Key) --->    IF (.NOT.Collection%Remove(Key)) DoSomething procedure, public :: Contain => HashList_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the collection.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Key) --->    IF (.NOT.Collection%Contain(Key)) DoSomething procedure, public :: GetValue => HashList_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the collection.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Collection%GetValue(Key, Value) --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething procedure, public :: ToArray => HashList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all key-value pairs from the collection.  Also, return\n      a flag indicating whether the pairs are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Keys, Values) --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething procedure, public :: GetAll => HashList_GetAll Type-Bound Function : GetAll Purpose :  To get all keys and/or all values (without removing them) from the collection.\n      Also, return a flag indicating whether the keys and/or the values are successfully\n      retrieved or not. Usage : --->    Success = Collection%GetAll(Keys, Values) --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething procedure, public :: CreateEmpty => HashList_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()            ! use default options --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity generic, public :: Construct => CopyCollection , HashList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Copy => HashList_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => HashList_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => HashList_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => HashList_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => HashList_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_hashlist.html"},{"title":"MClass_HTabInteger8B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HTabInteger8B type, the TabItem type and their\n  related routines.  The TabItem type is a helper and private type used to\n  store a key-value pair.  The HTabInteger8B type is a container type that\n  employs an open-addressing hash table implementation to provide common\n  operations for an unordered symbol table. Unlike the list-based and tree-based types, which can be used instantly\n  by inserting objects into a container, the HTabInteger8B type requires an\n  explicit construction before using other provided operations.  There are two\n  methods provided to create the container.  The CreateEmpty method constructs\n  an empty table with optional multiple arguments (including an initial capacity,\n  a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of a key) whereas the Construct method constructs a table from\n  arrays of keys and values. As an unordered symbol table, the HTabInteger8B type uses the Fortran intrinsic INTEGER(KIND=kInt64) type as the type of its stored keys and an unlimited polymorphic type\n  as the type of its stored values.  As a symbol table, the HTabInteger8B type\n  does not allow duplicated keys.  Therefore, if an inserted key is equal to a key\n  stored in the table, an associated value of the stored key is replaced by an\n  associated value of the inserted key. Technically, the HTabInteger8B type employs the open-addressing as a collision\n  resolution technique where the hash resolution is performed through probing.  It\n  provides three probing algorithms: linear probing, quadratic probing and double\n  hashing.  By default, the linear probing algorithm is used.  However, a user can\n  specify other probing algorithm during the construction of the table. Uses MBase_DoublyLinkedLists MBase_ErrHandlers MBase_SimpleHash32 MBase_MathUtil MBase_Common MBase_SIntUtil iso_c_binding Derived Types type, public :: HTabInteger8B The HTabInteger8B type is a container type that employs an open-addressing hash\n table implementation to provide common operations for an unordered symbol table. Finalizations Procedures final :: HashTable_Finalize To perform finalization of the hash table. Type-Bound Procedures procedure, public :: CreateEmpty => HashTable_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                           ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options Note : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. procedure, public :: Construct => HashTable_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a hash table from the specified key and value arrays. Usage : ! use default options --->    CALL Table%Construct(40, KeyArr, ValArr) ! specify all options (initial capacity is twice of the size of the given arrays) --->    CALL Table%Construct(20, KeyArr, ValArr, LoadFactor, ProbAlgo, HashFunc) procedure, public :: Clear => HashTable_ClearItems Type-Bound Subroutine : Clear Purpose :  To free components of the items from the table. Usage : --->    CALL Table%Clear() procedure, public :: Destruct => HashTable_Destroy Type-Bound Subroutine : Destruct Purpose :  To free all memory currently used by the table. Usage : --->    CALL Table%Destruct() Note :  This method is NOT equivalent to the Clear method.  After the Clear method\n      is called, other methods (the Insert method in particular) can be immediately used.\n      However, after the Destruct method is called, the Construct method must be called\n      again before other methods can be used. procedure, public :: Insert => HashTable_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the table. Usage : --->    CALL Table%Insert(Key, Value) procedure, public :: Remove => HashTable_Remove Type-Bound Function : Remove Purpose :  To remove the specified key (and its associated value) from the table.\n               Also, return a flag indicating whether the key-value pair is successfully\n               removed or not.  Optionally, retrieve the associated value if the key\n               exists in the table. Usage : --->    Flag = Table%Remove(Key, Value) --->    IF (.NOT.Table%Remove(Key)) DoSomething procedure, public :: StartFirst => HashTable_Move2FirstPair Type-Bound Function : StartFirst Purpose :  To start an iteration and return a flag indicating whether\n               the table is empty or not. Usage : --->    IsEmpty = Table%StartFirst() --->    IsEmpty = Table%StartFirst(FirstKey) --->    IsEmpty = Table%StartFirst(Value=FirstVal) --->    IsEmpty = Table%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => HashTable_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag\n               indicating whether the cursor pointer has reached the end of\n               the table or not. Usage : --->    IsTheEnd = Table%MoveForward() --->    IsTheEnd = Table%MoveForward(NextKey) --->    IsTheEnd = Table%MoveForward(Value=NextVal) --->    IsTheEnd = Table%MoveForward(NextKey, NextVal) Important Note : After the start of the current iteration (i.e. a call to the StartFirst method),\n  a user should not insert or remove any key-value pair.  Otherwise, the MoveForward method is not valid for the current iteration and the user must re-start the iteration\n  in order to use the MoveForward method. procedure, public :: IsEmpty => HashTable_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the table is empty or not. Usage : --->    Flag = Table%IsEmpty() --->    IF (.NOT.Table%IsEmpty()) DoSomeThing procedure, public :: GetSize => HashTable_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of keys and their associated values) of the table. Usage : --->    Size = Table%GetSize() procedure, public :: Contain => HashTable_Contain Type-Bound Function : Contain Purpose :  To find the specified key in the table.  Return true if\n               the specified key is found.  Otherwise, return false. Usage : --->    Flag = Table%Contain(Key) --->    IF (.NOT.Table%Contain(Key)) DoSomething procedure, public :: GetValue => HashTable_GetValue Type-Bound Function : GetValue Purpose :  To get a value associated with the specified key in the table.\n               Also, return a flag indicating whether the key-value pair is\n               successfully found or not. Usage : --->    Flag = Table%GetValue(Key, Value) --->    IF (.NOT.Table%GetValue(Key, Value)) DoSomething procedure, public :: GetKeys => HashTable_GetAllKeys Type-Bound Subroutine : GetKeys Purpose :  To return a queue of all keys and optionally a queue of all associated values. Usage : --->    CALL Tree%GetKeys(KeyQueue) --->    CALL Tree%GetKeys(KeyQueue, ValueQueue)","tags":"","loc":"module\\mclass_htabinteger8b.html"},{"title":"MClass_DArrInteger4B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrInteger4B type and related routines.\n  The DArrInteger4B type is a container with INTEGER(KIND=kInt32) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrInteger4B type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrInteger4B DArrInteger4B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt32) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger4B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrinteger4b.html"},{"title":"MClass_ListInteger2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListInteger2B type and related routines.\n  The ListInteger2B type is a container with INTEGER(KIND=kI2B) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListInteger2B type but utilizes a different implementation.\n  Also, unlike the ListInteger2B type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListInteger2B ListInteger2B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt16) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listinteger2b.html"},{"title":"MClass_TreeInteger4B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeInteger4B type and its related helper type and routines.\n  The TreeInteger4B type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeInteger4B type uses the Fortran intrinsic INTEGER(KIND=kInt32) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeInteger4B type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeInteger4B type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeInteger4B type but utilizes\n  a different implementation.  Also, unlike the TreeInteger4B type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeInteger4B TreeInteger4B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treeinteger4b.html"},{"title":"MClass_DArrCmpxSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrCmpxSP type and related routines.\n  The DArrCmpxSP type is a container with COMPLEX(KIND=kSingle) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrCmpxSP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrCmpxSP DArrCmpxSP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kSingle) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxSP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrcmpxsp.html"},{"title":"MClass_ListCmpxSP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListCmpxSP type and related routines.\n  The ListCmpxSP type is a container with COMPLEX(KIND=kSingle) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListCmpxSP type but utilizes a different implementation.\n  Also, unlike the ListCmpxSP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListCmpxSP ListCmpxSP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kSingle) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listcmpxsp.html"},{"title":"MClass_ListInteger4B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListInteger4B type and related routines.\n  The ListInteger4B type is a container with INTEGER(KIND=kI4B) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListInteger4B type but utilizes a different implementation.\n  Also, unlike the ListInteger4B type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListInteger4B ListInteger4B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt32) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listinteger4b.html"},{"title":"MClass_DArrCmpxQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrCmpxQP type and related routines.\n  The DArrCmpxQP type is a container with COMPLEX(KIND=kQuad) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrCmpxQP type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrCmpxQP DArrCmpxQP is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is COMPLEX(KIND=kQuad) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrCmpxQP class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrcmpxqp.html"},{"title":"MClass_ListInteger1B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListInteger1B type and related routines.\n  The ListInteger1B type is a container with INTEGER(KIND=kI1B) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListInteger1B type but utilizes a different implementation.\n  Also, unlike the ListInteger1B type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListInteger1B ListInteger1B is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt8) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listinteger1b.html"},{"title":"MClass_TreeCharacter – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeCharacter type and its related helper type and routines.\n  The TreeCharacter type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeCharacter type uses the Fortran intrinsic CHARACTER type as the type of its stored keys and an\n  unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeCharacter type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeCharacter type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeCharacter type but utilizes\n  a different implementation.  Also, unlike the TreeCharacter type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeCharacter TreeCharacter is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treecharacter.html"},{"title":"MClass_ListRealQP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ListRealQP type and related routines.\n  The ListRealQP type is a container with REAL(KIND=kQuad) as the type\n  of its stored items.  It employs a conventional doubly-linked list\n  implementation. See the MBase_DoublyLinkedLists module for an overview and usage notes of a doubly-linked-list-based type.\n  A user may use the MBase_DoublyLinkedLists module instead of using this\n  module directly. See the MClass_LinkedLists module for doubly-linked-list-based types of containers that are functionally\n  similar to the ListRealQP type but utilizes a different implementation.\n  Also, unlike the ListRealQP type, these container types are designed as\n  generic containers that can be used to store various data types providing that\n  the size (in bytes) of the data to be stored is known at compile time. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: ListRealQP ListRealQP is a container type that employs a doubly-linked list implementation to\n  provide common operations for a list container.  It can also represent other forms\n  of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is REAL(KIND=kQuad) . Finalizations Procedures final :: LinkedList_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: Construct => LinkedList_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a list from an array of items. Usage : --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items procedure, public :: Destruct => LinkedList_Destructor Type-Bound Subroutine : Destruct Purpose :  To destruct a list and get its items if requested. Usage : --->    CALL List%Destruct()    ! destruct the list Note : This method is equivalent to the Clear method. procedure, public :: AddFirst => LinkedList_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the list. Usage : --->    CALL List%AddFirst(Item) procedure, public :: AddLast => LinkedList_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the list. Usage : --->    CALL List%AddLast(Item) procedure, public :: AddAt => LinkedList_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = List%AddAt(Index, Item) --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething procedure, public :: Remove => LinkedList_Remove Type-Bound Subroutine : Remove Purpose :  To remove an item from the list.  The first item is removed\n              by default.  If specified, the last item can be removed instead. Usage : --->    CALL List%Remove()          ! remove the first item --->    CALL List%Remove(.FALSE.)   ! remove the last item --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item procedure, public :: RemoveFirst => LinkedList_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveFirst(Item) --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => LinkedList_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the list.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveLast(Item) --->    IF (.NOT.List%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => LinkedList_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the list size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = List%RemoveAt(Index, Item) --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => LinkedList_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the list. Usage : --->    CALL List%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods (or the StartLast and MoveBackward methods).  Therefore, after the call to one of those\n  methods and then calling this one will result in a removal of the\n  current item of the iteration (i.e. the same item that can be retrieved\n  via those iteration methods). procedure, public :: Clear => LinkedList_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the list. Usage : --->    CALL List%Clear() procedure, public :: ToArray => LinkedList_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the list.  Also, return a flag\n               indicating whether the items are successfully removed. Usage : --->    Success = List%ToArray(Items) --->    IF (.NOT.List%ToArray(Items)) DoSomething procedure, public :: RemoveDuplicates => LinkedList_RemoveDuplicates Type-Bound Subroutine : RemoveDuplicates Purpose :  To remove nodes with duplicated items from the list. Usage : --->    CALL List%RemoveDuplicates() procedure, public :: StartFirst => LinkedList_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => LinkedList_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move forward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list. ! start forward iteration (from the first item)\n  IsEmpty = List%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveForward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => LinkedList_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the list is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => LinkedList_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move backward to the next iteration and return a flag\n               indicating whether the cursor pointer has reached the end\n               of the list or not. Usage : The following code snippet illustrates how to typically traverse the list in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = List%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = List%MoveBackward()\n      ! check whether we reach the end of the list or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: IsEmpty => LinkedList_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the list is empty or not. Usage : --->    Flag = List%IsEmpty() --->    IF (.NOT.List%IsEmpty()) DoSomeThing procedure, public :: GetSize => LinkedList_GetSize Type-Bound Function : GetSize Purpose :  To get size of the list. Usage : --->    ListSize = List%GetSize() procedure, public :: PeekFirst => LinkedList_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the first item (without removing it from the list).\n               Also, return a flag indicating whether the item is available\n               or not. Usage : --->    Success = List%PeekFirst(Item) --->    IF (.NOT.List%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => LinkedList_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the list).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = List%PeekLast(Item) --->    IF (.NOT.List%PeekLast(Item)) DoSomething procedure, public :: PeekAt => LinkedList_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the list) at\n               the specified index where the index must be between 1 and the\n               list size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = List%PeekAt(Index, Item) --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => LinkedList_GetAllItems Type-Bound Subroutine : GetAll Purpose :  To get all items (without removing them) from the list. Also,\n               return a flag indicating whether the item is available or not. Usage : --->    Flag = List%GetAll(Items) --->    IF (.NOT.List%GetAll(Items)) DoSomething procedure, public :: EnQueue => LinkedList_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => LinkedList_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => LinkedList_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => LinkedList_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => LinkedList_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_listrealqp.html"},{"title":"MClass_TreeInteger2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the TreeInteger2B type and its related helper type and routines.\n  The TreeInteger2B type is a container type representing an ordered symbol table, which\n  is a container that associates a value with a key where keys are stored in a sorted\n  order.  It employs a balanced binary-search-tree (BST) implementation to provide common\n  operations for an ordered symbol table.  As an ordered symbol table, the TreeInteger2B type uses the Fortran intrinsic INTEGER(KIND=kInt16) type as the type of its stored keys\n  and an unlimited polymorphic type as the type of its stored values. As a symbol table, the TreeInteger2B type does not allow duplicated keys.  Therefore,\n  if an inserted key is equal to a key stored in the table, an associated value of the\n  stored key is replaced by an associated value of the inserted key.  Technically, the TreeInteger2B type employs a left-leaning red-black (RB) tree as the balanced BST. See the MBase_BalancedTrees module\n  for an overview of a balanced-tree-based type.  A user may use the MBase_BalancedTrees module instead of using this module directly. See the MClass_TreeTable module for a balanced\n  tree container type that is functionally similar to the TreeInteger2B type but utilizes\n  a different implementation.  Also, unlike the TreeInteger2B type, the TreeTable type\n  is designed as a generic ordered symbol table that allows keys with various types to be\n  inserted into the table. Uses MBase_MemHandlers MBase_DoublyLinkedLists MBase_ErrHandlers MBase_Common MBase_SIntUtil MClass_Object Derived Types type, public :: TreeInteger2B TreeInteger2B is a container type that employs a left-leaning red-black (RB) tree\n  implementation to provide common operations for an ordered symbol table. Finalizations Procedures final :: BSTree_Finalizer To perform finalization of the tree. Type-Bound Procedures procedure, public :: Construct => BSTree_ConstructByArray Type-Bound Subroutine : Construct Purpose :  To construct a tree from arrays of keys and values. Usage : --->    CALL Tree%Construct(10, KeyArr, ValArr) generic, public :: Destruct => BSTree_Destructor_I, BSTree_Destructor_II Type-Bound Subroutine : Destruct Purpose :  To remove all key-value pairs from the tree and optionally to\n               retrieve stored keys and values. Usage : --->    CALL Tree%Destruct() --->    CALL Tree%Destruct(KeyQueue, ValQueue) procedure, public :: Insert => BSTree_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified key-value pair to the tree. Usage : --->    CALL Tree%Insert(Key, Value) procedure, public :: Remove => BSTree_Remove Type-Bound Subroutine : Remove Purpose :  To remove the specified key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the associated value of the specified key can be retrieved. Usage : --->    Flag = Tree%Remove(Key) --->    IF (.NOT.Tree%Remove(Key, Value)) DoSomething procedure, public :: RemoveMin => BSTree_RemoveMin Type-Bound Subroutine : RemoveMin Purpose :  To remove the smallest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the smallest key and/or its associated value can be retrieved. Usage : --->    Flag = Tree%RemoveMin() --->    Flag = Tree%RemoveMin(Key) --->    IF (.NOT.Tree%RemoveMin(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMin(Key, Value)) DoSomething procedure, public :: RemoveMax => BSTree_RemoveMax Type-Bound Subroutine : RemoveMax Purpose :  To remove the largest key (and its associated value) from the tree\n      and return a flag indicating whether the key-value pair is successfully removed\n      or not.  Optionally, the largest key and/or its associated valuecan be retrieved. Usage : --->    Flag = Tree%RemoveMax() --->    Flag = Tree%RemoveMax(Key) --->    IF (.NOT.Tree%RemoveMax(Value=Value)) DoSomething --->    IF (.NOT.Tree%RemoveMax(Key, Value)) DoSomething procedure, public :: StartFirst => BSTree_Move2First Type-Bound Function : StartFirst Purpose :  To start an iteration (at a node with the smallest key) and return a flag\n               indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartFirst() --->    IsEmpty = Tree%StartFirst(FirstKey) --->    IsEmpty = Tree%StartFirst(Value=FirstVal) --->    IsEmpty = Tree%StartFirst(FirstKey, FirstVal) procedure, public :: MoveForward => BSTree_Move2NextPair Type-Bound Function : MoveForward Purpose :  To move to the next key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveForward() --->    IsTheEnd = Tree%MoveForward(NextKey) --->    IsTheEnd = Tree%MoveForward(Value=NextVal) --->    IsTheEnd = Tree%MoveForward(NextKey, NextVal) procedure, public :: StartLast => BSTree_Move2Last Type-Bound Function : StartLast Purpose :  To start an iteration in a reversed order (at a node with the largest key)\n               and return a flag indicating whether the tree is empty or not. Usage : --->    IsEmpty = Tree%StartLast() --->    IsEmpty = Tree%StartLast(LastKey) --->    IsEmpty = Tree%StartLast(Value=LastVal) --->    IsEmpty = Tree%StartLast(LastKey, LastVal) procedure, public :: MoveBackward => BSTree_Move2PrevPair Type-Bound Function : MoveBackward Purpose :  To move to the previous key-value pair and return a flag indicating whether\n               the cursor pointer has reached the end of the tree or not. Usage : --->    IsTheEnd = Tree%MoveBackward() --->    IsTheEnd = Tree%MoveBackward(PrevKey) --->    IsTheEnd = Tree%MoveBackward(Value=PrevVal) --->    IsTheEnd = Tree%MoveBackward(PrevKey, PrevVal) procedure, public :: IsEmpty => BSTree_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the three is empty or not. Usage : --->    Flag = Tree%IsEmpty() --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing procedure, public :: Contain => BSTree_FindKey Type-Bound Function : Contain Purpose :  To find the specified key in the tree.  Return true if the specified key\n               is found.  Otherwise, return false. Usage : --->    Flag = Tree%Contain(Key) --->    IF (.NOT.Tree%Contain(Key)) DoSomething procedure, public :: GetSize => BSTree_GetSize Type-Bound Function : GetSize Purpose :  To get size of the tree (the number of key-value pair stored in the tree). Usage : --->    TreeSize = Tree%GetSize() procedure, public :: GetRangeSize => BSTree_GetSize_Range Type-Bound Function : GetRangeSize Purpose :  To return the number of keys between KeyLo (inclusive)\n               and KeyHi (inclusive). Usage : --->    RangeSize = Tree%GetRangeSize(KeyLo, KeyHi) procedure, public :: GetValue => BSTree_GetValue Type-Bound Function : GetValue Purpose :  To get the value associated with the specified key in the tree.  Also, return\n               a flag indicating whether the key-value pair is successfully found or not. Usage : --->    Flag = Tree%GetValue(Key, Value) --->    IF (.NOT.Tree%GetValue(Key, Value)) DoSomething procedure, public :: GetMinKey => BSTree_GetSmallestKey Type-Bound Function : GetMinKey Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMinKey(Key) --->    IF (.NOT.Tree%GetMinKey(Key, Value)) DoSomething procedure, public :: GetMaxKey => BSTree_GetLargestKey Type-Bound Function : GetMaxKey Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree.  Also, return a flag indicating whether the key is successfully retrieved\n               or not.  If the tree is not empty, the returned flag is always true. Usage : --->    Flag = Tree%GetMaxKey(Key) --->    IF (.NOT.Tree%GetMaxKey(Key, Value)) DoSomething generic, public :: GetKeys => BSTree_GetKeys_Range, BSTree_GetKeys_All Type-Bound Subroutine : GetKeys Purpose :  To return all keys (in the tree or in the specified range) and\n               optionally all associated values. Usage : ! return all keys in the tree --->    CALL Tree%GetKeys(Keys) --->    CALL Tree%GetKeys(Keys, Values) ! return all keys in the specified range --->    CALL Tree%GetKeys(LoKey, HiKey, Keys) --->    CALL Tree%GetKeys(LoKey, HiKey, Keys, Values) procedure, public :: Floor => BSTree_Floor Type-Bound Function : Floor Purpose :  To get the largest key (and optionally a value associated with it) in the\n               tree less than or equal to the given key.  Also, return a flag indicating\n               whether the floor key is successfully retrieved or not. Usage : --->    Flag = Tree%Floor(KeyIn, KeyOut) --->    IF (.NOT.Tree%Floor(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Ceiling => BSTree_Ceiling Type-Bound Function : Ceiling Purpose :  To get the smallest key (and optionally a value associated with it) in the\n               tree greater than or equal to the given key.  Also, return a flag indicating\n               whether the ceiling key is successfully retrieved or not. Usage : --->    Flag = Tree%Ceiling(KeyIn, KeyOut) --->    IF (.NOT.Tree%Ceiling(KeyIn, KeyOut, Value)) DoSomething procedure, public :: Select => BSTree_Select Type-Bound Subroutine : Select Purpose :  To get the key (and optionally its associated value) of the specified rank\n               where the applicable range of rank is between 0 and TableSize-1. Also, return\n               a flag indicating whether the ranked key is successfully retrieved or not. --->    Flag = Tree%Select(Rank, Key) --->    IF (.NOT.Tree%Select(Rank, Key, Value)) DoSomething procedure, public :: GetRank => BSTree_Rank Type-Bound Function : GetRank Purpose :  To return the number of keys in the tree strictly less than the given key. Usage : --->    KeyRank = Tree%GetRank(Key) procedure, public :: Check => BSTree_CheckBST Type-Bound Function : Check Purpose :  To check integrity of the BST data structure. Usage : --->    Flag = Tree%Check() --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething","tags":"","loc":"module\\mclass_treeinteger2b.html"},{"title":"MClass_HashSet – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the HashSet type and its supporting routines and data type.\n  The HashSet type is a collection type that employs an open-addressing hash table\n  implementation to provide common operations for an unordered set.  Like any other\n  set collection types, the HashSet type does not allow duplicated items. The HashSet type requires an explicit construction before using other provided\n  operations.  There are two methods provided to create a collection.  The CreateEmpty method constructs an empty set with optional multiple arguments (including an initial\n  capacity, a load factor, a probing algorithm, and a hash function used to compute\n  a hash code of an item) whereas the Construct method constructs a set from an array\n  items.  As an unordered set, the HashSet type makes no guarantees as to the iteration\n  order of the set.  In particular, it does not guarantee that the order will remain\n  the same over time. The HashSet type uses the KeyUnordered type to store its set items.  Therefore, it\n  can be used to store items of any data type, except the LOGICAL type.  Like other\n  collection types, however, it must be employed to store items of only one particular\n  data type.  To store items of another data type, it must be destructed before inserting\n  items of different data type. Technically, the HashSet type employs the open-addressing as a collision resolution\n  technique where the hash resolution is performed through probing.  It provides three\n  probing algorithms: linear probing, quadratic probing and double hashing.  By default,\n  the linear probing algorithm is used.  However, a user can specify other probing\n  algorithm during the construction of the hash set. Uses MClass_BaseIterable MClass_CharBuffer MBase_ErrHandlers MBase_SimpleHash32 MBase_ByteUtil MBase_MathUtil MClass_BaseCollection MClass_GenData MClass_KeyUnordered MBase_Common MClass_MemoryPool MBase_SIntUtil MClass_Object Derived Types type, public, extends( BaseIterable ) :: HashSet The HashSet type is a collection type that employs an open-addressing hash table\n implementation to provide common operations for an unordered set.  It makes no\n guarantees as to the iteration order of the set; in particular, it does not guarantee\n that the order will remain constant over time. Finalizations Procedures final :: HashSet_Finalize To perform finalization of the hash set. Type-Bound Procedures procedure, public :: GetItemPtr => BaseIterable_GetItemPtr Type-Bound Function : GetItemPtr Purpose :  To get a pointer to an item stored in a collection.  The pointer is\n      intended to be used as a mold for the item (i.e. to provide type of the stored\n      items).  Return null pointer if the table is empty. Usage : --->    ValPtr => Collection%GetItemPtr() procedure, public :: SetMold => BaseIterable_SetMold SetMold is a procedure to set a mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: FreeMold => BaseIterable_FreeMold FreeMold is a procedure to free the mold of stored items.  This procedure is intended\n  to be used only by a subtype of the BaseIterable type, not by a user. procedure, public :: IsItemValid => BaseIterable_IsItemValid IsItemValid is a procedure to check whether the specified item is valid or not.  This\n  procedure is intended to be used only by a subtype of the BaseIterable type, not by\n  a user. procedure, public :: CopyCollection => HashSet_CopyCollection Use the Construct method to construct the collection from another collection. procedure, public :: Clear => HashSet_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the collection. Usage : --->    CALL Collection%Clear() procedure, public :: Destruct => HashSet_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the collection and free memory\n               of items stored in the collection. Usage : --->    CALL Collection%Destruct() procedure, public :: GetSize => HashSet_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the collection. Usage : --->    Size = Collection%GetSize() procedure, public :: IsEmpty => HashSet_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the collection is empty or not. Usage : --->    Flag = Collection%IsEmpty() --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing procedure, public :: StartFirst => HashSet_Move2FirstItem Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the collection is empty or not. Usage : --->    IsEmpty = Collection%StartFirst() --->    IsEmpty = Collection%StartFirst(FirstItem) procedure, public :: MoveForward => HashSet_Move2NextItem Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the collection or not. Usage : --->    IsTheEnd = Collection%MoveForward() --->    IsTheEnd = Collection%MoveForward(NextItem) Note : See the BaseIterable type\n           for illustrations of an iteration over a collection using the StartFirst and MoveForward methods. procedure, public :: Insert => HashSet_Insert Type-Bound Subroutine : Insert Purpose :  To insert the specified item to the collection. Usage : --->    CALL Collection%Insert(Item) procedure, public :: Delete => HashSet_Delete Type-Bound Subroutine : Delete Purpose :  To delete the current item from the collection. Usage : --->    CALL Collection%Delete() Note : This method is intended to be used in conjunction with the StartFirst and MoveForward methods.  Therefore, after the call to one of those methods and then\n      calling this one will result in a removal of the current item of the iteration\n      (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: ToArray => HashSet_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the collection.  Also, return a flag\n      indicating whether the items are successfully retrieved and removed or not. Usage : --->    Success = Collection%ToArray(Items) --->    IF (.NOT.Collection%ToArray(Items)) DoSomething procedure, public :: GetAll => HashSet_GetAll Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the collection. Also, return\n               a flag indicating whether the items are successfully retrieved or not. Usage : --->    Success = Collection%GetAll(Items) --->    IF (.NOT.Collection%GetAll(Items)) DoSomething procedure, public :: CreateEmpty => HashSet_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty table. Usage : --->    CALL Table%CreateEmpty()                                     ! use default options --->    CALL Table%CreateEmpty(InitCap=25)                           ! specify initial capacity --->    CALL Table%CreateEmpty(LoadFactor=0.5)                       ! specify load factor --->    CALL Table%CreateEmpty(ProbAlgo=2)                           ! specify probing algorithm --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt)           ! specify hash function --->    CALL Table%CreateEmpty(ItemCopy=CopyProc)                    ! specify copy procedure --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt, CopyProc) ! specify all options Note1 : Any suitable hash function routine from the ModBase_SimpleHash32 , ModBase_SimpleHash64 , ModBase_ReferenceHash32 , ModBase_ReferenceHash64 ModBase_OptimalHash32 , and ModBase_OptimalHash64 modules can be used to\n      specify the HashCal argument.  The term suitable means that any routine\n      that has exactly the same interface as the HashFunc abstract function\n      is the suitable one. Note2 : Depending on a type of indices defined in the ' Macro - Basic Definitions.f90 '\n      file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices\n      while a 64-bit hash-function routine is a suitable one for 64-bit integer indices.\n      This is a compile-time choice. generic, public :: Construct => CopyCollection , HashSet_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new collection from an array of items or from another\n               collection. Usage : ! create a collection from an array of 25 items --->    CALL Collection%Construct(25, Arr) ! create a collection and specify the optional arguments (see the CreateEmpy method) --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) ! create a collection from another collection --->    CALL Collection%Construct(OtherCollection) procedure, public :: Contain => HashSet_Contain Type-Bound Function : Contain Purpose :  To find the specified item in the collection.  Return true if\n               the specified item is found.  Otherwise, return false. Usage : --->    Flag = Collection%Contain(Item) --->    IF (.NOT.Collection%Contain(Item)) DoSomething procedure, public :: Remove => HashSet_Remove Type-Bound Function : Remove Purpose :  To remove the specified item from the collection.  Also, return a flag\n               indicating whether the item is successfully removed or not. Usage : --->    Flag = Collection%Remove(Item) --->    IF (.NOT.Collection%Remove(Item)) DoSomething procedure, public :: Copy => HashSet_Copy Type-Bound Subroutine : Copy Purpose : To make a copy of the source object. Usage : --->    CALL SrcObj%Copy(DstObj) procedure, public :: IsEqualTo => HashSet_IsEqualTo Type-Bound Function : IsEqualTo Purpose : To check whether two objects are equal to one another or not. Usage : --->    Flag = ObjA%IsEqualTo(ObjB) --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething procedure, public :: MemFree => HashSet_MemFree Type-Bound Subroutine : MemFree Purpose : To free memory/storage occupied by the object. Usage : --->    CALL Obj%MemFree() procedure, public :: ToString => HashSet_ToString Type-Bound Function : ToString Purpose :  To return the string representation of this object. Usage : --->    Str = Obj%ToString() procedure, public :: HashCode => HashSet_HashCode Type-Bound Function : HashCode Purpose :  To compute the hash code of this object. Usage : --->    Code = Obj%HashCode()","tags":"","loc":"module\\mclass_hashset.html"},{"title":"MBase_PriorityQueues – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module collectively contains priority-queue container types from other modules.\n It is provided so that a user can refer to this module instead of referring to several\n individual modules when various types are needed concurrently. Overview : These priority-queue container types are container types that employ a binary heap\n implementation (with the exception of the PQBasic type, which employs an elementary\n implementation) to provide common operations for a priority queue.  They can be used as\n a max-priority queue or a min-priority queue.  By default, each type represents the\n max-priority queue but a user can specify the optional MinPQ argument to true when\n constructing the container so that it can be employed as the min-priority queue instead. Each individual type can be used to store keys for a specific type of keys.   The allowed\n type of stored keys is one of Fortran intrinsic comparable types (i.e. CHARACTER, INTEGER\n and REAL) or any derived type in the Comparable class. Specifically, available priority-queue container types include: - the PQCharacter type\n   for character string key type, - the PQInteger1B type\n   for 1-byte (or 8-bit) integer key type, - the PQInteger2B type\n   for 2-byte (or 16-bit) integer key type, - the PQInteger4B type\n   for 4-byte (or 32-bit) integer key type, - the PQInteger8B type\n   for 8-byte (or 64-bit) integer key type, - the PQRealSP type\n   for single-precision real key type, - the PQRealDP type\n   for double-precision real key type, - the PQRealQP type\n   for quadruple-precision real key type, - the PQHeap type for type\n   of key in Comparable class, and - the PQBasic type for type\n   of key in Comparable class. Each priority-queue container type represents a priority queue where various common\n operations are provided and can be categorized as follows. (1) Construction and Destruction.  Methods for these operations include: - CreateEmpty method - method to construct an empty container, - Construct method - method to construct a container from an array of keys, and - Destruct method - method to destruct a container by removing all keys from\n     the container as well as free memory storage occupied by the container. (2) Insertion and Removal.  Methods for these operations include: - Insert method - method to insert a new key into a container, and - Remove method - method to remove a top-priority key from a container. (3) Retrieval.  A method for this operation is: - Peek method - method to retrieve a top-priority key from a container. (4) Inquiry.  Methods for this operation include: - IsEmpty method - method to check whether the container is empty or not, and - GetSize method - method to get the container size (number of key-value pairs stored). Uses MClass_PQCharacter MClass_PQInteger1B MClass_PQRealSP MClass_PQInteger4B MClass_PQInteger8B MClass_PQRealDP MClass_PQBasic MClass_PQInteger2B MClass_PQRealQP MClass_PQHeap","tags":"","loc":"module\\mbase_priorityqueues.html"},{"title":"MClass_DArrInteger2B – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the DArrInteger2B type and related routines.\n  The DArrInteger2B type is a container with INTEGER(KIND=kInt16) as the type\n  of its stored items.  It employs a dynamic-array implementation where\n  items are stored as a resizable array. See the MClass_DynamicArrays module for discussions about the Dynamic-Array concept and its strategy\n  used for growing and shrinking the array, which is similar to the strategy\n  employed by the DArrInteger2B type. See the MBase_DynamicArrays module for an overview and usage notes of a dynamic-array-based type.   A user\n  may use the MBase_DynamicArrays module instead of using this module directly. Uses MBase_ErrHandlers MBase_SIntUtil MBase_Common MBase_MemHandlers Derived Types type, public :: DArrInteger2B DArrInteger2B is a container type that employs a dynamic-array implementation to provide\n  common operations for a list container.  It can also represent other forms of\n  containers including a LIFO stack, a FIFO queue and a double-ended queue (deque).\n  The type of items stored in this container is INTEGER(KIND=kInt16) . Finalizations Procedures final :: DynArr_Finalizer To perform finalization of the container. Type-Bound Procedures procedure, public :: CreateEmpty => DynArr_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty container. Usage : ! create an empty container with specified initial capacity --->    CALL Container%CreateEmpty(25) ! create a container and specify the optional incremental size --->    CALL Container%CreateEmpty(25, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%CreateEmpty(25, Shrink=.TRUE.) generic, public :: Construct => DynArr_CreateByArray Type-Bound Subroutine : Construct Purpose :  To construct a new container from an array of items. Usage : ! create a container from an array of 25 items --->    CALL Container%Construct(25, Arr) ! create a container and specify the optional incremental size --->    CALL Container%Construct(25, Arr, IncSize=16) ! create a container and specify the optional shrink flag --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) procedure, public :: Destruct => DynArr_Destroy Type-Bound Subroutine : Destruct Purpose :  To remove all items from the container and free memory\n               of items stored in the container. Usage : --->    CALL Container%Destruct() Important Note :  For the DArrInteger2B class, this method is not equivalent\n  to the Clear method.  Therefore, after calling the Destruct method,\n  the user should reconstruct the container (by calling a Construction method again) before using other operations once more.  Otherwise, the\n  container's behavior may not be as expected. procedure, public :: AddFirst => DynArr_AddFirst Type-Bound Subroutine : AddFirst Purpose :  To insert the specified item at the front of the container. Usage : --->    CALL Container%AddFirst(Item) procedure, public :: AddLast => DynArr_AddLast Type-Bound Subroutine : AddLast Purpose :  To insert the specified item at the end of the container. Usage : --->    CALL Container%AddLast(Item) procedure, public :: AddAt => DynArr_AddAt Type-Bound Function : AddAt Purpose :  To insert the specified item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully added. Usage : --->    Success = Container%AddAt(Index, Item) --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething procedure, public :: RemoveFirst => DynArr_RemoveFirst Type-Bound Function : RemoveFirst Purpose :  To get and remove the front (first) item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveFirst(Item) --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething procedure, public :: RemoveLast => DynArr_RemoveLast Type-Bound Function : RemoveLast Purpose :  To get and remove the last item of the container.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveLast(Item) --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething procedure, public :: RemoveAt => DynArr_RemoveAt Type-Bound Function : RemoveAt Purpose :  To get and remove the item at the specified index where\n               the index must be between 1 and the container size.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Container%RemoveAt(Index, Item) --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething procedure, public :: Delete => DynArr_Delete Type-Bound Subroutine : Delete Purpose :  To delete an item from the container. Usage : --->    CALL Container%Delete() Note : This method is intended to be used in conjunction with\n  the StartFirst and MoveForward methods.  Therefore, after\n  the call to one of those methods and then calling this one\n  will result in a removal of the current item of the iteration\n  (i.e. the same item that can be retrieved via the StartFirst and MoveForward methods). procedure, public :: Clear => DynArr_ClearItems Type-Bound Subroutine : Clear Purpose :  To remove all items from the container. Usage : --->    CALL Container%Clear() procedure, public :: ToArray => DynArr_ToArray Type-Bound Function : ToArray Purpose :  To get and remove all items from the container.  Also, return\n               a flag indicating whether the items are successfully removed. Usage : --->    Success = Container%ToArray(Items) --->    IF (.NOT.Container%ToArray(Items)) DoSomething procedure, public :: StartFirst => DynArr_Move2FirstElm Type-Bound Function : StartFirst Purpose :  To start the forward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveForward procedure. procedure, public :: MoveForward => DynArr_Move2NextElm Type-Bound Function : MoveForward Purpose :  To move to the next iteration and return a flag indicating whether\n               the cursor pointer has reached the end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container. ! start forward iteration (from the first item)\n  IsEmpty = Container%StartFirst()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveForward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: StartLast => DynArr_Move2LastElm Type-Bound Function : StartLast Purpose :  To start the backward iteration and return a flag indicating\n               whether the container is empty or not. Usage : see MoveBackward procedure. procedure, public :: MoveBackward => DynArr_Move2PrevElm Type-Bound Function : MoveBackward Purpose :  To move to the next iteration (in reverse order) and return\n               a flag indicating whether the cursor pointer has reached the\n               end of the container or not. Usage : The following code snippet illustrates how to typically traverse the container in reverse order. ! start backward iteration (from the last item)\n  IsEmpty = Container%StartLast()\n  IF (.NOT.IsEmpty) DoSomeThing...\n  DO\n      ! move to the next iteration\n      IsTheEnd = Container%MoveBackward()\n      ! check whether we reach the end of the container or not\n      IF (IsTheEnd) EXIT\n      ! if not, do the task we need\n      DoSomeThing...\n  END DO Read more… procedure, public :: GetSize => DynArr_GetSize Type-Bound Function : GetSize Purpose :  To get the current size of the container. Usage : --->    Size = Container%GetSize() procedure, public :: IsEmpty => DynArr_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the container is empty or not. Usage : --->    Flag = Container%IsEmpty() --->    IF (.NOT.Container%IsEmpty()) DoSomeThing procedure, public :: PeekFirst => DynArr_PeekFirst Type-Bound Function : PeekFirst Purpose :  To get the front (first) item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekFirst(Item) --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething procedure, public :: PeekLast => DynArr_PeekLast Type-Bound Function : PeekLast Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekLast(Item) --->    IF (.NOT.Container%PeekLast(Item)) DoSomething procedure, public :: PeekAt => DynArr_PeekAt Type-Bound Function : PeekAt Purpose :  To get the item (without removing it from the container) at\n               the specified index where the index must be between 1 and the\n               container size.  Also, return a flag indicating whether the\n               item is available or not. Usage : --->    Success = Container%PeekAt(Index, Item) --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething procedure, public :: GetAll => DynArr_GetAll GetAll is a procedure deferred by the BaseIterable type. Type-Bound Function : GetAll Purpose :  To get all items (without removing them) from the container.\n               Also, return a flag indicating whether the items are available. Usage : --->    Success = Container%GetAll(Items) --->    IF (.NOT.Container%GetAll(Items)) DoSomething procedure, public :: EnQueue => DynArr_AddLast Type-Bound Subroutine : EnQueue Purpose :  To add a new item to the end of the queue. Usage : --->    CALL Queue%EnQueue(NewItem) Note : EnQueue is an alias of AddLast . procedure, public :: DeQueue => DynArr_RemoveFirst Type-Bound Function : DeQueue Purpose :  To get and remove the front (first) item of the queue.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Queue%DeQueue(Item) --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething Note : DeQueue is an alias of RemoveFirst . procedure, public :: Push => DynArr_AddLast Type-Bound Subroutine : Push Purpose :  To add a new item to the top of the stack. Usage : --->    CALL Stack%Push(NewItem) Note : Push is an alias of AddLast . procedure, public :: Pop => DynArr_RemoveLast Type-Bound Function : Pop Purpose :  To get and remove the top item of the stack.\n               Also, return a flag indicating whether the item is\n               successfully removed. Usage : --->    Success = Stack%Pop(Item) --->    IF (.NOT.Stack%Pop(Item)) DoSomething Note : Pop is an alias of RemoveLast . procedure, public :: PeekTop => DynArr_PeekLast Type-Bound Function : PeekTop Purpose :  To get the last item (without removing it from the container).\n               Also, return a flag indicating whether the item is available or not. Usage : --->    Success = Container%PeekTop(Item) --->    IF (.NOT.Container%PeekTop(Item)) DoSomething Note : PeekTop is an alias of PeekLast .","tags":"","loc":"module\\mclass_darrinteger2b.html"},{"title":"MClass_PQRealDP – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the PQRealDP type and its related routines.\n  The PQRealDP type is a priority-queue container with REAL(KIND=kDouble) as the type of its stored keys.  It employs a binary heap implementation\n  to order its stored keys. The PQRealDP type can represent either the max-priority queue or the\n  min-priority queue.  By default, it represents the max-priority queue but\n  a user can specify the MinPQ argument to true so that it represents\n  the min-priority queue instead. See the MBase_PriorityQueues module for an overview of a priority-queue-based type. A user may use the MBase_PriorityQueues module instead of using this module directly. Uses MBase_ErrHandlers MBase_MemHandlers MBase_Common Derived Types type, public :: PQRealDP The PQRealDP type is a container type that employs a binary heap implementation\n to provide common operations for a priority queue. Finalizations Procedures final :: PQHeap_Finalizer To perform finalization of the object. Type-Bound Procedures procedure, public :: CreateEmpty => PQHeap_CreateEmpty Type-Bound Subroutine : CreateEmpty Purpose :  To construct an empty priority queue. Usage : --->    CALL Table%CreateEmpty(InitCap)                 ! use default options --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)        ! use min-priority queue --->    CALL Table%CreateEmpty(32, IncSize=16)          ! specify incremental size --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)       ! specify shrinking --->    CALL Table%CreateEmpty(32, .TRUE., 16, .TRUE.)  ! specify all options procedure, public :: Construct => PQHeap_ConstructorByArray Type-Bound Subroutine : Construct Purpose :  To construct a priority queue from the specified key arrays. Usage : ! use default options --->    CALL PQ%Construct(40, KeyArr) ! specify all options (initial capacity is array size plus incremental size) --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) procedure, public :: Destruct => PQHeap_Destructor Type-Bound Subroutine : Destruct Purpose :  To remove all stored keys and free all memory currently used by the priority\n      queue.  Optionally, stored keys can be retrieved. Usage : --->    CALL PQ%Destruct() --->    CALL PQ%Destruct(StoredKeys) procedure, public :: Insert => PQHeap_InsertKey Type-Bound Subroutine : Insert Purpose :  To insert the specified key to the priority queue. Usage : --->    CALL PQ%Insert(Key) procedure, public :: Remove => PQHeap_RemoveKey Type-Bound Function : Remove Purpose :  To retrieve and remove the highest-priority key from the priority queue.  Also,\n      return a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Remove(Key) --->    IF (.NOT.PQ%Remove(Key)) DoSomething procedure, public :: IsEmpty => PQHeap_IsEmpty Type-Bound Function : IsEmpty Purpose :  To check whether the priority queue is empty or not. Usage : --->    Flag = PQ%IsEmpty() --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing procedure, public :: GetSize => PQHeap_GetSize Type-Bound Function : GetSize Purpose :  To get the current size (number of stored keys) of the priority queue. Usage : --->    Size = PQ%GetSize() procedure, public :: Peek => PQHeap_PeekKey Type-Bound Function : Peek Purpose :  To retrieve the highest-priority key from the priority queue.  Also, return\n      a flag indicating whether the key-value pair is successfully removed or not. Usage : --->    Flag = PQ%Peek(Key) --->    IF (.NOT.PQ%Peek(Key)) DoSomething","tags":"","loc":"module\\mclass_pqrealdp.html"},{"title":"MClass_ListTable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListTable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListTable* type and its supporting routines and data type.  The !   *ListTable* type is a collection type that employs a linked-list implementation to provide !   common operations for an unordered symbol table. <br> !   The *ListTable* type uses the *KeyUnordered* type to store its keys and the *GenData* type !   to store its values.  Therefore, it can be used to store key-value pairs of any data types !   (except the *LOGICAL* type for the keys).  Like other collection types, however, it must !   be employed to store key-value pairs of only specific key type and one specific value type. !   To store key-value pairs of another key type (or another value type), it must be destructed !   before inserting items of different key type (or different value type). <br> !   As a symbol table, the *ListTable* type does not allow duplicated keys.  Therefore, if an !   inserted key is equal to a key stored in the table, an associated value of the stored key !   is replaced by an associated value of the inserted key.  Although the *ListTable* type is !   an *unordered* symbol table, it provides an ordered iteration over its stored key-value items !   where its iteration ordering is normally the order in which keys were inserted into the table !   (i.e. insertion order). <br> !   Technically, the *ListTable* type employs a doubly-linked list implementation to provide common !   operations for an unordered symbol table.  The *ListTable* type uses the *IntrusiveLinearList* !   type as its component to store its list nodes.  The *IntrusiveLinearList* type, as an intrusive !   list container, provides common linked-list operations without a memory management task.  The !   memory management task of the inserted list nodes is handled by the *ListTable* type.  <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveLinkedLists , ONLY : DoublyLinkedNode , IntrusiveLinearList USE MClass_Object , ONLY : Object USE MClass_GenData USE MClass_BaseNodePool USE MClass_MemoryPool USE MClass_KeyUnordered USE MClass_BaseCollection USE MClass_BaseSymTable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListTable PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListTable' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *TabNode* is a doubly-linked-list node type containing key and value as its components. !   The *KeyUnordered* type is used as a storage for the key and the *GenData* type is used !   as a storage for the value.  The *TabNode* type is a subtype of the *DoublyLinkedNode* !   type and is intended to be used with the *ListTable* type, which is a collection type !   that utilizes the *IntrusiveLinearList* type. <br> TYPE , EXTENDS ( DoublyLinkedNode ) :: TabNode TYPE ( KeyUnordered ) :: Key !! stored key TYPE ( GenData ) :: Value !! stored value CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TabNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TabNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TabNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TabNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TabNode_HashCode ! --------------------------------------------------------------------- ! -----         Specific Procedure for TabNode Type               ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: SetKeyNVal <br> !  **Purpose**:  To set new key and value. <br> !  **Usage**: <br> !   --->    Valid = Node%SetKeyNVal(Key, Value, MemPool) PROCEDURE :: SetKeyNVal => TabNode_SetKeyNVal !> **Type-Bound Function**: IsKeyEqual <br> !  **Purpose**:  To check whether the specified key is equal to the node's key. <br> !  **Usage**: <br> !   --->    Flag = Node%IsKeyEqual(Key) PROCEDURE :: IsKeyEqual => TabNode_IsKeyEqual ! --------------------------------------------------------------------- END TYPE TabNode !> The *ListTable* type is a collection type that employs a linked-list implementation to !  provide common operations for an unordered symbol table.  The *ListTable* type employs !  the *IntrusiveLinearList* type as its component to store *TabNode* objects.  As an !  intrusive container, the *IntrusiveLinearList* type provides common linked-list operations !  without a memory management task.  The memory management task of the inserted *TabNode* !  objects is handled by the *ListTable* type. <br> !  As an unordered symbol table, the *ListTable* type directly extends the *BaseSymTable* !  type and implements all deferred procedures required by the *BaseSymTable* type and all !  its super classes.  As a symbol table, the *ListTable* type does not allow duplicated keys; !  therefore, if an inserted key is equal to a key stored in the table, an associated value !  of the stored key is replaced by an associated value of the inserted key. <br> TYPE , EXTENDS ( BaseSymTable ) :: ListTable PRIVATE ! a working doubly-linked list TYPE ( IntrusiveLinearList ) :: WrkLst !> memory pool of list nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => ListTable_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => ListTable_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => ListTable_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => ListTable_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: ListTable_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => ListTable_CopyCollection !> *Destruct* is a procedure deferred by the *BaseCollection* type. <br> !  **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => ListTable_Destroy !> *GetSize* is a procedure deferred by the *BaseCollection* type. <br> !  **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => ListTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => ListTable_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => ListTable_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => ListTable_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => ListTable_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => ListTable_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => ListTable_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => ListTable_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => ListTable_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => ListTable_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListTable Type             ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => ListTable_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => ListTable_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => ListTable_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => ListTable_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListTable_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => ListTable_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListTable_Finalize ! --------------------------------------------------------------------- END TYPE ListTable !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 TabNode Procedures                        ----- ! --------------------------------------------------------------------- SUBROUTINE TabNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( TabNode ) CALL SrcObj % CopyDLLNode ( DstObj ) CALL SrcObj % Key % Copy ( DstObj % Key , IsDeep ) CALL SrcObj % Value % Copy ( DstObj % Value , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TabNode_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"TabNode\" only.' ) RETURN END SELECT RETURN END SUBROUTINE TabNode_Copy !****************************************************************************** FUNCTION TabNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure by an *Object* object. <br> !  It should be noted that this routine uses all components of !  the *TabNode* object to check equality. Therefore, although !  (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) can return !  false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( TabNode ) Flag = FalseVal IF (. NOT . LhsObj % Key % IsEqualTo ( RhsObj % Key )) RETURN IF (. NOT . LhsObj % Value % IsEqualTo ( RhsObj % Value )) RETURN Flag = LhsObj % IsDLLNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabNode_IsEqualTo !****************************************************************************** SUBROUTINE TabNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free the key and value components CALL Obj % Key % MemFree () CALL Obj % Value % MemFree () ! free the pointer components CALL Obj % FreePointers () RETURN END SUBROUTINE TabNode_MemFree !****************************************************************************** FUNCTION TabNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{TabNode: {' // Obj % Key % ToString () // ' : ' // Obj % Value % ToString () // '}}' RETURN END FUNCTION TabNode_ToString !****************************************************************************** FUNCTION TabNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: AdjNode ! FLOW ! get code from previous node AdjNode => Obj % GetPrevious () SELECT TYPE ( PrevNode => AdjNode ) TYPE IS ( TabNode ) Code = PrevNode % Key % HashCode () END SELECT ! add code from this node Code = Code + Obj % Key % HashCode () ! add code from next node AdjNode => Obj % GetNext () SELECT TYPE ( NextNode => AdjNode ) TYPE IS ( TabNode ) Code = Code + NextNode % Key % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION TabNode_HashCode !****************************************************************************** SUBROUTINE TabNode_SetKeyNVal ( Node , Key , Value , Pool ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the key and value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Node !! TabNode object CLASS ( * ), INTENT ( IN ) :: Key !! the key CLASS ( * ), INTENT ( IN ) :: Value !! the associated value TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !! memory pool for both key and value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Key % Set ( Key , Pool ) CALL Node % Value % Set ( Value , Pool ) RETURN END SUBROUTINE TabNode_SetKeyNVal !****************************************************************************** FUNCTION TabNode_IsKeyEqual ( Node , Key , Pool ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is equal to the node's key. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TabNode object CLASS ( TabNode ), INTENT ( IN ) :: Node !% the key to be retrieved CLASS ( * ), INTENT ( IN ) :: Key !% memory pool TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !% true if the keys are equal; otherwise, false. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( GenData ) :: KeyInp !** FLOW: CALL KeyInp % Set ( Key , Pool ) Flag = Node % Key % IsEqualTo ( KeyInp ) CALL KeyInp % MemFree () RETURN END FUNCTION TabNode_IsKeyEqual ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- SUBROUTINE ListTable_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !  *Note*:  SrcObj must be in the *ListTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( ListTable ) CALL SrcObj % NodePool % Copy ( DstObj % NodePool , IsDeep ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) CALL SrcObj % WrkLst % CloneTo ( DstObj % WrkLst ) CLASS DEFAULT CALL Handle_ErrLevel ( 'ListTable_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE ListTable_Copy !****************************************************************************** FUNCTION ListTable_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( ListTable ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN ! implementation note:  we cannot use the iteration methods here !   due to the intent of the input data. BLOCK CLASS ( DoublyLinkedNode ), POINTER :: LhsNode , LhsNext CLASS ( DoublyLinkedNode ), POINTER :: RhsNode , RhsNext tLogical :: ReturnNow ReturnNow = FalseVal ! start iteration LhsNode => LhsObj % WrkLst % GetHead () RhsNode => RhsObj % WrkLst % GetHead () Loop : DO WHILE ( ASSOCIATED ( LhsNode ). AND . ASSOCIATED ( RhsNode )) LhsNext => LhsNode % GetNext () RhsNext => RhsNode % GetNext () ! check key and value equalities SELECT TYPE ( LhsNode ) TYPE IS ( TabNode ) SELECT TYPE ( RhsNode ) TYPE IS ( TabNode ) IF (. NOT . LhsNode % IsEqualTo ( RhsNode )) THEN ReturnNow = TrueVal EXIT Loop END IF END SELECT END SELECT ! move to the next iteration LhsNode => LhsNext RhsNode => RhsNext END DO Loop NULLIFY ( LhsNode , RhsNode ) NULLIFY ( LhsNext , RhsNext ) IF ( ReturnNow ) RETURN END BLOCK ELSE RETURN END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION ListTable_IsEqualTo !****************************************************************************** SUBROUTINE ListTable_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the ListTable object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % WrkLst % Clear () CALL Obj % NodePool % MemFree () CALL Obj % ItemPool % Destruct () CALL Obj % FreeMolds () RETURN END SUBROUTINE ListTable_MemFree !****************************************************************************** FUNCTION ListTable_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the ListTable type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr , ValStr , ItemStr CLASS ( BaseNode ), POINTER :: PoolNodes (:) ! initialize Count = 0_kIndex CALL Obj % NodePool % GetAllNodes ( PoolNodes ) CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE IF ( Nodes ( I )% Value % IsEmpty ()) CYCLE KeyStr = Nodes ( I )% Key % ToString () ValStr = Nodes ( I )% Value % ToString () ItemStr = '{' // KeyStr ( 17 : LEN ( KeyStr ) - 1 ) // ' : ' // ValStr ( 12 : LEN ( ValStr ) - 1 ) // '}' CALL ChrBuf % Append ( ItemStr ) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO END SELECT NULLIFY ( PoolNodes ) CALL ChrBuf % Append ( ']' ) BaseStr = ChrBuf % AsString () END BLOCK END IF Str = '{ListTable with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION ListTable_ToString !****************************************************************************** FUNCTION ListTable_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK CLASS ( BaseNode ), POINTER :: PoolNodes (:) tIndex :: I ! initialize CALL Obj % NodePool % GetAllNodes ( PoolNodes ) Code = 0_kIndex ! compute hash code SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE Code = Code + Nodes ( I )% Key % HashCode () END DO END SELECT END BLOCK END IF RETURN END FUNCTION ListTable_HashCode ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseCollection Type       ----- ! --------------------------------------------------------------------- SUBROUTINE ListTable_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). <br> !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( ListTable ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( Other ) TYPE IS ( ListTable ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseSymTable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: KeyItem CLASS ( * ), ALLOCATABLE :: ValItem ! get key and value molds MoldPtr => Other % GetKeyPtr () ALLOCATE ( KeyItem , MOLD = MoldPtr ) MoldPtr => Other % GetValPtr () ALLOCATE ( ValItem , MOLD = MoldPtr ) ! loop through the other collection and get key-value pairs along the way IsTheEnd = Other % StartFirst ( KeyItem , ValItem , ItemCopy , ValCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( KeyItem , ValItem ) IsTheEnd = Other % MoveForward ( KeyItem , ValItem , ItemCopy , ValCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( KeyItem , ValItem ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'ListTable_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseSymTable\" class.' ) END SELECT RETURN END SUBROUTINE ListTable_CopyCollection !****************************************************************************** SUBROUTINE ListTable_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if the collection is empty IF ( Collection % IsEmpty ()) RETURN ! clear elements CALL Collection % WrkLst % Clear () ! reset components CALL Collection % NodePool % Reset () ! free mold CALL Collection % FreeMolds () RETURN END SUBROUTINE ListTable_ClearItems !****************************************************************************** SUBROUTINE ListTable_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE ListTable_Destroy !****************************************************************************** FUNCTION ListTable_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of items in the collection. !  This is a deferred procedure inherited from the *BaseCollection* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( IN ) :: Collection tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % WrkLst % GetSize () RETURN END FUNCTION ListTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- FUNCTION ListTable_Move2FirstPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a symbol table. !  For the *ListTable*, which is an unordered symbol table, !  the starting pair is the first pair inserted.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the first key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the first value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection contains no pair data or not <br> ! - true if the collection is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( DoublyLinkedNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkLst % StartFirst ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'ListTable_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'ListTable_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkLst % StartFirst () END IF RETURN END FUNCTION ListTable_Move2FirstPair !****************************************************************************** FUNCTION ListTable_Move2NextPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table. !  For the *ListTable*, which is an unordered symbol table, !  the next pair is the pair inserted after the previous one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( DoublyLinkedNode ), POINTER :: CurrNode ! move to next iteration IsTheEnd = Collection % WrkLst % MoveForward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'ListTable_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'ListTable_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! move to next iteration IsTheEnd = Collection % WrkLst % MoveForward () END IF RETURN END FUNCTION ListTable_Move2NextPair !****************************************************************************** SUBROUTINE ListTable_Insert ( Collection , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into a symbol table.  If the specified key is already !  stored in the table, replace the old value with the new one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the key to be added to the collection CLASS ( * ), INTENT ( IN ) :: Key !% the associated value to be added to the collection CLASS ( * ), INTENT ( IN ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: KeyFound TYPE ( TabNode ), POINTER :: KeyNode CLASS ( BaseNode ), POINTER :: NewNode ! FLOW ! check the specified key and value IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN CALL Handle_ErrLevel ( 'ListTable_Insert' , ModName , ErrSevere , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN CALL Handle_ErrLevel ( 'ListTable_Insert' , ModName , ErrSevere , & 'Only values of the same type are allowed in a collection.' ) RETURN END IF ! check whether the key is already stored in the collection or not IF ( Collection % IsEmpty ()) THEN KeyFound = FalseVal ELSE KeyFound = Collection % FindKey ( Key , KeyNode ) END IF IF ( KeyFound ) THEN ! replace the current value with the new one CALL KeyNode % Value % Set ( Value , Collection % ItemPool ) ELSE ! +++ new key-value pair +++ ! check for first-time insertion IF (. NOT . Collection % NodePool % IsReady ()) THEN CALL Collection % NodePool % Construct ( KeyNode ) CALL Collection % ItemPool % Construct () END IF ! get new node from the node's pool CALL Collection % NodePool % GetNewNode ( NewNode ) SELECT TYPE ( NewNode ) TYPE IS ( TabNode ) KeyNode => NewNode END SELECT ! set key and value to the node ! (no need to check the valid flag since we have already done that in the beginning) CALL KeyNode % SetKeyNVal ( Key , Value , Collection % ItemPool ) ! append the new node to the working list CALL Collection % WrkLst % AddLast ( KeyNode ) END IF ! free working pointer NULLIFY ( KeyNode , NewNode ) RETURN END SUBROUTINE ListTable_Insert !****************************************************************************** SUBROUTINE ListTable_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a key-value pair from a symbol table.  This procedure is intended !  to be used in conjunction with the *StartFirst* and *MoveForward* procedures. !  Therefore, after the call to either procedure and then calling this procedure !  will result in a removal of the current key-value pair of the iteration (i.e. !  the same key-value pair that can be retrieved via those *Move* procedures). <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: CurrNode tLogical :: IsTheEnd ! FLOW ! get the cursor node CurrNode => Collection % WrkLst % GetCursor () ! check if the node is associated IF ( ASSOCIATED ( CurrNode )) THEN ! reset cursor by moving cursor backward IsTheEnd = Collection % WrkLst % MoveBackward () ! check if remove the node successfully or not IF ( Collection % WrkLst % RemoveNode ( CurrNode )) THEN ! return the node to the node's pool SELECT TYPE ( DelNode => CurrNode ) TYPE IS ( TabNode ) CALL Collection % NodePool % ReturnNode ( DelNode ) END SELECT ELSE CALL Handle_ErrLevel ( 'ListTable_Delete' , ModName , ErrWarning , & 'Check the Remove method of the intrusive list for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( CurrNode ) RETURN END SUBROUTINE ListTable_Delete !****************************************************************************** FUNCTION ListTable_Remove ( Collection , Key ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete the specified key (and its associated value) from a symbol !  table.  Also, return a flag indicating whether the key-value pair is !  successfully removed or not.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the key to be removed from the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF IF ( Flag ) THEN ! check if remove the node successfully or not IF ( Collection % WrkLst % RemoveNode ( KeyNode )) THEN ! return the node to the node's pool CALL Collection % NodePool % ReturnNode ( KeyNode ) ELSE CALL Handle_ErrLevel ( 'ListTable_Remove' , ModName , ErrWarning , & 'Check the Remove method of the intrusive list for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION ListTable_Remove !****************************************************************************** FUNCTION ListTable_Contain ( Collection , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSE Found = Collection % FindKey ( Key ) END IF RETURN END FUNCTION ListTable_Contain !****************************************************************************** FUNCTION ListTable_GetValue ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a value associated with the specified key in a symbol table. !  Also, return a flag indicating whether the key-value pair is successfully !  found or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the value associated with the specified key CLASS ( * ), INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF ! get value if key is found IF ( Flag ) THEN Flag = KeyNode % Value % Get ( Value , ValCopy ) END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION ListTable_GetValue !************************************************************************************** FUNCTION ListTable_ToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all key-value pairs from the collection.  Also, return a flag !  indicating whether the pairs are successfully retrieved and removed or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Keys , Values , KeyCopy , ValCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION ListTable_ToArray !************************************************************************************** FUNCTION ListTable_GetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys and/or all values (without removing them) from the collection.  Also, !  return a flag indicating whether the keys and/or values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: SameKeyType , SameValType ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF ( PRESENT ( Keys ). AND . PRESENT ( Values )) THEN SameKeyType = Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal ) SameValType = Collection % IsValValid ( Values ( 1 )) ! check whether types of the specified keys and values are valid or not IF ( SameKeyType . AND . SameValType ) THEN Success = Collection % GetAllPairs ( Keys , Values , KeyCopy , ValCopy ) ELSEIF ( SameKeyType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'ListTable_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) ELSEIF ( SameValType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'ListTable_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'ListTable_GetAll' , ModName , ErrSevere , & 'Types of both keys and values are NOT the same as those of stored pairs.' ) END IF ELSEIF ( PRESENT ( Keys )) THEN ! check whether type of the specified keys is valid or not IF ( Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal )) THEN Success = Collection % GetAllKeys ( Keys , KeyCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'ListTable_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Values )) THEN ! check whether type of the specified values is valid or not IF ( Collection % IsValValid ( Values ( 1 ))) THEN Success = Collection % GetAllVals ( Values , ValCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'ListTable_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION ListTable_GetAll !************************************************************************************** FUNCTION ListTable_GetAllPairs ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all key-value pairs (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , KeySize , ValSize tLogical :: IsTheEnd CLASS ( DoublyLinkedNode ), POINTER :: CurrNode ! FLOW ! initialize local variables KeySize = SIZE ( Keys , KIND = kIndex ) ValSize = SIZE ( Values , KIND = kIndex ) IF (( KeySize < 1_kindex ). AND .( ValSize < 1_kindex )) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkLst % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( I <= KeySize ) Success = CurrNode % Key % Get ( Keys ( I ), KeyCopy ) IF ( Success . AND .( I <= ValSize )) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex END SELECT IsTheEnd = Collection % WrkLst % MoveForward ( CurrNode ) END DO RETURN END FUNCTION ListTable_GetAllPairs !************************************************************************************** FUNCTION ListTable_GetAllKeys ( Collection , Keys , KeyCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( DoublyLinkedNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Keys , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkLst % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Key % Get ( Keys ( I ), KeyCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkLst % MoveForward ( CurrNode ) END DO RETURN END FUNCTION ListTable_GetAllKeys !************************************************************************************** FUNCTION ListTable_GetAllVals ( Collection , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all values (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListTable object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( DoublyLinkedNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Values , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the values along the way IsTheEnd = Collection % WrkLst % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkLst % MoveForward ( CurrNode ) END DO RETURN END FUNCTION ListTable_GetAllVals ! --------------------------------------------------------------------- ! -----                 Specific Procedures                       ----- ! --------------------------------------------------------------------- SUBROUTINE ListTable_CreateByArray ( Collection , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of key-value pairs !% the keys to be added to the table CLASS ( * ), INTENT ( IN ) :: Keys ( N ) !% the associated values to be added to the table CLASS ( * ), INTENT ( IN ) :: Values ( N ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! add key-value pairs to the table DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE ListTable_CreateByArray !****************************************************************************** FUNCTION ListTable_FindKey ( Collection , Key , KeyNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the specified key in a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( ListTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the node containing the specified key; null pointer if the key is not found TYPE ( TabNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: KeyNode !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: InNode CLASS ( DoublyLinkedNode ), POINTER :: StoredNode ! FLOW ! initialize Found = Falseval IF ( PRESENT ( KeyNode )) KeyNode => NULL () ! check the specified key and return quickly if not valid IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) RETURN ! set key for search node CALL InNode % Key % Set ( Key , Collection % ItemPool ) ! find the stored node equal to input node Found = Collection % WrkLst % Contain ( InNode , StoredNode ) IF ( PRESENT ( KeyNode ). AND . Found ) THEN SELECT TYPE ( StoredNode ) TYPE IS ( TabNode ) KeyNode => StoredNode END SELECT END IF ! free working pointer NULLIFY ( StoredNode ) RETURN END FUNCTION ListTable_FindKey ! --------------------------------------------------------------------- ! -----             Final Procedures                              ----- ! --------------------------------------------------------------------- SUBROUTINE ListTable_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ListTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE ListTable_Finalize !****************************************************************************** END MODULE MClass_ListTable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listtable.f90.html"},{"title":"MClass_HTabRealSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabRealSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabRealSP* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabRealSP* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabRealSP* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabRealSP* type uses the Fortran intrinsic !   *REAL(KIND=kSingle)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabRealSP* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabRealSP* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabRealSP #define     KeyTypeA        REAL(KIND=kSingle) #define     KeyTypeB        REAL(KIND=kSingle) #define     QueueKey        ListRealSP #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabRealSP PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabRealSP' tSInt32 , PARAMETER :: INFVAL = ToInt32 ( Z '7F800000' ) ! positive infinity tSInt32 , PARAMETER :: NANVAL = ToInt32 ( Z '7FC00000' ) ! quiet NAN ! Special marker token used to indicate the deletion of a key-value pair tRealSP , PARAMETER :: DELKEY = TRANSFER ( INFVAL , 1.0_kSingle ) ! Special marker token used to indicate the empty of a key-value pair tRealSP , PARAMETER :: NULKEY = TRANSFER ( NANVAL , 1.0_kSingle ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabRealSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabrealsp.f90.html"},{"title":"MClass_DArrRealSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrRealSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrRealSP* type and related routines. !   The *DArrRealSP* type is a container with *REAL(KIND=kSingle)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrRealSP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrRealSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrRealSP #define TypeAlloc       REAL(KIND=kSingle), ALLOCATABLE #define TypeArgmt       REAL(KIND=kSingle) #define TypeOfItem      REAL(KIND=kSingle) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrRealSP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrRealSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrrealsp.f90.html"},{"title":"MClass_ListObject.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListObject !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListObject* type and related routines. !   The *ListObject* type is a container with *CLASS(Object)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation.  All derived types extending from the *Object* type can be !   used with this container. <br> !   It should be noted that although the *ListObject* type allows items with !   different types (any derived types that are in the *Object* class) to be !   stored in different nodes of the same container, a user must be extremely !   careful when retrieving the items with different types from the container. !   The type specified for an output argument must match the type of an item !   stored in a particular node of the container.  Otherwise, the user would !   not be able to retrieve the item for that specific routine. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListObject* type but utilizes a different implementation. !   Also, unlike the *ListObject* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListObject PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListObject' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *DLLNode* is a node type that consists of an item and two pointers of the node type. !   As such, the node can point to its adjacent nodes in two directions (next node and !   previous node) allowing a doubly-linked list to be formed. <br> !   The type of the item stored in this node is a derived type in the *Object* !   class (i.e. the *Object* type or its subtypes).  The *DLLNode* type is a !   private type. TYPE DLLNode PRIVATE !> *Item* is an item (or value) stored in the node where its type can !   be any derived type that extends from the *Object* type. CLASS ( Object ), ALLOCATABLE :: Item !% pointer to the next node TYPE ( DLLNode ), POINTER :: Next => NULL () !% pointer to previous node TYPE ( DLLNode ), POINTER :: Prev => NULL () CONTAINS ! destructor procedure PROCEDURE , PRIVATE :: Destruct => LinkedNode_Destructor END TYPE DLLNode !> *ListObject* is a container type that employs a doubly-linked list implementation to !   provide common operations for a list container.  It can also represent other forms !   of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque). !   The type of items stored in this container is a derived type in the *Object* !   class (i.e. the *Object* type or its subtypes). TYPE ListObject PRIVATE !% size of the list container (i.e. number of nodes in the list) tIndex :: Size = 0 !% pointer to the first node (or the head node) of the list TYPE ( DLLNode ), POINTER :: Head => NULL () !% pointer to the last node (or the tail node) of the list TYPE ( DLLNode ), POINTER :: Tail => NULL () !% pointer to the current node used for iteration purpose TYPE ( DLLNode ), POINTER :: Cursor => NULL () !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: SetNewNode => LinkedList_SetNewNode PROCEDURE , PRIVATE :: RemoveNode => LinkedList_RemoveNode PROCEDURE , PRIVATE :: GetNodeAt => LinkedList_GetNodeAt PROCEDURE , PRIVATE :: Traverse => LinkedList_Traverse ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a list from an array of items <br> !  **Usage**: <br> !   --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items PROCEDURE :: Construct => LinkedList_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> ! **Purpose**:  To destruct a list and get its items if requested <br> !  **Usage**: <br> !   --->    CALL List%Destruct()    ! destruct the list <br> !  **Note**: This method is equivalent to the *Clear* method. PROCEDURE :: Destruct => LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddFirst(Item) PROCEDURE :: AddFirst => LinkedList_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddLast(Item) PROCEDURE :: AddLast => LinkedList_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = List%AddAt(Index, Item) <br> !   --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => LinkedList_AddAt !> **Type-Bound Subroutine**: Remove <br> ! **Purpose**:  To remove an item from the list.  The first item is removed !               by default.  If specified, the last item can be removed instead. <br> !  **Usage**: <br> !   --->    CALL List%Remove()          ! remove the first item <br> !   --->    CALL List%Remove(.FALSE.)   ! remove the last item <br> !   --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: Remove => LinkedList_Remove !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveFirst(Item) <br> !   --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveFirst => LinkedList_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveLast(Item) <br> !   --->    IF (.NOT.List%RemoveLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveLast => LinkedList_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveAt => LinkedList_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the list. <br> !  **Usage**: <br> !   --->    CALL List%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !   *StartFirst* and *MoveForward* methods (or the *StartLast* and !   *MoveBackward* methods).  Therefore, after the call to one of those !   methods and then calling this one will result in a removal of the !   current item of the iteration (i.e. the same item that can be retrieved !   via those iteration methods). PROCEDURE :: Delete => LinkedList_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the list. <br> !  **Usage**: <br> !   --->    CALL List%Clear() PROCEDURE :: Clear => LinkedList_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the list.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%ToArray(Items) <br> !   --->    IF (.NOT.List%ToArray(Items)) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored !   in different nodes have different types. PROCEDURE :: ToArray => LinkedList_ToArray !> **Type-Bound Subroutine**: RemoveDuplicates <br> !  **Purpose**:  To remove nodes with duplicated items from the list. <br> !  **Usage**: <br> !   --->    CALL List%RemoveDuplicates() PROCEDURE :: RemoveDuplicates => LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => LinkedList_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move *forward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = List%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveForward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = List%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveForward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveForward => LinkedList_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => LinkedList_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move *backward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = List%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveBackward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = List%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveBackward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveBackward => LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the list is empty or not. <br> !  **Usage**: <br> !   --->    Flag = List%IsEmpty() <br> !   --->    IF (.NOT.List%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => LinkedList_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the list. <br> !  **Usage**: <br> !   --->    ListSize = List%GetSize() PROCEDURE :: GetSize => LinkedList_GetSize !> **Type-Bound Function**: SameType <br> !  **Purpose**:  To check whether all stored items have the same type or not. <br> !  **Usage**: <br> !   --->    Flag = List%SameType() <br> !   --->    IF (.NOT.List%SameType()) DoSomeThing PROCEDURE :: SameType => LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the first item (without removing it from the list). !                Also, return a flag indicating whether the item is available !                or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekFirst(Item) <br> !   --->    IF (.NOT.List%PeekFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekFirst => LinkedList_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the list). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekLast(Item) <br> !   --->    IF (.NOT.List%PeekLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekLast => LinkedList_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the list) at !                the specified index where the index must be between 1 and the !                list size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekAt(Index, Item) <br> !   --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekAt => LinkedList_PeekAt !> **Type-Bound Subroutine**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the list. Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Flag = List%GetAll(Items) <br> !   --->    IF (.NOT.List%GetAll(Items)) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored !   in different nodes have different types. PROCEDURE :: GetAll => LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => LinkedList_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => LinkedList_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => LinkedList_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => LinkedList_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => LinkedList_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: LinkedList_Finalizer ! --------------------------------------------------------------------- END TYPE ListObject !** INTERFACE DEFINITIONS: ! abstract interfaces ABSTRACT INTERFACE ! IterFuncItem is a procedure supplied to a *Traverse* procedure that ! can be used to get the list's item. FUNCTION IterFuncItem ( Item , Done ) RESULT ( ErrStat ) IMPORT CLASS ( Object ), INTENT ( IN ) :: Item ! item tLogical , INTENT ( INOUT ) :: Done ! on input, Done is set to .FALSE. ! on exit, set it to .TRUE. if user !   want to stop the queue traversing. tLogical :: ErrStat ! true if error occurred in the user routine END FUNCTION IterFuncItem END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----             DLLNode PROCEDURES                            ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedNode_Deallocate ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To deallocate DLLNode pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DLLNode ), POINTER , INTENT ( INOUT ) :: Node !! DLLNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF ( ASSOCIATED ( Node )) THEN DEALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrDealloc ( 'LinkedNode_Deallocate' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE LinkedNode_Deallocate !****************************************************************************** SUBROUTINE LinkedNode_Destructor ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct DLLNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DLLNode ), INTENT ( INOUT ) :: Node !! DLLNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Item % MemFree () DEALLOCATE ( Node % Item ) NULLIFY ( Node % Next ) NULLIFY ( Node % Prev ) RETURN END SUBROUTINE LinkedNode_Destructor ! --------------------------------------------------------------------- ! -----             ListObject PROCEDURES                         ----- ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_SetNewNode ( List , NewNode , AppendAtTail ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set pointers for newly created node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object TYPE ( DLLNode ), POINTER , INTENT ( IN ) :: NewNode !! new node to be added to the list tLogical , INTENT ( IN ) :: AppendAtTail !! true if append to the tail !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if list is empty or not IF ( List % IsEmpty ()) THEN ! the list is EMPTY so the new node is added to the beginning of the list List % Head => NewNode List % Tail => NewNode ELSE ! the list is NOT empty so add NewNode according to AppendAtTail flag IF ( AppendAtTail ) THEN !++++++++++++++++++++++++++++++++++++++++++++++++++ !+++ Append the NewNode to the list at the tail +++ !++++++++++++++++++++++++++++++++++++++++++++++++++ NewNode % Prev => List % Tail List % Tail % Next => NewNode List % Tail => NewNode ELSE !++++++++++++++++++++++++++++++++++++++++++++++++++ !+++ Append the NewNode to the list at the head +++ !++++++++++++++++++++++++++++++++++++++++++++++++++ NewNode % Next => List % Head List % Head % Prev => NewNode List % Head => NewNode END IF END IF ! set list length List % Size = List % Size + 1 RETURN END SUBROUTINE LinkedList_SetNewNode !****************************************************************************** FUNCTION LinkedList_RemoveNode ( List , CurrNode , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified node from the list.  Also, return a flag indicating !  whether the node is removed successfully or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object TYPE ( DLLNode ), POINTER , INTENT ( INOUT ) :: CurrNode !! the node to be removed CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! item of the removed node if requested !> flag indicating whether the node is successfully removed. <br> ! - true if the node is successfully removed. ! - false if the node is NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check input data and their possibly-related errors IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN ELSEIF (. NOT . ASSOCIATED ( CurrNode )) THEN Flag = FalseVal RETURN ELSE ! set flag Flag = TrueVal ! +++ no error in required input arguments +++ ! check whether requesting the item of the node to be removed IF ( PRESENT ( Item )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , CurrNode % Item )) THEN ! copy item Item = CurrNode % Item ELSE ! report error CALL Handle_ErrLevel ( 'LinkedList_RemoveNode' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF END IF ! check whether there is only one node or not IF ( List % Size == 1 ) THEN ! ++ the list has only one node ++ ! check to make sure that the supplied node is really the only one IF ( ASSOCIATED ( CurrNode , List % Head ). AND . ASSOCIATED ( CurrNode , List % Tail )) THEN ! reset the list List % Head => NULL () List % Tail => NULL () List % Cursor => NULL () List % Size = 0 ELSE ! The list contains only one node but it is NOT associated with ! the specified node so no node is removed. Flag = FalseVal RETURN END IF ELSE ! ++ the list has two or more nodes ++ ! check where the supplied node is IF ( ASSOCIATED ( CurrNode , List % Head )) THEN ! the node is the head List % Head => CurrNode % Next List % Head % Prev => NULL () ELSEIF ( ASSOCIATED ( CurrNode , List % Tail )) THEN ! the node is the tail List % Tail => CurrNode % Prev List % Tail % Next => NULL () ELSE ! the node is in the middle CurrNode % Prev % Next => CurrNode % Next CurrNode % Next % Prev => CurrNode % Prev END IF ! set length List % Size = List % Size - 1 END IF ! destroy the current node CALL CurrNode % Destruct () CALL LinkedNode_Deallocate ( CurrNode ) END IF RETURN END FUNCTION LinkedList_RemoveNode !****************************************************************************** SUBROUTINE LinkedList_Traverse ( List , IterFunc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To traverse the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object PROCEDURE ( IterFuncItem ) :: IterFunc !! iterator function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode CLASS ( Object ), POINTER :: CurrItem tLogical :: ErrStat tLogical :: Done ! FLOW ! set defaults Done = FalseVal ! traverse to all nodes ErrStat = FalseVal ! initialize current node CurrNode => List % Head ! loop over all nodes of the list DO WHILE ( ASSOCIATED ( CurrNode )) ! get current item CurrItem => CurrNode % Item ! call iterator function ErrStat = IterFunc ( CurrItem , Done ) ! report error if necessary IF ( ErrStat ) THEN CALL Handle_ErrLevel ( 'LinkedList_Traverse' , ModName , ErrSevere , & 'An error occurred during call to iterator function.' ) RETURN END IF ! exit the loop if the user want to stop the traversing IF ( Done ) EXIT ! set current node CurrNode => CurrNode % Next END DO NULLIFY ( CurrNode ) NULLIFY ( CurrItem ) RETURN END SUBROUTINE LinkedList_Traverse !****************************************************************************** FUNCTION IsIndexValid ( Size , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified index is between 1 !  and the list size or not. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Size !! the list size tIndex , INTENT ( IN ) :: Index !! the specified index tLogical :: Flag !! true if the index is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal IF ( Index < 1_kIndex ) RETURN IF ( Index > Size ) RETURN Flag = TrueVal RETURN END FUNCTION IsIndexValid !****************************************************************************** FUNCTION LinkedList_GetNodeAt ( List , N ) RESULT ( NodeOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the Nth node from the list where N is between 1 and the list size. !  If the list is empty or N is not in a valid range, return Null pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object tIndex , INTENT ( IN ) :: N !! (one-based) index indicating the node TYPE ( DLLNode ), POINTER :: NodeOut !! pointer to the Nth node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurrIndex tLogical :: EndOfList !** FLOW ! check and return quickly if possible IF ( List % IsEmpty ()) THEN NodeOut => NULL () RETURN ELSEIF (. NOT . IsIndexValid ( List % Size , N )) THEN NodeOut => NULL () RETURN END IF ! check which direction to traverse the list IF ( N <= ( List % Size - N + 1 )) THEN ! perform forward iteration CurrIndex = 1 ! restart the iteration EndOfList = List % StartFirst () DO WHILE (. NOT . EndOfList ) ! check if the node is found IF ( CurrIndex == N ) EXIT ! move to the next iteration EndOfList = List % MoveForward () ! set index CurrIndex = CurrIndex + 1 END DO ELSE ! perform backward iteration CurrIndex = List % Size ! restart the iteration EndOfList = List % StartLast () DO WHILE (. NOT . EndOfList ) ! check if the node is found IF ( CurrIndex == N ) EXIT ! move to the next iteration EndOfList = List % MoveBackward () ! set index CurrIndex = CurrIndex - 1 END DO END IF ! set pointer to the Nth node NodeOut => List % Cursor RETURN END FUNCTION LinkedList_GetNodeAt ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_CreateByArray ( List , N , Items ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a list from an array of item. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object tIndex , INTENT ( IN ) :: N !! number of items CLASS ( Object ), INTENT ( IN ) :: Items ( N ) !! an array of items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! simply return if N is less than 1 IF ( N <= 0 ) RETURN ! built list of input items DO I = 1 , N CALL List % AddLast ( Items ( I )) END DO RETURN END SUBROUTINE LinkedList_CreateByArray !****************************************************************************** SUBROUTINE LinkedList_Destructor ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct ListObject object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! destroy all nodes and free up memory CALL List % Clear () RETURN END SUBROUTINE LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_AddFirst ( List , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a item at the head of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), INTENT ( IN ) :: Item !! item to be added to the list !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , PARAMETER :: AppendAtTail = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate new node and ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddFirst' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddFirst' , ModName , AllocMsg , AllocStat ) ! set pointers to new node CALL List % SetNewNode ( NewNode , AppendAtTail ) ! free up memory NULLIFY ( NewNode ) RETURN END SUBROUTINE LinkedList_AddFirst !****************************************************************************** SUBROUTINE LinkedList_AddLast ( List , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a item at the tail of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), INTENT ( IN ) :: Item !! item to be added to the list !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , PARAMETER :: AppendAtTail = TrueVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate new node ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddLast' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddLast' , ModName , AllocMsg , AllocStat ) ! set pointers to new node CALL List % SetNewNode ( NewNode , AppendAtTail ) ! free up memory NULLIFY ( NewNode ) RETURN END SUBROUTINE LinkedList_AddLast !****************************************************************************** FUNCTION LinkedList_AddAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the given item at the specified index where the index must be !  between 1 and the list size.  Also, return a flag indicating whether the !  item is successfully added. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be added to the list CLASS ( Object ), INTENT ( IN ) :: Item !> flag indicating whether the item is successfully added. <br> ! - true if the item is successfully added. ! - false if the item is NOT successfully added. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! check the validity of the specified index Flag = FalseVal IF (. NOT . IsIndexValid ( List % Size , Index )) RETURN ! allocate new node and set the new node's item ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddAt' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddAt' , ModName , AllocMsg , AllocStat ) ! set flag Flag = TrueVal IF ( Index == 1_kIndex ) THEN ! add node to the front CALL List % SetNewNode ( NewNode , AppendAtTail = FalseVal ) ELSE BLOCK ! block variables TYPE ( DLLNode ), POINTER :: NthNode TYPE ( DLLNode ), POINTER :: PrvNode ! get node at the index IF ( Index == List % Size ) THEN NthNode => List % Tail ELSE NthNode => List % GetNodeAt ( Index ) END IF ! get previous node PrvNode => NthNode % Prev ! add new node PrvNode % Next => NewNode NthNode % Prev => NewNode NewNode % Prev => PrvNode NewNode % Next => NthNode ! free block variables NULLIFY ( NthNode , PrvNode ) END BLOCK ! set list length List % Size = List % Size + 1 END IF ! free up pointer NULLIFY ( NewNode ) RETURN END FUNCTION LinkedList_AddAt !****************************************************************************** SUBROUTINE LinkedList_Remove ( List , First , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a node from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object tLogical , OPTIONAL , INTENT ( IN ) :: First !&#94; location flag where the node is removed <br> ! - true (by default) if want to remove the first node <br> ! - false if want to remove the last node CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! item of the removed node if requested !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: RemoveFirstNode tLogical :: Success ! FLOW ! first, check whether the list is empty or not IF ( List % IsEmpty ()) THEN ! set routine name SubName = 'LinkedList_Remove' ! set error message ErrMsg = 'The list is EMPTY.' ! report error CALL Handle_ErrLevel ( SubName , ModName , ErrWarning , ErrMsg ) RETURN END IF ! set default and check optional input SET_OPTION ( RemoveFirstNode , TrueVal , First ) ! check whether requesting the item of the node to be removed IF ( PRESENT ( Item )) THEN IF ( RemoveFirstNode ) THEN Success = List % PeekFirst ( Item ) ELSE Success = List % PeekLast ( Item ) END IF END IF ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE ! the list has two or more nodes so check which node to be removed IF ( RemoveFirstNode ) THEN ! reset the head List % Cursor => List % Head List % Head => List % Cursor % Next List % Head % Prev => NULL () ELSE ! reset the tail List % Cursor => List % Tail List % Tail => List % Cursor % Prev List % Tail % Next => NULL () END IF ! remove the node CALL List % Cursor % Destruct () CALL LinkedNode_Deallocate ( List % Cursor ) ! set length List % Size = List % Size - 1 END IF RETURN END SUBROUTINE LinkedList_Remove !****************************************************************************** FUNCTION LinkedList_RemoveFirst ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the first item of the list.  Also, return !  a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! return quickly if the list is empty IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! get the item of the node to be removed Flag = List % PeekFirst ( Item ) ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE BLOCK ! block variable TYPE ( DLLNode ), POINTER :: DelNode => NULL () ! reset the head DelNode => List % Head List % Head => DelNode % Next List % Head % Prev => NULL () ! remove the node CALL DelNode % Destruct () CALL LinkedNode_Deallocate ( DelNode ) ! free pointer NULLIFY ( DelNode ) END BLOCK ! set length List % Size = List % Size - 1 END IF RETURN END FUNCTION LinkedList_RemoveFirst !****************************************************************************** FUNCTION LinkedList_RemoveLast ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the last item of the list.  Also, return !  a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! return quickly if the list is empty IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! get the item of the node to be removed Flag = List % PeekLast ( Item ) ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE BLOCK ! block variable TYPE ( DLLNode ), POINTER :: DelNode ! reset the tail DelNode => List % Tail List % Tail => DelNode % Prev List % Tail % Next => NULL () ! remove the node CALL DelNode % Destruct () CALL LinkedNode_Deallocate ( DelNode ) ! free pointer NULLIFY ( DelNode ) END BLOCK ! set length List % Size = List % Size - 1 END IF RETURN END FUNCTION LinkedList_RemoveLast !****************************************************************************** FUNCTION LinkedList_RemoveAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the item at the specified index where the index must be !  between 1 and the list size.   Also, return a flag indicating whether !  the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be removed from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the item is successfully removed. ! - false if the item is NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: DelNode ! FLOW ! get node at the index DelNode => List % GetNodeAt ( Index ) IF ( ASSOCIATED ( DelNode )) THEN ! get item and remove node Flag = List % RemoveNode ( DelNode , Item ) ELSE Flag = FalseVal END IF NULLIFY ( DelNode ) RETURN END FUNCTION LinkedList_RemoveAt !****************************************************************************** SUBROUTINE LinkedList_Delete ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete an item from the list.  This procedure is intended to be used !  in conjunction with the *StartFirst* and *MoveForward* methods (or the !  *StartLast* and *MoveBackward*).  Therefore, after the call to one of !  these methods and then calling this procedure will result in a removal !  of the current item of the iteration (i.e. the same item that can be !  retrieved via those methods). <br> !  If the cursor pointer is not associated, nothing happens.  This usually !  means that the list is empty or this procedure is called before those !  iteration methods. <br> !  This procedure provides a way to remove items in the middle of the list !  without knowing specific locations of the items.  The user would perform !  an iteration over the list by calling those iteration methods.  While in !  the middle of the iteration, if the interested items are found, they can !  be removed from the list by this procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: DelNode tLogical :: Flag ! FLOW ! get the node to be deleted DelNode => List % Cursor IF ( ASSOCIATED ( DelNode )) THEN ! reset cursor IF ( List % Dir == 1 ) THEN ! forward iteration so move cursor backward List % Cursor => List % Cursor % Prev ELSE ! backward iteration so move cursor forward List % Cursor => List % Cursor % Next END IF Flag = List % RemoveNode ( DelNode ) END IF NULLIFY ( DelNode ) RETURN END SUBROUTINE LinkedList_Delete !************************************************************************************** SUBROUTINE LinkedList_ClearItems ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free up memory of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the list and destroy all nodes DO WHILE (. NOT . List % IsEmpty ()) CALL List % Remove () END DO ! free up pointers NULLIFY ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) ! reset components List % Size = 0 List % Dir = 0 RETURN END SUBROUTINE LinkedList_ClearItems !****************************************************************************** FUNCTION LinkedList_ToArray ( List , Items ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all items from the list.  Also, return !  a flag indicating whether the items are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( Object ), ALLOCATABLE , INTENT ( INOUT ) :: Items (:) !> flag indicating whether the items are successfully removed. <br> ! - true if the items are successfully removed. ! - false if the items are NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . List % SameType ()) THEN Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_ToArray' , ModName , ErrSevere , & 'Items does not have the same type.' ) RETURN END IF ! get items Flag = List % GetAll ( Items ) ! destroy all nodes and free up memory CALL List % Clear () END FUNCTION LinkedList_ToArray !****************************************************************************** SUBROUTINE LinkedList_RemoveDuplicates ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove nodes with duplicated items from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode TYPE ( DLLNode ), POINTER :: NextNode CLASS ( Object ), POINTER :: CurrItem CLASS ( Object ), ALLOCATABLE :: IterItem tLogical :: Repeat tLogical :: IsTheEnd tLogical :: Success tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg !** FLOW ! start the list CurrNode => List % Head NextNode => CurrNode % Next IF ( ASSOCIATED ( CurrNode )) THEN ALLOCATE ( IterItem , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = CurrNode % Item ) CALL Handle_ErrAlloc ( 'LinkedList_RemoveDuplicates' , ModName , AllocMsg , AllocStat ) END IF ! traverse the list DO WHILE ( ASSOCIATED ( NextNode )) ! set flag Repeat = FalseVal ! get current item CurrItem => CurrNode % Item ! start the iteration at the next node List % Cursor => NextNode IsTheEnd = FalseVal IterItem = List % Cursor % Item DO WHILE (. NOT . IsTheEnd ) ! check whether the items are the same IF ( CurrItem % IsEqualTo ( IterItem )) THEN Repeat = TrueVal EXIT END IF ! move to next iteration and get its item IsTheEnd = List % MoveForward ( IterItem ) END DO ! remove node if the current item has a duplicated one IF ( Repeat ) Success = List % RemoveNode ( CurrNode ) ! move to next node CurrNode => NextNode ! set NextNode NextNode => CurrNode % Next END DO ! free up memory NULLIFY ( CurrNode ) NULLIFY ( NextNode ) NULLIFY ( CurrItem ) DEALLOCATE ( IterItem ) RETURN END SUBROUTINE LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- FUNCTION LinkedList_Move2FirstElm ( List , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the head node of the list and return !  a flag indicating whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! first item tLogical :: IsEmpty !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Head ! set flag IsEmpty = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsEmpty ) List % Dir = 1 IF ( PRESENT ( Item ). AND .(. NOT . IsEmpty )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Cursor % Item )) THEN ! copy item Item = List % Cursor % Item ELSE ! report error CALL Handle_ErrLevel ( 'LinkedList_Move2FirstElm' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF END IF RETURN END FUNCTION LinkedList_Move2FirstElm !****************************************************************************** FUNCTION LinkedList_Move2LastElm ( List , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the tail node of the list and return !  a flag indicating whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! last item tLogical :: IsEmpty !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Tail ! set flag IsEmpty = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsEmpty ) List % Dir = - 1 IF ( PRESENT ( Item ). AND .(. NOT . IsEmpty )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Cursor % Item )) THEN ! copy item Item = List % Cursor % Item ELSE ! report error CALL Handle_ErrLevel ( 'LinkedList_Move2LastElm' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF END IF RETURN END FUNCTION LinkedList_Move2LastElm !****************************************************************************** FUNCTION LinkedList_Move2NextElm ( List , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move (forward) to the next node in the list and return a flag indicating !  whether the cursor pointer has reached the end of the list or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! item of the next node tLogical :: IsTheEnd !! true if the cursor has reached the end of the list !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Cursor % Next ! set flag IsTheEnd = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsTheEnd ) THEN List % Dir = 1 ELSE List % Dir = 0 END IF IF ( PRESENT ( Item ). AND .(. NOT . IsTheEnd )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Cursor % Item )) THEN ! copy item Item = List % Cursor % Item ELSE ! report error CALL Handle_ErrLevel ( 'LinkedList_Move2NextElm' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF END IF RETURN END FUNCTION LinkedList_Move2NextElm !****************************************************************************** FUNCTION LinkedList_Move2PrevElm ( List , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move backward to the next node (i.e. to the so-called previous node) !  in the list and return a flag indicating whether the cursor pointer has !  reached the end of the list or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: Item !! item of the previous node tLogical :: IsTheEnd !! true if the cursor has reached the end of the list !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Cursor % Prev ! set flag IsTheEnd = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsTheEnd ) THEN List % Dir = - 1 ELSE List % Dir = 0 END IF IF ( PRESENT ( Item ). AND .(. NOT . IsTheEnd )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Cursor % Item )) THEN ! copy item Item = List % Cursor % Item ELSE ! report error CALL Handle_ErrLevel ( 'LinkedList_Move2PrevElm' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF END IF RETURN END FUNCTION LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- FUNCTION LinkedList_IsEmpty ( List ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( IN ) :: List !! ListObject object tLogical :: Flag !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = . NOT . ASSOCIATED ( List % Head ) RETURN END FUNCTION LinkedList_IsEmpty !****************************************************************************** FUNCTION LinkedList_GetSize ( List ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !! To get size of the list (a number of nodes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( IN ) :: List !! ListObject object tIndex :: Size !! list size (number of nodes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = List % Size RETURN END FUNCTION LinkedList_GetSize !****************************************************************************** FUNCTION LinkedList_SameType ( List ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether all stored items have same type or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( IN ) :: List !! ListObject object tLogical :: Flag !! true if all items have same type !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode ! FLOW Flag = TrueVal CurrNode => List % Head % Next DO WHILE ( ASSOCIATED ( CurrNode )) IF ( SAME_TYPE_AS ( List % Head % Item , CurrNode % Item )) THEN CurrNode => CurrNode % Next ELSE Flag = FalseVal EXIT END IF END DO NULLIFY ( CurrNode ) RETURN END FUNCTION LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- FUNCTION LinkedList_PeekFirst ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the item stored at the first node without removing it from the list. !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( IN ) :: List !% the item to be retrieved from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Head % Item )) THEN Flag = TrueVal ! copy item Item = List % Head % Item ELSE Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_PeekFirst' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF RETURN END FUNCTION LinkedList_PeekFirst !****************************************************************************** FUNCTION LinkedList_PeekLast ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the item stored at the last node without removing it from the list. !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( IN ) :: List !% the item to be retrieved from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , List % Tail % Item )) THEN Flag = TrueVal ! copy item Item = List % Tail % Item ELSE Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_PeekLast' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF RETURN END FUNCTION LinkedList_PeekLast !****************************************************************************** FUNCTION LinkedList_PeekAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the item (without removing it from the list) at the specified index !  where the index must be between 1 and the list size.  Also, return !  a flag indicating whether the item is available or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListObject object CLASS ( ListObject ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be retrieved from the list CLASS ( Object ), INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the item is available. ! - false if the item is NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode ! FLOW ! get the specified node CurrNode => List % GetNodeAt ( Index ) IF ( ASSOCIATED ( CurrNode )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , CurrNode % Item )) THEN Flag = TrueVal ! copy item Item = CurrNode % Item ELSE Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_PeekAt' , ModName , ErrWarning , & 'Type of output item is not compatible with those in the list.' ) END IF ELSE ! set output flag Flag = FalseVal END IF NULLIFY ( CurrNode ) RETURN END FUNCTION LinkedList_PeekAt !************************************************************************************** FUNCTION LinkedList_GetAllItems ( List , Items ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To get all items (without removing them) from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object CLASS ( Object ), ALLOCATABLE , INTENT ( OUT ) :: Items (:) !! an allocatable array of items !> flag indicating whether the items are successfully retrieved. <br> ! - true if the items are available. ! - false if the items are NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , N ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN ! set output Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_GetAllItems' , ModName , ErrWarning , 'The list is EMPTY.' ) RETURN END IF ! get number of items N = List % Size ! allocate storage for output IF ( List % SameType ()) THEN ALLOCATE ( Items ( N ), MOLD = List % Head % Item ) ELSE ! set output Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_GetAllItems' , ModName , ErrSevere , & 'Items does not have the same type.' ) RETURN END IF ! get items I = 0 CALL List % Traverse ( ItemIterator ) ! set flag Flag = TrueVal RETURN CONTAINS FUNCTION ItemIterator ( Item , Done ) RESULT ( ErrStat ) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( Object ), INTENT ( IN ) :: Item ! item tLogical , INTENT ( INOUT ) :: Done ! on input, Done is set to FalseVal ! on exit, set it to TrueVal if user !   want to stop the stack traversing. tLogical :: ErrStat ! true if error occurred in the user routine !** FLOW: ! set flag ErrStat = FalseVal Done = FalseVal ! get item I = I + 1 Items ( I ) = Item RETURN END FUNCTION ItemIterator !************************************************************************** END FUNCTION LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_Finalizer ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ListObject ), INTENT ( INOUT ) :: List !! ListObject object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! destroy all nodes and free up memory CALL List % Clear () RETURN END SUBROUTINE LinkedList_Finalizer !****************************************************************************** END MODULE MClass_ListObject !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listobject.f90.html"},{"title":"MClass_DArrRealDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrRealDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrRealDP* type and related routines. !   The *DArrRealDP* type is a container with *REAL(KIND=kDouble)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrRealDP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrRealDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrRealDP #define TypeAlloc       REAL(KIND=kDouble), ALLOCATABLE #define TypeArgmt       REAL(KIND=kDouble) #define TypeOfItem      REAL(KIND=kDouble) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrRealDP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrRealDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrrealdp.f90.html"},{"title":"MClass_DArrObject.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrObject !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrObject* type and related routines. !   The *DArrObject* type is a container with *CLASS(Object)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array.  All derived types extending from the !   *Object* type can be used with this container. <br> !   Unlike the <a href=\"../module/mclass_listassignable.html\">ListObject</a> type, !   the *DArrObject* type does not allow items with different types to be stored !   in the same container.  The *DArrObject* type requires a user to specify the !   type of items to be stored via the *Mold* argument when an empty container is !   created.  Alternatively, the user may implicitly specify the type of items to be !   stored via the *Items* argument when a container is constructed from an array !   of items.  Also, it is important to note that the type of an item specified in !   all other routines must be the same as the type of stored items of the container. !   Otherwise, the container may not behave as expected. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrObject* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *ModBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrObject PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrObject' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !> *DArrObject* is a container type that employs a dynamic-array implementation !  to provide common operations for a list container.  It can also represent other !  forms of containers including a LIFO stack, a FIFO queue and a double-ended queue !  (deque).  The type of items stored in this container is a derived type in the !  *Object* class (i.e. the *Object* type or its subtypes). TYPE DArrObject PRIVATE !> incremental size of the container when the container is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16 !% flag to shrink the container capacity tLogical :: Shrink = . FALSE . !% pointer to first item of the queue tIndex :: First = 1_kIndex !% pointer to next to last item of the queue (i.e. the next available slot) tIndex :: Last = 1_kIndex !% size of the container (number of items) tIndex :: Size = 0_kIndex !% pointer to current item of the iteration tIndex :: Cursor = 0_kIndex !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !% items stored in the container. CLASS ( Object ), ALLOCATABLE :: Items (:) CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Offset => DynArr_GetFirst PROCEDURE , PRIVATE :: Resize => DynArr_MemResize PROCEDURE , PRIVATE :: Growing => DynArr_Growing PROCEDURE , PRIVATE :: Shrinking => DynArr_Shrinking PROCEDURE , PRIVATE :: DynArr_CreateByArray ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty container. <br> !  **Usage**: <br> !   ! create an empty container with specified initial capacity and type of items to be stored <br> !   --->    CALL Container%CreateEmpty(25, Mold) <br> !   ! create a container and specify the optional incremental size <br> !   --->    CALL Container%CreateEmpty(25, Mold, IncSize=16) <br> !   ! create a container and specify the optional shrink flag <br> !   --->    CALL Container%CreateEmpty(25, Mold, Shrink=.TRUE.) PROCEDURE :: CreateEmpty => DynArr_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new container from an array of items. <br> !  **Usage**: <br> !           ! create a container from an array of 25 items <br> !   --->    CALL Container%Construct(25, Arr) <br> !           ! create a container and specify the optional incremental size <br> !   --->    CALL Container%Construct(25, Arr, IncSize=16) <br> !           ! create a container and specify the optional shrink flag <br> !   --->    CALL Container%Construct(25, Arr, Shrink=.TRUE.) GENERIC :: Construct => DynArr_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the container and free memory !                of items stored in the container.<br> !  **Usage**: <br> !   --->    CALL Container%Destruct() <br> !  **Important Note**:  For the *DynArr* class, this method is not equivalent !   to the *Clear* method.  Therefore, after calling the *Destruct* method, !   the user should reconstruct the container (by calling a *Construction* !   method again) before using other operations once more.  Otherwise, the !   container's behavior may not be as expected. PROCEDURE :: Destruct => DynArr_Destroy ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the container. <br> !  **Usage**: <br> !   --->    CALL Container%AddFirst(Item) PROCEDURE :: AddFirst => DynArr_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the container. <br> !  **Usage**: <br> !   --->    CALL Container%AddLast(Item) PROCEDURE :: AddLast => DynArr_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the container size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = Container%AddAt(Index, Item) <br> !   --->    IF (.NOT.Container%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => DynArr_AddAt !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the container. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveFirst(Item) <br> !   --->    IF (.NOT.Container%RemoveFirst(Item)) DoSomething PROCEDURE :: RemoveFirst => DynArr_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the container. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveLast(Item) <br> !   --->    IF (.NOT.Container%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DynArr_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the container size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Container%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => DynArr_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the container. <br> !  **Usage**: <br> !   --->    CALL Container%Delete() <br> !  **Note**: This method is intended to be used in conjunction with !   the *StartFirst* and *MoveForward* methods.  Therefore, after !   the call to one of those methods and then calling this one !   will result in a removal of the current item of the iteration !   (i.e. the same item that can be retrieved via the *StartFirst* !   and *MoveForward* methods). PROCEDURE :: Delete => DynArr_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the container. <br> !  **Usage**: <br> !   --->    CALL Container%Clear() PROCEDURE :: Clear => DynArr_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the container.  Also, return !                a flag indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Container%ToArray(Items) <br> !   --->    IF (.NOT.Container%ToArray(Items)) DoSomething PROCEDURE :: ToArray => DynArr_ToArray ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the container is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => DynArr_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the container or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the container. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = Container%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Container%MoveForward() !       ! check whether we reach the end of the container or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the container. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = Container%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Container%MoveForward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveForward => DynArr_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the container is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => DynArr_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return !                a flag indicating whether the cursor pointer has reached the !                end of the container or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the container in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Container%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Container%MoveBackward() !       ! check whether we reach the end of the container or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the container in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Container%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Container%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DynArr_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the container. <br> !  **Usage**: <br> !   --->    Size = Container%GetSize() PROCEDURE :: GetSize => DynArr_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the container is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Container%IsEmpty() <br> !   --->    IF (.NOT.Container%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => DynArr_IsEmpty ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekFirst(Item) <br> !   --->    IF (.NOT.Container%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => DynArr_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekLast(Item) <br> !   --->    IF (.NOT.Container%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DynArr_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the container) at !                the specified index where the index must be between 1 and the !                container size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Container%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => DynArr_PeekAt !> *GetAll* is a procedure deferred by the *BaseIterable* type. <br> !  **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the container. !                Also, return a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Container%GetAll(Items) <br> !   --->    IF (.NOT.Container%GetAll(Items)) DoSomething PROCEDURE :: GetAll => DynArr_GetAll ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => DynArr_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => DynArr_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => DynArr_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => DynArr_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => DynArr_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: DynArr_Finalizer ! --------------------------------------------------------------------- END TYPE DArrObject !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- SUBROUTINE DynArr_MemResize ( Container , NewSize ) !** PURPOSE OF THIS SUBROUTINE: !! To re-allocate the array of items of the container and preserve its data !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object tIndex , INTENT ( IN ) :: NewSize !! new size of array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Offset tIndex :: OldSize ! original size of array tIndex :: PSize ! size of preserved data CLASS ( Object ), ALLOCATABLE :: Temp (:) ! temporary buffer !** FLOW: ! determine the original size and length of character string OldSize = SIZE ( Container % Items ) ! first, allocate the temporary array ALLOCATE ( Temp ( NewSize ), MOLD = Container % Items ( 1 )) ! determine the preserving size IF ( NewSize >= OldSize ) THEN PSize = OldSize ELSE PSize = NewSize END IF ! get offset Offset = Container % Offset () ! *** copy items to the temporary buffer *** IF ( Offset == 1_kIndex ) THEN ! use whole array expression (typical for a stack) Temp ( 1 : PSize ) = Container % Items ( 1 : PSize ) ELSE ! use do loop (typical for a deque or a queue) BLOCK tIndex :: I , J ! get offset to the first item J = Offset DO I = 1_kIndex , PSize ! copy an item to the buffer Temp ( I ) = Container % Items ( J ) ! update J and wrap around if necessary J = J + 1_kIndex IF ( J > OldSize ) J = 1_kIndex END DO END BLOCK END IF ! move data from the temporary array back to the array ! (this operation includes deallocate the array, reallocate it to !  the new size and copy data back) CALL MOVE_ALLOC ( Temp , Container % Items ) RETURN END SUBROUTINE DynArr_MemResize !************************************************************************************** SUBROUTINE DynArr_Growing ( Container ) !** PURPOSE OF THIS SUBROUTINE: !! To increase the container's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity !** FLOW: IF (. NOT . ALLOCATED ( Container % Items )) THEN ! the container has not yet been constructed so report error CALL Handle_ErrLevel ( 'DynArr_Growing' , ModName , ErrSevere , & 'The container has not yet been constructed.' ) ELSE Capacity = SIZE ( Container % Items ) IF ( Container % GetSize () == Capacity ) THEN ! increase the container's capacity IF ( Container % IncSize > 0 ) THEN Capacity = Capacity + Container % IncSize ELSE Capacity = Capacity * 2 END IF ! check integer overflow IF ( Capacity <= 0 ) Capacity = MaxCapacity ! resize the containers' items CALL Container % Resize ( Capacity ) END IF END IF RETURN END SUBROUTINE DynArr_Growing !************************************************************************************** SUBROUTINE DynArr_Shrinking ( Container ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease the container's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurCap , CurSize !** FLOW: IF (. NOT . ALLOCATED ( Container % Items )) THEN ! the container has not yet been constructed so simply return. RETURN END IF IF ( Container % Shrink ) THEN CurCap = SIZE ( Container % Items ) CurSize = Container % GetSize () IF (( CurSize >= 0 ). AND .( CurSize <= CurCap / 4 )) THEN ! halves the container's capacity CurCap = CurCap / 2 ! check if the capacity is zero or not IF ( CurCap <= 0 ) CurCap = 1 ! resize the containers' items CALL Container % Resize ( CurCap ) END IF END IF RETURN END SUBROUTINE DynArr_Shrinking !************************************************************************************** FUNCTION DynArr_GetFirst ( Container ) RESULT ( First ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get an index pointing to the first item. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container tIndex :: First !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set index to the first item First = Container % First ! reset index pointers of the container Container % First = 1_kIndex Container % Last = Container % Size + 1_kIndex RETURN END FUNCTION DynArr_GetFirst !****************************************************************************** FUNCTION IsIndexValid ( Size , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified index is between 1 and the container size or not. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Size !! the container size tIndex , INTENT ( IN ) :: Index !! the specified index tLogical :: Flag !! true if the index is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal IF ( Index < 1 ) RETURN IF ( Index > Size ) RETURN Flag = TrueVal RETURN END FUNCTION IsIndexValid !************************************************************************************** FUNCTION ComputeTrueIndex ( Container , Index ) RESULT ( ID ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the actual index of the container's items based on the specified index. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( IN ) :: Container !% the specified index tIndex , INTENT ( IN ) :: Index !% the actual index of the container's items tIndex :: ID !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ID = Index + Container % First - 1_kIndex IF ( Container % First >= Container % Last ) THEN BLOCK tIndex :: Capacity Capacity = SIZE ( Container % Items , KIND = kIndex ) IF ( ID > Capacity ) THEN ID = ID - Capacity END IF END BLOCK END IF RETURN END FUNCTION ComputeTrueIndex !************************************************************************************** SUBROUTINE MoveItemsRight ( Container , Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move the container's items to the right of the specified index. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the one-based index into the container's items tIndex , INTENT ( IN ) :: Index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Cap ! FLOW ! initialize local variables I = Container % Last - 1_kIndex Cap = SIZE ( Container % Items , KIND = kIndex ) ! move items as necessary DO IF ( I < Index ) EXIT IF ( I == 0_kIndex ) THEN Container % Items ( 1_kIndex ) = Container % Items ( Cap ) I = Cap - 1_kIndex ELSE Container % Items ( I + 1_kIndex ) = Container % Items ( I ) I = I - 1_kIndex END IF END DO RETURN END SUBROUTINE MoveItemsRight !************************************************************************************** SUBROUTINE MoveItemsLeft ( Container , Index ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move the container's items to the left of the specified index. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the one-based index into the container's items tIndex , INTENT ( IN ) :: Index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , Cap , Last ! FLOW ! initialize local variables I = Index Cap = SIZE ( Container % Items , KIND = kIndex ) Last = Container % Last - 1_kIndex IF ( Last == 0_kIndex ) Last = Cap ! move items as necessary DO IF ( I == Last ) EXIT IF ( I == Cap ) THEN Container % Items ( Cap ) = Container % Items ( 1_kIndex ) I = 1_kIndex ELSE Container % Items ( I ) = Container % Items ( I + 1_kIndex ) I = I + 1_kIndex END IF END DO RETURN END SUBROUTINE MoveItemsLeft ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- SUBROUTINE DynArr_CreateEmpty ( Container , InitCap , Mold , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !! To create an empty container. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object tIndex , INTENT ( IN ) :: InitCap !! initial size of the container CLASS ( Object ), INTENT ( IN ) :: Mold !! mold providing the type of items to be stored tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of the container when it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the container capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1 ) THEN CALL Handle_ErrLevel ( 'DynArr_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity to 16.' ) Capacity = Container % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the items in the container ALLOCATE ( Container % Items ( Capacity ), MOLD = Mold ) ! finally, check optional input data Container % IncSize = 0 IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0 ) Container % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) Container % Shrink = Shrink RETURN END SUBROUTINE DynArr_CreateEmpty !****************************************************************************** SUBROUTINE DynArr_CreateByArray ( Container , N , Items , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a container from an array of items. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object tIndex , INTENT ( IN ) :: N !! number of items CLASS ( Object ), INTENT ( IN ) :: Items (:) !! the items to be added to the container tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of the container when it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the container capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! create empty stack InitCap = N * 2 ! by default, doubling its capacity IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0 ) InitCap = N + IncSize END IF CALL Container % CreateEmpty ( InitCap , Items ( 1 ), IncSize , Shrink ) ! add items to the container DO I = 1 , N CALL Container % AddLast ( Items ( I )) END DO RETURN END SUBROUTINE DynArr_CreateByArray !****************************************************************************** SUBROUTINE DynArr_Destroy ( Container ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I !** FLOW: ! remove all items CALL Container % Clear () ! free storage memory DO I = 1_kIndex , SIZE ( Container % Items , KIND = kIndex ) CALL Container % Items ( I )% MemFree () END DO DEALLOCATE ( Container % Items ) RETURN END SUBROUTINE DynArr_Destroy ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- SUBROUTINE DynArr_AddLast ( Container , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the specified item at the end of the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be added to the container CLASS ( Object ), INTENT ( IN ) :: Item !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN ! report error CALL Handle_ErrLevel ( 'DynArr_AddLast' , ModName , ErrSevere , & 'Type of input item is not valid.' ) RETURN END IF ! first, grow the container capacity if necessary CALL Container % Growing () ! then, add new item to the container Container % Items ( Container % Last ) = Item ! next, update pointer (wrap around if necessary) and size Container % Last = Container % Last + 1_kIndex IF ( Container % Last > SIZE ( Container % Items , KIND = kIndex )) Container % Last = 1_kIndex Container % Size = Container % Size + 1_kIndex RETURN END SUBROUTINE DynArr_AddLast !************************************************************************************** SUBROUTINE DynArr_AddFirst ( Container , Item ) !** PURPOSE OF THIS SUBROUTINE: !! To insert the specified item at the front of the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be added to the container CLASS ( Object ), INTENT ( IN ) :: Item !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN ! report error CALL Handle_ErrLevel ( 'DynArr_AddFirst' , ModName , ErrSevere , & 'Type of input item is not valid.' ) RETURN END IF ! first, grow the container capacity if necessary CALL Container % Growing () ! then, update pointer (wrap around if necessary) and size Container % First = Container % First - 1_kIndex IF ( Container % First == 0_kIndex ) Container % First = SIZE ( Container % Items , KIND = kIndex ) Container % Size = Container % Size + 1_kIndex ! finally, add new item to the container Container % Items ( Container % First ) = Item RETURN END SUBROUTINE DynArr_AddFirst !************************************************************************************** FUNCTION DynArr_AddAt ( Container , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the specified item at the specified index where the index must be !  between 1 and the container size.  Also, return a flag indicating whether !  the item is successfully added. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the one-based index into the container's items tIndex , INTENT ( IN ) :: Index !% the item to be added to the container CLASS ( Object ), INTENT ( IN ) :: Item !> flag indicating whether the item is successfully added. <br> ! - true if the item is successfully added. ! - false if the item is NOT successfully added. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: ID ! FLOW IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN ! report error CALL Handle_ErrLevel ( 'DynArr_AddAt' , ModName , ErrSevere , & 'Type of input item is not valid.' ) RETURN END IF ! check the validity of the specified index Flag = FalseVal IF (. NOT . IsIndexValid ( Container % Size , Index )) RETURN ! first, grow the container capacity if necessary CALL Container % Growing () ! compute the actual index of the container's items ID = ComputeTrueIndex ( Container , Index ) ! move the container's items to the right of ID CALL MoveItemsRight ( Container , ID ) ! then, add new item to the container Container % Items ( ID ) = Item ! next, update pointer (wrap around if necessary) and size Container % Last = Container % Last + 1_kIndex IF ( Container % Last > SIZE ( Container % Items , KIND = kIndex )) Container % Last = 1_kIndex Container % Size = Container % Size + 1_kIndex ! set output flag Flag = TrueVal RETURN END FUNCTION DynArr_AddAt !************************************************************************************** FUNCTION DynArr_RemoveLast ( Container , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the last item of the container.  Also, return ! a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be removed from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the container is NOT empty. ! - false if the container is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Last ! FLOW ! check whether the container is empty or not IF ( Container % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'DynArr_RemoveLast' , ModName , ErrSevere , & 'Type of output item is not valid.' ) RETURN END IF Flag = TrueVal END IF ! set index pointer to the last item (wrap around if necessary) Last = Container % Last - 1_kIndex IF ( Last == 0_kIndex ) Last = SIZE ( Container % Items , KIND = kIndex ) ! get the last item Item = Container % Items ( Last ) ! update the last pointer (wrap around if necessary) and size Container % Last = Container % Last - 1_kIndex IF ( Container % Last == 0_kIndex ) Container % Last = SIZE ( Container % Items , KIND = kIndex ) Container % Size = Container % Size - 1_kIndex ! shrink the container if necessary CALL Container % Shrinking () RETURN END FUNCTION DynArr_RemoveLast !************************************************************************************** FUNCTION DynArr_RemoveFirst ( Container , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the first item of the container.  Also, return ! a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be removed from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the container is NOT empty. ! - false if the container is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the container is empty or not IF ( Container % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'DynArr_RemoveFirst' , ModName , ErrSevere , & 'Type of output item is not valid.' ) RETURN END IF Flag = TrueVal END IF ! get the first item Item = Container % Items ( Container % First ) ! update the first pointer (wrap around if necessary) and size Container % First = Container % First + 1_kIndex IF ( Container % First > SIZE ( Container % Items , KIND = kIndex )) Container % First = 1_kIndex Container % Size = Container % Size - 1_kIndex ! shrink the container if necessary CALL Container % Shrinking () RETURN END FUNCTION DynArr_RemoveFirst !************************************************************************************** FUNCTION DynArr_RemoveAt ( Container , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the item at the specified index where the index must be !  between 1 and the container size.  Also, return a flag indicating whether !  the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the one-based index into the container's items tIndex , INTENT ( IN ) :: Index !% the item to be removed from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the item is successfully removed. ! - false if the item is NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: ID ! FLOW ! check whether the item is available or not Flag = FalseVal IF ( Container % IsEmpty ()) RETURN IF (. NOT . IsIndexValid ( Container % Size , Index )) RETURN IF (. NOT . SAME_TYPE_AS ( Item , Container % Items ( 1 ))) THEN ! report error CALL Handle_ErrLevel ( 'DynArr_RemoveAt' , ModName , ErrSevere , & 'Type of output item is not valid.' ) RETURN END IF ! compute the actual index of the container's items ID = ComputeTrueIndex ( Container , Index ) ! get the item Item = Container % Items ( ID ) ! move the container's items to the left of ID CALL MoveItemsLeft ( Container , ID ) ! update pointer (wrap around if necessary) and size Container % Last = Container % Last - 1_kIndex IF ( Container % Last == 0_kIndex ) Container % Last = SIZE ( Container % Items , KIND = kIndex ) Container % Size = Container % Size - 1_kIndex ! shrink the container if necessary CALL Container % Shrinking () ! set output flag Flag = TrueVal RETURN END FUNCTION DynArr_RemoveAt !************************************************************************************** SUBROUTINE DynArr_ClearItems ( Container ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! reset pointer indices Container % First = 1_kIndex Container % Last = 1_kIndex Container % Cursor = 0_kIndex Container % Size = 0_kIndex Container % Dir = 0 ! shrink the container CALL Container % Shrinking () RETURN END SUBROUTINE DynArr_ClearItems !************************************************************************************** SUBROUTINE DynArr_Delete ( Container ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete an item from a container.  This procedure is intended !  to be used in conjunction with the *StartFirst* and *MoveForward* !  methods.  Therefore, after the call to one of the methods and then !  calling this procedure will result in a removal of the current item !  of the iteration (i.e. the same item that can be retrieved via those !  methods). !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! return immediately if the container is empty IF ( Container % IsEmpty ()) RETURN ! return immediately if the cursor is not in a valid position IF ( Container % Cursor == 0_kIndex ) RETURN IF ( Container % First < Container % Last ) THEN IF (( Container % Cursor < Container % First ). OR . & ( Container % Cursor >= Container % Last )) RETURN ELSE IF (( Container % Cursor < Container % First ). AND . & ( Container % Cursor >= Container % Last )) RETURN END IF ! the cursor is in a valid position Delete_Block : BLOCK ! block variables tIndex :: I , Cap , Last ! initialize block variables I = Container % Cursor Cap = SIZE ( Container % Items , KIND = kIndex ) Last = Container % Last - 1_kIndex IF ( Last == 0_kIndex ) Last = Cap ! move items as necessary DO IF ( I == Last ) EXIT IF ( I == Cap ) THEN Container % Items ( Cap ) = Container % Items ( 1_kIndex ) I = 1_kIndex ELSE Container % Items ( I ) = Container % Items ( I + 1_kIndex ) I = I + 1_kIndex END IF END DO ! update the last pointer and size Container % Last = Last Container % Size = Container % Size - 1_kIndex ! shrink the container if necessary CALL Container % Shrinking () ! reset cursor Cap = SIZE ( Container % Items , KIND = kIndex ) ! reset cursor IF ( Container % Dir == 1 ) THEN ! forward iteration so move cursor backward Container % Cursor = Container % Cursor - 1_kIndex IF ( Container % Cursor == 0_kIndex ) Container % Cursor = Cap ELSE ! backward iteration so move cursor forward Container % Cursor = Container % Cursor + 1_kIndex IF ( Container % Cursor == Cap ) Container % Cursor = 0_kIndex END IF END BLOCK Delete_Block RETURN END SUBROUTINE DynArr_Delete !************************************************************************************** FUNCTION DynArr_ToArray ( Container , Items ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all items from the container.  Also, return !  a flag indicating whether the items are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be removed from the container CLASS ( Object ), ALLOCATABLE , INTENT ( OUT ) :: Items (:) !> flag indicating whether the items are successfully removed. <br> ! - true if the items are successfully removed. ! - false if the items are NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Flag = Container % GetAll ( Items ) ! remove all items CALL Container % Clear () END FUNCTION DynArr_ToArray ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- FUNCTION DynArr_Move2FirstElm ( Container , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the front (first) element in the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the first element as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the container contains no element or not <br> ! - true if the container is empty. <br> ! - otherwise the first element is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor pointer Container % Cursor = Container % First ! set return flag IsEmpty = ( Container % Size == 0_kIndex ) ! set direction IF (. NOT . IsEmpty ) Container % Dir = 1 IF ((. NOT . IsEmpty ). AND . PRESENT ( Item )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Container % Cursor ))) THEN ! get item Item = Container % Items ( Container % Cursor ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_Move2FirstElm' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF END IF RETURN END FUNCTION DynArr_Move2FirstElm !************************************************************************************** FUNCTION DynArr_Move2NextElm ( Container , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move (backward) to the next element in the container. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the next element as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the move to the end of the container occurs or not <br> ! - true if next element is NOT available. <br> ! - otherwise next element is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if empty IF ( Container % IsEmpty ()) THEN IsTheEnd = TrueVal RETURN END IF ! set cursor pointer and wrap around if necessary Container % Cursor = Container % Cursor + 1_kIndex IF ( Container % Cursor > SIZE ( Container % Items , KIND = kIndex )) Container % Cursor = 1_kIndex ! set return flag IsTheEnd = ( Container % Cursor == Container % Last ) ! set direction IF (. NOT . IsTheEnd ) THEN Container % Dir = 1 ELSE Container % Dir = 0 END IF IF ((. NOT . IsTheEnd ). AND . PRESENT ( Item )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Container % Cursor ))) THEN ! get item Item = Container % Items ( Container % Cursor ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_Move2NextElm' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF END IF RETURN END FUNCTION DynArr_Move2NextElm !************************************************************************************** FUNCTION DynArr_Move2LastElm ( Container , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the last element in the container. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the last element as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the container contains no element or not <br> ! - true if the container is empty. <br> ! - otherwise the last element is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set return flag IsEmpty = ( Container % Size == 0_kIndex ) ! simply return if empty IF ( IsEmpty ) RETURN ! set cursor pointer (note: Container%Last points to the next to last item) ! and wrap around if necessary Container % Cursor = Container % Last - 1_kIndex IF ( Container % Cursor == 0_kIndex ) Container % Cursor = SIZE ( Container % Items , KIND = kIndex ) ! set direction IF (. NOT . IsEmpty ) Container % Dir = - 1 IF ((. NOT . IsEmpty ). AND . PRESENT ( Item )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Container % Cursor ))) THEN ! get item Item = Container % Items ( Container % Cursor ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_Move2LastElm' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF END IF RETURN END FUNCTION DynArr_Move2LastElm !************************************************************************************** FUNCTION DynArr_Move2PrevElm ( Container , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the previous element in the container. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the previous element as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the move to the end of the container occurs or not <br> ! - true if previous element is NOT available. <br> ! - otherwise previous element is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if empty IF ( Container % IsEmpty ()) THEN IsTheEnd = TrueVal RETURN END IF ! set return flag IsTheEnd = ( Container % Cursor == Container % First ) ! set cursor pointer and wrap around if necessary Container % Cursor = Container % Cursor - 1_kIndex IF ( Container % Cursor == 0_kIndex ) Container % Cursor = SIZE ( Container % Items , KIND = kIndex ) ! set direction IF (. NOT . IsTheEnd ) THEN Container % Dir = - 1 ELSE Container % Dir = 0 END IF IF ((. NOT . IsTheEnd ). AND . PRESENT ( Item )) THEN ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Container % Cursor ))) THEN ! get item Item = Container % Items ( Container % Cursor ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_Move2PrevElm' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF END IF RETURN END FUNCTION DynArr_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- FUNCTION DynArr_IsEmpty ( Container ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the container is currently empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( IN ) :: Container !! DynArr object tLogical :: Flag !! true if the container currently contains no item. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Container % GetSize () == 0 ) RETURN END FUNCTION DynArr_IsEmpty !****************************************************************************** FUNCTION DynArr_GetSize ( Container ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of items in the container. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DArrObject ), INTENT ( IN ) :: Container tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Container % Size RETURN END FUNCTION DynArr_GetSize ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- FUNCTION DynArr_PeekFirst ( Container , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the front (first) item (without removing it from the container). !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( IN ) :: Container !% the item to be retrieved from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the container is NOT empty. ! - false if the container is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the container is empty or not IF ( Container % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Container % First ))) THEN ! get the top item Item = Container % Items ( Container % First ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_PeekFirst' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF RETURN END FUNCTION DynArr_PeekFirst !************************************************************************************** FUNCTION DynArr_PeekLast ( Container , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the last item (without removing it from the container). !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( IN ) :: Container !% the item to be retrieved from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the container is NOT empty. ! - false if the container is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Last ! FLOW ! check whether the container is empty or not IF ( Container % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! set index pointer to the last item (wrap around if necessary) Last = Container % Last - 1_kIndex IF ( Last == 0_kIndex ) Last = SIZE ( Container % Items , KIND = kIndex ) ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( Last ))) THEN ! get the last item Item = Container % Items ( Last ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_PeekFirst' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF RETURN END FUNCTION DynArr_PeekLast !************************************************************************************** FUNCTION DynArr_PeekAt ( Container , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the item (without removing it from the container) at the specified index !  where the index must be between 1 and the container size.  Also, return a flag !  indicating whether the item is available or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( IN ) :: Container !% the one-based index into the container's items tIndex , INTENT ( IN ) :: Index !% the item to be retrieved from the container CLASS ( Object ), INTENT ( INOUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the item is available. ! - false if the item is NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: ID ! FLOW ! check whether the item is available or not Flag = FalseVal IF ( Container % IsEmpty ()) RETURN IF (. NOT . IsIndexValid ( Container % Size , Index )) RETURN ! compute the actual index of the container's items ID = ComputeTrueIndex ( Container , Index ) ! check whether the types of items are the same or not IF ( SAME_TYPE_AS ( Item , Container % Items ( ID ))) THEN ! get the item Item = Container % Items ( ID ) ELSE ! report error CALL Handle_ErrLevel ( 'DynArr_PeekFirst' , ModName , ErrWarning , & 'Type of output item is not valid.' ) END IF ! set output flag Flag = TrueVal RETURN END FUNCTION DynArr_PeekAt !************************************************************************************** FUNCTION DynArr_GetAll ( Container , Items ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all items (without removing them) from the container.  Also, !  return a flag indicating whether the items are available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% DynArr object CLASS ( DArrObject ), INTENT ( INOUT ) :: Container !% the item to be removed from the container CLASS ( Object ), ALLOCATABLE , INTENT ( OUT ) :: Items (:) !> flag indicating whether the items are successfully removed. <br> ! - true if the items are available. ! - false if the items are NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , N ! FLOW ! check whether the container is empty or not IF ( Container % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! get items from the container N = Container % Size ! allocate storage for output ALLOCATE ( Items ( N ), MOLD = Container % Items ( 1 )) ! get items from the container J = Container % First DO I = 1 , N Items ( I ) = Container % Items ( J ) J = J + 1_kIndex IF ( J > SIZE ( Container % Items , KIND = kIndex )) J = 1_kIndex END DO RETURN END FUNCTION DynArr_GetAll ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- SUBROUTINE DynArr_Finalizer ( Container ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DArrObject ), INTENT ( INOUT ) :: Container !! DynArr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! remove all items and free up memory CALL Container % Destruct () RETURN END SUBROUTINE DynArr_Finalizer !****************************************************************************** END MODULE MClass_DArrObject !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrobject.f90.html"},{"title":"MClass_PQHeap.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQHeap !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQHeap* type and its related routines.  The *PQHeap* !   type is a priority-queue container where the type of its stored keys is in the !   *Comparable* class (i.e. a concrete subtype of the *Comparable* type).  It uses !   a binary heap implementation to order its stored keys. <br> !   The *PQHeap* type can represent either a max-priority queue or a min-priority !   queue.  By default, it represents the max-priority queue but a user can specify !   the *MinPQ* argument to true so that it represents the min-priority queue instead. <br> !   It should be noted that the *PQHeap* type does not allow keys with different types !   to be stored in the same container.  The *PQHeap* type requires a user to specify !   the type of keys to be stored via the *Mold* argument when an empty container is !   created.  Alternatively, the user may implicitly specify the type of keys to be !   stored via the *Keys* argument when a container is constructed from an array of !   keys.  Also, it is important to note that the type of a key specified in all other !   routines must be the same as the type of stored keys of the container.  Otherwise, !   the container may not behave as expected. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_Comparable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQ_Heap PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     CLASS(Comparable) #define     PQHeap      PQ_Heap !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQHeap' !** DERIVED TYPE DEFINITIONS !> The *PQHeap* type is a container type that employs a binary heap implementation !  to provide common operations for a priority queue. TYPE PQHeap PRIVATE !% pointer to last item of the priority queue tIndex :: Last = 0_kIndex !% incremental size of priority queue if it is full tIndex :: IncSize = 16_kIndex !% flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> flag indicating whether the priority queue is implemented as !  a maximum PQ or a minimum PQ. <br> !  default -> a maximum PQ. tLogical :: Min = FalseVal !% stored keys in the priority queue. KeyType , ALLOCATABLE :: Keys (:) !% temporary key. KeyType , ALLOCATABLE :: Temp CONTAINS ! --------------------------------------------------------------------- ! -----                      Public Procedures                    ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap, Mold)                   ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)          ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)            ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)         ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE.)    ! specify all options <br> PROCEDURE :: CreateEmpty => PQHeap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL PQ%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> PROCEDURE :: Construct => PQHeap_ConstructorByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all stored keys and free all memory currently used by the priority !       queue.  Optionally, stored keys can be retrieved. <br> !  **Usage**: <br> !   --->    CALL PQ%Destruct() <br> !   --->    CALL PQ%Destruct(StoredKeys) <br> PROCEDURE :: Destruct => PQHeap_Destructor ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%Insert(Key) <br> PROCEDURE :: Insert => PQHeap_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Remove(Key) <br> !   --->    IF (.NOT.PQ%Remove(Key)) DoSomething PROCEDURE :: Remove => PQHeap_RemoveKey ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the priority queue is empty or not. <br> !  **Usage**: <br> !   --->    Flag = PQ%IsEmpty() <br> !   --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => PQHeap_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (number of stored keys) of the priority queue. <br> !  **Usage**: <br> !   --->    Size = PQ%GetSize() PROCEDURE :: GetSize => PQHeap_GetSize !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Peek(Key) <br> !   --->    IF (.NOT.PQ%Peek(Key)) DoSomething PROCEDURE :: Peek => PQHeap_PeekKey ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQHeap_Finalizer ! --------------------------------------------------------------------- END TYPE PQHeap !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                           Routines for PQHeap !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE PQHeap_CreateEmpty ( PQ , InitCap , Mold , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object tIndex , INTENT ( IN ) :: InitCap !! initial size of priority queue KeyType , INTENT ( IN ) :: Mold !! mold tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQHeap_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity of priority queue to 16.' ) Capacity = PQ % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the keys in the priority queue CALL MemAlloc ( PQ % Keys , Capacity , Mold ) ! finally, check optional input data IF ( PRESENT ( MinPQ )) PQ % Min = MinPQ IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) PQ % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) PQ % Shrink = Shrink RETURN END SUBROUTINE PQHeap_CreateEmpty !****************************************************************************** SUBROUTINE PQHeap_ConstructorByArray ( PQ , N , Keys , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a priority queue from an array of key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object tIndex , INTENT ( IN ) :: N !! number of keys KeyType , INTENT ( IN ) :: Keys ( N ) !! key array tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! simply return if N is less than 1 IF ( N <= 0_kIndex ) RETURN ! create empty priority queue IF ( PRESENT ( IncSize )) THEN InitCap = N + IncSize ELSE InitCap = N + PQ % IncSize END IF CALL PQ % CreateEmpty ( InitCap , Keys ( 1 ), MinPQ , IncSize , Shrink ) ! add input keys to the priority queue DO I = 1_kIndex , N CALL PQ % Insert ( Keys ( I )) END DO RETURN END SUBROUTINE PQHeap_ConstructorByArray !****************************************************************************** SUBROUTINE PQHeap_Destructor ( PQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct PQHeap object and get its keys if requested. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object KeyType , ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , ID tLogical :: Success ! FLOW IF (. NOT . PQ % IsEmpty ()) THEN IF ( PRESENT ( Keys )) THEN ! get keys (and free memory of components of keys if applicable) N = PQ % Last CALL MemAlloc ( Keys , N , PQ % Keys ( 1 )) DO ID = 1_kIndex , N Success = PQ % Remove ( Keys ( ID )) END DO END IF END IF ! reset components PQ % Last = 0_kIndex PQ % IncSize = 10_kIndex PQ % Shrink = FalseVal PQ % Min = FalseVal ! free memory of priority queue keys CALL MemFree ( PQ % Keys ) RETURN END SUBROUTINE PQHeap_Destructor !****************************************************************************** SUBROUTINE PQHeap_Finalizer ( PQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free up memory and reset components CALL PQ % Destruct () RETURN END SUBROUTINE PQHeap_Finalizer !****************************************************************************** SUBROUTINE PQHeap_InsertKey ( PQ , NewKey ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new key to the top (or bottom) of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object KeyType , INTENT ( IN ) :: NewKey !! new key to be added to the priority queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW IF (. NOT . SAME_TYPE_AS ( NewKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQHeap_InsertKey' , ModName , ErrWarning , & 'Type of the inserted key must be the same as that of stored keys.' ) RETURN END IF ! check capacity of the priority queue Capacity = SIZE ( PQ % Keys ) IF ( PQ % Last == Capacity ) THEN ! increase the priority queue capacity Capacity = Capacity + PQ % IncSize ! resize the priority queue CALL MemResize ( PQ % Keys , Capacity ) END IF ! increment the pointer PQ % Last = PQ % Last + 1_kIndex ! then, add new key to the priority queue PQ % Keys ( PQ % Last ) = NewKey ! restore heap order CALL ReHeapify_BottomUp ( PQ , PQ % Last ) #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( PQ , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQHeap_InsertKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif RETURN END SUBROUTINE PQHeap_InsertKey !****************************************************************************** FUNCTION PQHeap_RemoveKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object KeyType , INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW IF (. NOT . SAME_TYPE_AS ( HPKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQHeap_RemoveKey' , ModName , ErrWarning , & 'Type of the retrieved key must be the same as that of stored keys.' ) Flag = FalseVal RETURN END IF ! first, check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! get the highest-priority key HPKey = PQ % Keys ( 1 ) !--- remove the highest-priority key from the queue --- ! swap the highest-priority key with the last one ASSOCIATE ( Temp => PQ % Temp ) Temp = PQ % Keys ( 1 ) EXCHANGE ( PQ % Keys , 1_kIndex , PQ % Last ) END ASSOCIATE ! update pointer PQ % Last = PQ % Last - 1_kIndex ! restore heap order CALL ReHeapify_TopDown ( PQ , 1_kIndex , PQ % Last ) ! shrink capacity of the priority queue if necessary IF ( PQ % Shrink ) THEN Capacity = SIZE ( PQ % Keys , KIND = kIndex ) IF (( PQ % Last > 0_kIndex ). AND .( PQ % Last == Capacity / 4_kIndex )) THEN ! reduce the priority queue capacity Capacity = Capacity / 2_kIndex ! resize the priority queue CALL MemResize ( PQ % Keys , Capacity ) END IF END IF #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( PQ , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQHeap_RemoveKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif RETURN END FUNCTION PQHeap_RemoveKey !****************************************************************************** FUNCTION PQHeap_IsEmpty ( PQ ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the priority queue is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( IN ) :: PQ !! PQHeap object tLogical :: Flag !! true if the priority queue is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( PQ % Last == 0_kIndex ) RETURN END FUNCTION PQHeap_IsEmpty !****************************************************************************** FUNCTION PQHeap_GetSize ( PQ ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( IN ) :: PQ !! PQHeap object tIndex :: Size !! size (number of keys) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = PQ % Last RETURN END FUNCTION PQHeap_GetSize !****************************************************************************** FUNCTION PQHeap_PeekKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object KeyType , INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . SAME_TYPE_AS ( HPKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQHeap_PeekKey' , ModName , ErrWarning , & 'Type of the retrieved key must be the same as that of stored keys.' ) Flag = FalseVal RETURN END IF ! check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = TrueVal ! get the highest-priority key HPKey = PQ % Keys ( 1 ) END IF RETURN END FUNCTION PQHeap_PeekKey !****************************************************************************** SUBROUTINE ReHeapify_TopDown ( PQ , Start , Bottom ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by sinking down !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object tIndex , INTENT ( IN ) :: Start !! starting index tIndex , INTENT ( IN ) :: Bottom !! ending index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J !** FLOW: ASSOCIATE ( Temp => PQ % Temp ) Temp = PQ % Keys ( Start ) I = Start J = I + I ! do while j <= bottom IF ( PQ % Min ) THEN ! for MinPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( PQ % Keys ( J ) > PQ % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( PQ % Keys ( J ) >= Temp ) EXIT ! otherwise, demote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I + I END DO ELSE ! for MaxPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( PQ % Keys ( J ) < PQ % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( PQ % Keys ( J ) <= Temp ) EXIT ! otherwise, demote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I + I END DO END IF ! put key into its slot. PQ % Keys ( I ) = Temp END ASSOCIATE RETURN END SUBROUTINE ReHeapify_TopDown !****************************************************************************** SUBROUTINE ReHeapify_BottomUp ( PQ , Start ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by swimming up. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( INOUT ) :: PQ !! PQHeap object tIndex , INTENT ( IN ) :: Start !! starting index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J !** FLOW: ASSOCIATE ( Temp => PQ % Temp ) Temp = PQ % Keys ( Start ) I = Start J = I / 2 ! do while k > 1 and key(k/2) < key(k) IF ( PQ % Min ) THEN ! for MinPQ DO WHILE (( I > 1 ). AND .( PQ % Keys ( J ) > Temp )) ! promote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I / 2 END DO ELSE ! for MaxPQ DO WHILE (( I > 1 ). AND .( PQ % Keys ( J ) < Temp )) ! promote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I / 2 END DO END IF ! put key into its slot. PQ % Keys ( I ) = Temp END ASSOCIATE RETURN END SUBROUTINE ReHeapify_BottomUp !****************************************************************************** RECURSIVE FUNCTION IsHeapOrdered ( PQ , Start ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether the heap is in order or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQHeap ), INTENT ( IN ) :: PQ !! PQHeap object tIndex , INTENT ( IN ) :: Start !! starting index tLogical :: Flag !! true if the heap is in order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Left , Right !** FLOW: IF ( Start > PQ % Last ) THEN Flag = TrueVal RETURN END IF Left = Start + Start Right = Left + 1 IF ( PQ % Min ) THEN ! for MinPQ IF (( Left <= PQ % Last ) . AND . ( PQ % Keys ( Start ) > PQ % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= PQ % Last ) . AND . ( PQ % Keys ( Start ) > PQ % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF ELSE ! for MaxPQ IF (( Left <= PQ % Last ) . AND . ( PQ % Keys ( Start ) < PQ % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= PQ % Last ) . AND . ( PQ % Keys ( Start ) < PQ % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF END IF Flag = ( IsHeapOrdered ( PQ , Left ) . AND . IsHeapOrdered ( PQ , Right )) RETURN END FUNCTION IsHeapOrdered !****************************************************************************** END MODULE MClass_PQHeap !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqheap.f90.html"},{"title":"MClass_DArrCmpxDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrCmpxDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrCmpxDP* type and related routines. !   The *DArrCmpxDP* type is a container with *COMPLEX(KIND=kDouble)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrCmpxDP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrCmpxDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrCmpxDP #define TypeAlloc       COMPLEX(KIND=kDouble), ALLOCATABLE #define TypeArgmt       COMPLEX(KIND=kDouble) #define TypeOfItem      COMPLEX(KIND=kDouble) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrCmpxDP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrCmpxDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrcmpxdp.f90.html"},{"title":"MClass_PQInteger2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQInteger2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQInteger2B* type and its related routines. !   The *PQInteger2B* type is a priority-queue container with *INTEGER(KIND=kInt16)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQInteger2B* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQInteger2B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     INTEGER(KIND=kInt16) #define     PQHeap      PQInteger2B !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQInteger2B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQInteger2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqinteger2b.f90.html"},{"title":"MClass_DArrCharacter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrCharacter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrCharacter* type and related routines. !   The *DArrCharacter* type is a container with *CHARACTER* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrCharacter* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrCharacter PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define ItemType_Is_Character #define DynArr          DArrCharacter #define TypeAlloc       CHARACTER(LEN=:), ALLOCATABLE #define TypeArgmt       CHARACTER(LEN=*) #define TypeOfItem      CHARACTER !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrCharacter' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef ItemType_Is_Character #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrCharacter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrcharacter.f90.html"},{"title":"MClass_ListCmpxQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListCmpxQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListCmpxQP* type and related routines. !   The *ListCmpxQP* type is a container with *COMPLEX(KIND=kQuad)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListCmpxQP* type but utilizes a different implementation. !   Also, unlike the *ListCmpxQP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListCmpxQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListCmpxQP #define DLLNode             DLLNodeCmpxQP #define ItemTypeA           COMPLEX(KIND=kQuad) #define ItemTypeB           COMPLEX(KIND=kQuad) #define ItemTypeC           COMPLEX(KIND=kQuad) #define TypeOfItem          COMPLEX(KIND=kQuad) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListCmpxQP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListCmpxQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listcmpxqp.f90.html"},{"title":"MClass_HTabInteger1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabInteger1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabInteger1B* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabInteger1B* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabInteger1B* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabInteger1B* type uses the Fortran intrinsic !   *INTEGER(KIND=kInt8)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabInteger1B* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabInteger1B* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabInteger1B #define     KeyTypeA        INTEGER(KIND=kInt8) #define     KeyTypeB        INTEGER(KIND=kInt8) #define     QueueKey        ListInteger1B #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabInteger1B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabInteger1B' ! Special marker token used to indicate the deletion of a key-value pair tSInt8 , PARAMETER :: DELKEY = ToInt8 ( Z '7F' ) ! Special marker token used to indicate the empty of a key-value pair tSInt8 , PARAMETER :: NULKEY = ToInt8 ( Z '80' ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabInteger1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabinteger1b.f90.html"},{"title":"MClass_HTabCharacter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabCharacter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabCharacter* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabCharacter* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabCharacter* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabCharacter* type uses the Fortran intrinsic !   *CHARACTER* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabCharacter* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabCharacter* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     KeyType_Is_Character #define     HashTable       HTabCharacter #define     KeyTypeA        CHARACTER(LEN=:), ALLOCATABLE #define     KeyTypeB        CHARACTER(LEN=*) #define     QueueKey        ListCharacter #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE , INTRINSIC :: ISO_FORTRAN_ENV , ONLY : CHARACTER_STORAGE_SIZE USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabCharacter PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabCharacter' ! Special marker token used to indicate the deletion of a key-value pair tCharParam :: DELKEY = ACHAR ( 127 ) ! Special marker token used to indicate the empty of a key-value pair tCharParam :: NULKEY = ACHAR ( 0 ) tSInt32 , PARAMETER :: Bits_kByte = BIT_SIZE ( 0_kInt8 ) ! should be  8 bits tSInt32 , PARAMETER :: Bits_Char = CHARACTER_STORAGE_SIZE tSInt32 , PARAMETER :: Bytes_Char = Bits_Char / Bits_kByte !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Character HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef KeyType_Is_Character #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabCharacter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabcharacter.f90.html"},{"title":"MClass_HTabObject.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabObject !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabObject* type, and its related routines.   The !   *HTabObject* type is a container type that employs an open-addressing hash table !   implementation to provide common operations for an unordered symbol table.  As a !   symbol table, the *HTabObject* type uses the *Object* derived type to store the !   keys and their associated values.  Unlike other hash-table containers, the !  *HTabObject* type uses a user-defined type in the *Object* class to represent !   a key-value pair and requires only one argument (instead of two) when inserting !   or retrieving the key and its associated value. <br> !   It should be noted that a user must be careful when implementing a *user-defined !   concrete* subtype of the *Object* type.  The *HTabObject* type employs the !   assignment statement copy data of the key-value object.  It also utilizes the !   relational operators (e.g. ==) to compare keys of the key-value objects.  Moreover, !   in order to compute indices of buckets used to store the specified key-value object, !   it uses the *HashCode* method to compute the hash value of the specified key.  These !   imply that the user should implement the deferred *CopyAssign* procedure where both !   key and value components are copied from the source object to the destination object !   whereas, when implemented, the deferred *CompareTo* and *ComputeHashValue* procedures !   should be dependent on its key component only. <br> !   It is also worth mentioning that the *HTabObject* type does not allow key-value objects !   of different types to be stored in the same container.  The *HTabObject* type requires !   a user to specify the type of user-defined key-value objects to be stored via arguments !   specified during the creation of a container.  Also, the type of a user-define key-value !   object specified in all other routines must be the same as the type of stored objects of !   the container. Otherwise, the container may not behave as expected. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly by inserting !   objects into a container, the *HTabObject* type requires an explicit construction before !   using other provided operations.  There are two methods provided to create the container. !   The *CreateEmpty* method constructs an empty table with optional multiple arguments !   (including an initial capacity, a load factor, a probing algorithm, and a hash function !   used to compute a hash code of a key) whereas the *Construct* method constructs a table !   from an array of key-value pairs. <br> !   As a symbol table, the *HTabObject* type does not allow duplicated keys.  Therefore, if !   an inserted key is equal to a key stored in the table, an associated value of the stored !   key is replaced by an associated value of the inserted key. <br> !   Technically, the *HTabObject* type employs the open-addressing as a collision resolution !   technique where the hash resolution is performed through probing.  It provides three probing !   algorithms: linear probing, quadratic probing and double hashing.  By default, the linear !   probing algorithm is used.  However, a user can specify other probing algorithm during the !   construction of the container. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabObject #define     QueueKeyVal     ListObject !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists USE MClass_Object #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabObject PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabObject' ! default capacity tIndex , PARAMETER :: DefaultCapacity = 7 ! default load factor tRealDP , PARAMETER :: DefaultLoadFactor = 0.65_kDouble tSInt32 , PARAMETER :: LinearProbing = 1 tSInt32 , PARAMETER :: QuadraticProbing = 2 tSInt32 , PARAMETER :: DoubleHashing = 3 ! This is the linear constant used in the linear probing, it can be ! any positive number. The table capacity will be adjusted so that ! the GCD(capacity, LinearConstant) = 1 so that all buckets can be probed. tIndex , PARAMETER :: LinearConstant = 17_kIndex ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 #ifdef Indx32Bits tSInt32 , PARAMETER :: MaxHash = ToInt32 ( Z '7FFFFFFF' ) #else tSInt64 , PARAMETER :: MaxHash = ToInt64 ( Z '7FFFFFFFFFFFFFFF' ) #endif !** DERIVED TYPE DEFINITIONS !> The *HashTable* type is a table type that employs an open-addressing hash table !  implementation to provide common operations for an unordered symbol table. TYPE HashTable PRIVATE !% current capacity of the hash table tIndex :: Capacity = DefaultCapacity !% working table buckets used to store key-value pairs CLASS ( Object ), ALLOCATABLE :: Buckets (:) !% Special marker token used to indicate the deletion of a key-value pair CLASS ( Object ), ALLOCATABLE :: DELOBJ !% Special marker token used to indicate the empty of a key-value pair CLASS ( Object ), ALLOCATABLE :: NULOBJ !% current index into the working buckets (used for iteration purpose) tIndex :: Indx = 0_kIndex !% the number of keys not yet visited (used for iteration purpose) tIndex :: KeyLeft = 0_kIndex !% current modification count (used for iteration purpose) tIndex :: IterModCount = 0_kIndex !% load factor tRealDP :: LoadFactor = DefaultLoadFactor !% threshold for resizing tIndex :: Threshold = 0_kIndex !% modification count tIndex :: ModCount = 0_kIndex !% the total number of used buckets inside the hash table (including cells marked as deleted). tIndex :: UsedBuckets = 0_kIndex !% the total number of unique keys currently inside the hash table. tIndex :: KeyCount = 0_kIndex !% probing algorithm tSInt32 :: ProbAlgo = LinearProbing !% index for double hashing tHash :: HashIndx = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%FindKey(KeyVal) <br> !   --->    IF (.NOT.Table%FindKey(KeyVal)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashTable_FindKey !> **Type-Bound Subroutine**: Resize <br> !  **Purpose**:  To resize the table to the specified capacity. <br> !  **Usage**: <br> !   --->    CALL Table%Resize(64) PROCEDURE , PRIVATE :: Resize => HashTable_Resize ! --------------------------------------------------------------------- ! -----                      Public Procedures                    ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(NulObj, DelObj)                  ! use default options  <br> !   --->    CALL Table%CreateEmpty(NulObj, DelObj, InitCap=25)      ! specify initial capacity <br> !   --->    CALL Table%CreateEmpty(NulObj, DelObj, LoadFactor=0.5)  ! specify load factor <br> !   --->    CALL Table%CreateEmpty(NulObj, DelObj, ProbAlgo=2)      ! specify probing algorithm <br> !   --->    CALL Table%CreateEmpty(NulObj, DelObj, 30, 0.75, 3)     ! specify all options <br> !  **Important Note**: <br> !  A user is required to specify two user-defined key-value pair objects to represent a null !  object and a deleted object where these two objects are not the same one when compared using !  the *operator ==*.  Also, these two objects should never be specified in any operations other !  than the construction operations. <br> PROCEDURE :: CreateEmpty => HashTable_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a hash table from the specified key-value array. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL Table%Construct(40, KeyValArr, NulObj, DelObj) <br> !   ! specify all options (initial capacity is twice of the size of the given arrays) <br> !   --->    CALL Table%Construct(20, KeyValArr, NulObj, DelObj, LoadFactor, ProbAlgo) <br> !  **Important Note**: <br> !  A user is required to specify two user-defined key-value pair objects to represent a null !  object and a deleted object where these two objects are not the same one when compared using !  the *operator ==*.  Also, these two objects should never be specified in any operations other !  than the construction operations. <br> PROCEDURE :: Construct => HashTable_CreateByArray !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To free components of the buckets from the table. <br> !  **Usage**: <br> !   --->    CALL Table%Clear() PROCEDURE :: Clear => HashTable_ClearBuckets !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To free all memory currently used by the table.<br> !  **Usage**: <br> !   --->    CALL Table%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method.  After the *Clear* method !       is called, other methods (the *Insert* method in particular) can be immediately used. !       However, after the *Destruct* method is called, the *Construct* method must be called !       again before other methods can be used. <br> PROCEDURE :: Destruct => HashTable_Destroy ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the table. <br> !  **Usage**: <br> !   --->    CALL Table%Insert(KeyVal) <br> PROCEDURE :: Insert => HashTable_Insert !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from the table. !                Also, return a flag indicating whether the key-value pair is successfully !                removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Table%Remove(KeyVal) <br> !   --->    IF (.NOT.Table%Remove(KeyVal)) DoSomething PROCEDURE :: Remove => HashTable_Remove ! ------------------------------------------------------- ! -----           tree-traversing procedures        ----- ! ------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the table is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Table%StartFirst() <br> !   --->    IsEmpty = Table%StartFirst(FirstKeyVal) <br> PROCEDURE :: StartFirst => HashTable_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the table or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Table%MoveForward() <br> !   --->    IsTheEnd = Table%MoveForward(NextKeyVal) <br> !  **Important Note**: <br> !   After the start of the current iteration (i.e. a call to the *StartFirst* method), !   a user should not insert or remove any key-value pair.  Otherwise, the *MoveForward* !   method is not valid for the current iteration and the user must re-start the iteration !   in order to use the *MoveForward* method. PROCEDURE :: MoveForward => HashTable_Move2NextPair ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the table is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Table%IsEmpty() <br> !   --->    IF (.NOT.Table%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => HashTable_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (number of keys and their associated values) of the table. <br> !  **Usage**: <br> !   --->    Size = Table%GetSize() PROCEDURE :: GetSize => HashTable_GetSize !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the table.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Table%Contain(KeyVal) <br> !   --->    IF (.NOT.Table%Contain(KeyVal)) DoSomething PROCEDURE :: Contain => HashTable_Contain !> **Type-Bound Subroutine**: GetKeys <br> !  **Purpose**:  To return a queue of all key-value pairs. <br> !  **Usage**: <br> !   --->    CALL Tree%GetKeys(KeyValQueue) <br> PROCEDURE :: GetKeys => HashTable_GetAllKeys ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash table. FINAL :: HashTable_Finalize ! --------------------------------------------------------------------- END TYPE HashTable !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! ----------------------------------------------------------------------------- ! -----                        Common Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE HashTable_CreateEmpty ( Table , NulObj , DelObj , InitCap , LoadFactor , ProbAlgo ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTable object CLASS ( HashTable ), INTENT ( INOUT ) :: Table !> a user-defined object representing a null object; the user should never specify this !  object in any operations other than the construction operations. CLASS ( Object ), INTENT ( IN ) :: NulObj !> a user-defined object representing a deleted object (different from the null object); the user !  should never specify this object in any operations other than the construction operations. CLASS ( Object ), INTENT ( IN ) :: DelObj !% initial capacity of the hash table tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !% load factor tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! check and return quickly if needed IF ( NulObj % IsEqualTo ( DelObj )) THEN CALL Handle_ErrLevel ( 'HashTable_CreateEmpty' , ModName , ErrWarning , & 'The null object must be different from the deleted object.' ) RETURN ELSEIF (. NOT . SAME_TYPE_AS ( NulObj , DelObj )) THEN CALL Handle_ErrLevel ( 'HashTable_CreateEmpty' , ModName , ErrWarning , & 'Types of the null and deleted objects must be the same.' ) RETURN END IF ! determine initial capacity IF ( PRESENT ( InitCap )) THEN IF ( InitCap < 0_kIndex ) THEN Table % Capacity = DefaultCapacity ELSE Table % Capacity = MAX ( DefaultCapacity , InitCap ) END IF ELSE Table % Capacity = DefaultCapacity END IF ! determine load factor IF ( PRESENT ( LoadFactor )) THEN IF ( InitCap < 0.0_kDouble ) THEN Table % LoadFactor = DefaultLoadFactor ELSE Table % LoadFactor = LoadFactor END IF ELSE Table % LoadFactor = DefaultLoadFactor END IF ! determine probing algorithm IF ( PRESENT ( ProbAlgo )) THEN SELECT CASE ( ProbAlgo ) CASE ( 1 : 3 ) Table % ProbAlgo = ProbAlgo CASE DEFAULT Table % ProbAlgo = LinearProbing END SELECT ELSE Table % ProbAlgo = LinearProbing END IF ! adjust the capacity according to the probing algorithm CALL AdjustCapacity ( Table ) ! compute threshold Table % Threshold = ToIndex ( Table % Capacity * Table % LoadFactor ) ! allocate module variables ALLOCATE ( Table % NULOBJ , SOURCE = NulObj ) ALLOCATE ( Table % DELOBJ , SOURCE = DelObj ) ! allocate memory of bucket storages ALLOCATE ( Table % Buckets ( 0 : Table % Capacity - 1 ), SOURCE = Table % NULOBJ ) RETURN END SUBROUTINE HashTable_CreateEmpty !****************************************************************************** SUBROUTINE HashTable_CreateByArray ( Table , N , KeyVals , NulObj , DelObj , LoadFactor , ProbAlgo ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTable object CLASS ( HashTable ), INTENT ( INOUT ) :: Table !% number of key-value pairs tIndex , INTENT ( IN ) :: N !% the key-value pairs to be added to the table CLASS ( Object ), INTENT ( IN ) :: KeyVals (:) !> a user-defined object representing a null object; the user should never specify this !  object in any operations other than the construction operations. CLASS ( Object ), INTENT ( IN ) :: NulObj !> a user-defined object representing a deleted object (different from the null object); the user !  should never specify this object in any operations other than the construction operations. CLASS ( Object ), INTENT ( IN ) :: DelObj !% load factor tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! check and return quickly if needed IF ( NulObj % IsEqualTo ( DelObj )) THEN CALL Handle_ErrLevel ( 'HashTable_CreateByArray' , ModName , ErrWarning , & 'The null object must be different from the deleted object' ) RETURN ELSEIF (. NOT . SAME_TYPE_AS ( NulObj , DelObj ). OR .. NOT . SAME_TYPE_AS ( NulObj , KeyVals )) THEN CALL Handle_ErrLevel ( 'HashTable_CreateByArray' , ModName , ErrWarning , & 'Types of the null and deleted objects must be the same.' ) RETURN END IF ! create empty symbol table with capacity twice of the key size CALL Table % CreateEmpty ( NulObj , DelObj , N * 2_kIndex , LoadFactor , ProbAlgo ) ! add key-value pairs to the table DO I = 1_kIndex , N CALL Table % Insert ( KeyVals ( I )) END DO RETURN END SUBROUTINE HashTable_CreateByArray !****************************************************************************** SUBROUTINE HashTable_ClearBuckets ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free components of the buckets from the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I !** FLOW: DO I = 0_kIndex , Table % Capacity - 1_kIndex Table % Buckets ( I ) = Table % NULOBJ END DO Table % KeyCount = 0_kIndex Table % UsedBuckets = 0_kIndex Table % ModCount = Table % ModCount + 1_kIndex RETURN END SUBROUTINE HashTable_ClearBuckets !****************************************************************************** SUBROUTINE HashTable_Destroy ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! first free memory storages IF ( ALLOCATED ( Table % Buckets )) THEN BLOCK tIndex :: I DO I = 0_kIndex , Table % Capacity - 1_kIndex CALL Table % Buckets ( I )% MemFree () END DO END BLOCK DEALLOCATE ( Table % Buckets ) END IF IF ( ALLOCATED ( Table % NULOBJ )) DEALLOCATE ( Table % NULOBJ ) IF ( ALLOCATED ( Table % DELOBJ )) DEALLOCATE ( Table % DELOBJ ) ! reset all components Table % Capacity = DefaultCapacity Table % Indx = 0_kIndex Table % KeyLeft = 0_kIndex Table % IterModCount = 0_kIndex Table % LoadFactor = DefaultLoadFactor Table % Threshold = 0_kIndex Table % ModCount = 0_kIndex Table % UsedBuckets = 0_kIndex Table % KeyCount = 0_kIndex Table % ProbAlgo = LinearProbing Table % HashIndx = 0_kIndex RETURN END SUBROUTINE HashTable_Destroy !****************************************************************************** SUBROUTINE HashTable_Finalize ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the HashTable object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Table % Destruct () RETURN END SUBROUTINE HashTable_Finalize !****************************************************************************** FUNCTION HashTable_GetSize ( Table ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of keys currently in the hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( IN ) :: Table !! HashTable object tIndex :: Size !! the number of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Table % KeyCount RETURN END FUNCTION HashTable_GetSize !****************************************************************************** FUNCTION HashTable_IsEmpty ( Table ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the hash table is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( IN ) :: Table !! HashTable object tLogical :: Flag !! true if the table is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Table % KeyCount == 0_kIndex ) RETURN END FUNCTION HashTable_IsEmpty !****************************************************************************** SUBROUTINE HashTable_Resize ( Table , MoreCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To resize the capacity of the hash table according the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object tLogical , INTENT ( IN ) :: MoreCap !&#94; true if increasing the capacity; otherwise, decreasing the capacity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( Object ), ALLOCATABLE :: OldBuckets (:) tIndex :: OldCap , I !** FLOW: OldCap = Table % Capacity IF ( MoreCap ) THEN CALL IncreaseCapacity ( Table ) ELSE ! halving the capacity Table % Capacity = Table % Capacity / 2_kIndex END IF CALL AdjustCapacity ( Table ) ! update threshold Table % Threshold = ToIndex ( Table % Capacity * Table % LoadFactor ) ! move currently stored objects to temporary variable CALL MOVE_ALLOC ( Table % Buckets , OldBuckets ) ! allocate working buckets to new capacity ALLOCATE ( Table % Buckets ( 0 : Table % Capacity - 1_kIndex ), SOURCE = Table % NULOBJ ) ! Reset the key count and buckets used since we are about to ! re-insert all the keys into the hash-table. Table % KeyCount = 0_kIndex Table % UsedBuckets = 0_kIndex ! loop over the temporary lists to move stored objects (Buckets) ! back to the working lists of the hash table DO I = 0_kIndex , OldCap - 1_kIndex IF ((. NOT . OldBuckets ( I )% IsEqualTo ( Table % NULOBJ )). AND .(. NOT . OldBuckets ( I )% IsEqualTo ( Table % DELOBJ ))) THEN ! re-insert the key and its associated value CALL Table % Insert ( OldBuckets ( I )) END IF CALL OldBuckets ( I )% MemFree () END DO ! free temporary variable DEALLOCATE ( OldBuckets ) RETURN END SUBROUTINE HashTable_Resize !****************************************************************************** SUBROUTINE HashTable_Insert ( Table , KeyVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into the hash table.  If the specified key !  is already stored in the table, replace the old value with the !  new one.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object CLASS ( Object ), INTENT ( IN ) :: KeyVal !! key to be inserted and its associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J ! FLOW ! check and return quickly if needed IF (( KeyVal % IsEqualTo ( Table % NULOBJ )). OR .( KeyVal % IsEqualTo ( Table % DELOBJ ))) THEN CALL Handle_ErrLevel ( 'HashTable_Insert' , ModName , ErrWarning , & 'The inserted object must not be a null or a deleted one.' ) RETURN ELSEIF (. NOT . SAME_TYPE_AS ( KeyVal , Table % NULOBJ )) THEN CALL Handle_ErrLevel ( 'HashTable_Insert' , ModName , ErrWarning , & 'Type of the inserted object must be the same as that of stored objects.' ) RETURN END IF ! resize the capacity if needed IF ( Table % UsedBuckets >= Table % Threshold ) THEN CALL Table % Resize ( MoreCap = TrueVal ) END IF ! set up the probing if needed CALL SetupProbing ( Table , KeyVal ) ! compute the hash code and offset HashCode = KeyVal % HashCode () Offset = ComputeIndex ( HashCode , Table % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex DO IF ( Table % Buckets ( I )% IsEqualTo ( Table % DELOBJ )) THEN ! The current bucket was previously deleted IF ( J == - 1_kIndex ) J = I ELSEIF (. NOT . Table % Buckets ( I )% IsEqualTo ( Table % NULOBJ )) THEN ! The current bucket already contains a key IF ( Table % Buckets ( I )% IsEqualTo ( KeyVal )) THEN ! The key we're trying to insert already exists in the hash-table, ! so update its value with the most recent value IF ( J == - 1_kIndex ) THEN Table % Buckets ( I ) = KeyVal ELSE Table % Buckets ( I ) = Table % DELOBJ Table % Buckets ( J ) = KeyVal END IF Table % ModCount = Table % ModCount + 1_kIndex EXIT END IF ELSE ! The current bucket is null so an insertion/update can occur IF ( J == - 1_kIndex ) THEN ! No previously encountered deleted buckets Table % UsedBuckets = Table % UsedBuckets + 1_kIndex Table % Buckets ( I ) = KeyVal ELSE ! Previously seen deleted bucket. Instead of inserting ! the new element at i where the null element is insert ! it where the deleted token was found. Table % Buckets ( J ) = KeyVal END IF Table % KeyCount = Table % KeyCount + 1_kIndex Table % ModCount = Table % ModCount + 1_kIndex EXIT END IF I = ComputeIndex ( Offset + Probe ( Table , Indx ), Table % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END SUBROUTINE HashTable_Insert !****************************************************************************** FUNCTION HashTable_Remove ( Table , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified key (and its associated value) from a symbol !  table.  Also, return a flag indicating whether the key-value pair is !  successfully removed or not.  Optionally, retrieve the associated !  value if the key exists in the table.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object CLASS ( Object ), INTENT ( IN ) :: KeyVal !! key to be removed and its associated value !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I ! FLOW ! check and return quickly if needed IF (( KeyVal % IsEqualTo ( Table % NULOBJ )). OR .( KeyVal % IsEqualTo ( Table % DELOBJ ))) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashTable_Remove' , ModName , ErrWarning , & 'The removed object must not be a null or a deleted one.' ) RETURN ELSEIF (. NOT . SAME_TYPE_AS ( KeyVal , Table % NULOBJ )) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashTable_Remove' , ModName , ErrWarning , & 'Type of the removed object must be the same as that of stored objects.' ) RETURN END IF IF ( Table % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! set up the probing if needed CALL SetupProbing ( Table , KeyVal ) ! compute the hash code and offset HashCode = KeyVal % HashCode () Offset = ComputeIndex ( HashCode , Table % Capacity ) ! initialize indices I = Offset Indx = 1_kIndex ! Starting at the original hash probe until we find a spot where our key is ! or we hit a null element in which case our element does not exist. DO IF ( Table % Buckets ( I )% IsEqualTo ( Table % DELOBJ )) THEN ! ignore deleted bucket so do nothing here ELSEIF ( Table % Buckets ( I )% IsEqualTo ( Table % NULOBJ )) THEN ! the key was not found Flag = FalseVal EXIT ELSEIF ( Table % Buckets ( I )% IsEqualTo ( KeyVal )) THEN ! found the key we want to remove Table % KeyCount = Table % KeyCount - 1_kIndex Table % ModCount = Table % ModCount + 1_kIndex Table % Buckets ( I ) = Table % DELOBJ Flag = TrueVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Table , Indx ), Table % Capacity ) Indx = Indx + 1_kIndex END DO ! halve the hash table capacity if it is 12.5% full or less IF (( Table % KeyCount > 0_kIndex ). AND .( Table % KeyCount <= Table % Capacity / 8 )) THEN CALL Table % Resize ( MoreCap = FalseVal ) END IF RETURN END FUNCTION HashTable_Remove !****************************************************************************** FUNCTION HashTable_Contain ( Table , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object CLASS ( Object ), INTENT ( IN ) :: Key !! key to be looked for !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check and return quickly if needed IF (( Key % IsEqualTo ( Table % NULOBJ )). OR .( Key % IsEqualTo ( Table % DELOBJ ))) THEN Found = FalseVal CALL Handle_ErrLevel ( 'HashTable_Contain' , ModName , ErrWarning , & 'The key to be looked for must not be a null or a deleted one.' ) RETURN ELSEIF (. NOT . SAME_TYPE_AS ( Key , Table % NULOBJ )) THEN Found = FalseVal CALL Handle_ErrLevel ( 'HashTable_Contain' , ModName , ErrWarning , & 'Type of the specified key must be the same as that of stored objects.' ) RETURN END IF IF ( Table % IsEmpty ()) THEN Found = FalseVal ELSE ! find the key Found = Table % FindKey ( Key ) END IF RETURN END FUNCTION HashTable_Contain !****************************************************************************** FUNCTION HashTable_FindKey ( Table , KeyVal ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table. !  Optionally, retrieve the associated value if the key is found. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object CLASS ( Object ), INTENT ( IN ) :: KeyVal !! key to be looked for and its associated value !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J ! FLOW ! set up the probing if needed CALL SetupProbing ( Table , KeyVal ) ! compute the hash code and offset HashCode = KeyVal % HashCode () Offset = ComputeIndex ( HashCode , Table % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex ! Start at the original hash value and probe until we find a spot where our key ! is or hit a null element in which case our element does not exist. DO IF ( Table % Buckets ( I )% IsEqualTo ( Table % DELOBJ )) THEN ! Ignore deleted buckets, but record where the first index ! of a deleted bucket is found to perform lazy relocation later. IF ( J == - 1_kIndex ) J = I ELSEIF (. NOT . Table % Buckets ( I )% IsEqualTo ( Table % NULOBJ )) THEN ! found the key we want to remove IF ( J /= - 1_kIndex ) THEN ! If J /= -1 this means we previously encountered a deleted cell. ! We can perform an optimization by swapping the entries in cells ! I and J so that the next time we search for this key it will be ! found faster. This is called lazy deletion/relocation. Table % Buckets ( J ) = Table % Buckets ( I ) Table % Buckets ( I ) = Table % DELOBJ END IF Found = TrueVal EXIT ELSE ! the key was not found Found = FalseVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Table , Indx ), Table % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END FUNCTION HashTable_FindKey !****************************************************************************** FUNCTION HashTable_Move2FirstPair ( Table , KeyVal ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a hash table.   For the hash table, !  which is an unordered symbol table, the starting pair is the first pair found !  in the non-empty bucket.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !% the first key and its associated value as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: KeyVal !> a flag indicating whether the table contains no pair data or not <br> ! - true if the table is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Table % IsEmpty ()) THEN IsEmpty = TrueVal RETURN ELSE IsEmpty = FalseVal END IF ! initialize iteration-related components Table % Indx = 0_kIndex Table % KeyLeft = Table % KeyCount Table % IterModCount = Table % ModCount ! start iteration by looking for the first non-empty slot DO WHILE (( Table % Buckets ( Table % Indx )% IsEqualTo ( Table % NULOBJ )). OR . & ( Table % Buckets ( Table % Indx )% IsEqualTo ( Table % DELOBJ ))) Table % Indx = Table % Indx + 1_kIndex END DO ! update KeyLelf Table % KeyLeft = Table % KeyLeft - 1_kIndex ! get key if requested IF ( PRESENT ( KeyVal )) THEN IF ( SAME_TYPE_AS ( KeyVal , Table % NULOBJ )) THEN KeyVal = Table % Buckets ( Table % Indx ) ELSE CALL Handle_ErrLevel ( 'HashTable_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key-value must be the same as that of stored objects.' ) END IF END IF RETURN END FUNCTION HashTable_Move2FirstPair !****************************************************************************** FUNCTION HashTable_Move2NextPair ( Table , KeyVal ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table.  For the *HashTable*, which !  is an unordered symbol table,  the next pair is a pair inserted in the first !  non-empty bucket after the previous one.  <br> !  The routine will report an error if an alteration to stored bucket(s) (either !  by an insertion or a removal) has been occurred during current iteration.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !% the next key and its associated value as output if requested (and available) CLASS ( Object ), OPTIONAL , INTENT ( OUT ) :: KeyVal !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Table % IterModCount /= Table % ModCount ) THEN CALL Handle_ErrLevel ( 'HashTable_Move2NextPair' , ModName , ErrWarning , & \"Must re-start the iteration because the stored buckets have been altered.\" ) RETURN END IF ! check for empty table IF ( Table % IsEmpty ()) THEN IsTheEnd = TrueVal RETURN ELSEIF ( Table % KeyLeft == 0_kIndex ) THEN IsTheEnd = TrueVal RETURN END IF ! update Indx and set flag Table % Indx = Table % Indx + 1 IsTheEnd = FalseVal ! start iteration by looking for the next non-empty slot DO WHILE (( Table % Buckets ( Table % Indx )% IsEqualTo ( Table % NULOBJ )). OR . & ( Table % Buckets ( Table % Indx )% IsEqualTo ( Table % DELOBJ ))) Table % Indx = Table % Indx + 1_kIndex END DO ! update KeyLelf Table % KeyLeft = Table % KeyLeft - 1_kIndex ! get key if requested IF ( PRESENT ( KeyVal )) THEN IF ( SAME_TYPE_AS ( KeyVal , Table % NULOBJ )) THEN KeyVal = Table % Buckets ( Table % Indx ) ELSE CALL Handle_ErrLevel ( 'HashTable_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key-value must be the same as that of stored objects.' ) END IF END IF RETURN END FUNCTION HashTable_Move2NextPair !****************************************************************************** SUBROUTINE HashTable_GetAllKeys ( Table , KeyValQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return all keys in the table (and all associated values). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object TYPE ( QueueKeyVal ), INTENT ( OUT ) :: KeyValQ !! key-value queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW DO I = 0_kIndex , Table % Capacity - 1_kIndex IF ((. NOT . Table % Buckets ( I )% IsEqualTo ( Table % DELOBJ )). AND . & (. NOT . Table % Buckets ( I )% IsEqualTo ( Table % NULOBJ ))) THEN CALL KeyValQ % EnQueue ( Table % Buckets ( I )) END IF END DO RETURN END SUBROUTINE HashTable_GetAllKeys ! ----------------------------------------------------------------------------- ! -----             Procedures Dependent On Probing Algorithm             ----- ! ----------------------------------------------------------------------------- SUBROUTINE SetupProbing ( Table , Key ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set up the probing according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object CLASS ( Object ), INTENT ( IN ) :: Key !! key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Table % ProbAlgo ) CASE ( LinearProbing ) ! no setup required CASE ( QuadraticProbing ) ! no setup required CASE ( DoubleHashing ) BLOCK tIndex :: HashCode ! Cache second hash value. HashCode = Key % HashCode () Table % HashIndx = ComputeIndex ( HashCode , Table % Capacity ) ! Fail safe to avoid infinite loop IF ( Table % HashIndx == 0_kIndex ) Table % HashIndx = 1_kIndex END BLOCK END SELECT RETURN END SUBROUTINE SetupProbing !****************************************************************************** FUNCTION Probe ( Table , IdIn ) RESULT ( IdOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To look for the next available bucket according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object tIndex , INTENT ( IN ) :: IdIn !! starting index for the probing tIndex :: IdOut !! index of available bucket !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Table % ProbAlgo ) CASE ( LinearProbing ) IdOut = LinearConstant * IdIn CASE ( QuadraticProbing ) ! Quadratic probing function (x**2 + x) / 2 IdOut = SHIFTR ( IdIn * IdIn + IdIn , 1 ) CASE ( DoubleHashing ) IdOut = Table % HashIndx * IdIn END SELECT RETURN END FUNCTION Probe !****************************************************************************** SUBROUTINE AdjustCapacity ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To adjust capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Table % ProbAlgo ) CASE ( LinearProbing ) ! Adjust the capacity so that the linear constant and ! the table capacity are relatively prime. DO WHILE ( ComputeGCD ( LinearConstant , Table % Capacity ) /= 1_kIndex ) Table % Capacity = Table % Capacity + 1_kIndex END DO CASE ( QuadraticProbing ) ! Adjust the capacity of the hash table to be a power of two. BLOCK tIndex :: Pow2 Pow2 = HighestOneBit ( Table % Capacity ) IF ( Table % Capacity /= Pow2 ) THEN CALL IncreaseCapacity ( Table ) END IF END BLOCK CASE ( DoubleHashing ) ! Adjust the capacity until it is a prime number. The reason for ! doing this is to help ensure that the GCD(hash, capacity) = 1 when ! probing so that all the cells can be reached. IF (. NOT . IsPrime ( Table % Capacity )) THEN Table % Capacity = NextPrime ( Table % Capacity ) END IF END SELECT RETURN END SUBROUTINE AdjustCapacity !****************************************************************************** SUBROUTINE IncreaseCapacity ( Table ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To increase capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTable ), INTENT ( INOUT ) :: Table !! HashTable object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Table % ProbAlgo ) CASE ( LinearProbing ) ! doubling the capacity Table % Capacity = Table % Capacity * 2_kIndex + 1_kIndex CASE ( QuadraticProbing ) ! increase the capacity of the hash table to the next power of two. Table % Capacity = SHIFTL ( HighestOneBit ( Table % Capacity ), 1 ) CASE ( DoubleHashing ) ! doubling the capacity Table % Capacity = Table % Capacity * 2_kIndex + 1_kIndex END SELECT RETURN END SUBROUTINE IncreaseCapacity ! ----------------------------------------------------------------------------- ! -----                     Auxiliary Procedures                          ----- ! ----------------------------------------------------------------------------- FUNCTION ComputeIndex ( HashCode , Capacity ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the index of working buckets of the hash table for !  the specified hash code.  Returns value between 0 and !  Capacity-1 (assumes Capacity is a power of 2). !** SUBROUTINE ARGUMENT DECLARATIONS: tHash , INTENT ( IN ) :: HashCode tIndex , INTENT ( IN ) :: Capacity tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! remove sign and set the index in the applicable range Indx = IAND ( IAND ( HashCode , MaxHash ), Capacity - 1_kIndex ) RETURN END FUNCTION ComputeIndex !****************************************************************************** RECURSIVE FUNCTION ComputeGCD ( A , B ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the greatest common denominator of A and B. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: A , B tIndex :: C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( B == 0_kIndex ) THEN C = A ELSE C = ComputeGCD ( B , MOD ( A , B )) END IF RETURN END FUNCTION ComputeGCD !****************************************************************************** !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef QueueKeyVal END MODULE MClass_HTabObject !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabobject.f90.html"},{"title":"MClass_OrderedSymTable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_OrderedSymTable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *OrderedSymTable* type and its related routines.  The *OrderedSymTable* !   type is an abstract type representing an ordered symbol table, which is a collection containing !   key-value pairs that keeps the keys in order. <br> !   The *OrderedSymTable* type is a subtype of the *BaseSymTable* type and thus inherits all methods !   of the *BaseSymTable* type and all its super classes.  The *OrderedSymTable* type provides an !   expanded API that defines numerous natural and useful operations involving relative key order. <br> !   It is important to note that checking the key equality is usually sufficient for an unordered !   symbol table.  However, for an ordered symbol table, the comparison between keys should provide !   a total ordering on all the keys.  This means that although all Fortran intrinsic types (with !   the exception of the *LOGICAL* type) can be used as a type of the key in an unordered symbol !   table, only *CHARACTER*, *INTEGER* and *REAL* types can be used as a type of the key in an !   ordered symbol table.  To use a derived type as a type of the key, any derived types are allowed !   for an unordered symbol table.  However, for an ordered symbol table, only derived types that !   are in the *Comparable* class are allowed. <br> !** USE STATEMENTS: USE MBase_Common USE MClass_BaseSymTable USE MClass_GenData , ONLY : IfacePolyCopy IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: OrderedSymTable PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_OrderedSymTable' !** DERIVED TYPE !> The *OrderedSymTable* type is an abstract collection type that defines an API for an !  ordered symbol table. TYPE , ABSTRACT , EXTENDS ( BaseSymTable ) :: OrderedSymTable CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *GetMinKey* is a deferred procedure to get the smallest key (and optionally a value !   associated with it) in a symbol table. <br> PROCEDURE ( IfaceMinKey ), DEFERRED :: GetMinKey !> *GetMaxKey* is a deferred procedure to get the largest key (and optionally a value !   associated with it) in a symbol table. <br> PROCEDURE ( IfaceMaxKey ), DEFERRED :: GetMaxKey !> *Floor* is a deferred procedure to get the largest key (and optionally a value !   associated with it) in a symbol table less than or equal to the given key. <br> PROCEDURE ( IfaceFloor ), DEFERRED :: Floor !> *Ceiling* is a deferred procedure to get the smallest key (and optionally a value !   associated with it) in a symbol table greater than or equal to the given key. <br> PROCEDURE ( IfaceCeiling ), DEFERRED :: Ceiling !> *GetRank* is a deferred procedure to return the number of keys in the symbol table !   strictly less than the given key. <br> PROCEDURE ( IfaceRank ), DEFERRED :: GetRank !> *Select* is a deferred procedure to get the key (and optionally its associated value) of !   the specified rank where the applicable range of rank is between 0 and TableSize-1. <br> PROCEDURE ( IfaceSelect ), DEFERRED :: Select !> *RemoveMin* is a deferred procedure to remove the smallest key (and a value associated !   with it) from a symbol table. <br> PROCEDURE ( IfaceDelMin ), DEFERRED :: RemoveMin !> *RemoveMax* is a deferred procedure to remove the largest key (and a value associated !   with it) from a symbol table. <br> PROCEDURE ( IfaceDelMax ), DEFERRED :: RemoveMax !> *GetRangeSize* is a deferred procedure to return the number of keys between *KeyLo* !   (inclusive) and *KeyHi* (inclusive). <br> PROCEDURE ( IfaceRangeSize ), DEFERRED :: GetRangeSize ! --------------------------------------------------------------------- END TYPE OrderedSymTable !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> *IfaceMinKey* is an interface for a procedure to get the smallest key (and optionally !  a value associated with the key) in a symbol table.  Also, return a flag indicating !  whether the key is successfully retrieved or not.  If the table is empty, the flag is !  typically false.  Otherwise, the flag is always true. <br> FUNCTION IfaceMinKey ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table !> the smallest key to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Key !> the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key-value pair is found or not. tLogical :: Flag END FUNCTION IfaceMinKey !> *IfaceMaxKey* is an interface for a procedure to get the largest key (and optionally !  a value associated with the key) in a symbol table.  Also, return a flag indicating !  whether the key is successfully retrieved or not.  If the table is empty, the flag ! is typically false.  Otherwise, the flag is always true. FUNCTION IfaceMaxKey ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table !> the largest key to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Key !> the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key-value pair is found or not. tLogical :: Flag END FUNCTION IfaceMaxKey !> *GetFloor* is an interface for a procedure to get the largest key (and optionally !  a value associated with the key) in a symbol table less than or equal to the given !  key.  Also, return a flag indicating whether the floor key is successfully obtained !  or not. FUNCTION IfaceFloor ( Collection , KeyIn , KeyOut , ValOut , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: KeyIn !! the specified key !> the largest key in the table less than or equal to the given key CLASS ( * ), INTENT ( INOUT ) :: KeyOut !> the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: ValOut !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key-value pair is found or not. tLogical :: Flag END FUNCTION IfaceFloor !> *IfaceCeiling* is an interface for a procedure to get the smallest key (and optionally !  a value associated with the key) in a symbol table greater than or equal to the given !  key.  Also, return a flag indicating whether the ceiling key is successfully retrieved !  or not. FUNCTION IfaceCeiling ( Collection , KeyIn , KeyOut , ValOut , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: KeyIn !! the specified key !> the smallest key in the table less than or equal to the given key CLASS ( * ), INTENT ( INOUT ) :: KeyOut !> the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: ValOut !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key-value pair is found or not. tLogical :: Flag END FUNCTION IfaceCeiling !> *IfaceRank* is an interface for a procedure to get the number of keys in the symbol !  table strictly less than the given key. FUNCTION IfaceRank ( Collection , Key ) RESULT ( Rank ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: Key !! the specified key !> the number of keys less than the given key. tIndex :: Rank END FUNCTION IfaceRank !> *KeySelect* is an interface for a procedure to get the key (and optionally its !  associated value) of the given rank.  Also, return a flag indicating whether the !  ranked key is successfully retrieved or not. <br> !  This ranked key has the property such that there are keys in the symbol table that !  are smaller.  In other words, this key is the (rank+1)st smallest key in the table. <br> !  The applicable range of rank is between 0 and TableSize-1 where the rank number is !  zero-based.  If the specified rank is out of range or the table is empty, set the !  returned flag to false.  Otherwise, set the returned flag to true. <br> FUNCTION IfaceSelect ( Collection , Rank , Key , Value , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table tIndex , INTENT ( IN ) :: Rank !! the specified rank !> the key of the specified rank CLASS ( * ), INTENT ( INOUT ) :: Key !> the value associated with the ranked key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key-value pair is found or not. tLogical :: Flag END FUNCTION IfaceSelect !> *IfaceDelMin* is an interface for a procedure to remove the smallest key and a value !  associated with the key from a symbol table.  Also, return a flag indicating whether !  the key is successfully removed or not.  If the table is empty, the flag is typically !  false.  Otherwise, the flag is always true. FUNCTION IfaceDelMin ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !! the smallest key !> the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key is successfully removed or not tLogical :: Flag END FUNCTION IfaceDelMin !> *IfaceDelMax* is an interface for a procedure to remove the largest key and a value !  associated with the key from a symbol table.  Also, return a flag indicating whether !  the key is successfully removed or not.  If the table is empty, the flag is typically !  false.  Otherwise, the flag is always true. FUNCTION IfaceDelMax ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !! the largest key !> the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the key is successfully removed or not tLogical :: Flag END FUNCTION IfaceDelMax !> *IfaceRangeSize* is an interface for a procedure to get the number of keys in the given !   range (between KeyLo and KeyHi). FUNCTION IfaceRangeSize ( Collection , KeyLo , KeyHi ) RESULT ( Size ) IMPORT CLASS ( OrderedSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: KeyLo !! the minimum key (inclusive) CLASS ( * ), INTENT ( IN ) :: KeyHi !! the maximum key (inclusive) !> the number of keys in the given range tIndex :: Size END FUNCTION IfaceRangeSize END INTERFACE !** MODULE VARIABLE DECLARATIONS: !  na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !************************************************************************************** END MODULE MClass_OrderedSymTable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_orderedsymtable.f90.html"},{"title":"MClass_ListAnyType.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListAnyType !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListAnyType* type and related routines. The !   *ListAnyType* type is a container with an unlimited polymorphic type !   (i.e. *CLASS(*)*) as the type of its stored items.  It employs a !   conventional doubly-linked list implementation.  Any data types can !   be used with this container. <br> !   Similar to other classes of the linked list container, the *ListAnyType* !   type allows items with different types to be stored in different nodes !   of the same container.  However, unlike other classes, to retrieve the !   stored items, a user must specify an allocatable unlimited polymorphic !   type as an output argument.  Therefore, when the user uses the output !   item(s), the *SELECT TYPE* construct must be used to select a type !   that is suitable for a particular item.  <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListAnyType* type but utilizes a different implementation. !   Similar to the *ListAnyType* type, these container types are designed as !   generic containers that can be used to store various data types providing !   that the size (in bytes) of the data to be stored is known at compile time. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_Object , ONLY : Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListAnyType PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListAnyType' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *DLLNode* is a node type that consists of an item and two pointers of the node type. !   As such, the node can point to its adjacent nodes in two directions (next node and !   previous node) allowing a doubly-linked list to be formed. <br> !   The type of the item stored in this node can be any data type.  The *DLLNode* type !   is a private type. TYPE DLLNode PRIVATE !> *Item* is an item (or value) stored in the node where its type can !   be any derived type that extends from the *Object* type. CLASS ( * ), ALLOCATABLE :: Item !% pointer to the next node TYPE ( DLLNode ), POINTER :: Next => NULL () !% pointer to previous node TYPE ( DLLNode ), POINTER :: Prev => NULL () CONTAINS ! destructor procedure PROCEDURE , PRIVATE :: Destruct => LinkedNode_Destructor END TYPE DLLNode !> *ListAnyType* is a container type that employs a doubly-linked list implementation to !   provide common operations for a list container.  It can also represent other forms !   of containers including a LIFO stack, a FIFO queue and a double-ended queue (deque). !   The type of items stored in this container can be any data type. TYPE ListAnyType PRIVATE !% size of the list container (i.e. number of nodes in the list) tIndex :: Size = 0 !% pointer to the first node (or the head node) of the list TYPE ( DLLNode ), POINTER :: Head => NULL () !% pointer to the last node (or the tail node) of the list TYPE ( DLLNode ), POINTER :: Tail => NULL () !% pointer to the current node used for iteration purpose TYPE ( DLLNode ), POINTER :: Cursor => NULL () !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: SetNewNode => LinkedList_SetNewNode PROCEDURE , PRIVATE :: RemoveNode => LinkedList_RemoveNode PROCEDURE , PRIVATE :: GetNodeAt => LinkedList_GetNodeAt PROCEDURE , PRIVATE :: Traverse => LinkedList_Traverse ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a list from an array of items <br> !  **Usage**: <br> !   --->    CALL List%Construct(10, Arr)    ! create a list from an array of 10 items PROCEDURE :: Construct => LinkedList_CreateByArray !> **Type-Bound Subroutine**: Destruct <br> ! **Purpose**:  To destruct a list and get its items if requested <br> !  **Usage**: <br> !   --->    CALL List%Destruct()    ! destruct the list <br> !  **Note**: This method is equivalent to the *Clear* method. PROCEDURE :: Destruct => LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddFirst(Item) PROCEDURE :: AddFirst => LinkedList_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the list. <br> !  **Usage**: <br> !   --->    CALL List%AddLast(Item) PROCEDURE :: AddLast => LinkedList_AddLast !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully added. <br> !  **Usage**: <br> !   --->    Success = List%AddAt(Index, Item) <br> !   --->    IF (.NOT.List%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => LinkedList_AddAt !> **Type-Bound Subroutine**: Remove <br> ! **Purpose**:  To remove an item from the list.  The first item is removed !               by default.  If specified, the last item can be removed instead. <br> !  **Usage**: <br> !   --->    CALL List%Remove()          ! remove the first item <br> !   --->    CALL List%Remove(.FALSE.)   ! remove the last item <br> !   --->    CALL List%Remove(Item=Item) ! retrieve and the remove the first item <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: Remove => LinkedList_Remove !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveFirst(Item) <br> !   --->    IF (.NOT.List%RemoveFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveFirst => LinkedList_RemoveFirst !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the list. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveLast(Item) <br> !   --->    IF (.NOT.List%RemoveLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveLast => LinkedList_RemoveLast !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where !                the index must be between 1 and the list size. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.List%RemoveAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: RemoveAt => LinkedList_RemoveAt !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the list. <br> !  **Usage**: <br> !   --->    CALL List%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !   *StartFirst* and *MoveForward* methods (or the *StartLast* and !   *MoveBackward* methods).  Therefore, after the call to one of those !   methods and then calling this one will result in a removal of the !   current item of the iteration (i.e. the same item that can be retrieved !   via those iteration methods). PROCEDURE :: Delete => LinkedList_Delete !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the list. <br> !  **Usage**: <br> !   --->    CALL List%Clear() PROCEDURE :: Clear => LinkedList_ClearItems !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the list.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = List%ToArray(Items, MakeCopy) <br> !   --->    IF (.NOT.List%ToArray(Items), MakeCopy) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored in !   different nodes have different types.  Also, a user must supply a procedure !   to make a copy of an item for the specific type of stored items. PROCEDURE :: ToArray => LinkedList_ToArray !> **Type-Bound Subroutine**: RemoveDuplicates <br> !  **Purpose**:  To remove nodes with duplicated items from the list. <br> !  **Usage**: <br> !   --->    CALL List%RemoveDuplicates(Compare) <br> !  **Important Note**: A user must supply a procedure to compare items stored !   in the list. PROCEDURE :: RemoveDuplicates => LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveForward* procedure. PROCEDURE :: StartFirst => LinkedList_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move *forward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = List%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveForward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = List%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveForward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveForward => LinkedList_Move2NextElm !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the list is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => LinkedList_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move *backward* to the next iteration and return a flag !                indicating whether the cursor pointer has reached the end !                of the list or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = List%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = List%MoveBackward() !       ! check whether we reach the end of the list or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the list in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = List%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = List%MoveBackward(CurrItem) !   END DO !   </Code></Pre> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: MoveBackward => LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the list is empty or not. <br> !  **Usage**: <br> !   --->    Flag = List%IsEmpty() <br> !   --->    IF (.NOT.List%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => LinkedList_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the list. <br> !  **Usage**: <br> !   --->    ListSize = List%GetSize() PROCEDURE :: GetSize => LinkedList_GetSize !> **Type-Bound Function**: SameType <br> !  **Purpose**:  To check whether all stored items have the same type or not. <br> !  **Usage**: <br> !   --->    Flag = List%SameType() <br> !   --->    IF (.NOT.List%SameType()) DoSomeThing PROCEDURE :: SameType => LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the first item (without removing it from the list). !                Also, return a flag indicating whether the item is available !                or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekFirst(Item) <br> !   --->    IF (.NOT.List%PeekFirst(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekFirst => LinkedList_PeekFirst !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the list). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekLast(Item) <br> !   --->    IF (.NOT.List%PeekLast(Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekLast => LinkedList_PeekLast !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the list) at !                the specified index where the index must be between 1 and the !                list size.  Also, return a flag indicating whether the !                item is available or not. <br> !  **Usage**: <br> !   --->    Success = List%PeekAt(Index, Item) <br> !   --->    IF (.NOT.List%PeekAt(Index, Item)) DoSomething <br> !  **Important Note**: The specified type of item to be retrieved must match that !   of an item stored in the list. PROCEDURE :: PeekAt => LinkedList_PeekAt !> **Type-Bound Subroutine**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the list. Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Flag = List%GetAll(Items, MakeCopy) <br> !   --->    IF (.NOT.List%GetAll(Items), MakeCopy) DoSomething <br> !  **Important Note**: This operation will not be successful if items stored in !   different nodes have different types.  Also, a user must supply a procedure !   to make a copy of an item for the specific type of stored items. PROCEDURE :: GetAll => LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----                 Queue Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: EnQueue <br> ! **Purpose**:  To add a new item to the end of the queue. <br> !  **Usage**: <br> !   --->    CALL Queue%EnQueue(NewItem) <br> !  **Note**: *EnQueue* is an alias of *AddLast*. PROCEDURE :: EnQueue => LinkedList_AddLast !> **Type-Bound Function**: DeQueue <br> !  **Purpose**:  To get and remove the front (first) item of the queue. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Queue%DeQueue(Item) <br> !   --->    IF (.NOT.Queue%DeQueue(Item)) DoSomething <br> !  **Note**: *DeQueue* is an alias of *RemoveFirst*. PROCEDURE :: DeQueue => LinkedList_RemoveFirst ! --------------------------------------------------------------------- ! -----                 Stack Procedures                         ------ ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> ! **Purpose**:  To add a new item to the top of the stack. <br> !  **Usage**: <br> !   --->    CALL Stack%Push(NewItem) <br> !  **Note**: *Push* is an alias of *AddLast*. PROCEDURE :: Push => LinkedList_AddLast !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top item of the stack. !                Also, return a flag indicating whether the item is !                successfully removed. <br> !  **Usage**: <br> !   --->    Success = Stack%Pop(Item) <br> !   --->    IF (.NOT.Stack%Pop(Item)) DoSomething <br> !  **Note**: *Pop* is an alias of *RemoveLast*. PROCEDURE :: Pop => LinkedList_RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last item (without removing it from the container). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Container%PeekTop(Item) <br> !   --->    IF (.NOT.Container%PeekTop(Item)) DoSomething <br> !  **Note**: *PeekTop* is an alias of *PeekLast*. PROCEDURE :: PeekTop => LinkedList_PeekLast ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- !> To perform finalization of the container. FINAL :: LinkedList_Finalizer ! --------------------------------------------------------------------- END TYPE ListAnyType !** INTERFACE DEFINITIONS: ! abstract interfaces ABSTRACT INTERFACE ! IterFuncItem is a procedure supplied to a *Traverse* procedure that ! can be used to get the list's item. FUNCTION IterFuncItem ( Item , Done ) RESULT ( ErrStat ) IMPORT CLASS ( * ), INTENT ( IN ) :: Item ! item tLogical , INTENT ( INOUT ) :: Done ! on input, Done is set to .FALSE. ! on exit, set it to .TRUE. if user !   want to stop the queue traversing. tLogical :: ErrStat ! true if error occurred in the user routine END FUNCTION IterFuncItem !&#94; *CopyData* is an interface for a procedure to copy unlimited polymorphic data where !  both the source and the destination must have the same type, kind, rank, and size. !  If all of those samenesses are met, the routine should set the *ErrStat* to false !  and copy data from the source to the destination. Otherwise, the routine should set !  the *ErrStat* to true and return immediately. <br> FUNCTION CopyData ( OutData , InData ) RESULT ( ErrStat ) CLASS ( * ), INTENT ( OUT ) :: OutData !! output (destination) CLASS ( * ), INTENT ( IN ) :: InData !! input (source) tLogical :: ErrStat !! true if error occurs while copying data END FUNCTION CopyData !&#94; *CompareData* is an interface for a procedure to compare *comparable* data !  where the output flag should be set to the following value: <br> !   1 if DataA is greater than DataB,  <br> !   0 if DataA is equal to DataB, <br> !  -1 if DataA is less than DataB. FUNCTION CompareData ( DataA , DataB ) RESULT ( Flag ) IMPORT CLASS ( * ), INTENT ( IN ) :: DataA !! data A CLASS ( * ), INTENT ( IN ) :: DataB !! data B tSInt32 :: Flag !! output flag END FUNCTION CompareData END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----             DLLNode PROCEDURES                            ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedNode_Deallocate ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To deallocate DLLNode pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DLLNode ), POINTER , INTENT ( INOUT ) :: Node !! DLLNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF ( ASSOCIATED ( Node )) THEN DEALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrDealloc ( 'LinkedNode_Deallocate' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE LinkedNode_Deallocate !****************************************************************************** SUBROUTINE LinkedNode_Destructor ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct DLLNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( DLLNode ), INTENT ( INOUT ) :: Node !! DLLNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( Item => Node % Item ) CLASS IS ( Object ) CALL Item % MemFree () END SELECT DEALLOCATE ( Node % Item ) NULLIFY ( Node % Next ) NULLIFY ( Node % Prev ) RETURN END SUBROUTINE LinkedNode_Destructor ! --------------------------------------------------------------------- ! -----             ListAnyType PROCEDURES                         ----- ! --------------------------------------------------------------------- ! -----             PRIVATE PROCEDURES                            ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_SetNewNode ( List , NewNode , AppendAtTail ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set pointers for newly created node. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object TYPE ( DLLNode ), POINTER , INTENT ( IN ) :: NewNode !! new node to be added to the list tLogical , INTENT ( IN ) :: AppendAtTail !! true if append to the tail !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if list is empty or not IF ( List % IsEmpty ()) THEN ! the list is EMPTY so the new node is added to the beginning of the list List % Head => NewNode List % Tail => NewNode ELSE ! the list is NOT empty so add NewNode according to AppendAtTail flag IF ( AppendAtTail ) THEN !++++++++++++++++++++++++++++++++++++++++++++++++++ !+++ Append the NewNode to the list at the tail +++ !++++++++++++++++++++++++++++++++++++++++++++++++++ NewNode % Prev => List % Tail List % Tail % Next => NewNode List % Tail => NewNode ELSE !++++++++++++++++++++++++++++++++++++++++++++++++++ !+++ Append the NewNode to the list at the head +++ !++++++++++++++++++++++++++++++++++++++++++++++++++ NewNode % Next => List % Head List % Head % Prev => NewNode List % Head => NewNode END IF END IF ! set list length List % Size = List % Size + 1 RETURN END SUBROUTINE LinkedList_SetNewNode !****************************************************************************** FUNCTION LinkedList_RemoveNode ( List , CurrNode , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified node from the list.  Also, return a flag indicating !  whether the node is removed successfully or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object TYPE ( DLLNode ), POINTER , INTENT ( INOUT ) :: CurrNode !! the node to be removed CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! item of the removed node if requested !> flag indicating whether the node is successfully removed. <br> ! - true if the node is successfully removed. ! - false if the node is NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check input data and their possibly-related errors IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN ELSEIF (. NOT . ASSOCIATED ( CurrNode )) THEN Flag = FalseVal RETURN ELSE ! set flag Flag = TrueVal ! +++ no error in required input arguments +++ ! check whether requesting the item of the node to be removed IF ( PRESENT ( Item )) ALLOCATE ( Item , SOURCE = CurrNode % Item ) ! check whether there is only one node or not IF ( List % Size == 1 ) THEN ! ++ the list has only one node ++ ! check to make sure that the supplied node is really the only one IF ( ASSOCIATED ( CurrNode , List % Head ). AND . ASSOCIATED ( CurrNode , List % Tail )) THEN ! reset the list List % Head => NULL () List % Tail => NULL () List % Cursor => NULL () List % Size = 0 ELSE ! The list contains only one node but it is NOT associated with ! the specified node so no node is removed. Flag = FalseVal RETURN END IF ELSE ! ++ the list has two or more nodes ++ ! check where the supplied node is IF ( ASSOCIATED ( CurrNode , List % Head )) THEN ! the node is the head List % Head => CurrNode % Next List % Head % Prev => NULL () ELSEIF ( ASSOCIATED ( CurrNode , List % Tail )) THEN ! the node is the tail List % Tail => CurrNode % Prev List % Tail % Next => NULL () ELSE ! the node is in the middle CurrNode % Prev % Next => CurrNode % Next CurrNode % Next % Prev => CurrNode % Prev END IF ! set length List % Size = List % Size - 1 END IF ! destroy the current node CALL CurrNode % Destruct () CALL LinkedNode_Deallocate ( CurrNode ) END IF RETURN END FUNCTION LinkedList_RemoveNode !****************************************************************************** SUBROUTINE LinkedList_Traverse ( List , IterFunc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To traverse the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object PROCEDURE ( IterFuncItem ) :: IterFunc !! iterator function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode CLASS ( * ), POINTER :: CurrItem tLogical :: ErrStat tLogical :: Done ! FLOW ! set defaults Done = FalseVal ! traverse to all nodes ErrStat = FalseVal ! initialize current node CurrNode => List % Head ! loop over all nodes of the list DO WHILE ( ASSOCIATED ( CurrNode )) ! get current item CurrItem => CurrNode % Item ! call iterator function ErrStat = IterFunc ( CurrItem , Done ) ! report error if necessary IF ( ErrStat ) THEN CALL Handle_ErrLevel ( 'LinkedList_Traverse' , ModName , ErrSevere , & 'An error occurred during call to iterator function.' ) RETURN END IF ! exit the loop if the user want to stop the traversing IF ( Done ) EXIT ! set current node CurrNode => CurrNode % Next END DO NULLIFY ( CurrNode ) NULLIFY ( CurrItem ) RETURN END SUBROUTINE LinkedList_Traverse !****************************************************************************** FUNCTION IsIndexValid ( Size , Index ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified index is between 1 !  and the list size or not. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Size !! the list size tIndex , INTENT ( IN ) :: Index !! the specified index tLogical :: Flag !! true if the index is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal IF ( Index < 1_kIndex ) RETURN IF ( Index > Size ) RETURN Flag = TrueVal RETURN END FUNCTION IsIndexValid !****************************************************************************** FUNCTION LinkedList_GetNodeAt ( List , N ) RESULT ( NodeOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the Nth node from the list where N is between 1 and the list size. !  If the list is empty or N is not in a valid range, return Null pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object tIndex , INTENT ( IN ) :: N !! (one-based) index indicating the node TYPE ( DLLNode ), POINTER :: NodeOut !! pointer to the Nth node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurrIndex tLogical :: EndOfList !** FLOW ! check and return quickly if possible IF ( List % IsEmpty ()) THEN NodeOut => NULL () RETURN ELSEIF (. NOT . IsIndexValid ( List % Size , N )) THEN NodeOut => NULL () RETURN END IF ! check which direction to traverse the list IF ( N <= ( List % Size - N + 1 )) THEN ! perform forward iteration CurrIndex = 1 ! restart the iteration EndOfList = List % StartFirst () DO WHILE (. NOT . EndOfList ) ! check if the node is found IF ( CurrIndex == N ) EXIT ! move to the next iteration EndOfList = List % MoveForward () ! set index CurrIndex = CurrIndex + 1 END DO ELSE ! perform backward iteration CurrIndex = List % Size ! restart the iteration EndOfList = List % StartLast () DO WHILE (. NOT . EndOfList ) ! check if the node is found IF ( CurrIndex == N ) EXIT ! move to the next iteration EndOfList = List % MoveBackward () ! set index CurrIndex = CurrIndex - 1 END DO END IF ! set pointer to the Nth node NodeOut => List % Cursor RETURN END FUNCTION LinkedList_GetNodeAt ! --------------------------------------------------------------------- ! -----             PUBLIC PROCEDURES                             ----- ! --------------------------------------------------------------------- ! -----             Constructor and Destructor Procedures         ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_CreateByArray ( List , N , Items ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a list from an array of item. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object tIndex , INTENT ( IN ) :: N !! number of items CLASS ( * ), INTENT ( IN ) :: Items ( N ) !! an array of items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! simply return if N is less than 1 IF ( N <= 0 ) RETURN ! built list of input items DO I = 1 , N CALL List % AddLast ( Items ( I )) END DO RETURN END SUBROUTINE LinkedList_CreateByArray !****************************************************************************** SUBROUTINE LinkedList_Destructor ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct ListAnyType object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! destroy all nodes and free up memory CALL List % Clear () RETURN END SUBROUTINE LinkedList_Destructor ! --------------------------------------------------------------------- ! -----             Insertion and Removal Procedures              ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_AddFirst ( List , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a item at the head of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), INTENT ( IN ) :: Item !! item to be added to the list !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , PARAMETER :: AppendAtTail = FalseVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate new node and ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddFirst' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddFirst' , ModName , AllocMsg , AllocStat ) ! set pointers to new node CALL List % SetNewNode ( NewNode , AppendAtTail ) ! free up memory NULLIFY ( NewNode ) RETURN END SUBROUTINE LinkedList_AddFirst !****************************************************************************** SUBROUTINE LinkedList_AddLast ( List , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a item at the tail of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), INTENT ( IN ) :: Item !! item to be added to the list !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , PARAMETER :: AppendAtTail = TrueVal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate new node ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddLast' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddLast' , ModName , AllocMsg , AllocStat ) ! set pointers to new node CALL List % SetNewNode ( NewNode , AppendAtTail ) ! free up memory NULLIFY ( NewNode ) RETURN END SUBROUTINE LinkedList_AddLast !****************************************************************************** FUNCTION LinkedList_AddAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the given item at the specified index where the index must be !  between 1 and the list size.  Also, return a flag indicating whether the !  item is successfully added. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be added to the list CLASS ( * ), INTENT ( IN ) :: Item !> flag indicating whether the item is successfully added. <br> ! - true if the item is successfully added. ! - false if the item is NOT successfully added. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: NewNode tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! check the validity of the specified index Flag = FalseVal IF (. NOT . IsIndexValid ( List % Size , Index )) RETURN ! allocate new node and set the new node's item ALLOCATE ( NewNode , STAT = AllocStat , ERRMSG = AllocMsg ) CALL Handle_ErrAlloc ( 'LinkedList_AddAt' , ModName , AllocMsg , AllocStat ) ! allocate the new node's item and copy its data ALLOCATE ( NewNode % Item , STAT = AllocStat , ERRMSG = AllocMsg , SOURCE = Item ) CALL Handle_ErrAlloc ( 'LinkedList_AddAt' , ModName , AllocMsg , AllocStat ) ! set flag Flag = TrueVal IF ( Index == 1_kIndex ) THEN ! add node to the front CALL List % SetNewNode ( NewNode , AppendAtTail = FalseVal ) ELSE BLOCK ! block variables TYPE ( DLLNode ), POINTER :: NthNode TYPE ( DLLNode ), POINTER :: PrvNode ! get node at the index IF ( Index == List % Size ) THEN NthNode => List % Tail ELSE NthNode => List % GetNodeAt ( Index ) END IF ! get previous node PrvNode => NthNode % Prev ! add new node PrvNode % Next => NewNode NthNode % Prev => NewNode NewNode % Prev => PrvNode NewNode % Next => NthNode ! free block variables NULLIFY ( NthNode , PrvNode ) END BLOCK ! set list length List % Size = List % Size + 1 END IF ! free up pointer NULLIFY ( NewNode ) RETURN END FUNCTION LinkedList_AddAt !****************************************************************************** SUBROUTINE LinkedList_Remove ( List , First , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove a node from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object tLogical , OPTIONAL , INTENT ( IN ) :: First !&#94; location flag where the node is removed <br> ! - true (by default) if want to remove the first node <br> ! - false if want to remove the last node CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! item of the removed node if requested !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: RemoveFirstNode tLogical :: Success ! FLOW ! first, check whether the list is empty or not IF ( List % IsEmpty ()) THEN ! set routine name SubName = 'LinkedList_Remove' ! set error message ErrMsg = 'The list is EMPTY.' ! report error CALL Handle_ErrLevel ( SubName , ModName , ErrWarning , ErrMsg ) RETURN END IF ! set default and check optional input SET_OPTION ( RemoveFirstNode , TrueVal , First ) ! check whether requesting the item of the node to be removed IF ( PRESENT ( Item )) THEN IF ( RemoveFirstNode ) THEN Success = List % PeekFirst ( Item ) ELSE Success = List % PeekLast ( Item ) END IF END IF ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE ! the list has two or more nodes so check which node to be removed IF ( RemoveFirstNode ) THEN ! reset the head List % Cursor => List % Head List % Head => List % Cursor % Next List % Head % Prev => NULL () ELSE ! reset the tail List % Cursor => List % Tail List % Tail => List % Cursor % Prev List % Tail % Next => NULL () END IF ! remove the node CALL List % Cursor % Destruct () CALL LinkedNode_Deallocate ( List % Cursor ) ! set length List % Size = List % Size - 1 END IF RETURN END SUBROUTINE LinkedList_Remove !****************************************************************************** FUNCTION LinkedList_RemoveFirst ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the first item of the list.  Also, return !  a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! return quickly if the list is empty IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! get the item of the node to be removed Flag = List % PeekFirst ( Item ) ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE BLOCK ! block variable TYPE ( DLLNode ), POINTER :: DelNode => NULL () ! reset the head DelNode => List % Head List % Head => DelNode % Next List % Head % Prev => NULL () ! remove the node CALL DelNode % Destruct () CALL LinkedNode_Deallocate ( DelNode ) ! free pointer NULLIFY ( DelNode ) END BLOCK ! set length List % Size = List % Size - 1 END IF RETURN END FUNCTION LinkedList_RemoveFirst !****************************************************************************** FUNCTION LinkedList_RemoveLast ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the last item of the list.  Also, return !  a flag indicating whether the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! return quickly if the list is empty IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF ! get the item of the node to be removed Flag = List % PeekLast ( Item ) ! check whether there is only one node or not IF ( ASSOCIATED ( List % Head , List % Tail )) THEN ! the list has only one node so reset the list CALL List % Head % Destruct () CALL LinkedNode_Deallocate ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) List % Size = 0 ELSE BLOCK ! block variable TYPE ( DLLNode ), POINTER :: DelNode ! reset the tail DelNode => List % Tail List % Tail => DelNode % Prev List % Tail % Next => NULL () ! remove the node CALL DelNode % Destruct () CALL LinkedNode_Deallocate ( DelNode ) ! free pointer NULLIFY ( DelNode ) END BLOCK ! set length List % Size = List % Size - 1 END IF RETURN END FUNCTION LinkedList_RemoveLast !****************************************************************************** FUNCTION LinkedList_RemoveAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove the item at the specified index where the index must be !  between 1 and the list size.   Also, return a flag indicating whether !  the item is successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be removed from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is successfully removed. <br> ! - true if the item is successfully removed. ! - false if the item is NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: DelNode ! FLOW ! get node at the index DelNode => List % GetNodeAt ( Index ) IF ( ASSOCIATED ( DelNode )) THEN ! get item and remove node Flag = List % RemoveNode ( DelNode , Item ) ELSE Flag = FalseVal END IF NULLIFY ( DelNode ) RETURN END FUNCTION LinkedList_RemoveAt !****************************************************************************** SUBROUTINE LinkedList_Delete ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete an item from the list.  This procedure is intended to be used !  in conjunction with the *StartFirst* and *MoveForward* methods (or the !  *StartLast* and *MoveBackward*).  Therefore, after the call to one of !  these methods and then calling this procedure will result in a removal !  of the current item of the iteration (i.e. the same item that can be !  retrieved via those methods). <br> !  If the cursor pointer is not associated, nothing happens.  This usually !  means that the list is empty or this procedure is called before those !  iteration methods. <br> !  This procedure provides a way to remove items in the middle of the list !  without knowing specific locations of the items.  The user would perform !  an iteration over the list by calling those iteration methods.  While in !  the middle of the iteration, if the interested items are found, they can !  be removed from the list by this procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: DelNode tLogical :: Flag ! FLOW ! get the node to be deleted DelNode => List % Cursor IF ( ASSOCIATED ( DelNode )) THEN ! reset cursor IF ( List % Dir == 1 ) THEN ! forward iteration so move cursor backward List % Cursor => List % Cursor % Prev ELSE ! backward iteration so move cursor forward List % Cursor => List % Cursor % Next END IF Flag = List % RemoveNode ( DelNode ) END IF NULLIFY ( DelNode ) RETURN END SUBROUTINE LinkedList_Delete !************************************************************************************** SUBROUTINE LinkedList_ClearItems ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free up memory of the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the list and destroy all nodes DO WHILE (. NOT . List % IsEmpty ()) CALL List % Remove () END DO ! free up pointers NULLIFY ( List % Head ) NULLIFY ( List % Tail ) NULLIFY ( List % Cursor ) ! reset components List % Size = 0 List % Dir = 0 RETURN END SUBROUTINE LinkedList_ClearItems !****************************************************************************** FUNCTION LinkedList_ToArray ( List , Items , MakeCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all items from the list.  Also, return !  a flag indicating whether the items are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the item to be removed from the list CLASS ( * ), ALLOCATABLE , INTENT ( INOUT ) :: Items (:) !% procedure to copy items PROCEDURE ( CopyData ) :: MakeCopy !> flag indicating whether the items are successfully removed. <br> ! - true if the items are successfully removed. ! - false if the items are NOT successfully removed. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . List % SameType ()) THEN Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_ToArray' , ModName , ErrSevere , & 'Items does not have the same type.' ) RETURN END IF ! get items Flag = List % GetAll ( Items , MakeCopy ) ! destroy all nodes and free up memory CALL List % Clear () END FUNCTION LinkedList_ToArray !****************************************************************************** SUBROUTINE LinkedList_RemoveDuplicates ( List , Compare ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove nodes with duplicated items from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object PROCEDURE ( CompareData ) :: Compare !! procedure to compare items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode TYPE ( DLLNode ), POINTER :: NextNode CLASS ( * ), POINTER :: CurrItem CLASS ( * ), ALLOCATABLE :: IterItem tLogical :: Repeat tLogical :: IsTheEnd tLogical :: Success !** FLOW ! start the list CurrNode => List % Head NextNode => CurrNode % Next IF ( ASSOCIATED ( CurrNode )) ALLOCATE ( IterItem , SOURCE = CurrNode % Item ) ! traverse the list DO WHILE ( ASSOCIATED ( NextNode )) ! set flag Repeat = FalseVal ! get current item CurrItem => CurrNode % Item ! start the iteration at the next node IsTheEnd = List % MoveForward ( IterItem ) DO WHILE (. NOT . IsTheEnd ) ! check whether the items are the same IF ( Compare ( CurrItem , IterItem ) == 0 ) THEN Repeat = TrueVal EXIT END IF ! move to next iteration and get its item IsTheEnd = List % MoveForward ( IterItem ) END DO ! remove node if the current item has a duplicated one IF ( Repeat ) Success = List % RemoveNode ( CurrNode ) ! move to next node CurrNode => NextNode ! set NextNode NextNode => CurrNode % Next END DO ! free up memory NULLIFY ( CurrNode ) NULLIFY ( NextNode ) NULLIFY ( CurrItem ) IF ( ALLOCATED ( IterItem )) DEALLOCATE ( IterItem ) RETURN END SUBROUTINE LinkedList_RemoveDuplicates ! --------------------------------------------------------------------- ! -----                 Iteration Procedures                      ----- ! --------------------------------------------------------------------- FUNCTION LinkedList_Move2FirstElm ( List , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the head node of the list and return !  a flag indicating whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! first item tLogical :: IsEmpty !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Head ! set flag IsEmpty = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsEmpty ) List % Dir = 1 IF ( PRESENT ( Item ). AND .(. NOT . IsEmpty )) THEN ALLOCATE ( Item , SOURCE = List % Cursor % Item ) END IF RETURN END FUNCTION LinkedList_Move2FirstElm !****************************************************************************** FUNCTION LinkedList_Move2LastElm ( List , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the tail node of the list and return !  a flag indicating whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! last item tLogical :: IsEmpty !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Tail ! set flag IsEmpty = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsEmpty ) List % Dir = - 1 IF ( PRESENT ( Item ). AND .(. NOT . IsEmpty )) THEN ALLOCATE ( Item , SOURCE = List % Cursor % Item ) END IF RETURN END FUNCTION LinkedList_Move2LastElm !****************************************************************************** FUNCTION LinkedList_Move2NextElm ( List , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move (forward) to the next node in the list and return a flag indicating !  whether the cursor pointer has reached the end of the list or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! item of the next node tLogical :: IsTheEnd !! true if the cursor has reached the end of the list !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Cursor % Next ! set flag IsTheEnd = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsTheEnd ) THEN List % Dir = 1 ELSE List % Dir = 0 END IF IF ( PRESENT ( Item ). AND .(. NOT . IsTheEnd )) THEN ALLOCATE ( Item , SOURCE = List % Cursor % Item ) END IF RETURN END FUNCTION LinkedList_Move2NextElm !****************************************************************************** FUNCTION LinkedList_Move2PrevElm ( List , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move backward to the next node (i.e. to the so-called previous node) !  in the list and return a flag indicating whether the cursor pointer has !  reached the end of the list or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), OPTIONAL , ALLOCATABLE , INTENT ( OUT ) :: Item !! item of the previous node tLogical :: IsTheEnd !! true if the cursor has reached the end of the list !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor List % Cursor => List % Cursor % Prev ! set flag IsTheEnd = . NOT . ASSOCIATED ( List % Cursor ) ! set direction IF (. NOT . IsTheEnd ) THEN List % Dir = - 1 ELSE List % Dir = 0 END IF IF ( PRESENT ( Item ). AND .(. NOT . IsTheEnd )) THEN ALLOCATE ( Item , SOURCE = List % Cursor % Item ) END IF RETURN END FUNCTION LinkedList_Move2PrevElm ! --------------------------------------------------------------------- ! -----                 Inquiry Procedures                       ------ ! --------------------------------------------------------------------- FUNCTION LinkedList_IsEmpty ( List ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the list is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( IN ) :: List !! ListAnyType object tLogical :: Flag !! true if the list is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = . NOT . ASSOCIATED ( List % Head ) RETURN END FUNCTION LinkedList_IsEmpty !****************************************************************************** FUNCTION LinkedList_GetSize ( List ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !! To get size of the list (a number of nodes). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( IN ) :: List !! ListAnyType object tIndex :: Size !! list size (number of nodes) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = List % Size RETURN END FUNCTION LinkedList_GetSize !****************************************************************************** FUNCTION LinkedList_SameType ( List ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether all stored items have same type or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( IN ) :: List !! ListAnyType object tLogical :: Flag !! true if all items have same type !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode ! FLOW Flag = TrueVal CurrNode => List % Head % Next DO WHILE ( ASSOCIATED ( CurrNode )) IF ( SAME_TYPE_AS ( List % Head % Item , CurrNode % Item )) THEN CurrNode => CurrNode % Next ELSE Flag = FalseVal EXIT END IF END DO NULLIFY ( CurrNode ) RETURN END FUNCTION LinkedList_SameType ! --------------------------------------------------------------------- ! -----                 Retrieval Procedures                     ------ ! --------------------------------------------------------------------- FUNCTION LinkedList_PeekFirst ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the item stored at the first node without removing it from the list. !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( IN ) :: List !% the item to be retrieved from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF Flag = TrueVal ALLOCATE ( Item , SOURCE = List % Head % Item ) RETURN END FUNCTION LinkedList_PeekFirst !****************************************************************************** FUNCTION LinkedList_PeekLast ( List , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the item stored at the last node without removing it from the list. !  Also, return a flag indicating whether the item is available. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( IN ) :: List !% the item to be retrieved from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the list is NOT empty. ! - false if the list is empty. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN Flag = FalseVal RETURN END IF Flag = TrueVal ALLOCATE ( Item , SOURCE = List % Tail % Item ) RETURN END FUNCTION LinkedList_PeekLast !****************************************************************************** FUNCTION LinkedList_PeekAt ( List , Index , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the item (without removing it from the list) at the specified index !  where the index must be between 1 and the list size.  Also, return !  a flag indicating whether the item is available or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% ListAnyType object CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !% the one-based index into the list's items tIndex , INTENT ( IN ) :: Index !% the item to be retrieved from the list CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Item !> flag indicating whether the item is available. <br> ! - true if the item is available. ! - false if the item is NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( DLLNode ), POINTER :: CurrNode ! FLOW ! get the specified node CurrNode => List % GetNodeAt ( Index ) IF ( ASSOCIATED ( CurrNode )) THEN Flag = TrueVal ALLOCATE ( Item , SOURCE = CurrNode % Item ) ELSE ! set output flag Flag = FalseVal END IF NULLIFY ( CurrNode ) RETURN END FUNCTION LinkedList_PeekAt !************************************************************************************** FUNCTION LinkedList_GetAllItems ( List , Items , MakeCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To get all items (without removing them) from the list. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object CLASS ( * ), ALLOCATABLE , INTENT ( OUT ) :: Items (:) !! an allocatable array of items PROCEDURE ( CopyData ) :: MakeCopy !! procedure to copy items !> flag indicating whether the items are successfully retrieved. <br> ! - true if the items are available. ! - false if the items are NOT available. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , N ! FLOW ! check if the list is empty or not IF ( List % IsEmpty ()) THEN ! set output Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_GetAllItems' , ModName , ErrWarning , 'The list is EMPTY.' ) RETURN END IF ! get number of items N = List % Size ! allocate storage for output IF ( List % SameType ()) THEN ALLOCATE ( Items ( N ), MOLD = List % Head % Item ) ELSE ! set output Flag = FalseVal ! report error CALL Handle_ErrLevel ( 'LinkedList_GetAllItems' , ModName , ErrSevere , & 'Items does not have the same type.' ) RETURN END IF ! get items I = 0 CALL List % Traverse ( ItemIterator ) ! set flag Flag = TrueVal RETURN CONTAINS FUNCTION ItemIterator ( Item , Done ) RESULT ( ErrStat ) !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( * ), INTENT ( IN ) :: Item ! item tLogical , INTENT ( INOUT ) :: Done ! on input, Done is set to FalseVal ! on exit, set it to TrueVal if user !   want to stop the stack traversing. tLogical :: ErrStat ! true if error occurred in the user routine !** FLOW: ! set flag Done = FalseVal ! get item I = I + 1 ErrStat = MakeCopy ( Items ( I ), Item ) RETURN END FUNCTION ItemIterator !************************************************************************** END FUNCTION LinkedList_GetAllItems ! --------------------------------------------------------------------- ! -----             Final Procedure                               ----- ! --------------------------------------------------------------------- SUBROUTINE LinkedList_Finalizer ( List ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ListAnyType ), INTENT ( INOUT ) :: List !! ListAnyType object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! destroy all nodes and free up memory CALL List % Clear () RETURN END SUBROUTINE LinkedList_Finalizer !****************************************************************************** END MODULE MClass_ListAnyType !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listanytype.f90.html"},{"title":"MClass_PQInteger1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQInteger1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQInteger1B* type and its related routines. !   The *PQInteger1B* type is a priority-queue container with *INTEGER(KIND=kInt8)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQInteger1B* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQInteger1B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     INTEGER(KIND=kInt8) #define     PQHeap      PQInteger1B !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQInteger1B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQInteger1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqinteger1b.f90.html"},{"title":"MClass_PQBasic.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQBasic !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQBasic* type and its related routines.  The *PQBasic* !   type is a priority-queue container where the type of its stored keys is in the !   *Comparable* class (i.e. a concrete subtype of the *Comparable* type).  It uses !   an elementary implementation where its array representation can be unordered or !   ordered.  By default, its array representation is ordered where a sorting !   algorithm is employed to order its stored keys.  <br> !   Functionally, the *PQBasic* type is exactly the same as the *PQHeap* type.  They !   only differs in their internal implementations where the *PQBasic* type can use !   any sorting algorithm from the *MBase_SortAscend* and *MBase_SortDescend* !   modules while the *PQHeap* type uses a binary heap (i.e. essentially heap sort) !   to order its stored keys.  The sorting algorithms for the *PQBasic* type are !   optionally specified when the container is created. <br> !   See the <a href=\"../module/mclass_pqheap.html\">MClass_PQHeap</a> module for more !   explanations about its functionalities and limitations, which are the same as !   those of the *PQBasic* type. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !   See the <a href=\"../../xpfranknsort/module/mbase_sortdescend.html\">MBase_SortDescend</a> !   module for routines that perform sorting of an array in a *descending* order, and see the !   <a href=\"../../xpfranknsort/module/mbase_sortascend.html\">MBase_SortAscend</a> module for !   routines that perform sorting of an array in an *ascending* order. !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_Comparable USE MBase_SortAscend , ONLY : RustSortAscend => RustSort USE MBase_SortDescend , ONLY : RustSortDescend => RustSort IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQ_Basic PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     CLASS(Comparable) #define     PQBasic     PQ_Basic !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQBasic' !** DERIVED TYPE DEFINITIONS !> The *PQBasic* type is a container type that employs a binary heap implementation !  to provide common operations for a priority queue. TYPE PQBasic PRIVATE !% pointer to last item of the priority queue tIndex :: Last = 0_kIndex !% incremental size of priority queue if it is full tIndex :: IncSize = 16_kIndex !% flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> flag indicating whether the priority queue is implemented as !  a maximum PQ or a minimum PQ. <br> !  default -> a maximum PQ. tLogical :: Min = FalseVal !> flag indicating whether the priority queue is implemented as !  an ordered or unordered array representation. <br> !  default -> an ordered array representation. tLogical :: Unordered = FalseVal !% stored keys in the priority queue. KeyType , ALLOCATABLE :: Keys (:) !% temporary key. KeyType , ALLOCATABLE :: Temp !% pointer to sorting algorithm PROCEDURE ( Sort ), NOPASS , POINTER :: SortAscend => NULL () !% pointer to sorting algorithm PROCEDURE ( Sort ), NOPASS , POINTER :: SortDescend => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                      Public Procedures                    ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap, Mold)                 ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold, MinPQ=.TRUE.)        ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, Mold, IncSize=16)          ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Mold, Shrink=.TRUE.)       ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, Mold, Unordered=.TRUE.)    ! specify unordered PQ <br> !   --->    CALL Table%CreateEmpty(32, Mold, SortAscend=WiseSort) ! specify ascending sorting algorithm <br> !   --->    CALL Table%CreateEmpty(32, Mold, SortDescend=TimSort) ! specify descending sorting algorithm <br> !           ! specify all options <br> !   --->    CALL Table%CreateEmpty(32, Mold, .TRUE., 16, .TRUE., .TRUE., RustSort, IntroSort) <br> PROCEDURE :: CreateEmpty => PQBasic_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL PQ%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink, Unordered, SortAscend, SortDescend) <br> PROCEDURE :: Construct => PQBasic_ConstructorByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all stored keys and free all memory currently used by the priority !       queue.  Optionally, stored keys can be retrieved. <br> !  **Usage**: <br> !   --->    CALL PQ%Destruct() <br> !   --->    CALL PQ%Destruct(StoredKeys) <br> PROCEDURE :: Destruct => PQBasic_Destructor ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%Insert(Key) <br> PROCEDURE :: Insert => PQBasic_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Remove(Key) <br> !   --->    IF (.NOT.PQ%Remove(Key)) DoSomething PROCEDURE :: Remove => PQBasic_RemoveKey ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the priority queue is empty or not. <br> !  **Usage**: <br> !   --->    Flag = PQ%IsEmpty() <br> !   --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => PQBasic_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (number of stored keys) of the priority queue. <br> !  **Usage**: <br> !   --->    Size = PQ%GetSize() PROCEDURE :: GetSize => PQBasic_GetSize !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Peek(Key) <br> !   --->    IF (.NOT.PQ%Peek(Key)) DoSomething PROCEDURE :: Peek => PQBasic_PeekKey ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQBasic_Finalizer ! --------------------------------------------------------------------- END TYPE PQBasic !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE SUBROUTINE Sort ( A ) IMPORT CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                           Routines for PQBasic !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE PQBasic_CreateEmpty ( PQ , InitCap , Mold , MinPQ , IncSize , Shrink , Unordered , & SortAscend , SortDescend ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object tIndex , INTENT ( IN ) :: InitCap !! initial size of priority queue KeyType , INTENT ( IN ) :: Mold !! mold tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. tLogical , OPTIONAL , INTENT ( IN ) :: Unordered !&#94; true if the priority queue to be internally implemented as an unordered array PQ; !  default is an ordered array PQ. PROCEDURE ( Sort ), OPTIONAL :: SortAscend !! procedure to sort in ascending order PROCEDURE ( Sort ), OPTIONAL :: SortDescend !! procedure to sort in descending order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQBasic_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity of priority queue to 16.' ) Capacity = PQ % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the keys in the priority queue CALL MemAlloc ( PQ % Keys , Capacity , Mold ) ! finally, check optional input data IF ( PRESENT ( MinPQ )) PQ % Min = MinPQ IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) PQ % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) PQ % Shrink = Shrink IF ( PRESENT ( Unordered )) PQ % Unordered = Unordered IF ( PRESENT ( SortAscend )) PQ % SortAscend => SortAscend IF ( PRESENT ( SortDescend )) PQ % SortDescend => SortDescend RETURN END SUBROUTINE PQBasic_CreateEmpty !****************************************************************************** SUBROUTINE PQBasic_ConstructorByArray ( PQ , N , Keys , MinPQ , IncSize , Shrink , Unordered , & SortAscend , SortDescend ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a priority queue from an array of key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object tIndex , INTENT ( IN ) :: N !! number of keys KeyType , INTENT ( IN ) :: Keys ( N ) !! key array tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. tLogical , OPTIONAL , INTENT ( IN ) :: Unordered !&#94; true if the priority queue to be internally implemented as an unordered array PQ; !  default is an ordered array PQ. PROCEDURE ( Sort ), OPTIONAL :: SortAscend !! procedure to sort in ascending order PROCEDURE ( Sort ), OPTIONAL :: SortDescend !! procedure to sort in descending order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! simply return if N is less than 1 IF ( N <= 0_kIndex ) RETURN ! create empty priority queue IF ( PRESENT ( IncSize )) THEN InitCap = N + IncSize ELSE InitCap = N + PQ % IncSize END IF CALL PQ % CreateEmpty ( InitCap , Keys ( 1 ), MinPQ , IncSize , Shrink , Unordered , SortAscend , SortDescend ) ! add input keys to the priority queue DO I = 1_kIndex , N CALL PQ % Insert ( Keys ( I )) END DO RETURN END SUBROUTINE PQBasic_ConstructorByArray !****************************************************************************** SUBROUTINE PQBasic_Destructor ( PQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct PQBasic object and get its keys if requested. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object KeyType , ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , ID tLogical :: Success ! FLOW IF (. NOT . PQ % IsEmpty ()) THEN IF ( PRESENT ( Keys )) THEN ! get keys (and free memory of components of keys if applicable) N = PQ % Last CALL MemAlloc ( Keys , N , PQ % Keys ( 1 )) DO ID = 1_kIndex , N Success = PQ % Remove ( Keys ( ID )) END DO END IF END IF ! reset components PQ % Last = 0_kIndex PQ % IncSize = 10_kIndex PQ % Shrink = FalseVal PQ % Min = FalseVal PQ % Unordered = FalseVal ! free memory of priority queue keys CALL MemFree ( PQ % Keys ) ! free pointers NULLIFY ( PQ % SortAscend ) NULLIFY ( PQ % SortDescend ) RETURN END SUBROUTINE PQBasic_Destructor !****************************************************************************** SUBROUTINE PQBasic_Finalizer ( PQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free up memory and reset components CALL PQ % Destruct () RETURN END SUBROUTINE PQBasic_Finalizer !****************************************************************************** SUBROUTINE PQBasic_InsertKey ( PQ , NewKey ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new key to the top (or bottom) of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object KeyType , INTENT ( IN ) :: NewKey !! new key to be added to the priority queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW IF (. NOT . SAME_TYPE_AS ( NewKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQBasic_InsertKey' , ModName , ErrWarning , & 'Type of the inserted key must be the same as that of stored keys.' ) RETURN END IF ! check capacity of the priority queue Capacity = SIZE ( PQ % Keys ) IF ( PQ % Last == Capacity ) THEN ! increase the priority queue capacity Capacity = Capacity + PQ % IncSize ! resize the priority queue CALL MemResize ( PQ % Keys , Capacity ) END IF ! increment the pointer PQ % Last = PQ % Last + 1_kIndex ! then, add new key to the priority queue PQ % Keys ( PQ % Last ) = NewKey ! sort the keys if necessary IF (. NOT . PQ % Unordered ) THEN ! the array elements 1 to PQ%Last-1 are already in order (total sorted) ! so perform sorting using sorting algorithm (algorithm can be changed ! via the use statements) IF ( PQ % Min ) THEN ! descending order IF ( ASSOCIATED ( PQ % SortDescend )) THEN CALL PQ % SortDescend ( PQ % Keys ( 1 : PQ % Last )) ELSE CALL RustSortDescend ( PQ % Keys ( 1 : PQ % Last )) END IF ELSE ! ascending order IF ( ASSOCIATED ( PQ % SortAscend )) THEN CALL PQ % SortAscend ( PQ % Keys ( 1 : PQ % Last )) ELSE CALL RustSortAscend ( PQ % Keys ( 1 : PQ % Last )) END IF END IF END IF RETURN END SUBROUTINE PQBasic_InsertKey !****************************************************************************** FUNCTION PQBasic_RemoveKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object KeyType , INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity , HPIndex , I ! FLOW IF (. NOT . SAME_TYPE_AS ( HPKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQBasic_RemoveKey' , ModName , ErrWarning , & 'Type of the retrieved key must be the same as that of stored keys.' ) Flag = FalseVal RETURN END IF ! first, check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! get the highest-priority key IF ( PQ % UnOrdered ) THEN ! for an unordered-array PQ, get the index of the highest-priority key HPIndex = 1_kIndex IF ( PQ % Min ) THEN ! for MinPQ DO I = 2_kIndex , PQ % Last IF ( PQ % Keys ( HPIndex ) > PQ % Keys ( I )) HPIndex = I END DO ELSE ! for MaxPQ DO I = 2_kIndex , PQ % Last IF ( PQ % Keys ( HPIndex ) < PQ % Keys ( I )) HPIndex = I END DO END IF ! get the highest-priority key HPKey = PQ % Keys ( HPIndex ) ELSE ! for an ordered-array PQ, get the last key as the highest-priority one HPKey = PQ % Keys ( PQ % Last ) END IF ! remove the highest-priority key from the queue IF ( PQ % UnOrdered ) THEN ! swap the highest-priority key with the last one ASSOCIATE ( Temp => PQ % Temp ) Temp = PQ % Keys ( HPIndex ) EXCHANGE ( PQ % Keys , HPIndex , PQ % Last ) END ASSOCIATE END IF ! update pointer PQ % Last = PQ % Last - 1_kIndex ! shrink capacity of the priority queue if necessary IF ( PQ % Shrink ) THEN Capacity = SIZE ( PQ % Keys , KIND = kIndex ) IF (( PQ % Last > 0_kIndex ). AND .( PQ % Last == Capacity / 4_kIndex )) THEN ! reduce the priority queue capacity Capacity = Capacity / 2_kIndex ! resize the priority queue CALL MemResize ( PQ % Keys , Capacity ) END IF END IF RETURN END FUNCTION PQBasic_RemoveKey !****************************************************************************** FUNCTION PQBasic_IsEmpty ( PQ ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the priority queue is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( IN ) :: PQ !! PQBasic object tLogical :: Flag !! true if the priority queue is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( PQ % Last == 0_kIndex ) RETURN END FUNCTION PQBasic_IsEmpty !****************************************************************************** FUNCTION PQBasic_GetSize ( PQ ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( IN ) :: PQ !! PQBasic object tIndex :: Size !! size (number of keys) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = PQ % Last RETURN END FUNCTION PQBasic_GetSize !****************************************************************************** FUNCTION PQBasic_PeekKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBasic ), INTENT ( INOUT ) :: PQ !! PQBasic object KeyType , INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: HPIndex , I ! FLOW IF (. NOT . SAME_TYPE_AS ( HPKey , PQ % Keys )) THEN CALL Handle_ErrLevel ( 'PQBasic_PeekKey' , ModName , ErrWarning , & 'Type of the retrieved key must be the same as that of stored keys.' ) Flag = FalseVal RETURN END IF ! check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! get the highest-priority key IF ( PQ % UnOrdered ) THEN ! for an unordered-array PQ, get the index of the highest-priority key HPIndex = 1_kIndex IF ( PQ % Min ) THEN ! for MinPQ DO I = 2_kIndex , PQ % Last IF ( PQ % Keys ( HPIndex ) > PQ % Keys ( I )) HPIndex = I END DO ELSE ! for MaxPQ DO I = 2_kIndex , PQ % Last IF ( PQ % Keys ( HPIndex ) < PQ % Keys ( I )) HPIndex = I END DO END IF ! get the highest-priority key HPKey = PQ % Keys ( HPIndex ) ELSE ! for an ordered-array PQ, get the last key as the highest-priority one HPKey = PQ % Keys ( PQ % Last ) END IF RETURN END FUNCTION PQBasic_PeekKey !****************************************************************************** END MODULE MClass_PQBasic !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqbasic.f90.html"},{"title":"MClass_TreeRealSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeRealSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeRealSP* type and its related helper type and routines. !   The *TreeRealSP* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeRealSP* !   type uses the Fortran intrinsic *REAL(KIND=kSingle)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeRealSP* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeRealSP* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeRealSP* type but utilizes !   a different implementation.  Also, unlike the *TreeRealSP* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeRealSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        REAL(KIND=kSingle) #define KeyTypeB        REAL(KIND=kSingle) #define KeyTypeC        REAL(KIND=kSingle) #define QueueKey        ListRealSP #define QueueVal        ListAnyType #define RedBlackTree    TreeRealSP !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeRealSP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeRealSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treerealsp.f90.html"},{"title":"MClass_LinkedLists.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_LinkedLists !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains *linked-list-based* collection types and their related routines. !   A *linked-list-based* type is a collection type that employs a linked list implementation. <br> !   Available collection types based on the linked list concept include:  <br> !   - the *StackLinked* type that represents a last-in-first-out (LIFO) stack,  <br> !   - the *QueueLinked* type that represents a first-in-first-out (FIFO) queue,  <br> !   - the *DequeLinked* type that represents a double-ended queue (deque).  <br> !   - the *ListLinked* type that represents a list where an item can be added, removed or !     retrieved at the (valid) specified index.  <br> !   <br> !   **Usage Notes**:  <br> !   - Unlike the *dynamic-array-based* types, the *linked-list-based* types commonly do not !     require an explicit construction.  Items can be added via the *Construction* method !     or an insertion method.  Therefore, the *CreateEmpty* method used to construct an empty !     collection is deemed unnecessary and thus NOT provided.  <br> !   - Other than that, all operations provided are the same for both groups of collections.  <br> !   <br> !   **Important Notes**:  <br> !   (1) By design, similar to the *dynamic-array-based* types, although all *linked-list-based* !       types are generic containers that can be used to store items of any data types, they !       must be employed to store items of only one particular data type.  To store items of !       another data type, they must be cleared and/or destructed before inserting items of !       different data type. <br> !   (2) To be able to successfully retrieve stored items, the specified output item must have !       the same (concrete) type as that of stored items. <br> !   (3) Additionally, if type of the stored items is a derived one that is NOT in the *Object* !       class and this type has allocatable and/or pointer components, a user must specify the !       optional *ItemCopy* argument when trying to retrieve the stored items.  The *ItemCopy* !       argument is a user-defined procedure to copy an unlimited polymorphic entity.  It must !       must provide a type-guard statement to check the compatibility of concrete types of its !       arguments.  It must also handle the storage allocation (and/or the assignment) of those !       allocatable (and/or pointer) components as appropriate. <br> !   <br> !   **Implementation Notes**:  <br> !   - Unlike conventional implementation, all *linked-list-based* types provided in this module !     employ the <a href=\"../../xpfbase/module/mclass_intrusivelinkedlists.html#type-intrusivelinearlist\"> !     IntrusiveLinearList</a> type, which is an intrusive doubly-linked list container type that !     performs common linked-list operations without a memory management task.  <br> !   - As a result, the *linked-list-based* types mostly handle the memory management task while !     common operations of a linked list are relegated to the *IntrusiveLinearList* type, which !     is declared as a private component of the *linked-list-based* collection types.  <br> !   - The implementation here in this module (and its submodules) is intended to illustrate the !     usage of an intrusive container type. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveLinkedLists , ONLY : DoublyLinkedNode , IntrusiveLinearList USE MClass_Object , ONLY : Object USE MClass_BaseNodePool USE MClass_MemoryPool USE MClass_GenData USE MClass_BaseCollection USE MClass_BaseIterable USE MClass_CharBuffer IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DequeLinked PUBLIC :: ListLinked PUBLIC :: QueueLinked PUBLIC :: StackLinked PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_LinkedLists' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *LinkedNode* is a linked node type that uses the *GenData* type to store its item. !  The *LinkedNode* type is a subtype of the *DoublyLinkedNode* type, which is intended !  to be used with a collection type that utilizes the *IntrusiveLinearList* type. <br> TYPE , EXTENDS ( DoublyLinkedNode ) :: LinkedNode TYPE ( GenData ) :: Store !! storage of item (or value) CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => LinkedNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => LinkedNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => LinkedNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => LinkedNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => LinkedNode_HashCode ! --------------------------------------------------------------------- END TYPE LinkedNode !> **Description**: <br> !   The *QueueLinked* type is a collection type that employs a linked-list implementation !   to provide common operations for a FIFO queue. <br> !  **Usage Overview**: <br> !   The *QueueLinked* type is a *queue* collection type that provides common operations of !   a FIFO queue.  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of !          items or from another collection, <br> !   (1.2) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *Enqueue* method - method to insert an item to the end of the collection, <br> !   (2.2) *Dequeue* method - method to get and remove the first item of the collection, <br> !   (2.3) *Clear* method - method to remove all items from the collection. <br> !   (2.4) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekFirst* method - method to retrieve the first item of the collection, <br> !   (3.2) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.3) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.4) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item. <br> TYPE , EXTENDS ( BaseIterable ) :: QueueLinked PRIVATE !> a working doubly-linked list TYPE ( IntrusiveLinearList ) :: WrkLst !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of linked nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: QueueLinked_CreateByArray !> *ToString* is a deferred procedure to get the string representation of this object. PROCEDURE , PRIVATE :: BaseString => QueueLinked_BaseString ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method in place of the *CopyCollection* method to !  create a collection from another collection. PROCEDURE :: CopyCollection => QueueLinked_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory of items stored !                in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => QueueLinked_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => QueueLinked_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => QueueLinked_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether the !                cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => QueueLinked_Move2NextElm !> Use the *Enqueue* method in place of the *Insert* method to add an item to the queue. PROCEDURE :: Insert => QueueLinked_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete an item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => QueueLinked_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => QueueLinked_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, !                return a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => QueueLinked_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => QueueLinked_CreateByArray !> **Type-Bound Subroutine**: Enqueue <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Enqueue(Item) GENERIC :: Enqueue => Insert !> **Type-Bound Function**: Dequeue <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Dequeue(Item) <br> !   --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething PROCEDURE :: Dequeue => QueueLinked_Dequeue !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekFirst(Item) <br> !   --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => QueueLinked_PeekFirst ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => QueueLinked_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => QueueLinked_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => QueueLinked_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => QueueLinked_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => QueueLinked_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: QueueLinked_Finalize ! --------------------------------------------------------------------- END TYPE QueueLinked !> **Description**: <br> !   The *StackLinked* type is a collection type that employs a linked-list implementation to !   provide common operations for a LIFO stack. <br> !  **Usage Overview**: <br> !   The *StackLinked* type is a *stack* collection type that provides common operations of !   a LIFO stack.  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of !          items another or from collection, <br> !   (1.2) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *Push* method - method to insert an item at the top of the collection, <br> !   (2.2) *Pop* method - method to get and remove the top (last) item of the collection, <br> !   (2.3) *Clear* method - method to remove all items from the collection. <br> !   (2.4) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekTop* method - method to retrieve the top (last) item of the collection, <br> !   (3.2) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.3) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.4) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item. <br> !  **Note**: Since the *StackLinked* type is a subtype of the *QueueLinked* type, it can also !            be used as a FIFO queue. TYPE , EXTENDS ( QueueLinked ) :: StackLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething PROCEDURE :: Pop => StackLinked_Pop !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething PROCEDURE :: PeekTop => StackLinked_PeekTop ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StackLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: StackLinked_Finalize ! --------------------------------------------------------------------- END TYPE StackLinked !> **Description**: <br> !   The *DequeLinked* type is a collection type that employs a linked-list implementation to !   provide common operations for a double-ended queue (deque).  It can be used as a FIFO !   queue or a LIFO stack as well. <br> !  **Usage Overview**: <br> !   The *DequeLinked* type is a *deque* collection type that provides common operations of !   a double-ended queue (deque).  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of !          items or from another collection, <br> !   (1.2) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *AddFirst* method - method to insert an item to the front of the collection, <br> !   (2.2) *AddLast* method - method to insert an item to the end of the collection, <br> !   (2.3) *RemoveFirst* method - method to get and remove the first item of the collection, <br> !   (2.4) *RemoveLast* method - method to get and remove the last item of the collection, <br> !   (2.5) *Clear* method - method to remove all items from the collection. <br> !   (2.6) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekFirst* method - method to retrieve the first item of the collection, <br> !   (3.2) *PeekLast* method - method to retrieve the last item of the collection, <br> !   (3.3) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.4) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.5) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item, <br> !   (4.3) *StartLast* method - method to start a backward iteration over items, <br> !   (4.4) *MoveBackward* method - method to move backward to the previous item. <br> !  **Note**: The *DequeArray* type also supports the usual *Enqueue*, *Dequeue* and *PeekFirst* !       operations of a FIFO queue as well as the usual *Push*, *Pop* and *PeekTop* operations !       of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be !       used in place of *insert*, *remove*, *peek* operations of a deque as desired. <br> TYPE , EXTENDS ( QueueLinked ) :: DequeLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**:  See the *MoveBackward* method. PROCEDURE :: StartLast => DequeLinked_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse across the collection !   in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Collection%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward() !       ! check whether we reach the end of the collection or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the collection in reverse !   order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Collection%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DequeLinked_Move2PrevElm !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddFirst(Item) PROCEDURE :: AddFirst => DequeLinked_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddLast(Item) GENERIC :: AddLast => Insert !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the collection.  Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveFirst(Item) <br> !   --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething GENERIC :: RemoveFirst => Dequeue !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the collection.  Also, return a flag !                indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveLast(Item) <br> !   --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DequeLinked_RemoveLast !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the collection).  Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekLast(Item) <br> !   --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DequeLinked_PeekLast ! --------------------------------------------------------------------- ! -----             Redefined Stack Operations                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection.  Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething GENERIC :: Pop => RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething GENERIC :: PeekTop => PeekLast ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => DequeLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: DequeLinked_Finalize ! --------------------------------------------------------------------- END TYPE DequeLinked !> **Description**: <br> !   The *ListLinked* type is a collection type that employs a linked-list implementation to !   provide common operations for a list. <br> !  **Usage Overview**: <br> !   The *ListLinked* type provides insert, remove and peek operations at a specified index !   where the index must be between 1 and the collection size.  The *ListLinked* type is a !   subtype of the *DequeLinked* type; therefore, all operations available for the !   *DequeLinked* type are also available for the *ListLinked* type.  Furthermore, it thus !   can be used as a deque, a FIFO queue or a LIFO stack.  <br> TYPE , EXTENDS ( DequeLinked ) :: ListLinked CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListLinked Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where the index must !                be between 1 and the collection size.  Also, return a flag indicating !                whether the item is successfully added. <br> !  **Usage**: <br> !   --->    Success = Collection%AddAt(Index, Item) <br> !   --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => ListLinked_AddAt !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where the index must be !                between 1 and the collection size.  Also, return a flag indicating whether !                the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => ListLinked_RemoveAt !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the collection) at the specified !                index where the index must be between 1 and the collection size.  Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => ListLinked_PeekAt ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListLinked_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListLinked_Finalize ! --------------------------------------------------------------------- END TYPE ListLinked !** INTERFACE DEFINITIONS: ! interfaces for QueueLinked INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_Copy ( SrcObj , DstObj , IsDeep ) !&#94; To copy the source object to the destination object. <br> CLASS ( QueueLinked ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !&#94; To check whether LhsObj and RhsObj are equal or not. <br> CLASS ( QueueLinked ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_MemFree ( Obj ) !&#94; To free memory of the object. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Obj END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( QueueLinked ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_HashCode ( Obj ) RESULT ( Code ) !&#94; To compute hash code for this object. CLASS ( QueueLinked ), INTENT ( IN ) :: Obj tIndex :: Code END FUNCTION QueueLinked_HashCode ! --------------------------------------------------------------------- ! -----      Deferred Procedures from BaseCollection Type         ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_CopyCollection ( This , Other , ItemCopy , ValCopy ) !&#94; To creates a new collection (This) from the given collection (Other). <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: This !! collection object to be created CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !! collection object to be copied !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_ClearItems ( Collection ) !&#94; To remove all of the items from the collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_Destroy ( Collection ) !&#94; To destruct the collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_GetSize ( Collection ) RESULT ( Size ) !&#94; To get the number of items stored in the collection. <br> CLASS ( QueueLinked ), INTENT ( IN ) :: Collection !! collection object tIndex :: Size !! number of items END FUNCTION ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseIterable Type         ----- ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_Move2FirstElm ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !&#94; To move to the first element in the collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the first element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection contains no element or not <br> ! - true if the collection is empty. <br> ! - otherwise the first element is available. tLogical :: IsEmpty END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_Move2NextElm ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !&#94; To move to the next element in the collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the next element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the collection occurs or not <br> ! - true if next element is NOT available. <br> ! - otherwise next element is available. tLogical :: IsTheEnd END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_AddElm ( Collection , Item ) !&#94; To insert the specified item at the end of the collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_DelElm ( Collection ) !&#94; To delete the current item from a collection. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection END SUBROUTINE ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueLinked Type            ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueLinked_CreateByArray ( Collection , N , Items ) !&#94; To construct the collection from an array of items. <br> CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object tIndex , INTENT ( IN ) :: N !! number of items CLASS ( * ), INTENT ( IN ) :: Items (:) !! array of items END SUBROUTINE QueueLinked_CreateByArray ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_Dequeue ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the first item of the collection.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_PeekFirst ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the first item (without removing it from the collection). Also, return !  a flag indicating whether the item is successfully retrieved or not. CLASS ( QueueLinked ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_ToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get and remove all items from the collection.  Also, return !  a flag indicating whether the items are successfully removed. CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_GetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get all items (without removing them) from the collection.  Also, !  return a flag indicating whether the items are available. CLASS ( QueueLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueLinked_BaseString ( Obj ) RESULT ( Str ) !&#94; To return the base-string representation of the *QueueLinked* class. CLASS ( QueueLinked ), INTENT ( IN ) :: Obj !! collection object tCharAlloc :: Str !! base string END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for StackLinked INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE FUNCTION StackLinked_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( StackLinked ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackLinked Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION StackLinked_Pop ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the top (last) item of the collection.  Also, return !  a flag indicating whether the item is successfully removed. CLASS ( StackLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackLinked_PeekTop ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the top (last) item (without removing it from the collection). Also, !  return a flag indicating whether the item is successfully retrieved or not. CLASS ( StackLinked ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for DequeLinked INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE FUNCTION DequeLinked_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( DequeLinked ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeLinked Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION DequeLinked_Move2LastElm ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !&#94; To move to the last element in the collection. <br> CLASS ( DequeLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the last element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection contains no element or not <br> ! - true if the collection is empty. <br> ! - otherwise the last element is available. tLogical :: IsEmpty END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION DequeLinked_Move2PrevElm ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !&#94; To move to the previous element in the collection. <br> CLASS ( DequeLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the previous element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the collection occurs or not <br> ! - true if previous element is NOT available. <br> ! - otherwise previous element is available. tLogical :: IsTheEnd END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE DequeLinked_AddFirst ( Collection , Item ) !&#94; To insert the specified item at the start of the collection. <br> CLASS ( DequeLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION DequeLinked_RemoveLast ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the last item of the collection.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( DequeLinked ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved and removed. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION DequeLinked_PeekLast ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the last item (without removing it from the collection). Also, return !  a flag indicating whether the item is successfully retrieved or not. CLASS ( DequeLinked ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for ListLinked INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE FUNCTION ListLinked_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( ListLinked ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListLinked Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION ListLinked_AddAt ( Collection , Index , Item ) RESULT ( Success ) !&#94; To insert the specified item at the specified position in the collection. CLASS ( ListLinked ), INTENT ( INOUT ) :: Collection !! collection object !> index indicating the position in the collection to add the item tIndex , INTENT ( IN ) :: Index !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item !> flag indicating whether the item is successfully added or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION ListLinked_RemoveAt ( Collection , Index , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the item at the specified position.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( ListLinked ), INTENT ( INOUT ) :: Collection !! collection object !> index indicating the position in the collection to retrieve and remove the item tIndex , INTENT ( IN ) :: Index !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved and removed. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION ListLinked_PeekAt ( Collection , Index , Item , ItemCopy ) RESULT ( Success ) !&#94; To retrieve the item at the specified position (without removing it from the !  collection). Also, return a flag indicating whether the item is successfully !  retrieved or not. CLASS ( ListLinked ), INTENT ( INOUT ) :: Collection !! collection object !> index indicating the position in the collection to retrieve the item tIndex , INTENT ( IN ) :: Index !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! ----------------------------------------------------------------------------- ! -----                     LinkedNode Procedures                         ----- ! ----------------------------------------------------------------------------- SUBROUTINE LinkedNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the LinkedNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LinkedNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( LinkedNode ) CALL SrcObj % CopyDLLNode ( DstObj ) CALL SrcObj % Store % Copy ( DstObj % Store , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'LinkedNode_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE LinkedNode_Copy !****************************************************************************** FUNCTION LinkedNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LinkedNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( LinkedNode ) Flag = FalseVal IF (. NOT . LhsObj % Store % IsEqualTo ( RhsObj % Store )) RETURN Flag = LhsObj % IsDLLNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION LinkedNode_IsEqualTo !****************************************************************************** SUBROUTINE LinkedNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the LinkedNode object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LinkedNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % Store % MemFree () CALL Obj % FreePointers () RETURN END SUBROUTINE LinkedNode_MemFree !****************************************************************************** FUNCTION LinkedNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LinkedNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{LinkedNode : ' // Obj % Store % ToString () // '}' RETURN END FUNCTION LinkedNode_ToString !****************************************************************************** FUNCTION LinkedNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( LinkedNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: AdjNode ! FLOW ! get code from previous node AdjNode => Obj % GetPrevious () SELECT TYPE ( Prev => AdjNode ) TYPE IS ( LinkedNode ) Code = Prev % Store % HashCode () END SELECT ! add code from this node Code = Code + Obj % Store % HashCode () ! add code from next node AdjNode => Obj % GetNext () SELECT TYPE ( Next => AdjNode ) TYPE IS ( LinkedNode ) Code = Code + Next % Store % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION LinkedNode_HashCode ! ------------------------------------------------------------------------------ ! -----                     Final Procedures                               ----- ! ------------------------------------------------------------------------------ SUBROUTINE DequeLinked_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DequeLinked ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE DequeLinked_Finalize !****************************************************************************** SUBROUTINE ListLinked_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ListLinked ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE ListLinked_Finalize !****************************************************************************** SUBROUTINE QueueLinked_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueLinked ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE QueueLinked_Finalize !****************************************************************************** SUBROUTINE StackLinked_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( StackLinked ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE StackLinked_Finalize !****************************************************************************** END MODULE MClass_LinkedLists !******************************************************************************","tags":"","loc":"sourcefile\\mclass_linkedlists.f90.html"},{"title":"MClass_HashTree.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HashTree !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HashTree* type and its supporting routines and data type. !   The *HashTree* type is a collection type that employs a separate-chaining hash table !   implementation to provide common operations for an unordered symbol table. <br> !   The *HashTree* type uses the *KeyOrdered* type to store its keys and the *GenData* !   type to store its values.  Therefore, it can be used to store comparable keys and !   values of any data types.  Allowed types of comparable keys include the *CHARACTER*, !   *INTEGER* and *REAL* intrinsic types as well as any derived type that is in the !   *Comparable* class.  Like other collection types, however, it must be employed to store !   key-value pairs of only specific key type and one specific value type.  To store pairs !   of another key type (and/or another value type), it must be destructed before inserting !   items of different key type (or different value type). <br> !   As a symbol table, the *HashTree* type does not allow duplicated keys.  Therefore, if !   an inserted key is equal to a key stored in the table, an associated value of the stored !   key is replaced by an associated value of the inserted key.  As an *unordered* symbol !   table, the *HashTree* type makes no guarantees as to the iteration order of the table. !   In particular, it does not guarantee that the order will remain the same over time. <br> !   Technically, the *HashTree* type utilizes the *IntrusiveHashTree* type as its component !   to store its hash-tree nodes.  As an *intrusive* container, the *IntrusiveHashTree* type, !   which is based on a separate-chaining hash table implementation, provides common hash-table !   operations without a memory management task.  The memory management task of the inserted !   hash-tree nodes is handled by the *HashTree* type.  <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveBSTrees , ONLY : BSTNode USE MClass_IntrusiveHashTree USE MClass_Object , ONLY : Object USE MClass_Comparable , ONLY : Comparable USE MClass_CompNodePool USE MClass_MemoryPool USE MClass_GenData USE MClass_KeyOrdered USE MClass_BaseCollection USE MClass_BaseSymTable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HashTree PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HashTree' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! default initial capacity tIndex , PARAMETER :: DfltInitCap = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *TabNode* is a binary-search-tree node type containing key and value as its components. !   The *KeyOrdered* type is used as a storage for the key and the *GenData* type is used !   as a storage for the value.  The *TabNode* type is a subtype of the *HashTreeNode* type !   and is intended to be used with the *HashTree* type, which is a collection type that !   utilizes the *IntrusiveHashTree* type. <br> TYPE , EXTENDS ( HashTreeNode ) :: TabNode TYPE ( KeyOrdered ) :: Key !! stored key TYPE ( GenData ) :: Value !! stored value CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TabNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TabNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TabNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TabNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TabNode_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedure from Comparable Type           ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => TabNode_CompareTo ! --------------------------------------------------------------------- ! -----         Specific Procedure for TabNode Type               ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: SetKeyNVal <br> !  **Purpose**:  To set new key and value. <br> !  **Usage**: <br> !   --->    Valid = Node%SetKeyNVal(Key, Value, MemPool) PROCEDURE :: SetKeyNVal => TabNode_SetKeyNVal !> **Type-Bound Function**: IsEqualKey <br> !  **Purpose**:  To check whether the specified key is equal to the node's key. <br> !  **Usage**: <br> !   --->    Flag = Node%IsEqualKey(Key) PROCEDURE :: IsEqualKey => TabNode_IsEqualKey ! --------------------------------------------------------------------- END TYPE TabNode !> The *HashTree* type is a collection type that employs a separate-chaining hash table !  implementation to provide common operations for an unordered symbol table.  The *HashTree* !  type utilizes the *IntrusiveHashTree* type as its component to store *TabNode* objects. !  As an intrusive container, the *IntrusiveHashTree* type provides common operations for !  hash table without a memory management task.  The memory management task of the inserted !  *TabNode* objects is handled by the *HashTree* type. <br> !  As an unordered symbol table, the *HashTree* type directly extends the *BaseSymTable* !  type and implements all deferred procedures required by the *BaseSymTable* type and all !  its super classes.  As a symbol table, the *HashTree* type does not allow duplicated keys; !  therefore, if an inserted key is equal to a key stored in the table, an associated value !  of the stored key is replaced by an associated value of the inserted key. <br> TYPE , EXTENDS ( BaseSymTable ) :: HashTree PRIVATE ! a working hash table TYPE ( IntrusiveHashTree ) :: WrkTab !> memory pool of hash-tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashTree_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashTree_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashTree_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => HashTree_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: HashTree_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashTree_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashTree_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashTree_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashTree_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashTree_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashTree_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => HashTree_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashTree_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashTree_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashTree_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashTree_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashTree_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()            ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity <br> PROCEDURE :: CreateEmpty => HashTree_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) <br> GENERIC :: Construct => HashTree_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashTree_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashTree_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashTree_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashTree_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashTree_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: HashTree_Finalize ! --------------------------------------------------------------------- END TYPE HashTree !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 TabNode Procedures                        ----- ! --------------------------------------------------------------------- SUBROUTINE TabNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( TabNode ) CALL SrcObj % CopyHashNode ( DstObj ) CALL SrcObj % Key % Copy ( DstObj % Key , IsDeep ) CALL SrcObj % Value % Copy ( DstObj % Value , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TabNode_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"TabNode\" only.' ) RETURN END SELECT RETURN END SUBROUTINE TabNode_Copy !****************************************************************************** FUNCTION TabNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure by an *Object* object. <br> !  It should be noted that this routine uses all components of !  the *TabNode* object to check equality. Therefore, although !  (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) can return !  false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( TabNode ) Flag = FalseVal IF (. NOT . LhsObj % Key % IsEqualTo ( RhsObj % Key )) RETURN IF (. NOT . LhsObj % Value % IsEqualTo ( RhsObj % Value )) RETURN Flag = LhsObj % IsHashNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabNode_IsEqualTo !****************************************************************************** SUBROUTINE TabNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free the key and value components CALL Obj % Key % MemFree () CALL Obj % Value % MemFree () ! reset the node's components CALL Obj % ResetHashNode () RETURN END SUBROUTINE TabNode_MemFree !****************************************************************************** FUNCTION TabNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{TabNode: {' // Obj % Key % ToString () // ' : ' // Obj % Value % ToString () // '}}' RETURN END FUNCTION TabNode_ToString !****************************************************************************** FUNCTION TabNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: AdjNode ! FLOW ! get code from left node AdjNode => Obj % GetLeft () SELECT TYPE ( Left => AdjNode ) TYPE IS ( TabNode ) Code = Left % Key % HashCode () END SELECT ! add code from this node Code = Code + Obj % Key % HashCode () ! add code from right node AdjNode => Obj % GetRight () SELECT TYPE ( Right => AdjNode ) TYPE IS ( TabNode ) Code = Code + Right % Key % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION TabNode_HashCode !****************************************************************************** FUNCTION TabNode_CompareTo ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare *A* and *B* and return <br> !   1 if *A* is greater than *B*, <br> !   0 if *A* is equal to *B*, <br> !  -1 if *A* is less than *B*, <br> !  -999 if types of input keys are not the same or either key is invalid. <br> ! Also, write an error message to the default log file if this happens. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: A CLASS ( Comparable ), INTENT ( IN ) :: B tSInt32 :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( B ) TYPE IS ( TabNode ) Flag = A % Key % CompareTo ( B % Key ) CLASS DEFAULT Flag = - 999 CALL Handle_ErrLevel ( 'TabNode_CompareTo' , ModName , ErrSevere , 'Type of B is valid.' ) END SELECT RETURN END FUNCTION TabNode_CompareTo !****************************************************************************** SUBROUTINE TabNode_SetKeyNVal ( Node , Key , Value , Pool ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the key and value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Node !! TabNode object CLASS ( * ), INTENT ( IN ) :: Key !! the key CLASS ( * ), INTENT ( IN ) :: Value !! the associated value TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !! memory pool for both key and value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Key % Set ( Key , Pool ) CALL Node % Value % Set ( Value , Pool ) RETURN END SUBROUTINE TabNode_SetKeyNVal !****************************************************************************** FUNCTION TabNode_IsEqualKey ( Node , Key , Pool ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is equal to the node's key. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TabNode object CLASS ( TabNode ), INTENT ( IN ) :: Node !% the key to be retrieved CLASS ( * ), INTENT ( IN ) :: Key !% memory pool TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !% true if the keys are equal; otherwise, false. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( GenData ) :: KeyInp !** FLOW: CALL KeyInp % Set ( Key , Pool ) Flag = Node % Key % IsEqualTo ( KeyInp ) CALL KeyInp % MemFree () RETURN END FUNCTION TabNode_IsEqualKey ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- SUBROUTINE HashTree_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !  *Note*:  SrcObj must be in the *HashTree* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( HashTree ) CALL SrcObj % NodePool % Copy ( DstObj % NodePool , IsDeep ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) CALL SrcObj % WrkTab % CloneTo ( DstObj % WrkTab ) CLASS DEFAULT CALL Handle_ErrLevel ( 'HashTree_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE HashTree_Copy !****************************************************************************** FUNCTION HashTree_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashTree ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN ! implementation note:  we cannot use the iteration methods here !   due to the intent of the input data. BLOCK tIndex :: I CLASS ( CompNode ), POINTER :: LhsNodes (:), RhsNodes (:) ! initialize CALL LhsObj % NodePool % GetAllNodes ( LhsNodes ) CALL RhsObj % NodePool % GetAllNodes ( RhsNodes ) IF ( SIZE ( LhsNodes , KIND = kIndex ) == SIZE ( RhsNodes , KIND = kIndex )) THEN SELECT TYPE ( LhsNodes ) TYPE IS ( TabNode ) SELECT TYPE ( RhsNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( LhsNodes , KIND = kIndex ) Flag = LhsNodes ( I )% IsEqualTo ( RhsNodes ( I )) IF (. NOT . Flag ) EXIT END DO END SELECT END SELECT END IF NULLIFY ( LhsNodes , RhsNodes ) END BLOCK END IF CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashTree_IsEqualTo !****************************************************************************** SUBROUTINE HashTree_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the HashTree object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % WrkTab % Destruct () CALL Obj % NodePool % MemFree () CALL Obj % ItemPool % Destruct () CALL Obj % FreeMolds () RETURN END SUBROUTINE HashTree_MemFree !****************************************************************************** FUNCTION HashTree_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the HashTree type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr , ValStr , ItemStr CLASS ( CompNode ), POINTER :: PoolNodes (:) ! initialize Count = 0_kIndex CALL Obj % NodePool % GetAllNodes ( PoolNodes ) CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE IF ( Nodes ( I )% Value % IsEmpty ()) CYCLE KeyStr = Nodes ( I )% Key % ToString () ValStr = Nodes ( I )% Value % ToString () ItemStr = '{' // KeyStr ( 17 : LEN ( KeyStr ) - 1 ) // ' : ' // ValStr ( 12 : LEN ( ValStr ) - 1 ) // '}' CALL ChrBuf % Append ( ItemStr ) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO END SELECT NULLIFY ( PoolNodes ) CALL ChrBuf % Append ( ']' ) BaseStr = ChrBuf % AsString () END BLOCK END IF Str = '{HashTree with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION HashTree_ToString !****************************************************************************** FUNCTION HashTree_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK CLASS ( CompNode ), POINTER :: PoolNodes (:) tIndex :: I ! initialize CALL Obj % NodePool % GetAllNodes ( PoolNodes ) Code = 0_kIndex ! compute hash code SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE Code = Code + Nodes ( I )% Key % HashCode () END DO END SELECT END BLOCK END IF RETURN END FUNCTION HashTree_HashCode ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseCollection Type       ----- ! --------------------------------------------------------------------- SUBROUTINE HashTree_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). <br> !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( HashTree ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( Other ) TYPE IS ( HashTree ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseSymTable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: KeyItem CLASS ( * ), ALLOCATABLE :: ValItem ! get key and value molds MoldPtr => Other % GetKeyPtr () ALLOCATE ( KeyItem , MOLD = MoldPtr ) MoldPtr => Other % GetValPtr () ALLOCATE ( ValItem , MOLD = MoldPtr ) ! loop through the other collection and get key-value pairs along the way IsTheEnd = Other % StartFirst ( KeyItem , ValItem , ItemCopy , ValCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( KeyItem , ValItem ) IsTheEnd = Other % MoveForward ( KeyItem , ValItem , ItemCopy , ValCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( KeyItem , ValItem ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'HashTree_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseSymTable\" class.' ) END SELECT RETURN END SUBROUTINE HashTree_CopyCollection !****************************************************************************** SUBROUTINE HashTree_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if the collection is empty IF ( Collection % IsEmpty ()) RETURN ! clear elements CALL Collection % WrkTab % Clear () ! reset components CALL Collection % NodePool % Reset () ! free mold CALL Collection % FreeMolds () RETURN END SUBROUTINE HashTree_ClearItems !****************************************************************************** SUBROUTINE HashTree_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE HashTree_Destroy !****************************************************************************** FUNCTION HashTree_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of items in the collection. !  This is a deferred procedure inherited from the *BaseCollection* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( IN ) :: Collection tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % WrkTab % GetSize () RETURN END FUNCTION HashTree_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- FUNCTION HashTree_Move2FirstPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a symbol table. !  For the *HashTree*, which is an unordered symbol table, !  the starting pair is the first pair inserted.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the first key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the first value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection contains no pair data or not <br> ! - true if the collection is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( HashTreeNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTab % StartFirst ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'HashTree_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashTree_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTab % StartFirst () END IF RETURN END FUNCTION HashTree_Move2FirstPair !****************************************************************************** FUNCTION HashTree_Move2NextPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table. !  For the *HashTree*, which is an unordered symbol table, !  the next pair is the pair inserted after the previous one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( HashTreeNode ), POINTER :: CurrNode ! move to next iteration IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'HashTree_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashTree_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! move to next iteration IsTheEnd = Collection % WrkTab % MoveForward () END IF RETURN END FUNCTION HashTree_Move2NextPair !****************************************************************************** SUBROUTINE HashTree_Insert ( Collection , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into a symbol table.  If the specified key is already !  stored in the table, replace the old value with the new one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the key to be added to the collection CLASS ( * ), INTENT ( IN ) :: Key !% the associated value to be added to the collection CLASS ( * ), INTENT ( IN ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: KeyFound TYPE ( TabNode ), POINTER :: KeyNode CLASS ( CompNode ), POINTER :: NewNode ! FLOW ! check the specified key and value IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = TrueVal )) THEN CALL Handle_ErrLevel ( 'HashTree_Insert' , ModName , ErrSevere , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN CALL Handle_ErrLevel ( 'HashTree_Insert' , ModName , ErrSevere , & 'Only values of the same type are allowed in a collection.' ) RETURN END IF ! check whether the key is already stored in the collection or not IF ( Collection % IsEmpty ()) THEN KeyFound = FalseVal ELSE KeyFound = Collection % FindKey ( Key , KeyNode ) END IF IF ( KeyFound ) THEN ! replace the current value with the new one CALL KeyNode % Value % Set ( Value , Collection % ItemPool ) ELSE ! +++ new key-value pair +++ ! check for first-time insertion IF (. NOT . Collection % NodePool % IsReady ()) THEN CALL Collection % CreateEmpty ( DfltInitCap ) END IF ! get new node from the node's pool CALL Collection % NodePool % GetNewNode ( NewNode ) SELECT TYPE ( NewNode ) TYPE IS ( TabNode ) KeyNode => NewNode END SELECT ! set key and value to the node ! (no need to check the valid flag since we have already done that in the beginning) CALL KeyNode % SetKeyNVal ( Key , Value , Collection % ItemPool ) ! append the new node to the working hash table CALL Collection % WrkTab % Insert ( KeyNode ) END IF ! free working pointer NULLIFY ( KeyNode , NewNode ) RETURN END SUBROUTINE HashTree_Insert !****************************************************************************** SUBROUTINE HashTree_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a key-value pair from a symbol table.  This procedure is intended !  to be used in conjunction with the *StartFirst* and *MoveForward* procedures. !  Therefore, after the call to either procedure and then calling this procedure !  will result in a removal of the current key-value pair of the iteration (i.e. !  the same key-value pair that can be retrieved via those *Move* procedures). <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashTreeNode ), POINTER :: DelNode ! FLOW ! remove node of the current iteration CALL Collection % WrkTab % Delete ( DelNode ) ! return the node to the nodes' pool IF ( ASSOCIATED ( DelNode )) THEN SELECT TYPE ( DelNode ) TYPE IS ( TabNode ) CALL Collection % NodePool % ReturnNode ( DelNode ) END SELECT END IF NULLIFY ( DelNode ) RETURN END SUBROUTINE HashTree_Delete !****************************************************************************** FUNCTION HashTree_Remove ( Collection , Key ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete the specified key (and its associated value) from a symbol !  table.  Also, return a flag indicating whether the key-value pair is !  successfully removed or not.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the key to be removed from the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF IF ( Flag ) THEN ! check if remove the node successfully or not IF ( Collection % WrkTab % Remove ( KeyNode )) THEN ! return the node to the node's pool CALL Collection % NodePool % ReturnNode ( KeyNode ) ELSE CALL Handle_ErrLevel ( 'HashTree_Remove' , ModName , ErrWarning , & 'Check the Remove method of the intrusive list for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION HashTree_Remove !****************************************************************************** FUNCTION HashTree_Contain ( Collection , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSE Found = Collection % FindKey ( Key ) END IF RETURN END FUNCTION HashTree_Contain !****************************************************************************** FUNCTION HashTree_GetValue ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a value associated with the specified key in a symbol table. !  Also, return a flag indicating whether the key-value pair is successfully !  found or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the value associated with the specified key CLASS ( * ), INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF ! get value if key is found IF ( Flag ) THEN Flag = KeyNode % Value % Get ( Value , ValCopy ) END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION HashTree_GetValue !************************************************************************************** FUNCTION HashTree_ToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all key-value pairs from the collection.  Also, return a flag !  indicating whether the pairs are successfully retrieved and removed or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Keys , Values , KeyCopy , ValCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION HashTree_ToArray !************************************************************************************** FUNCTION HashTree_GetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys and/or all values (without removing them) from the collection.  Also, !  return a flag indicating whether the keys and/or values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: SameKeyType , SameValType ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF ( PRESENT ( Keys ). AND . PRESENT ( Values )) THEN SameKeyType = Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = TrueVal ) SameValType = Collection % IsValValid ( Values ( 1 )) ! check whether types of the specified keys and values are valid or not IF ( SameKeyType . AND . SameValType ) THEN Success = Collection % GetAllPairs ( Keys , Values , ValCopy ) ELSEIF ( SameKeyType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashTree_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) ELSEIF ( SameValType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashTree_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashTree_GetAll' , ModName , ErrSevere , & 'Types of both keys and values are NOT the same as those of stored pairs.' ) END IF ELSEIF ( PRESENT ( Keys )) THEN ! check whether type of the specified keys is valid or not IF ( Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = TrueVal )) THEN Success = Collection % GetAllKeys ( Keys ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashTree_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Values )) THEN ! check whether type of the specified values is valid or not IF ( Collection % IsValValid ( Values ( 1 ))) THEN Success = Collection % GetAllVals ( Values , ValCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashTree_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION HashTree_GetAll !************************************************************************************** FUNCTION HashTree_GetAllPairs ( Collection , Keys , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all key-value pairs (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , KeySize , ValSize tLogical :: IsTheEnd CLASS ( HashTreeNode ), POINTER :: CurrNode ! FLOW ! initialize local variables KeySize = SIZE ( Keys , KIND = kIndex ) ValSize = SIZE ( Values , KIND = kIndex ) IF (( KeySize < 1_kindex ). AND .( ValSize < 1_kindex )) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( I <= KeySize ) Success = CurrNode % Key % Get ( Keys ( I )) IF ( Success . AND .( I <= ValSize )) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashTree_GetAllPairs !************************************************************************************** FUNCTION HashTree_GetAllKeys ( Collection , Keys ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( HashTreeNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Keys , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Key % Get ( Keys ( I )) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashTree_GetAllKeys !************************************************************************************** FUNCTION HashTree_GetAllVals ( Collection , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all values (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashTree object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( HashTreeNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Values , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the values along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashTree_GetAllVals ! --------------------------------------------------------------------- ! -----                 Specific Procedures                       ----- ! --------------------------------------------------------------------- SUBROUTINE HashTree_CreateEmpty ( Collection , InitCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !! collection tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !! initial capacity of the hash table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: NodeMold !** FLOW: ! construct working hash table CALL Collection % WrkTab % Construct ( InitCap ) ! construct nodes' pool CALL Collection % NodePool % Construct ( NodeMold ) ! construct items' pool CALL Collection % ItemPool % Construct () RETURN END SUBROUTINE HashTree_CreateEmpty !****************************************************************************** SUBROUTINE HashTree_CreateByArray ( Collection , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of key-value pairs !% the keys to be added to the table CLASS ( * ), INTENT ( IN ) :: Keys ( N ) !% the associated values to be added to the table CLASS ( * ), INTENT ( IN ) :: Values ( N ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! create empty symbol table with capacity twice of the key size CALL Collection % CreateEmpty ( N * 2_kIndex ) ! add key-value pairs to the table DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE HashTree_CreateByArray !****************************************************************************** FUNCTION HashTree_FindKey ( Collection , Key , KeyNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the specified key in a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashTree ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the node containing the specified key; null pointer if the key is not found TYPE ( TabNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: KeyNode !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: InNode CLASS ( HashTreeNode ), POINTER :: StoredNode ! FLOW ! initialize Found = Falseval IF ( PRESENT ( KeyNode )) KeyNode => NULL () ! check the specified key and return quickly if not valid IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = TrueVal )) RETURN ! set key for search node CALL InNode % Key % Set ( Key , Collection % ItemPool ) ! find the stored node equal to input node Found = Collection % WrkTab % FindNode ( InNode , StoredNode ) IF ( PRESENT ( KeyNode ). AND . Found ) THEN SELECT TYPE ( StoredNode ) TYPE IS ( TabNode ) KeyNode => StoredNode END SELECT END IF ! free working pointer NULLIFY ( StoredNode ) RETURN END FUNCTION HashTree_FindKey ! --------------------------------------------------------------------- ! -----             Final Procedures                              ----- ! --------------------------------------------------------------------- SUBROUTINE HashTree_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashTree ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE HashTree_Finalize !****************************************************************************** END MODULE MClass_HashTree !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hashtree.f90.html"},{"title":"MClass_BaseIterable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BaseIterable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BaseIterable* type and its related routines.  The *BaseIterable* !   type is an abstract data type extending the *BaseCollection* type.  It defines two additional !   methods for an iteration over items stored in a collection.  The *StartFirst* method is used !   to start an iteration and the *MoveForward* method is used to move to the next iteration. <br> !   <br> !   **Usage**:  <br> !   The following code snippet illustrates how to iterate over the collection. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsEmpty = Collection%StartFirst() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Collection%MoveForward() !       ! check whether we reach the end of the collection or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> !   The following code snippet shows another way to traverse across the collection. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start forward iteration (from the first item) !   IsTheEnd = Collection%StartFirst(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Collection%MoveForward(CurrItem) !   END DO !   </Code></Pre> !** USE STATEMENTS: USE MBase_Common USE MClass_BaseCollection USE MClass_GenData , ONLY : IsSameDataType , IfacePolyCopy IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseIterable PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_BaseIterable' !** DERIVED TYPE !> The *BaseIterable* type is an abstract collection type that defines an API for !  iterable collections, which are collections that can iterate over their items. <br> !  It is important to note that, by design, a concrete collection type that extends !  from the *BaseIterable* type only stores items of one specific type.  To store !  items of another type, the collection must be cleared and/or destructed. <br> TYPE , ABSTRACT , EXTENDS ( BaseCollection ) :: BaseIterable PRIVATE CLASS ( * ), ALLOCATABLE :: Mold CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *StartFirst* is a deferred procedure to start the *forward* iteration. <br> PROCEDURE ( IfaceStartFirst ), DEFERRED :: StartFirst !> *MoveForward* is a deferred procedure to move to the next iteration. <br> PROCEDURE ( IfaceMoveNext ), DEFERRED :: MoveForward !> *Insert* is a deferred procedure to insert the specified item to the collection.  This !   is a default procedure for adding an item to the collection.  For a particular collection, !   an alias name (e.g. the *Push* method for a stack or the *Enqueue* method for a queue) !   may be used in place of the *Insert* method. <br> PROCEDURE ( IfaceInsert ), DEFERRED :: Insert !> *Delete* is a deferred procedure to delete the current item from the collection.  This !   method is intended to be used in conjunction with the *StartFirst* and *MoveForward* !   methods.  Therefore, after the call to one of those methods and then calling this one !   will result in a removal of the current item of the iteration (i.e. the same item that !   can be retrieved via the *StartFirst* and *MoveForward* methods). <br> PROCEDURE ( IfaceDelete ), DEFERRED :: Delete !> *ToArray* is a deferred procedure to retrieve and remove all items from the collection. <br> PROCEDURE ( IfaceToArray ), DEFERRED :: ToArray !> *GetAll* is a deferred procedure to retrieve all items (without removing them) from the !   collection. <br> PROCEDURE ( IfaceGetAll ), DEFERRED :: GetAll ! --------------------------------------------------------------------- ! -----      Deferred Procedures from BaseCollection Type         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() <br> !  **Note**: The *Clear* method provided by the *BaseIterable* type is !       a simple implementation.   It can be overridden by a better and !       more efficient implementation. PROCEDURE :: Clear => BaseIterable_ClearItems !> **Type-Bound Function**: GetItemPtr <br> !  **Purpose**:  To get a pointer to an item stored in a collection.  The pointer is !       intended to be used as a mold for the item (i.e. to provide type of the stored !       items).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    ValPtr => Collection%GetItemPtr() PROCEDURE :: GetItemPtr => BaseIterable_GetItemPtr ! --------------------------------------------------------------------- ! -----       Public Procedures To Be Used Internally             ----- ! --------------------------------------------------------------------- !> *SetMold* is a procedure to set a mold of stored items.  This procedure is intended !   to be used only by a subtype of the *BaseIterable* type, not by a user. PROCEDURE :: SetMold => BaseIterable_SetMold !> *FreeMold* is a procedure to free the mold of stored items.  This procedure is intended !   to be used only by a subtype of the *BaseIterable* type, not by a user. PROCEDURE :: FreeMold => BaseIterable_FreeMold !> *IsItemValid* is a procedure to check whether the specified item is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseIterable* type, not by !   a user. PROCEDURE :: IsItemValid => BaseIterable_IsItemValid ! --------------------------------------------------------------------- END TYPE BaseIterable !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> *IfaceStartFirst* is an interface for a procedure to move to the first element in an !   iterable collection. FUNCTION IfaceStartFirst ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) IMPORT CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! iterable collection object !% the first element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection is empty or not <br> tLogical :: IsEmpty END FUNCTION !> *IfaceMoveNext* is an interface for a procedure to move to the next element in an !   iterable collection. FUNCTION IfaceMoveNext ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) IMPORT CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! iterable collection object !% the next element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the end of the collection is encountered or not <br> tLogical :: IsTheEnd END FUNCTION !> *IfaceInsert* is an interface for a procedure to add an item to a collection.  For a !  collection with various *add* procedures.  This procedure should be the default one. SUBROUTINE IfaceInsert ( Collection , Item ) IMPORT CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! iterable collection object !% the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE !> *IfaceDelete* is an interface for a procedure to delete an item from a collection. !   This procedure is intended to be used in conjunction with the *StartFirst* and !   *MoveForward* methods.  Therefore, after the call to either method and then calling !   this procedure will result in a removal of the current item of the iteration (i.e. !   the same item that can be retrieved via those iteration methods). SUBROUTINE IfaceDelete ( Collection ) IMPORT CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! iterable collection object END SUBROUTINE !> *IfaceToArray* is an interface for a procedure to get and remove all items from the !   collection.  Also, return a flag indicating whether the items are successfully !   removed or not. FUNCTION IfaceToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) IMPORT CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! iterable collection object !% the items to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully removed. <br> tLogical :: Success END FUNCTION !> *IfaceGetAll* is an interface for a procedure to get all items (without removing them) !   from the collection.  Also, return a flag indicating whether the items are successfully !   retrieved or not. FUNCTION IfaceGetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) IMPORT !% iterable collection object CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !% the items to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: !  na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE BaseIterable_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the collection.  This routine provides a basic implementation !  of the *Clear* deferred procedure required by the *BaseCollection* class. <br> !  This routine should be overridden if a better implementation is available. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! collection object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: TheEnd !** FLOW: TheEnd = Collection % StartFirst () DO WHILE (. NOT . TheEnd ) CALL Collection % Delete () TheEnd = Collection % MoveForward () END DO RETURN END SUBROUTINE BaseIterable_ClearItems !************************************************************************************** FUNCTION BaseIterable_GetItemPtr ( Collection ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a pointer to an item stored in a collection.  The pointer is intended to be !  used as a mold for the item (i.e. provides type of the stored items).  Return null !  pointer if the table is empty. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseIterable ), TARGET , INTENT ( IN ) :: Collection !! collection CLASS ( * ), POINTER :: Val !! pointer to a stored item !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Collection % Mold )) THEN Val => Collection % Mold ELSE Val => NULL () END IF RETURN END FUNCTION BaseIterable_GetItemPtr !************************************************************************************** SUBROUTINE BaseIterable_SetMold ( Collection , Mold ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the \"Mold\" component. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! collection object CLASS ( * ), INTENT ( IN ) :: Mold !! mold for stored items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: IF (. NOT . ALLOCATED ( Collection % Mold )) ALLOCATE ( Collection % Mold , MOLD = Mold ) RETURN ENDSUBROUTINE BaseIterable_SetMold !************************************************************************************** SUBROUTINE BaseIterable_FreeMold ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free the \"Mold\" component. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! collection object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: IF ( ALLOCATED ( Collection % Mold )) DEALLOCATE ( Collection % Mold ) RETURN END SUBROUTINE BaseIterable_FreeMold !************************************************************************************** FUNCTION BaseIterable_IsItemValid ( Collection , Item ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the type of specified item is valid or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseIterable ), INTENT ( INOUT ) :: Collection !! collection object CLASS ( * ), INTENT ( IN ) :: Item !! the item to be added to the collection tLogical :: Valid !! true if type of the specified item is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the mold and the specified item have the same type or not IF ( ALLOCATED ( Collection % Mold )) THEN Valid = IsSameDataType ( Collection % Mold , Item ) ELSE ! this is the first item so set it as the mold CALL Collection % SetMold ( Item ) Valid = TrueVal END IF RETURN END FUNCTION BaseIterable_IsItemValid !************************************************************************************** END MODULE MClass_BaseIterable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_baseiterable.f90.html"},{"title":"MClass_PQInteger4B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQInteger4B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQInteger4B* type and its related routines. !   The *PQInteger4B* type is a priority-queue container with *INTEGER(KIND=kInt32)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQInteger4B* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQInteger4B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     INTEGER(KIND=kInt32) #define     PQHeap      PQInteger4B !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQInteger4B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQInteger4B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqinteger4b.f90.html"},{"title":"MClass_HashMap.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HashMap !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HashMap* type and its supporting routines and data type.  The !   *HashMap* type is a collection type that employs an open-addressing hash table implementation !   to provide common operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* symbol table types, which can be used instantly by !   inserting objects into a collection, the *HashMap* type requires an explicit construction !   before using other provided operations.  There are two methods provided to create the !   collection.  The *CreateEmpty* method constructs an empty table with optional multiple !   arguments (including an initial capacity, a load factor, a probing algorithm, and a hash !   function used to compute a hash code of a key) whereas the *Construct* method constructs !   a table from arrays of keys and values. <br> !   The *HashMap* type uses the *KeyUnordered* type to store its keys and the *GenData* type !   to store its values.  Therefore, it can be used to store key-value pairs of any data types !   (except the *LOGICAL* type for the keys).  Like other collection types, however, it must !   be employed to store key-value pairs of only specific key type and one specific value type. !   To store key-value pairs of another key type (or another value type), it must be destructed !   before inserting items of different key type (or different value type). <br> !   As a symbol table, the *HashMap* type does not allow duplicated keys.  Therefore, if an !   inserted key is equal to a key stored in the table, an associated value of the stored key !   is replaced by an associated value of the inserted key.  As an *unordered* symbol table, the !   *HashMap* type makes no guarantees as to the iteration order of the table.  In particular, !   it does not guarantee that the order will remain the same over time. <br> !   Technically, the *HashMap* type employs the open-addressing as a collision resolution !   technique where the hash resolution is performed through probing.  It provides three probing !   algorithms: linear probing, quadratic probing and double hashing.  By default, the linear !   probing algorithm is used.  However, a user can specify other probing algorithm during the !   construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ToChar => ToDecStrSigned USE MBase_MathUtil #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_Object , ONLY : Object USE MClass_GenData USE MClass_MemoryPool USE MClass_KeyUnordered USE MClass_BaseCollection USE MClass_BaseSymTable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HashMap PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HashMap' ! status of the TabItem tCharLen ( 3 ), PARAMETER :: STAT_DEL = 'DEL' tCharLen ( 3 ), PARAMETER :: STAT_NUL = 'NUL' tCharLen ( 3 ), PARAMETER :: STAT_GEN = 'GEN' ! default capacity tIndex , PARAMETER :: DefaultCapacity = 7 ! default load factor tRealDP , PARAMETER :: DefaultLoadFactor = 0.65_kDouble tSInt32 , PARAMETER :: LinearProbing = 1 tSInt32 , PARAMETER :: QuadraticProbing = 2 tSInt32 , PARAMETER :: DoubleHashing = 3 ! This is the linear constant used in the linear probing, it can be ! any positive number. The table capacity will be adjusted so that ! the GCD(capacity, LinearConstant) = 1 so that all buckets can be probed. tIndex , PARAMETER :: LinearConstant = 17_kIndex ! seed for computation of hash code #ifdef Indx32Bits tSInt32 , PARAMETER :: HashSeed = 313131_kInt32 #else tSInt64 , PARAMETER :: HashSeed = 313131_kInt64 #endif ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *TabItem* is a key-value pair data type containing key and value as !  its components. TYPE , EXTENDS ( Object ) :: TabItem tCharLen ( 3 ) :: Stat = STAT_NUL !! current status of the object TYPE ( KeyUnordered ) :: Key !! stored key TYPE ( GenData ) :: Value !! stored value CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures for TabItem Type              ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: TabItem_SetKeyValue PROCEDURE , PRIVATE :: TabItem_SetKeyOnly GENERIC :: Set => TabItem_SetKeyValue , TabItem_SetKeyOnly PROCEDURE :: IsKeyEqual => TabItem_IsKeyEqual ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TabItem_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TabItem_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TabItem_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TabItem_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TabItem_HashCode ! --------------------------------------------------------------------- END TYPE TabItem !> The *HashMap* type is a collection type that employs an open-addressing hash table !  implementation to provide common operations for an unordered symbol table.  It makes !  no guarantees as to the iteration order of the symbol table; in particular, it does !  not guarantee that the order will remain constant over time. TYPE , EXTENDS ( BaseSymTable ) :: HashMap PRIVATE !% current capacity of the hash table tIndex :: Capacity = DefaultCapacity !% working table items used to store key-value pairs TYPE ( TabItem ), ALLOCATABLE :: Items (:) !% current index into the working items (used for iteration purpose) tIndex :: Indx = 0_kIndex !% the number of keys not yet visited (used for iteration purpose) tIndex :: KeyLeft = 0_kIndex !% current modification count (used for iteration purpose) tIndex :: IterModCount = 0_kIndex !% load factor tRealDP :: LoadFactor = DefaultLoadFactor !% threshold for resizing tIndex :: Threshold = 0_kIndex !% modification count tIndex :: ModCount = 0_kIndex !% the total number of used buckets inside the hash table (including cells marked as deleted). tIndex :: UsedBuckets = 0_kIndex !% the total number of unique keys currently inside the hash table. tIndex :: KeyCount = 0_kIndex !% probing algorithm tSInt32 :: ProbAlgo = LinearProbing !% index for double hashing tHash :: HashIndx = 0_kIndex !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool !% pointer to a hash function PROCEDURE ( HashFunc ), NOPASS , POINTER :: HashCalc => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: KeyCopy => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: ValCopy => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyItem) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashMap_FindKey !> **Type-Bound Subroutine**: Resize <br> !  **Purpose**:  To resize the collection to the specified capacity. <br> !  **Usage**: <br> !   --->    CALL Collection%Resize(64) PROCEDURE , PRIVATE :: Resize => HashMap_Resize !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: HashMap_CreateByArray !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashMap_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashMap_GetAllVals ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashMap_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => HashMap_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => HashMap_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashMap_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => HashMap_IsEmpty ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashMap_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashMap_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashMap_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => HashMap_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashMap_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashMap_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. Also, !       return a flag indicating whether the key-value pair is successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashMap_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashMap_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashMap_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()                           ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)                 ! specify initial capacity <br> !   --->    CALL Table%CreateEmpty(LoadFactor=0.5)             ! specify load factor <br> !   --->    CALL Table%CreateEmpty(ProbAlgo=2)                 ! specify probing algorithm <br> !   --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt) ! specify hash function <br> !   --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt) ! specify all options <br> !  **Note**: Any suitable hash function routine from the *ModBase_SimpleHash32*, !       *ModBase_SimpleHash64*, *ModBase_ReferenceHash32*, *ModBase_ReferenceHash64* !       *ModBase_OptimalHash32*, and *ModBase_OptimalHash64* modules can be used to !       specify the *HashCal* argument.  The term *suitable* means that any routine !       that has exactly the same interface as the *HashFunc* abstract function !       is the suitable one.  <br> !  **Note2**: Depending on a type of indices defined in the '*Macro - Basic Definitions.f90*' !       file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices !       while a 64-bit hash-function routine is a suitable one for 64-bit integer indices. !       This is a compile-time choice.  <br> PROCEDURE :: CreateEmpty => HashMap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection and specify the optional arguments (see the *CreateEmpy* method) <br> !   --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => HashMap_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashMap_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashMap_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashMap_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashMap_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashMap_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash table. FINAL :: HashMap_Finalize ! --------------------------------------------------------------------- END TYPE HashMap !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !---------------------------------------------------------------------- !&#94; *HashFunc* is a generic interface for a procedure to compute the hash value. FUNCTION HashFunc ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) IMPORT TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tHash , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tHash :: HashCode !! hash code END FUNCTION HashFunc !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! ----------------------------------------------------------------------------- ! -----                       TabItem Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE TabItem_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the TabItem object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( TabItem ) DstObj % Stat = SrcObj % Stat CALL SrcObj % Key % Copy ( DstObj % Key , IsDeep ) CALL SrcObj % Value % Copy ( DstObj % Value , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TabItem_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE TabItem_Copy !****************************************************************************** FUNCTION TabItem_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( TabItem ) Flag = FalseVal IF ( LhsObj % Stat /= RhsObj % Stat ) RETURN IF (. NOT . LhsObj % Key % IsEqualTo ( RhsObj % Key )) RETURN Flag = LhsObj % Value % IsEqualTo ( RhsObj % Value ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabItem_IsEqualTo !****************************************************************************** SUBROUTINE TabItem_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the TabItem object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Obj % Stat = STAT_NUL CALL Obj % Key % MemFree () CALL Obj % Value % MemFree () RETURN END SUBROUTINE TabItem_MemFree !****************************************************************************** FUNCTION TabItem_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{TabItem : {' // Obj % Key % ToString () // ' : ' // Obj % Value % ToString () // '}}' RETURN END FUNCTION TabItem_ToString !****************************************************************************** FUNCTION TabItem_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = Obj % Key % HashCode () + Obj % Value % HashCode () RETURN END FUNCTION TabItem_HashCode !****************************************************************************** SUBROUTINE TabItem_SetKeyValue ( Obj , Status , Pool , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set value of the specified item. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( INOUT ) :: Obj tCharLen ( 3 ), INTENT ( IN ) :: Status TYPE ( MemoryPool ), OPTIONAL , INTENT ( INOUT ) :: Pool CLASS ( * ), OPTIONAL , INTENT ( IN ) :: Key CLASS ( * ), OPTIONAL , INTENT ( IN ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Obj % Stat = Status IF ( PRESENT ( Key ). AND . PRESENT ( Pool )) CALL Obj % Key % Set ( Key , Pool ) IF ( PRESENT ( Value ). AND . PRESENT ( Pool )) CALL Obj % Value % Set ( Value , Pool ) RETURN END SUBROUTINE TabItem_SetKeyValue !****************************************************************************** SUBROUTINE TabItem_SetKeyOnly ( This , Status , Other ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set data of the specified input. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( INOUT ) :: This tCharLen ( 3 ), INTENT ( IN ) :: Status TYPE ( TabItem ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: This % Stat = Status CALL Other % Key % Copy ( This % Key ) RETURN END SUBROUTINE TabItem_SetKeyOnly !****************************************************************************** FUNCTION TabItem_IsKeyEqual ( Obj , Key , Pool ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is equal to the item's key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabItem ), INTENT ( IN ) :: Obj CLASS ( * ), INTENT ( IN ) :: Key TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( GenData ) :: KeyInp !** FLOW: CALL KeyInp % Set ( Key , Pool ) Flag = Obj % Key % IsEqualTo ( KeyInp ) CALL KeyInp % MemFree () RETURN END FUNCTION TabItem_IsKeyEqual ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- SUBROUTINE HashMap_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !  *Note*:  SrcObj must be in the *HashMap* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; flag indicating whether to perform deep copy or shallow copy; <br> !  - if true, perform shallow copy; <br> !  - if false, perform deep copy; <br> !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( HashMap ) DstObj % Capacity = SrcObj % Capacity DstObj % Indx = SrcObj % Indx DstObj % KeyLeft = SrcObj % KeyLeft DstObj % IterModCount = SrcObj % IterModCount DstObj % LoadFactor = SrcObj % LoadFactor DstObj % Threshold = SrcObj % Threshold DstObj % ModCount = SrcObj % ModCount DstObj % UsedBuckets = SrcObj % UsedBuckets DstObj % KeyCount = SrcObj % KeyCount DstObj % ProbAlgo = SrcObj % ProbAlgo DstObj % HashIndx = SrcObj % HashIndx DstObj % HashCalc => SrcObj % HashCalc DstObj % KeyCopy => SrcObj % KeyCopy DstObj % ValCopy => SrcObj % ValCopy ALLOCATE ( DstObj % Items , SOURCE = SrcObj % Items ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'HashMap_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE HashMap_Copy !****************************************************************************** FUNCTION HashMap_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashMap ) Flag = FalseVal IF ( LhsObj % Capacity /= RhsObj % Capacity ) RETURN IF ( LhsObj % KeyCount /= RhsObj % KeyCount ) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN BLOCK tIndex :: I DO I = 1_kIndex , SIZE ( LhsObj % Items ) IF (. NOT . LhsObj % Items ( I )% IsEqualTo ( RhsObj % Items ( I ))) RETURN END DO END BLOCK END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashMap_IsEqualTo !****************************************************************************** SUBROUTINE HashMap_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the HashMap object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! first free items' components and then free of the items themselves IF ( ALLOCATED ( Obj % Items )) THEN DO I = 1_kIndex , SIZE ( Obj % Items ) CALL Obj % Items ( I )% MemFree () END DO DEALLOCATE ( Obj % Items ) END IF ! reset all components Obj % Capacity = DefaultCapacity Obj % Indx = 0_kIndex Obj % KeyLeft = 0_kIndex Obj % IterModCount = 0_kIndex Obj % LoadFactor = DefaultLoadFactor Obj % Threshold = 0_kIndex Obj % ModCount = 0_kIndex Obj % UsedBuckets = 0_kIndex Obj % KeyCount = 0_kIndex Obj % ProbAlgo = LinearProbing Obj % HashIndx = 0_kIndex NULLIFY ( Obj % HashCalc ) NULLIFY ( Obj % KeyCopy ) NULLIFY ( Obj % ValCopy ) CALL Obj % FreeMolds () CALL Obj % ItemPool % Destruct () RETURN RETURN END SUBROUTINE HashMap_MemFree !****************************************************************************** FUNCTION HashMap_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the HashMap type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr , ValStr , ItemStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) Count = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items ) ! skip if the item is empty IF ( Obj % Items ( I )% Stat /= STAT_GEN ) CYCLE ! add the string representation of the current item KeyStr = Obj % Items ( I )% Key % ToString () ValStr = Obj % Items ( I )% Value % ToString () ItemStr = '{' // KeyStr ( 17 : LEN ( KeyStr ) - 1 ) // ' : ' // ValStr ( 12 : LEN ( ValStr ) - 1 ) // '}' CALL ChrBuf % Append ( ItemStr ) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO CALL ChrBuf % Append ( ']' ) BaseStr = ChrBuf % AsString () END BLOCK END IF Str = '{HashMap with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION HashMap_ToString !****************************************************************************** FUNCTION HashMap_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK tIndex :: I Code = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items ) IF ( Obj % Items ( I )% Stat /= STAT_GEN ) CYCLE Code = Code + Obj % Items ( I )% Key % HashCode () END DO END BLOCK END IF RETURN END FUNCTION HashMap_HashCode ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- SUBROUTINE HashMap_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). <br> !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( HashMap ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( Other ) TYPE IS ( HashMap ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseSymTable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: KeyItem CLASS ( * ), ALLOCATABLE :: ValItem ! get key and value molds MoldPtr => Other % GetKeyPtr () ALLOCATE ( KeyItem , MOLD = MoldPtr ) MoldPtr => Other % GetValPtr () ALLOCATE ( ValItem , MOLD = MoldPtr ) ! loop through the other collection and get key-value pairs along the way IsTheEnd = Other % StartFirst ( KeyItem , ValItem , ItemCopy , ValCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( KeyItem , ValItem ) IsTheEnd = Other % MoveForward ( KeyItem , ValItem , ItemCopy , ValCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( KeyItem , ValItem ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'HashMap_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseSymTable\" class.' ) END SELECT RETURN END SUBROUTINE HashMap_CopyCollection !****************************************************************************** SUBROUTINE HashMap_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free components of the items from the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I !** FLOW: IF ( ALLOCATED ( Collection % Items )) THEN DO I = 0_kIndex , Collection % Capacity - 1_kIndex CALL Collection % Items ( I )% MemFree () END DO END IF Collection % Indx = 0_kIndex Collection % KeyLeft = 0_kIndex Collection % IterModCount = 0_kIndex Collection % Threshold = 0_kIndex Collection % KeyCount = 0_kIndex Collection % UsedBuckets = 0_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % FreeMolds () NULLIFY ( Collection % KeyCopy ) NULLIFY ( Collection % ValCopy ) RETURN END SUBROUTINE HashMap_ClearItems !****************************************************************************** SUBROUTINE HashMap_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE HashMap_Destroy !****************************************************************************** FUNCTION HashMap_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of keys currently in the hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: Collection !! collection tIndex :: Size !! the number of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % KeyCount RETURN END FUNCTION HashMap_GetSize !****************************************************************************** FUNCTION HashMap_IsEmpty ( Collection ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the hash table is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( IN ) :: Collection !! collection tLogical :: Flag !! true if the table is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Collection % KeyCount == 0_kIndex ) RETURN END FUNCTION HashMap_IsEmpty ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseSymTable Type         ----- ! --------------------------------------------------------------------- FUNCTION HashMap_Move2FirstPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a hash table.   For the hash table, !  which is an unordered symbol table, the starting pair is the first pair found !  in the non-empty bucket.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !% the first key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the first value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the table contains no pair data or not <br> ! - true if the table is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN IsEmpty = TrueVal RETURN ELSE IsEmpty = FalseVal END IF ! initialize iteration-related components Collection % Indx = 0_kIndex Collection % KeyLeft = Collection % KeyCount Collection % IterModCount = Collection % ModCount ! start iteration by looking for the first non-empty slot DO WHILE ( Collection % Items ( Collection % Indx )% Stat /= STAT_GEN ) Collection % Indx = Collection % Indx + 1_kIndex END DO ! update KeyLelf Collection % KeyLeft = Collection % KeyLeft - 1_kIndex ! get key if requested IF ( PRESENT ( Key ). AND . PRESENT ( KeyCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Key )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Key % Get ( Key , Collection % KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value ). AND . PRESENT ( ValCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Value )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Value % Get ( Value , Collection % ValCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified value is likely NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION HashMap_Move2FirstPair !****************************************************************************** FUNCTION HashMap_Move2NextPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table.  For the *HashMap*, which !  is an unordered symbol table,  the next pair is a pair inserted in the first !  non-empty bucket after the previous one.  <br> !  The routine will report an error if an alteration to stored item(s) (either !  by an insertion or a removal) has been occurred during current iteration.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !% the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IterModCount /= Collection % ModCount ) THEN CALL Handle_ErrLevel ( 'HashMap_Move2NextPair' , ModName , ErrWarning , & \"Must re-start the iteration because the stored items have been altered.\" ) RETURN END IF ! check for empty table IF ( Collection % IsEmpty ()) THEN IsTheEnd = TrueVal RETURN ELSEIF ( Collection % KeyLeft == 0_kIndex ) THEN IsTheEnd = TrueVal RETURN END IF ! update Indx and set flag Collection % Indx = Collection % Indx + 1 IsTheEnd = FalseVal ! start iteration by looking for the next non-empty slot DO WHILE ( Collection % Items ( Collection % Indx )% Stat /= STAT_GEN ) Collection % Indx = Collection % Indx + 1_kIndex END DO ! update KeyLelf Collection % KeyLeft = Collection % KeyLeft - 1_kIndex ! get key if requested IF ( PRESENT ( Key ). AND . PRESENT ( KeyCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Key )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Key % Get ( Key , Collection % KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value ). AND . PRESENT ( ValCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Value )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Value % Get ( Value , Collection % ValCopy )) THEN CALL Handle_ErrLevel ( 'HashMap_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified value is likely NOT the same as that of stored values.' ) END IF END IF RETURN RETURN END FUNCTION HashMap_Move2NextPair !****************************************************************************** SUBROUTINE HashMap_Insert ( Collection , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into the hash table.  If the specified key is already stored !  in the table, replace the old value with the new one.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key to be inserted CLASS ( * ), INTENT ( IN ) :: Value !! associated value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J tIndex :: KeySize ! FLOW ! check the specified key and value IF (. NOT . IsKeyUnordered ( Key )) THEN CALL Handle_ErrLevel ( 'HashMap_Insert' , ModName , ErrSevere , & 'Type of the specified key is NOT valid.' ) RETURN ELSEIF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN CALL Handle_ErrLevel ( 'HashMap_Insert' , ModName , ErrSevere , & 'Only keys of the same type are allowed in a collection.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN CALL Handle_ErrLevel ( 'HashMap_Insert' , ModName , ErrSevere , & 'Only values of the same type are allowed in a collection.' ) RETURN END IF IF (. NOT . ALLOCATED ( Collection % Items )) THEN ! not constructed yet so check type of the specified key IF ( GetDataType ( Key ) == TYPE_DERIVED ) THEN CALL Collection % FreeMolds () CALL Handle_ErrLevel ( 'HashMap_Insert' , ModName , ErrSevere , & 'The collection must be explicitly constructed before using any other method(s).' ) RETURN END IF ! construct empty collection with default options CALL Collection % CreateEmpty () END IF ! resize the capacity if needed IF ( Collection % UsedBuckets >= Collection % Threshold ) CALL Collection % Resize ( MoreCap = TrueVal ) ! set up the probing if needed CALL SetupProbing ( Collection , Key ) ! compute the hash code and offset KeySize = AnyType_GetByteSize ( Key ) HashCode = Collection % HashCalc ( Key , KeySize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! The current bucket was previously deleted IF ( J == - 1_kIndex ) J = I ELSEIF ( Collection % Items ( I )% Stat /= STAT_NUL ) THEN ! The current bucket already contains a key IF ( Collection % Items ( I )% IsKeyEqual ( Key , Collection % ItemPool )) THEN ! The key we're trying to insert already exists in the hash-table, ! so update its value with the most recent value IF ( J == - 1_kIndex ) THEN CALL Collection % Items ( I )% Set ( STAT_GEN , Collection % ItemPool , Value = Value ) ELSE CALL Collection % Items ( I )% Set ( STAT_DEL ) CALL Collection % Items ( J )% Set ( STAT_GEN , Collection % ItemPool , Key , Value ) END IF Collection % ModCount = Collection % ModCount + 1_kIndex EXIT END IF ELSE ! The current bucket is null so an insertion/update can occur IF ( J == - 1_kIndex ) THEN ! No previously encountered deleted buckets Collection % UsedBuckets = Collection % UsedBuckets + 1_kIndex CALL Collection % Items ( I )% Set ( STAT_GEN , Collection % ItemPool , Key , Value ) ELSE ! Previously seen deleted bucket. Instead of inserting ! the new element at i where the null element is insert ! it where the deleted token was found. CALL Collection % Items ( J )% Set ( STAT_GEN , Collection % ItemPool , Key , Value ) END IF Collection % KeyCount = Collection % KeyCount + 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END SUBROUTINE HashMap_Insert !****************************************************************************** SUBROUTINE HashMap_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a key-value pair of the current iteration from a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Collection % KeyCount = Collection % KeyCount - 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % Items ( Collection % Indx )% Set ( STAT_DEL ) RETURN END SUBROUTINE HashMap_Delete !****************************************************************************** FUNCTION HashMap_Remove ( Collection , Key ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified key (and its associated value) from a symbol !  table.  Also, return a flag indicating whether the key-value pair is !  successfully removed or not. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key to be removed !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I tIndex :: KeySize ! FLOW ! return quickly if possible IF ( Collection % IsEmpty ()) THEN Flag = FalseVal RETURN ELSEIF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashMap_Remove' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as that of stored keys.' ) RETURN END IF ! set up the probing if needed CALL SetupProbing ( Collection , Key ) ! compute the hash code and offset KeySize = AnyType_GetByteSize ( Key ) HashCode = Collection % HashCalc ( Key , KeySize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset Indx = 1_kIndex ! Starting at the original hash probe until we find a spot where our key is ! or we hit a null element in which case our element does not exist. DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! ignore deleted bucket so do nothing here ELSEIF ( Collection % Items ( I )% Stat == STAT_NUL ) THEN ! the key was not found Flag = FalseVal EXIT ELSEIF ( Collection % Items ( I )% IsKeyEqual ( Key , Collection % ItemPool )) THEN ! found the key we want to remove Collection % KeyCount = Collection % KeyCount - 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % Items ( I )% Set ( STAT_DEL ) Flag = TrueVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO ! halve the hash table capacity if it is 12.5% full or less IF (( Collection % KeyCount > 0_kIndex ). AND .( Collection % KeyCount <= Collection % Capacity / 8 )) THEN CALL Collection % Resize ( MoreCap = FalseVal ) END IF RETURN END FUNCTION HashMap_Remove !****************************************************************************** FUNCTION HashMap_Contain ( Collection , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key to be looked for !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSEIF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN Found = FalseVal CALL Handle_ErrLevel ( 'HashMap_Contain' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as that of stored keys.' ) RETURN ELSE ! find the key Found = Collection % FindKey ( Key ) END IF RETURN END FUNCTION HashMap_Contain !****************************************************************************** FUNCTION HashMap_GetValue ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the associated value of the specified key.  Also, return !  a flag indicating whether the value is successfully retrieved or not. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key to be looked for CLASS ( * ), INTENT ( INOUT ) :: Value !! associated value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the value is successfully retrieved or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSEIF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetValue' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as that of stored keys.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetValue' , ModName , ErrSevere , & 'Type of the specified value is NOT the same as that of stored values.' ) RETURN ELSE ! find the key and get its associated value Flag = Collection % FindKey ( Key , Value , ValCopy ) END IF RETURN END FUNCTION HashMap_GetValue !************************************************************************************** FUNCTION HashMap_ToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all key-value pairs from the collection.  Also, return a flag !  indicating whether the pairs are successfully retrieved and removed or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashMap object CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Keys , Values , KeyCopy , ValCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION HashMap_ToArray !************************************************************************************** FUNCTION HashMap_GetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys and/or all values (without removing them) from the collection.  Also, !  return a flag indicating whether the keys and/or values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashMap object CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: SameKeyType , SameValType ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF ( PRESENT ( Keys ). AND . PRESENT ( Values )) THEN SameKeyType = Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal ) SameValType = Collection % IsValValid ( Values ( 1 )) ! check whether types of the specified keys and values are valid or not IF ( SameKeyType . AND . SameValType ) THEN Success = Collection % GetAllKeys ( Keys , KeyCopy ) IF ( Success ) Success = Collection % GetAllVals ( Values , ValCopy ) ELSEIF ( SameKeyType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) ELSEIF ( SameValType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetAll' , ModName , ErrSevere , & 'Types of both keys and values are NOT the same as those of stored pairs.' ) END IF ELSEIF ( PRESENT ( Keys )) THEN ! check whether type of the specified keys is valid or not IF ( Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal )) THEN Success = Collection % GetAllKeys ( Keys , KeyCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Values )) THEN ! check whether type of the specified values is valid or not IF ( Collection % IsValValid ( Values ( 1 ))) THEN Success = Collection % GetAllVals ( Values , ValCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashMap_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION HashMap_GetAll !************************************************************************************** FUNCTION HashMap_GetAllKeys ( Collection , Keys , KeyCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashMap object CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , ArrSize PROCEDURE ( IfacePolyCopy ), POINTER :: CopyProc ! FLOW ! set a pointer to copy procedure IF ( PRESENT ( KeyCopy )) THEN CopyProc => KeyCopy ELSE CopyProc => Collection % KeyCopy END IF ! initialize local variables ArrSize = SIZE ( Keys , KIND = kIndex ) I = 1_kindex ! loop through all buckets DO J = 1_kIndex , SIZE ( Collection % Items , KIND = kIndex ) ! skip the rest if the bucket is empty IF ( Collection % Items ( J )% Stat /= STAT_GEN ) CYCLE Success = Collection % Items ( J )% Key % Get ( Keys ( I ), CopyProc ) IF (. NOT . Success ) THEN CALL Handle_ErrLevel ( 'HashMap_GetAllKeys' , ModName , ErrSevere , & 'Unable to retrieve a key.  This is likely a bug.' ) EXIT END IF ! update I I = I + 1_kIndex ! if we got all items requested, quit the loop IF ( I > ArrSize ) EXIT END DO ! free pointer NULLIFY ( CopyProc ) RETURN END FUNCTION HashMap_GetAllKeys !************************************************************************************** FUNCTION HashMap_GetAllVals ( Collection , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all values (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashMap object CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , ArrSize PROCEDURE ( IfacePolyCopy ), POINTER :: CopyProc ! FLOW ! set a pointer to copy procedure IF ( PRESENT ( ValCopy )) THEN CopyProc => ValCopy ELSE CopyProc => Collection % ValCopy END IF ! initialize local variables ArrSize = SIZE ( Values , KIND = kIndex ) I = 1_kindex ! loop through all buckets DO J = 1_kIndex , SIZE ( Collection % Items , KIND = kIndex ) ! skip the rest if the bucket is empty IF ( Collection % Items ( J )% Stat /= STAT_GEN ) CYCLE Success = Collection % Items ( J )% Value % Get ( Values ( I ), CopyProc ) IF (. NOT . Success ) THEN CALL Handle_ErrLevel ( 'HashMap_GetAllVals' , ModName , ErrSevere , & 'Unable to retrieve a value.  This is likely a bug.' ) EXIT END IF ! update I I = I + 1_kIndex ! if we got all items requested, quit the loop IF ( I > ArrSize ) EXIT END DO ! free pointer NULLIFY ( CopyProc ) RETURN END FUNCTION HashMap_GetAllVals ! ----------------------------------------------------------------------------- ! -----                        Common Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE HashMap_Resize ( Collection , MoreCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To resize the capacity of the hash table according the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection tLogical , INTENT ( IN ) :: MoreCap !&#94; true if increasing the capacity; otherwise, decreasing the capacity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabItem ), ALLOCATABLE :: OldItems (:) tIndex :: OldCap , I tLogical :: Success CLASS ( * ), POINTER :: KeyMold CLASS ( * ), POINTER :: ValMold CLASS ( * ), ALLOCATABLE :: Key CLASS ( * ), ALLOCATABLE :: Value !** FLOW: OldCap = Collection % Capacity IF ( MoreCap ) THEN CALL IncreaseCapacity ( Collection ) ELSE ! halving the capacity Collection % Capacity = Collection % Capacity / 2_kIndex END IF CALL AdjustCapacity ( Collection ) ! update threshold Collection % Threshold = ToIndex ( Collection % Capacity * Collection % LoadFactor ) ! move currently stored objects to temporary variable CALL MOVE_ALLOC ( Collection % Items , OldItems ) ! allocate working items to new capacity ALLOCATE ( Collection % Items ( 0 : Collection % Capacity - 1_kIndex )) ! set status to null Collection % Items (:)% Stat = STAT_NUL ! Reset the key count and buckets used since we are about to ! re-insert all the keys into the hash-table. Collection % KeyCount = 0_kIndex Collection % UsedBuckets = 0_kIndex ! loop over the temporary lists to move stored objects (Items) ! back to the working lists of the hash table KeyMold => Collection % GetKeyPtr () ValMold => Collection % GetValPtr () ALLOCATE ( Key , MOLD = KeyMold ) ALLOCATE ( Value , MOLD = ValMold ) DO I = 0_kIndex , OldCap - 1_kIndex IF ( OldItems ( I )% Stat == STAT_GEN ) THEN ! get old key and value back Success = OldItems ( I )% Key % Get ( Key , Collection % ValCopy ) IF ( Success ) Success = OldItems ( I )% Value % Get ( Value , Collection % ValCopy ) ! re-insert the key and its associated value IF ( Success ) THEN CALL Collection % Insert ( Key , Value ) ELSE CALL Handle_ErrLevel ( 'HashMap_Resize' , ModName , ErrSevere , & 'Unable to get old key and/or value.  This is likely due to invalid copy procedure(s).' ) EXIT END IF END IF CALL OldItems ( I )% MemFree () END DO ! free local variables DEALLOCATE ( OldItems ) NULLIFY ( KeyMold , ValMold ) DEALLOCATE ( Key ) DEALLOCATE ( Value ) RETURN END SUBROUTINE HashMap_Resize !****************************************************************************** FUNCTION HashMap_FindKey ( Collection , Key , Value , ValCopy ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table. !  Optionally, retrieve the associated value if the key is found. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key to be looked for CLASS ( * ), OPTIONAL , INTENT ( OUT ) :: Value !! associated value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J tIndex :: KeySize tLogical :: Success ! FLOW ! set up the probing if needed CALL SetupProbing ( Collection , Key ) ! compute the hash code and offset KeySize = AnyType_GetByteSize ( Key ) HashCode = Collection % HashCalc ( Key , KeySize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex ! Start at the original hash value and probe until we find a spot where our key ! is or hit a null element in which case our element does not exist. DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! Ignore deleted buckets, but record where the first index ! of a deleted bucket is found to perform lazy relocation later. IF ( J == - 1_kIndex ) J = I ELSEIF ( Collection % Items ( I )% Stat /= STAT_NUL ) THEN ! found the key we want to remove IF ( J /= - 1_kIndex ) THEN ! If J /= -1 this means we previously encountered a deleted cell. ! We can perform an optimization by swapping the entries in cells ! I and J so that the next time we search for this key it will be ! found faster. This is called lazy deletion/relocation. CALL Collection % Items ( J )% Set ( STAT_GEN , Collection % Items ( I )) CALL Collection % Items ( I )% Set ( STAT_DEL ) IF ( PRESENT ( Value )) Success = Collection % Items ( J )% Value % Get ( Value , ValCopy ) ELSE IF ( PRESENT ( Value )) Success = Collection % Items ( I )% Value % Get ( Value , ValCopy ) END IF Found = TrueVal EXIT ELSE ! the key was not found Found = FalseVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END FUNCTION HashMap_FindKey !****************************************************************************** SUBROUTINE HashMap_CreateEmpty ( Collection , InitCap , LoadFactor , ProbAlgo , HashCalc , KeyCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !! initial capacity of the hash table tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !! load factor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !> hash function to compute the hash value of the key; if not present, use default one. PROCEDURE ( HashFunc ), OPTIONAL :: HashCalc !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! determine initial capacity IF ( PRESENT ( InitCap )) THEN IF ( InitCap < 0_kIndex ) THEN Collection % Capacity = DefaultCapacity ELSE Collection % Capacity = MAX ( DefaultCapacity , InitCap ) END IF ELSE Collection % Capacity = DefaultCapacity END IF ! determine load factor IF ( PRESENT ( LoadFactor )) THEN IF ( InitCap < 0.0_kDouble ) THEN Collection % LoadFactor = DefaultLoadFactor ELSE Collection % LoadFactor = LoadFactor END IF ELSE Collection % LoadFactor = DefaultLoadFactor END IF ! determine probing algorithm IF ( PRESENT ( ProbAlgo )) THEN SELECT CASE ( ProbAlgo ) CASE ( 1 : 3 ) Collection % ProbAlgo = ProbAlgo CASE DEFAULT Collection % ProbAlgo = LinearProbing END SELECT ELSE Collection % ProbAlgo = LinearProbing END IF ! set hash function pointer IF ( PRESENT ( HashCalc )) THEN ! use supplied function Collection % HashCalc => HashCalc ELSE ! use default algorithm Collection % HashCalc => ComputeHash END IF ! set pointer to copy procedures IF ( PRESENT ( KeyCopy )) THEN Collection % KeyCopy => KeyCopy ELSE Collection % KeyCopy => NULL () END IF IF ( PRESENT ( ValCopy )) THEN Collection % ValCopy => ValCopy ELSE Collection % ValCopy => NULL () END IF ! adjust the capacity according to the probing algorithm CALL AdjustCapacity ( Collection ) ! compute threshold Collection % Threshold = ToIndex ( Collection % Capacity * Collection % LoadFactor ) ! allocate memory of item storages ALLOCATE ( Collection % Items ( 0 : Collection % Capacity - 1 )) ! set status to null Collection % Items (:)% Stat = STAT_NUL ! construct items' pool CALL Collection % ItemPool % Construct () RETURN END SUBROUTINE HashMap_CreateEmpty !****************************************************************************** SUBROUTINE HashMap_CreateByArray ( Collection , N , Keys , Values , LoadFactor , ProbAlgo , & HashCalc , KeyCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of key-value pairs !% the keys to be added to the table CLASS ( * ), INTENT ( IN ) :: Keys ( N ) !% the associated values to be added to the table CLASS ( * ), INTENT ( IN ) :: Values ( N ) tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !! load factor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !> hash function to compute the hash value of the key; if not present, use default one. PROCEDURE ( HashFunc ), OPTIONAL :: HashCalc !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! create empty symbol table with capacity twice of the key size CALL Collection % CreateEmpty ( N * 2_kIndex , LoadFactor , ProbAlgo , HashCalc , KeyCopy , ValCopy ) ! add key-value pairs to the table DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE HashMap_CreateByArray !****************************************************************************** SUBROUTINE HashMap_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the collection. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % Destruct () RETURN END SUBROUTINE HashMap_Finalize ! ----------------------------------------------------------------------------- ! -----             Procedures Dependent On Probing Algorithm             ----- ! ----------------------------------------------------------------------------- SUBROUTINE SetupProbing ( Collection , Key ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set up the probing according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! no setup required CASE ( QuadraticProbing ) ! no setup required CASE ( DoubleHashing ) BLOCK tIndex :: HashCode tIndex :: KeySize ! Cache second hash value. KeySize = AnyType_GetByteSize ( Key ) HashCode = Collection % HashCalc ( Key , KeySize , HashSeed , RemoveSign = TrueVal ) Collection % HashIndx = ComputeIndex ( HashCode , Collection % Capacity ) ! Fail safe to avoid infinite loop IF ( Collection % HashIndx == 0_kIndex ) Collection % HashIndx = 1_kIndex END BLOCK END SELECT RETURN END SUBROUTINE SetupProbing !****************************************************************************** FUNCTION Probe ( Collection , IdIn ) RESULT ( IdOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To look for the next available bucket according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: IdIn !! starting index for the probing tIndex :: IdOut !! index of available bucket !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) IdOut = LinearConstant * IdIn CASE ( QuadraticProbing ) ! Quadratic probing function (x**2 + x) / 2 IdOut = SHIFTR ( IdIn * IdIn + IdIn , 1 ) CASE ( DoubleHashing ) IdOut = Collection % HashIndx * IdIn END SELECT RETURN END FUNCTION Probe !****************************************************************************** SUBROUTINE AdjustCapacity ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To adjust capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! Adjust the capacity so that the linear constant and ! the table capacity are relatively prime. DO WHILE ( ComputeGCD ( LinearConstant , Collection % Capacity ) /= 1_kIndex ) Collection % Capacity = Collection % Capacity + 1_kIndex END DO CASE ( QuadraticProbing ) ! Adjust the capacity of the hash table to be a power of two. BLOCK tIndex :: Pow2 Pow2 = HighestOneBit ( Collection % Capacity ) IF ( Collection % Capacity /= Pow2 ) THEN CALL IncreaseCapacity ( Collection ) END IF END BLOCK CASE ( DoubleHashing ) ! Adjust the capacity until it is a prime number. The reason for ! doing this is to help ensure that the GCD(hash, capacity) = 1 when ! probing so that all the cells can be reached. IF (. NOT . IsPrime ( Collection % Capacity )) THEN Collection % Capacity = NextPrime ( Collection % Capacity ) END IF END SELECT RETURN END SUBROUTINE AdjustCapacity !****************************************************************************** SUBROUTINE IncreaseCapacity ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To increase capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashMap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! doubling the capacity Collection % Capacity = Collection % Capacity * 2_kIndex + 1_kIndex CASE ( QuadraticProbing ) ! increase the capacity of the hash table to the next power of two. Collection % Capacity = SHIFTL ( HighestOneBit ( Collection % Capacity ), 1 ) CASE ( DoubleHashing ) ! doubling the capacity Collection % Capacity = Collection % Capacity * 2_kIndex + 1_kIndex END SELECT RETURN END SUBROUTINE IncreaseCapacity ! ----------------------------------------------------------------------------- ! -----                     Auxiliary Procedures                          ----- ! ----------------------------------------------------------------------------- FUNCTION ComputeIndex ( HashCode , Capacity ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the index of working items of the hash table for !  the specified hash code.  Returns value between 0 and !  Capacity-1 (assumes Capacity is a power of 2). !** SUBROUTINE ARGUMENT DECLARATIONS: tHash , INTENT ( IN ) :: HashCode tIndex , INTENT ( IN ) :: Capacity tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! Note: the sign of the hash code must have already been removed. Indx = IAND ( HashCode , Capacity - 1_kIndex ) RETURN END FUNCTION ComputeIndex !****************************************************************************** RECURSIVE FUNCTION ComputeGCD ( A , B ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the greatest common denominator of A and B. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: A , B tIndex :: C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( B == 0_kIndex ) THEN C = A ELSE C = ComputeGCD ( B , MOD ( A , B )) END IF RETURN END FUNCTION ComputeGCD !****************************************************************************** !** UNDEFINE MACROS ** #undef tHash END MODULE MClass_HashMap !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hashmap.f90.html"},{"title":"MClass_TreeRealDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeRealDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeRealDP* type and its related helper type and routines. !   The *TreeRealDP* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeRealDP* !   type uses the Fortran intrinsic *REAL(KIND=kDouble)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeRealDP* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeRealDP* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeRealDP* type but utilizes !   a different implementation.  Also, unlike the *TreeRealDP* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeRealDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        REAL(KIND=kDouble) #define KeyTypeB        REAL(KIND=kDouble) #define KeyTypeC        REAL(KIND=kDouble) #define QueueKey        ListRealDP #define QueueVal        ListAnyType #define RedBlackTree    TreeRealDP !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeRealDP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeRealDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treerealdp.f90.html"},{"title":"MBase_HashTables.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_HashTables !&#94;  **PURPOSE OF THIS MODULE**: <br> !   This module collectively contains *hash-table* container types from other modules. It is !   provided so that a user can refer to this module instead of referring to several individual !   modules when various types are needed concurrently. <br> !   <br> !   **Overview**: <br> !   These hash-table container types are container types that employ a hash table implementation !   to provide common operations for an unordered symbol table.  Technically, all of them employ !   the open-addressing as a collision resolution technique where the hash resolution is performed !   through probing.  They provide three probing algorithms: linear probing, quadratic probing and !   double hashing.  By default, the linear probing algorithm is used.  However, a user can specify !   other probing algorithm during a construction of a table. <br> !   Each individual type can be used to store key-value pairs for a specific type of keys where the !   allowed types of stored keys include the Fortran intrinsic CHARACTER, INTEGER and REAL types as !   well as any derived type in the *Object* class.  Most of the hash-table container types (except !   the *HTabObject* type) utilize an unlimited polymorphic type to store values; therefore, a type !   of inserted values can be any data type.  Unlike other types, the *HTabObject* type uses the !   *Object* type to represent both key and value, and it requires only one argument (instead of !   two) when inserting or retrieving the key and its associated value.  Therefore, its application !   programming interface (API) is slightly different from the API of other hash-table types.  <br> !   Available hash-table-based container types include: <br> !   - the <a href=\"../module/mclass_htabcharacter.html#type-htabcharacter\">HTabCharacter</a> type !     for character string key type, <br> !   - the <a href=\"../module/mclass_htabinteger1b.html#type-htabinteger1b\">HTabInteger1B</a> type !     for 1-byte (or 8-bit) integer key type, <br> !   - the <a href=\"../module/mclass_htabinteger2b.html#type-htabinteger2b\">HTabInteger2B</a> type !     for 2-byte (or 16-bit) integer key type, <br> !   - the <a href=\"../module/mclass_htabinteger4b.html#type-htabinteger4b\">HTabInteger4B</a> type !     for 4-byte (or 32-bit) integer key type, <br> !   - the <a href=\"../module/mclass_htabinteger8b.html#type-htabinteger8b\">HTabInteger8B</a> type !     for 8-byte (or 64-bit) integer key type, <br> !   - the <a href=\"../module/mclass_htabrealsp.html#type-htabrealsp\">HTabRealSP</a> type !     for single-precision real key type, <br> !   - the <a href=\"../module/mclass_htabrealdp.html#type-htabrealdp\">HTabRealDP</a> type !     for double-precision real key type, <br> !   - the <a href=\"../module/mclass_htabrealqp.html#type-htabrealqp\">HTabRealQP</a> type !     for quadruple-precision real key type, <br> !   - the <a href=\"../module/mclass_htabobject.html#type-htabobject\">HTabObject</a> !     type for a derived type of key-value pair in the *Object* class. <br> !   Each hash-table-based container type represents an unordered symbol table where various common !   operations are provided and can be categorized as follows. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *CreateEmpty* method - method to construct an empty container, <br> !   - *Construct* method - method to construct a container from arrays of keys and values, and <br> !   - *Destruct* method - method to destruct a container by removing all key-value pairs from !       the container as well as free memory storage occupied by the container. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *Insert* method - method to insert a key and its associated value into a container, <br> !   - *Remove* method - method to remove a key (and its associated value) from a container, and <br> !   - *Clear* method - method to remove all key-value pairs from a container. <br> !   (3) Retrieval.  A method for this operation is: <br> !   - *GetKeys* method - method to retrieve all keys and optionally all their associated values. <br> !   (4) Inquiry.  Methods for this operation include: <br> !   - *IsEmpty* method - method to check whether the container is empty or not, <br> !   - *Contain* method - method to check whether the specified key is in the container or not, and <br> !   - *GetSize* method - method to get the container size (number of key-value pairs stored). <br> !   (5) Iteration.  Methods for this operation include: <br> !   - *StartFirst* method - method to start a forward iteration over key-value pairs, and <br> !   - *MoveForward* method - method to move forward to the next key-value pair. <br> !** USE STATEMENTS: USE MClass_HTabCharacter USE MClass_HTabInteger1B USE MClass_HTabInteger2B USE MClass_HTabInteger4B USE MClass_HTabInteger8B USE MClass_HTabRealSP USE MClass_HTabRealDP USE MClass_HTabRealQP USE MClass_HTabObject END MODULE MBase_HashTables","tags":"","loc":"sourcefile\\mbase_hashtables.f90.html"},{"title":"MClass_HTabInteger4B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabInteger4B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabInteger4B* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabInteger4B* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabInteger4B* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabInteger4B* type uses the Fortran intrinsic !   *INTEGER(KIND=kInt32)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabInteger4B* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabInteger4B* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabInteger4B #define     KeyTypeA        INTEGER(KIND=kInt32) #define     KeyTypeB        INTEGER(KIND=kInt32) #define     QueueKey        ListInteger4B #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabInteger4B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabInteger4B' ! Special marker token used to indicate the deletion of a key-value pair tSInt32 , PARAMETER :: DELKEY = ToInt32 ( Z '7FFFFFFF' ) ! Special marker token used to indicate the empty of a key-value pair tSInt32 , PARAMETER :: NULKEY = ToInt32 ( Z '80000000' ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabInteger4B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabinteger4b.f90.html"},{"title":"MClass_TreeTable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeTable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeTable* type and its supporting routines and data type.  The !   The *TreeTable* type is a collection type that employs a balanced binary-search-tree (BST) !   implementation to provide common operations for an ordered symbol table. <br> !   The *TreeTable* type uses the *KeyOrdered* type to store its keys and the *GenData* type !   to store its values.  Therefore, it can be used to store comparable keys and values of any !   data types.  Allowed types of comparable keys include the *CHARACTER*, *INTEGER* and *REAL* !   intrinsic types as well as any derived type that is in the *Comparable* class.  Like other !   collection types, however, it must be employed to store key-value pairs of only specific !   key type and one specific value type.  To store key-value pairs of another key type (or !   another value type), it must be destructed before inserting items of different key type !   (or different value type). <br> !   As a symbol table, the *TreeTable* type does not allow duplicated keys.  Therefore, if an !   inserted key is equal to a key stored in the table, an associated value of the stored key !   is replaced by an associated value of the inserted key.  As an *ordered* symbol table, the !   *TreeTable* type provides an ordered iteration over its stored key-value items, which are !   sorted according to the natural ordering of its keys.  It can be accessed and traversed in !   either ascending (using the *StartFirst* method) or descending (using the *StartLast* method) !   key order. <br> !   Technically, the *TreeTable* type employs a balanced binary search tree (BST) implementation !   to provide common operations for an ordered symbol table.  The *TreeTable* type utilizes the !   *IntrusiveRBTree* type as its component to store its tree nodes.  The *IntrusiveRBTree* type, !   as an intrusive BST container, provides common binary-search-tree operations without a memory !   management task.  The memory management task of the inserted tree nodes is handled by the !   *TreeTable* type.  <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveBSTrees USE MClass_Object , ONLY : Object USE MClass_Comparable , ONLY : Comparable USE MClass_KeyOrdered USE MClass_GenData USE MClass_CompNodePool USE MClass_MemoryPool USE MClass_BaseCollection USE MClass_BaseSymTable USE MClass_OrderedSymTable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeTable PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeTable' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *TabNode* is a binary-search-tree node type containing key and value as its components. !   The *KeyOrdered* type is used as a storage for the key and the *GenData* type is used !   as a storage for the value.  The *TabNode* type is a subtype of the *BSTNode* type and !   is intended to be used with the *TreeTable* type, which is a collection type that utilizes !   the *IntrusiveRBTree* type. <br> TYPE , EXTENDS ( BSTNode ) :: TabNode TYPE ( KeyOrdered ) :: Key !! stored key TYPE ( GenData ) :: Value !! stored value CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TabNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TabNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TabNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TabNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TabNode_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedure from Comparable Type           ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => TabNode_CompareKey ! --------------------------------------------------------------------- ! -----         Specific Procedure for TabNode Type               ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: SetKeyNVal <br> !  **Purpose**:  To set new key and value. <br> !  **Usage**: <br> !   --->    Valid = Node%SetKeyNVal(Key, Value, MemPool) PROCEDURE :: SetKeyNVal => TabNode_SetKeyNVal ! --------------------------------------------------------------------- END TYPE TabNode !> The *TreeTable* type is a collection type that utilizes a balanced BST implementation to !   provide common operations for an ordered symbol table.  The *TreeTable* type uses the !   *IntrusiveRBTree* type as its component to store *TabNode* objects.  As an intrusive !   BST container, the *IntrusiveRBTree* type provides common binary-search-tree operations !   without a memory management task.  The memory management task of the inserted *TabNode* !   objects is handled by the *TreeTable* type.  <br> !   As an ordered symbol table, the *TreeTable* type is a subtype of the *OrderedSymTable* !   type.  Thus, it implements all deferred procedures required by the *OrderedSymTable* !   type and all its super classes.  As a symbol table, the *TreeTable* type does not allow !   duplicated keys; therefore, if an inserted key is equal to a key stored in the table, an !   associated value of the stored key is replaced by an associated value of the inserted key. <br> !   Because the *IntrusiveRBTree* type is a subtype of the *IntrusiveAVLTree* type, the !   *WrkTree* component can be employed as a red-black tree or an AVL tree.  Therefore, the !   *TreeTable* type allows a user to specify which type of binary-search tree implementation !   to be used.  By default, the red-black tree implementation is used.  The user can call the !   *UseAVLTree* method to change to AVL tree implementation.  The *UseAVLTree* method must !   be called before inserting an object into the symbol table (i.e when the table is empty). !   Otherwise, the red-black tree implementation is employed.  <br> TYPE , EXTENDS ( OrderedSymTable ) :: TreeTable PRIVATE !> a flag indicating whether to use the red-black tree implementation !  or the AVL tree implementation tLogical :: IsRBTree = TrueVal !% a working binary-search tree TYPE ( IntrusiveRBTree ) :: WrkTree !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To check whether the specified key is stored in the !                collection or not.  Optionally, return a stored node !                containing a key equal to the specified key. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => TreeTable_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => TreeTable_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => TreeTable_GetAllVals !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: TreeTable_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => TreeTable_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => TreeTable_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => TreeTable_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => TreeTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => TreeTable_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => TreeTable_Move2NextPair !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order and return a flag !                indicating whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartLast() <br> !   --->    IsEmpty = Collection%StartLast(LastKey) <br> !   --->    IsEmpty = Collection%StartLast(Value=LastVal) <br> !   --->    IsEmpty = Collection%StartLast(LastKey, LastVal) PROCEDURE :: StartLast => TreeTable_Move2LastPair !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveBackward() <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevKey) <br> !   --->    IsTheEnd = Collection%MoveBackward(Value=PrevVal) <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevKey, PrevVal) PROCEDURE :: MoveBackward => TreeTable_Move2PrevPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => TreeTable_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => TreeTable_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => TreeTable_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => TreeTable_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. Also, !       return a flag indicating whether the key-value pair is successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => TreeTable_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => TreeTable_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => TreeTable_GetAll ! --------------------------------------------------------------------- ! -----     Deferred Procedures from OrderedSymTable Type         ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: GetMinKey <br> !  **Purpose**:  To get the smallest key (and optionally a value associated !                with it) in a symbol table.  Also, return a flag indicating !                whether the key is successfully retrieved or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetMinKey(Key) <br> !   --->    IF (.NOT.Collection%GetMinKey(Key, Value)) DoSomething PROCEDURE :: GetMinKey => TreeTable_GetMinKey !> **Type-Bound Function**: GetMaxKey <br> !  **Purpose**:  To get the largest key (and optionally a value associated !                with it) in a symbol table.  Also, return a flag indicating !                whether the key is successfully retrieved or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetMaxKey(Key) <br> !   --->    IF (.NOT.Collection%GetMaxKey(Key, Value)) DoSomething PROCEDURE :: GetMaxKey => TreeTable_GetMaxKey !> **Type-Bound Function**: Floor <br> !  **Purpose**:  To get the largest key (and optionally a value associated !                with it) in a symbol table less than or equal to the given !                key.  Also, return a flag indicating whether the floor key !                is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Floor(KeyIn, KeyOut) <br> !   --->    IF (.NOT.Collection%Floor(KeyIn, KeyOut, Value)) DoSomething PROCEDURE :: Floor => TreeTable_Floor !> **Type-Bound Function**: Ceiling <br> !  **Purpose**:  To get the smallest key (and optionally a value associated !                with it) in a symbol table greater than or equal to the given !                key.  Also, return a flag indicating whether the ceiling key !                is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Ceiling(KeyIn, KeyOut) <br> !   --->    IF (.NOT.Collection%Ceiling(KeyIn, KeyOut, Value)) DoSomething PROCEDURE :: Ceiling => TreeTable_Ceiling !> **Type-Bound Function**: GetRank <br> !  **Purpose**:  To return the number of keys in the symbol table strictly !                less than the given key. <br> !  **Usage**: <br> !   --->    KeyRank = Collection%GetRank(Key) PROCEDURE :: GetRank => TreeTable_GetRank !> **Type-Bound Subroutine**: Select <br> !  **Purpose**:  To get the key (and optionally its associated value) of the !                specified rank where the applicable range of rank is between !                0 and TableSize-1. Also, return a flag indicating whether the !                ranked key is successfully retrieved or not. <br> !   --->    Flag = Collection%Select(Rank, Key) <br> !   --->    IF (.NOT.Collection%Select(Rank, Key, Value)) DoSomething PROCEDURE :: Select => TreeTable_Select !> **Type-Bound Function**: RemoveMin <br> !  **Purpose**:  To remove the smallest key (and a value associated with it) !                from a symbol table.  Also, return a flag indicating !                whether the key is successfully removed or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMin() <br> !   --->    Flag = Collection%RemoveMin(MinKey) <br> !   --->    Flag = Collection%RemoveMin(Value=MinVal) <br> !   --->    IF (.NOT.Collection%RemoveMin(MinKey, MinVal)) DoSomething PROCEDURE :: RemoveMin => TreeTable_RemoveMin !> **Type-Bound Function**: RemoveMax <br> !  **Purpose**:  To remove the largest key (and a value associated with it) !                from a symbol table.  Also, return a flag indicating !                whether the key is successfully removed or not.  If the !                table is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMax() <br> !   --->    Flag = Collection%RemoveMax(MaxKey) <br> !   --->    Flag = Collection%RemoveMax(Value=MaxVal) <br> !   --->    IF (.NOT.Collection%RemoveMax(MaxKey, MaxVal)) DoSomething PROCEDURE :: RemoveMax => TreeTable_RemoveMax !> **Type-Bound Function**: GetRangeSize <br> !  **Purpose**:  To return the number of keys between *KeyLo* (inclusive) !                and *KeyHi* (inclusive). <br> !  **Usage**: <br> !   --->    RangeSize = Collection%GetRangeSize(KeyLo, KeyHi) PROCEDURE :: GetRangeSize => TreeTable_RangeSize ! --------------------------------------------------------------------- ! -----         Specific Procedures by TreeTable Type             ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => TreeTable_CreateByArray !> **Type-Bound Subroutine**: UseAVLTree <br> !  **Purpose**:  To set the working tree component to work as an AVL tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseAVLTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseAVLTree => TreeTable_UseAVLTree !> **Type-Bound Subroutine**: UseRBTree <br> !  **Purpose**:  To set the working tree component to work as an red-black RB tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseRBTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseRBTree => TreeTable_UseRBTree !> **Type-Bound Function**: Check <br> !  **Purpose**:  To check integrity of the BST data structure. <br> !  **Usage**: <br> !   --->    Flag = Tree%Check() <br> !   --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething PROCEDURE :: Check => TreeTable_CheckIntegrity ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TreeTable_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TreeTable_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TreeTable_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TreeTable_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TreeTable_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: TreeTable_Finalize ! --------------------------------------------------------------------- END TYPE TreeTable !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 TabNode Procedures                        ----- ! --------------------------------------------------------------------- SUBROUTINE TabNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( TabNode ) CALL SrcObj % CopyBSTNode ( DstObj ) CALL SrcObj % Key % Copy ( DstObj % Key , IsDeep ) CALL SrcObj % Value % Copy ( DstObj % Value , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TabNode_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"TabNode\" only.' ) RETURN END SELECT RETURN END SUBROUTINE TabNode_Copy !****************************************************************************** FUNCTION TabNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not.  This is a deferred procedure by !  an *Object* object. <br> !  It should be noted that this routine uses all components of the *TabNode* object to !  check equality. Therefore, although (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) !  can return false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( TabNode ) Flag = FalseVal IF (. NOT . LhsObj % Key % IsEqualTo ( RhsObj % Key )) RETURN IF (. NOT . LhsObj % Value % IsEqualTo ( RhsObj % Value )) RETURN Flag = LhsObj % IsBSTNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabNode_IsEqualTo !****************************************************************************** SUBROUTINE TabNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free the key and value components CALL Obj % Key % MemFree () CALL Obj % Value % MemFree () ! reset the \"BSTNode\" components CALL Obj % ResetBSTNode () RETURN END SUBROUTINE TabNode_MemFree !****************************************************************************** FUNCTION TabNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{TabNode: {' // Obj % Key % ToString () // ' : ' // Obj % Value % ToString () // '}}' RETURN END FUNCTION TabNode_ToString !****************************************************************************** FUNCTION TabNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: AdjNode ! FLOW ! get code from left node AdjNode => Obj % GetLeft () SELECT TYPE ( Left => AdjNode ) TYPE IS ( TabNode ) Code = Left % Key % HashCode () END SELECT ! add code from this node Code = Code + Obj % Key % HashCode () ! add code from right node AdjNode => Obj % GetRight () SELECT TYPE ( Right => AdjNode ) TYPE IS ( TabNode ) Code = Code + Right % Key % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION TabNode_HashCode !****************************************************************************** FUNCTION TabNode_CompareKey ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare *A* and *B* and return <br> !   1 if *A* is greater than *B*, <br> !   0 if *A* is equal to *B*, <br> !  -1 if *A* is less than *B*, <br> !  -999 if type of *B* is invalid. <br> !  Also, write an error message to the default log file if this happens. <br> !  This is a deferred procedure by an *Comparable* object. <br> !  It is important to note that this routine only uses the key component !  of the *TabNode* object.  Thus, even though (A%CompareTo(B) == 0) !  is true, A%IsEqualTo(B) may be false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: A CLASS ( Comparable ), INTENT ( IN ) :: B tSInt32 :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( B ) TYPE IS ( TabNode ) Flag = A % Key % CompareTo ( B % Key ) CLASS DEFAULT Flag = - 999 CALL Handle_ErrLevel ( 'TabNode_CompareKey' , ModName , ErrSevere , 'Type of B is valid.' ) END SELECT RETURN END FUNCTION TabNode_CompareKey !****************************************************************************** SUBROUTINE TabNode_SetKeyNVal ( Node , Key , Value , Pool ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the key and value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Node !! TabNode object CLASS ( * ), INTENT ( IN ) :: Key !! the key CLASS ( * ), INTENT ( IN ) :: Value !! the associated value TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !! memory pool for both key and value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Key % Set ( Key , Pool ) CALL Node % Value % Set ( Value , Pool ) RETURN END SUBROUTINE TabNode_SetKeyNVal ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- SUBROUTINE TreeTable_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object.  This is a deferred procedure !  inherited from the *Object* type. <br> !  *Note*:  SrcObj must be in the *TreeTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( TreeTable ) DstObj % Dir = SrcObj % Dir DstObj % IsRBTree = SrcObj % IsRBTree CALL SrcObj % NodePool % Copy ( DstObj % NodePool , IsDeep ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) CALL SrcObj % WrkTree % CloneTo ( DstObj % WrkTree ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TreeTable_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE TreeTable_Copy !****************************************************************************** FUNCTION TreeTable_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( TreeTable ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN ! implementation note:  we cannot use the iteration methods here !   due to the intent of the input data. BLOCK CLASS ( BSTNode ), POINTER :: LhsNode , LhsNext , LhsRoot CLASS ( BSTNode ), POINTER :: RhsNode , RhsNext , RhsRoot tLogical :: ReturnNow ReturnNow = FalseVal ! start iteration LhsNode => LhsObj % WrkTree % GetMinNode () RhsNode => RhsObj % WrkTree % GetMinNode () LhsRoot => LhsObj % WrkTree % GetRoot () RhsRoot => RhsObj % WrkTree % GetRoot () Loop : DO WHILE ( ASSOCIATED ( LhsNode ). AND . ASSOCIATED ( RhsNode )) ! get successor nodes CALL Find_Inorder_Successor ( LhsRoot , LhsNode , LhsNext ) CALL Find_Inorder_Successor ( RhsRoot , RhsNode , RhsNext ) ! check key and value equalities SELECT TYPE ( LhsNode ) TYPE IS ( TabNode ) SELECT TYPE ( RhsNode ) TYPE IS ( TabNode ) IF (. NOT . LhsNode % IsEqualTo ( RhsNode )) THEN ReturnNow = TrueVal EXIT Loop END IF END SELECT END SELECT ! move to the next iteration LhsNode => LhsNext RhsNode => RhsNext END DO Loop NULLIFY ( LhsNode , RhsNode ) NULLIFY ( LhsNext , RhsNext ) NULLIFY ( LhsRoot , RhsRoot ) IF ( ReturnNow ) RETURN END BLOCK ELSE RETURN END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TreeTable_IsEqualTo !****************************************************************************** SUBROUTINE TreeTable_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TreeTable object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % WrkTree % Clear () CALL Obj % NodePool % MemFree () CALL Obj % ItemPool % Destruct () CALL Obj % FreeMolds () RETURN END SUBROUTINE TreeTable_MemFree !****************************************************************************** FUNCTION TreeTable_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the TreeTable type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE ! implementation note:  we cannot use the iteration methods here ! due to the intent of the input data. BLOCK CLASS ( BSTNode ), POINTER :: CurrNode , NextNode , RootNode TYPE ( CharBuffer ) :: ChrBuf tCharAlloc :: KeyStr , ValStr , ItemStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) ! start iteration CurrNode => Obj % WrkTree % GetMinNode () RootNode => Obj % WrkTree % GetRoot () Loop : DO WHILE ( ASSOCIATED ( CurrNode )) ! get successor nodes CALL Find_Inorder_Successor ( RootNode , CurrNode , NextNode ) ! get string representation of the stored item of the current node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) KeyStr = CurrNode % Key % ToString () ValStr = CurrNode % Value % ToString () ItemStr = '{' // KeyStr ( 15 : LEN ( KeyStr ) - 1 ) // ' : ' // ValStr ( 12 : LEN ( ValStr ) - 1 ) // '}' CALL ChrBuf % Append ( ItemStr ) IF ( ASSOCIATED ( NextNode )) CALL ChrBuf % Append ( ', ' ) END SELECT ! move to the next iteration CurrNode => NextNode END DO Loop NULLIFY ( CurrNode , NextNode , RootNode ) CALL ChrBuf % Append ( ']' ) Str = ChrBuf % AsString () END BLOCK END IF Str = '{TreeTable with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION TreeTable_ToString !****************************************************************************** FUNCTION TreeTable_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK CLASS ( CompNode ), POINTER :: PoolNodes (:) tIndex :: I ! initialize CALL Obj % NodePool % GetAllNodes ( PoolNodes ) Code = 0_kIndex ! compute hash code SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE Code = Code + Nodes ( I )% Key % HashCode () END DO END SELECT END BLOCK END IF RETURN END FUNCTION TreeTable_HashCode ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseCollection Type       ----- ! --------------------------------------------------------------------- SUBROUTINE TreeTable_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *OrderedSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( TreeTable ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! return if Other is empty IF ( Other % IsEmpty ()) RETURN SELECT TYPE ( Other ) TYPE IS ( TreeTable ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( OrderedSymTable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: KeyItem CLASS ( * ), ALLOCATABLE :: ValItem ! get key and value molds MoldPtr => Other % GetKeyPtr () ALLOCATE ( KeyItem , MOLD = MoldPtr ) MoldPtr => Other % GetValPtr () ALLOCATE ( ValItem , MOLD = MoldPtr ) ! loop through the other collection and get key-value pairs along the way IsTheEnd = Other % StartFirst ( KeyItem , ValItem , ItemCopy , ValCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( KeyItem , ValItem ) IsTheEnd = Other % MoveForward ( KeyItem , ValItem , ItemCopy , ValCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( KeyItem , ValItem ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'TreeTable_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"OrderedSymTable\" class.' ) END SELECT RETURN END SUBROUTINE TreeTable_CopyCollection !****************************************************************************** SUBROUTINE TreeTable_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the collection.  This is a deferred procedure !  by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if the collection is empty IF ( Collection % IsEmpty ()) RETURN ! clear elements CALL Collection % WrkTree % Clear () ! reset components Collection % Dir = 0 CALL Collection % NodePool % Reset () ! free mold CALL Collection % FreeMolds () RETURN END SUBROUTINE TreeTable_ClearItems !****************************************************************************** SUBROUTINE TreeTable_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the collection.  This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE TreeTable_Destroy !****************************************************************************** FUNCTION TreeTable_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of items in the collection.  This is a deferred procedure !  by the *BaseCollection* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( IN ) :: Collection tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % WrkTree % GetSize () RETURN END FUNCTION TreeTable_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- FUNCTION TreeTable_Move2FirstPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a symbol table.  For the *TreeTable*, which !  is an ordered symbol table, the starting pair is the pair with smallest key.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the smallest key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the associated value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection contains no pair data or not <br> ! - true if the collection is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTree % StartMin ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) ! get key if requested IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTree % StartMin () END IF ! set direction IF (. NOT . IsEmpty ) Collection % Dir = 1 RETURN END FUNCTION TreeTable_Move2FirstPair !****************************************************************************** FUNCTION TreeTable_Move2NextPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table.  For the *TreeTable*, which is an !  ordered symbol table, the next pair is the so-called successor pair.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! move to next iteration IsTheEnd = Collection % WrkTree % MoveForward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) ! get key if requested IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! move to next iteration IsTheEnd = Collection % WrkTree % MoveForward () END IF ! set direction IF (. NOT . IsTheEnd ) THEN Collection % Dir = 1 ELSE Collection % Dir = 0 END IF RETURN END FUNCTION TreeTable_Move2NextPair !****************************************************************************** FUNCTION TreeTable_Move2LastPair ( Collection , Key , Value , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the last (starting in a reversed order) pair data in a symbol table. For the !  *TreeTable*, which is an ordered symbol table,  the starting pair in a reversed order !  is the pair with greatest key.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the greatest key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the associated value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection contains no pair data or not <br> ! - true if the collection is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTree % StartMax ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) ! get key if requested IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2LastPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2LastPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTree % StartMax () END IF ! set direction IF (. NOT . IsEmpty ) Collection % Dir = - 1 RETURN END FUNCTION TreeTable_Move2LastPair !****************************************************************************** FUNCTION TreeTable_Move2PrevPair ( Collection , Key , Value , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the previous pair data in a symbol table.  For the *TreeTable*, which is an !  ordered symbol table,  the previous pair is the so-called predecessor pair.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the previous key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the previous value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsTheEnd = Collection % WrkTree % MoveBackward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) ! get key if requested IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2PrevPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF ! get value if requested IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_Move2PrevPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsTheEnd = Collection % WrkTree % MoveBackward () END IF ! set direction IF (. NOT . IsTheEnd ) THEN Collection % Dir = - 1 ELSE Collection % Dir = 0 END IF RETURN END FUNCTION TreeTable_Move2PrevPair !****************************************************************************** SUBROUTINE TreeTable_Insert ( Collection , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into a symbol table.  If the specified key is already stored !  in the table, replace the old value with the new one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the key to be added to the collection CLASS ( * ), INTENT ( IN ) :: Key !% the associated value to be added to the collection CLASS ( * ), INTENT ( IN ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: KeyFound TYPE ( TabNode ), POINTER :: KeyNode CLASS ( CompNode ), POINTER :: NewNode ! FLOW ! check the specified key and value IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = TrueVal )) THEN CALL Handle_ErrLevel ( 'TreeTable_Insert' , ModName , ErrSevere , & 'Type of the specified key is either invalid or NOT the same as that of stored keys.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN CALL Handle_ErrLevel ( 'TreeTable_Insert' , ModName , ErrSevere , & 'Only values of the same type are allowed in a collection.' ) RETURN END IF ! check whether the key is already stored in the collection or not IF ( Collection % IsEmpty ()) THEN KeyFound = FalseVal ELSE KeyFound = Collection % FindKey ( Key , KeyNode ) END IF IF ( KeyFound ) THEN ! replace the current value with the new one CALL KeyNode % Value % Set ( Value , Collection % ItemPool ) ELSE ! +++ new key-value pair +++ ! check for first-time insertion IF (. NOT . Collection % NodePool % IsReady ()) THEN CALL Collection % NodePool % Construct ( KeyNode ) CALL Collection % ItemPool % Construct () END IF ! get new node from the node's pool CALL Collection % NodePool % GetNewNode ( NewNode ) SELECT TYPE ( NewNode ) TYPE IS ( TabNode ) KeyNode => NewNode END SELECT ! set key and value to the node ! (no need to check the valid flag since we have already done that in the beginning) CALL KeyNode % SetKeyNVal ( Key , Value , Collection % ItemPool ) ! insert the new node to the working tree IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. CALL Collection % WrkTree % Insert ( KeyNode ) ELSE ! WrkTree is an AVL tree. CALL Collection % WrkTree % IntrusiveAVLTree % Insert ( KeyNode ) END IF END IF ! free working pointer NULLIFY ( KeyNode , NewNode ) RETURN END SUBROUTINE TreeTable_Insert !****************************************************************************** SUBROUTINE TreeTable_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a key-value pair from a symbol table.  This procedure is intended !  to be used in conjunction with the *StartFirst* and *MoveForward* procedures. !  Therefore, after the call to either procedure and then calling this procedure !  will result in a removal of the current key-value pair of the iteration (i.e. !  the same key-value pair that can be retrieved via those *Move* procedures). <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: CurrNode tLogical :: Success tLogical :: IsTheEnd ! FLOW ! get the cursor node CurrNode => Collection % WrkTree % GetCursor () ! check if the node is associated IF ( ASSOCIATED ( CurrNode )) THEN ! reset cursor IF ( Collection % Dir == 1 ) THEN ! forward iteration so move cursor backward IsTheEnd = Collection % WrkTree % MoveBackward () ELSE ! backward iteration so move cursor forward IsTheEnd = Collection % WrkTree % MoveForward () END IF IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. Success = Collection % WrkTree % Remove ( CurrNode ) ELSE ! WrkTree is an AVL tree. Success = Collection % WrkTree % IntrusiveAVLTree % Remove ( CurrNode ) END IF ! check if remove the node successfully or not IF ( Success ) THEN ! return the node to the node's pool SELECT TYPE ( DelNode => CurrNode ) TYPE IS ( TabNode ) CALL Collection % NodePool % ReturnNode ( DelNode ) END SELECT ELSE CALL Handle_ErrLevel ( 'TreeTable_Delete' , ModName , ErrWarning , & 'Check the Remove method of the intrusive tree for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( CurrNode ) RETURN END SUBROUTINE TreeTable_Delete !****************************************************************************** FUNCTION TreeTable_Remove ( Collection , Key ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete the specified key (and its associated value) from a symbol table.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the key to be removed from the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode tLogical :: Success ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF IF ( Flag ) THEN IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. Success = Collection % WrkTree % Remove ( KeyNode ) ELSE ! WrkTree is an AVL tree. Success = Collection % WrkTree % IntrusiveAVLTree % Remove ( KeyNode ) END IF ! check if remove the node successfully or not IF ( Success ) THEN ! return the node to the node's pool CALL Collection % NodePool % ReturnNode ( KeyNode ) ELSE CALL Handle_ErrLevel ( 'TreeTable_Remove' , ModName , ErrWarning , & 'Check the Remove method of the intrusive tree for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION TreeTable_Remove !****************************************************************************** FUNCTION TreeTable_Contain ( Collection , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSE Found = Collection % FindKey ( Key ) END IF RETURN END FUNCTION TreeTable_Contain !****************************************************************************** FUNCTION TreeTable_GetValue ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a value associated with the specified key in a symbol table. !  Also, return a flag indicating whether the key-value pair is successfully !  found or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the value associated with the specified key CLASS ( * ), INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF ! get value if key is found IF ( Flag ) THEN Flag = KeyNode % Value % Get ( Value , ValCopy ) END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION TreeTable_GetValue !************************************************************************************** FUNCTION TreeTable_ToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all key-value pairs from the collection.  Also, return a flag !  indicating whether the pairs are successfully retrieved and removed or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Keys , Values , KeyCopy , ValCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION TreeTable_ToArray !************************************************************************************** FUNCTION TreeTable_GetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys and/or all values (without removing them) from the collection.  Also, !  return a flag indicating whether the keys and/or values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: SameKeyType , SameValType ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF ( PRESENT ( Keys ). AND . PRESENT ( Values )) THEN SameKeyType = Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal ) SameValType = Collection % IsValValid ( Values ( 1 )) ! check whether types of the specified keys and values are valid or not IF ( SameKeyType . AND . SameValType ) THEN Success = Collection % GetAllKeys ( Keys ) IF ( Success ) Success = Collection % GetAllVals ( Values , ValCopy ) ELSEIF ( SameKeyType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'TreeTable_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) ELSEIF ( SameValType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'TreeTable_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'TreeTable_GetAll' , ModName , ErrSevere , & 'Types of both keys and values are NOT the same as those of stored pairs.' ) END IF ELSEIF ( PRESENT ( Keys )) THEN ! check whether type of the specified keys is valid or not IF ( Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal )) THEN Success = Collection % GetAllKeys ( Keys ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'TreeTable_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Values )) THEN ! check whether type of the specified values is valid or not IF ( Collection % IsValValid ( Values ( 1 ))) THEN Success = Collection % GetAllVals ( Values , ValCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'TreeTable_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION TreeTable_GetAll !************************************************************************************** FUNCTION TreeTable_GetAllKeys ( Collection , Keys ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( BSTNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Keys , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkTree % StartMin ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Key % Get ( Keys ( I )) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTree % MoveForward ( CurrNode ) END DO RETURN END FUNCTION TreeTable_GetAllKeys !************************************************************************************** FUNCTION TreeTable_GetAllVals ( Collection , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all values (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeTable object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( BSTNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Values , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the values along the way IsTheEnd = Collection % WrkTree % StartMin ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTree % MoveForward ( CurrNode ) END DO RETURN END FUNCTION TreeTable_GetAllVals ! --------------------------------------------------------------------- ! -----         Deferred Procedures from OrderedSymTable Type     ----- ! --------------------------------------------------------------------- FUNCTION TreeTable_GetMinKey ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the smallest key (and optionally a value associated with it) in a symbol table. !  Also, return a flag indicating whether the key is successfully retrieved or not.  If !  the table is empty, the flag is typically false.  Otherwise, the flag is always true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the smallest key to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Key !% the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: MinNode ! FLOW ! get node with smallest key MinNode => Collection % WrkTree % GetMinNode () IF ( ASSOCIATED ( MinNode )) THEN SELECT TYPE ( MinNode ) TYPE IS ( TabNode ) Flag = MinNode % Key % Get ( Key ) IF ( PRESENT ( Value ). AND . Flag ) Flag = MinNode % Value % Get ( Value , ValCopy ) END SELECT ELSE Flag = FalseVal END IF ! free working pointer NULLIFY ( MinNode ) RETURN END FUNCTION TreeTable_GetMinKey !****************************************************************************** FUNCTION TreeTable_GetMaxKey ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the largest key (and optionally a value associated with it) !  in a symbol table.  Also, return a flag indicating whether the key !  is successfully retrieved or not.  If the table is empty, the flag !  is typically false.  Otherwise, the flag is always true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the largest key to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Key !% the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: MaxNode ! FLOW ! get node with largest key MaxNode => Collection % WrkTree % GetMaxNode () IF ( ASSOCIATED ( MaxNode )) THEN SELECT TYPE ( MaxNode ) TYPE IS ( TabNode ) Flag = MaxNode % Key % Get ( Key ) IF ( PRESENT ( Value ). AND . Flag ) Flag = MaxNode % Value % Get ( Value , ValCopy ) END SELECT ELSE Flag = FalseVal END IF ! free working pointer NULLIFY ( MaxNode ) RETURN END FUNCTION TreeTable_GetMaxKey !****************************************************************************** FUNCTION TreeTable_Floor ( Collection , KeyIn , KeyOut , ValOut , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To the largest key (and optionally a value associated with the key) in !  a collection less than or equal to the given key.  Also, return a flag !  indicating whether the floor key is successfully retrieved or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the specified key CLASS ( * ), INTENT ( IN ) :: KeyIn !% the largest key in the table less than or equal to the given key CLASS ( * ), INTENT ( INOUT ) :: KeyOut !% the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: ValOut !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: KeyNode CLASS ( BSTNode ), POINTER :: FloorNode ! FLOW ! set key CALL KeyNode % Key % Set ( KeyIn , Collection % ItemPool ) ! get floor node FloorNode => Collection % WrkTree % Floor ( KeyNode ) IF ( ASSOCIATED ( FloorNode )) THEN SELECT TYPE ( FloorNode ) TYPE IS ( TabNode ) Flag = FloorNode % Key % Get ( KeyOut ) IF ( PRESENT ( ValOut ). AND . Flag ) Flag = FloorNode % Value % Get ( ValOut , ValCopy ) END SELECT ELSE Flag = FalseVal END IF ! free working pointer NULLIFY ( FloorNode ) RETURN END FUNCTION TreeTable_Floor !****************************************************************************** FUNCTION TreeTable_Ceiling ( Collection , KeyIn , KeyOut , ValOut , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To the smallest key (and optionally a value associated with the key) in !  a collection greater than or equal to the given key.  Also, return a flag !  indicating whether the floor key is successfully retrieved or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the specified key CLASS ( * ), INTENT ( IN ) :: KeyIn !% the smallest key in the table greater than or equal to the given key CLASS ( * ), INTENT ( INOUT ) :: KeyOut !% the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: ValOut !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: KeyNode CLASS ( BSTNode ), POINTER :: CeilingNode ! FLOW ! set key CALL KeyNode % Key % Set ( KeyIn , Collection % ItemPool ) ! get floor node CeilingNode => Collection % WrkTree % Ceiling ( KeyNode ) IF ( ASSOCIATED ( CeilingNode )) THEN SELECT TYPE ( CeilingNode ) TYPE IS ( TabNode ) Flag = CeilingNode % Key % Get ( KeyOut ) IF ( PRESENT ( ValOut ). AND . Flag ) Flag = CeilingNode % Value % Get ( ValOut , ValCopy ) END SELECT ELSE Flag = FalseVal END IF ! free working pointer NULLIFY ( CeilingNode ) RETURN END FUNCTION TreeTable_Ceiling !****************************************************************************** FUNCTION TreeTable_GetRank ( Collection , Key ) RESULT ( Rank ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of keys in the symbol table strictly less than the given key. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the specified key CLASS ( * ), INTENT ( IN ) :: Key !% the number of keys less than the given key. tIndex :: Rank !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: KeyNode ! FLOW ! set key CALL KeyNode % Key % Set ( Key , Collection % ItemPool ) ! get rank Rank = Collection % WrkTree % Rank ( KeyNode ) RETURN END FUNCTION TreeTable_GetRank !****************************************************************************** FUNCTION TreeTable_Select ( Collection , Rank , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the key (and optionally its associated value) of the given rank. !  Also, return a flag indicating whether the ranked key is successfully !  retrieved or not. <br> !  This ranked key has the property such that there are keys in the symbol !  table that are smaller.  In other words, this key is the (rank+1)st smallest !  key in the table. <br> !  The applicable range of rank is between 0 and TableSize-1 where the rank number !  is zero-based.  If the specified rank is out of range or the table is empty, !  the returned flag is false.  Otherwise, the returned flag is true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the specified rank. tIndex , INTENT ( IN ) :: Rank !% the key of the specified rank CLASS ( * ), INTENT ( INOUT ) :: Key !% the value associated with the ranked key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: RankNode ! FLOW ! get rank node RankNode => Collection % WrkTree % Select ( Rank ) ! get key and optionally its associated value IF ( ASSOCIATED ( RankNode )) THEN SELECT TYPE ( RankNode ) TYPE IS ( TabNode ) Flag = RankNode % Key % Get ( Key ) IF ( PRESENT ( Value ). AND . Flag ) Flag = RankNode % Value % Get ( Value , ValCopy ) END SELECT ELSE Flag = FalseVal END IF ! free working pointer NULLIFY ( RankNode ) RETURN END FUNCTION TreeTable_Select !****************************************************************************** FUNCTION TreeTable_RemoveMin ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the smallest key and a value associated with the key from !  a symbol table.  Also, return a flag indicating whether the key is !  successfully removed or not.  If the table is empty, the flag is !  typically false.  Otherwise, the flag is always true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the value associated with the smallest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key is successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (( PRESENT ( Key )). OR .( PRESENT ( Value ))) THEN BLOCK ! local variable CLASS ( BSTNode ), POINTER :: MinNode ! remove node with smallest key IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree Flag = Collection % WrkTree % RemoveMin ( MinNode ) ELSE ! WrkTree is an AVL tree Flag = Collection % WrkTree % IntrusiveAVLTree % RemoveMin ( MinNode ) END IF ! optionally get key and its associated value IF ( ASSOCIATED ( MinNode )) THEN SELECT TYPE ( MinNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . MinNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_RemoveMin' , ModName , ErrSevere , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . MinNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_RemoveMin' , ModName , ErrSevere , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF ! free working pointer NULLIFY ( MinNode ) END BLOCK ELSE ! remove node with smallest key IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree Flag = Collection % WrkTree % RemoveMin () ELSE ! WrkTree is an AVL tree Flag = Collection % WrkTree % IntrusiveAVLTree % RemoveMin () END IF END IF RETURN END FUNCTION TreeTable_RemoveMin !****************************************************************************** FUNCTION TreeTable_RemoveMax ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the largest key and a value associated with the key from !  a symbol table.  Also, return a flag indicating whether the key is !  successfully removed or not.  If the table is empty, the flag is !  typically false.  Otherwise, the flag is always true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the value associated with the largest key CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key is successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (( PRESENT ( Key )). OR .( PRESENT ( Value ))) THEN BLOCK ! local variable CLASS ( BSTNode ), POINTER :: MaxNode ! remove node with largest key IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree Flag = Collection % WrkTree % RemoveMax ( MaxNode ) ELSE ! WrkTree is an AVL tree Flag = Collection % WrkTree % IntrusiveAVLTree % RemoveMax ( MaxNode ) END IF ! optionally get key and its associated value IF ( ASSOCIATED ( MaxNode )) THEN SELECT TYPE ( MaxNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . MaxNode % Key % Get ( Key )) THEN CALL Handle_ErrLevel ( 'TreeTable_RemoveMax' , ModName , ErrSevere , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . MaxNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'TreeTable_RemoveMax' , ModName , ErrSevere , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF ! free working pointer NULLIFY ( MaxNode ) END BLOCK ELSE ! remove node with largest key IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree Flag = Collection % WrkTree % RemoveMax () ELSE ! WrkTree is an AVL tree Flag = Collection % WrkTree % IntrusiveAVLTree % RemoveMax () END IF END IF RETURN END FUNCTION TreeTable_RemoveMax !****************************************************************************** FUNCTION TreeTable_RangeSize ( Collection , KeyLo , KeyHi ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of keys in the given range (between KeyLo and KeyHi). !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the minimum key (inclusive) CLASS ( * ), INTENT ( IN ) :: KeyLo !% the maximum key (inclusive) CLASS ( * ), INTENT ( IN ) :: KeyHi !% the number of keys in the given range. tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: NodeLo TYPE ( TabNode ) :: NodeHi ! FLOW ! set keys CALL NodeLo % Key % Set ( KeyLo , Collection % ItemPool ) CALL NodeHi % Key % Set ( KeyHi , Collection % ItemPool ) ! get range size Size = Collection % WrkTree % GetRangeSize ( NodeLo , NodeHi ) RETURN END FUNCTION TreeTable_RangeSize ! --------------------------------------------------------------------- ! -----         Specific Procedures for TreeTable Type            ----- ! --------------------------------------------------------------------- SUBROUTINE TreeTable_CreateByArray ( Collection , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of key-value pairs !% the keys to be added to the table CLASS ( * ), INTENT ( IN ) :: Keys ( N ) !% the associated values to be added to the table CLASS ( * ), INTENT ( IN ) :: Values ( N ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! add key-value pairs to the table DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE TreeTable_CreateByArray !****************************************************************************** SUBROUTINE TreeTable_UseAVLTree ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the *IsRBTree* component to false. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Collection % IsRBTree = FalseVal RETURN END SUBROUTINE TreeTable_UseAVLTree !****************************************************************************** SUBROUTINE TreeTable_UseRBTree ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the *IsRBTree* component to true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Collection % IsRBTree = TrueVal RETURN END SUBROUTINE TreeTable_UseRBTree !****************************************************************************** FUNCTION TreeTable_CheckIntegrity ( Collection , Message ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check integrity of the binary-search-tree (BST) data structure. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !> message indicating the reason why the tree did not pass the !  integrity test tCharAlloc , OPTIONAL , INTENT ( OUT ) :: Message !> flag for integrity <br> ! - true if the tree passed the integrity test. ! - false if the tree did not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree Flag = Collection % WrkTree % Check ( Message ) ELSE ! WrkTree is an AVL tree Flag = Collection % WrkTree % IntrusiveAVLTree % Check ( Message ) END IF RETURN END FUNCTION TreeTable_CheckIntegrity ! --------------------------------------------------------------------- ! -----                 Auxiliary Procedures                      ----- ! --------------------------------------------------------------------- FUNCTION TreeTable_FindKey ( Collection , Key , KeyNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the specified key in a symbol table.  Optionally, return !  a stored node containing a key equal to the specified key. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeTable ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the node containing the specified key; null pointer if the key is not found TYPE ( TabNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: KeyNode !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: InNode CLASS ( BSTNode ), POINTER :: StoredNode ! FLOW ! initialize Found = Falseval IF ( PRESENT ( KeyNode )) KeyNode => NULL () ! check the specified key and return quickly if not valid IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = TrueVal )) RETURN ! set key for search node CALL InNode % Key % Set ( Key , Collection % ItemPool ) ! find the stored node equal to input node Found = Collection % WrkTree % Contain ( InNode , StoredNode ) IF ( PRESENT ( KeyNode ). AND . Found ) THEN SELECT TYPE ( StoredNode ) TYPE IS ( TabNode ) KeyNode => StoredNode END SELECT END IF ! free working pointer NULLIFY ( StoredNode ) RETURN END FUNCTION TreeTable_FindKey ! --------------------------------------------------------------------- ! -----             Final Procedures                              ----- ! --------------------------------------------------------------------- SUBROUTINE TreeTable_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TreeTable ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE TreeTable_Finalize !****************************************************************************** END MODULE MClass_TreeTable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treetable.f90.html"},{"title":"MClass_ListCmpxDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListCmpxDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListCmpxDP* type and related routines. !   The *ListCmpxDP* type is a container with *COMPLEX(KIND=kDouble)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListCmpxDP* type but utilizes a different implementation. !   Also, unlike the *ListCmpxDP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListCmpxDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListCmpxDP #define DLLNode             DLLNodeCmpxDP #define ItemTypeA           COMPLEX(KIND=kDouble) #define ItemTypeB           COMPLEX(KIND=kDouble) #define ItemTypeC           COMPLEX(KIND=kDouble) #define TypeOfItem          COMPLEX(KIND=kDouble) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListCmpxDP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListCmpxDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listcmpxdp.f90.html"},{"title":"MClass_TreeComparable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeComparable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeComparable* type and its related helper type and routines. !   The *TreeComparable* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeComparable* !   type uses the *Comparable* derived type to store both the keys and their associated values. !   Unlike other tree-based containers, the *TreeComparable* type uses a user-defined type in !   the *Comparable* class to represent a key-value pair and requires only one argument (instead !   of two) when inserting or retrieving the key and its associated value.  <br> !   It is important to note that a user must be careful when implementing a *user-defined concrete* !   subtype of the *Comparable* type.  The *TreeComparable* type employs the assignment statement !   copy data of the key-value object and it utilizes the relational operators (e.g. ==, > and <) !   to compare keys of the key-value objects.  This implies that the user should implement the !   deferred *CopyAssign* procedure where both key and value components are copied from the source !   object to the destination object whereas, when implemented, the deferred *CompareTo* procedure !   should be dependent on its key component only.  It is also worth mentioning that only one !   user-defined type in the *Comparable* class should be used for one container instance.  If !   more than one types are inserted into the container, they should all be able to compare to !   other types.  In this case, additionally, the user must implement the *CopyAssign* procedure !   in a way that allows one type to make a copy of another type.  This indicates that all these !   inserted types must be subtypes of one parent type.  Otherwise, the *TreeComparable* type would !   not operate properly and the user will not be able to correctly retrieve a key-value pair from !   the container. <br> !   As a symbol table, the *TreeComparable* type does not allow duplicated keys.  Therefore, !   if an inserted key-value pair is equal to a key-value pair stored in the table, the stored !   pair is replaced by the inserted one.  Technically, the *TreeComparable* type employs a !   left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeComparable* type but utilizes !   a different implementation.  Also, unlike the *TreeComparable* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Comparable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeComparable PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define tComparable         CLASS(Comparable) #define QueueKeyVal         ListObject !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeComparable' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! traverse flags tSInt32 , PARAMETER :: Inorder = 1 tSInt32 , PARAMETER :: Preorder = 2 tSInt32 , PARAMETER :: Postorder = 3 ! color flags tLogical , PARAMETER :: Red = TrueVal tLogical , PARAMETER :: Black = FalseVal !** DERIVED TYPE DEFINITIONS !> *RBNode* is a red-black tree node type that consists of a key, a value and two !   pointers of the node type.  The  *RBNode* type is a private type. TYPE RBNode PRIVATE ! 'KeyVal' represents a key-value pair stored in the symbol table.  It is ! a derived type in the *Comparable* class that can be compared and sorted. tComparable , ALLOCATABLE :: KeyVal ! pointer to the left node (or subtree) TYPE ( RBNode ), POINTER :: Left => NULL () ! pointer to the right node (or subtree) TYPE ( RBNode ), POINTER :: Right => NULL () ! number of nodes in subtree rooted by this node tIndex :: Size = 0_kIndex ! color of parent node tLogical :: Color = Black CONTAINS PRIVATE PROCEDURE :: SetNew => BSTNode_SetNewKeyNValue PROCEDURE :: Destruct => BSTNode_Destructor END TYPE RBNode !> *TreeComparable* is a container type that employs a left-leaning red-black (RB) tree !   implementation to provide common operations for an ordered symbol table. TYPE TreeComparable PRIVATE ! pointer to the root node (topmost item) of the tree TYPE ( RBNode ), POINTER :: Root => NULL () ! pointer to the current item (or node) used for iteration purpose TYPE ( RBNode ), POINTER :: Cursor => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: BSTree_Destructor_I PROCEDURE , PRIVATE :: BSTree_Destructor_II PROCEDURE , PRIVATE :: BSTree_Traverse_I PROCEDURE , PRIVATE :: BSTree_Traverse_II PROCEDURE , PRIVATE :: BSTree_GetKeys_Range PROCEDURE , PRIVATE :: BSTree_GetKeys_All PROCEDURE , PRIVATE :: IsRankConsistent => BSTree_IsRankConsistent PROCEDURE , PRIVATE :: IsSizeConsistent => BSTree_IsSizeConsistent PROCEDURE , PRIVATE :: IsBSTree => BSTree_IsBinarySearchTree PROCEDURE , PRIVATE :: Is23Tree => BSTree_Is23Tree PROCEDURE , PRIVATE :: IsBalanced => BSTree_IsBalanced GENERIC , PRIVATE :: Traverse => BSTree_Traverse_I , BSTree_Traverse_II ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> ! **Purpose**:  To construct a tree from an array of key-value pairs.  <br> !  **Usage**: <br> !   --->    CALL Tree%Construct(10, KeyValArr) PROCEDURE :: Construct => BSTree_ConstructByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all key-value pairs from the tree and optionally to !                retrieve stored key-value pairs. <br> !  **Usage**: <br> !   --->    CALL Tree%Destruct() <br> !   --->    CALL Tree%Destruct(KeyValQueue, ValQueue) <br> GENERIC :: Destruct => BSTree_Destructor_I , BSTree_Destructor_II ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the tree. <br> !  **Usage**: <br> !   --->    CALL Tree%Insert(KeyVal) <br> PROCEDURE :: Insert => BSTree_Insert !> **Type-Bound Subroutine**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Remove(KeyVal) <br> !   --->    IF (.NOT.Tree%Remove(KeyVal)) DoSomething <br> PROCEDURE :: Remove => BSTree_Remove !> **Type-Bound Subroutine**: RemoveMin <br> !  **Purpose**:  To remove the smallest key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not.  Optionally, the smallest key and its associated value can be retrieved. <br> !  **Usage**: <br> !   --->    Flag = Tree%RemoveMin() <br> !   --->    IF (.NOT.Tree%RemoveMin(KeyVal)) DoSomething <br> PROCEDURE :: RemoveMin => BSTree_RemoveMin !> **Type-Bound Subroutine**: RemoveMax <br> !  **Purpose**:  To remove the largest key (and its associated value) from the tree !       and return a flag indicating whether the key-value pair is successfully removed !       or not.  Optionally, the largest key and its associated value can be retrieved. <br> !  **Usage**: <br> !   --->    Flag = Tree%RemoveMax() <br> !   --->    IF (.NOT.Tree%RemoveMax(KeyVal)) DoSomething <br> PROCEDURE :: RemoveMax => BSTree_RemoveMax ! ------------------------------------------------------- ! -----           tree-traversing procedures        ----- ! ------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration (at a node with the smallest key) and return a flag !                indicating whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Tree%StartFirst() <br> !   --->    IsEmpty = Tree%StartFirst(FirstKeyVal) <br> PROCEDURE :: StartFirst => BSTree_Move2First !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag indicating whether !                the cursor pointer has reached the end of the tree or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Tree%MoveForward() <br> !   --->    IsTheEnd = Tree%MoveForward(NextKeyVal) <br> PROCEDURE :: MoveForward => BSTree_Move2NextPair !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order (at a node with the largest key) !                and return a flag indicating whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Tree%StartLast() <br> !   --->    IsEmpty = Tree%StartLast(LastKeyVal) <br> PROCEDURE :: StartLast => BSTree_Move2Last !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous key-value pair and return a flag indicating whether !                the cursor pointer has reached the end of the tree or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Tree%MoveBackward() <br> !   --->    IsTheEnd = Tree%MoveBackward(PrevKeyVal) <br> PROCEDURE :: MoveBackward => BSTree_Move2PrevPair ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the tree is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%IsEmpty() <br> !   --->    IF (.NOT.Tree%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => BSTree_IsEmpty !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the tree.  Return true if the specified key !                is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Tree%Contain(KeyVal) <br> !   --->    IF (.NOT.Tree%Contain(KeyVal)) DoSomething PROCEDURE :: Contain => BSTree_FindKey !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get size of the tree (the number of key-value pair stored in the tree). <br> !  **Usage**: <br> !   --->    TreeSize = Tree%GetSize() PROCEDURE :: GetSize => BSTree_GetSize !> **Type-Bound Function**: GetRangeSize <br> !  **Purpose**:  To return the number of keys between *KeyLo* (inclusive) !                and *KeyHi* (inclusive). <br> !  **Usage**: <br> !   --->    RangeSize = Tree%GetRangeSize(KeyValLo, KeyValHi) PROCEDURE :: GetRangeSize => BSTree_GetSize_Range !> **Type-Bound Function**: GetMinKey <br> !  **Purpose**:  To get the smallest key (and a value associated with it) in the tree. !                Also, return a flag indicating whether the key is successfully retrieved !                or not.  If the tree is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Tree%GetMinKey(KeyVal) <br> !   --->    IF (.NOT.Tree%GetMinKey(KeyVal)) DoSomething PROCEDURE :: GetMinKey => BSTree_GetSmallestKey !> **Type-Bound Function**: GetMaxKey <br> !  **Purpose**:  To get the largest key (and a value associated with it) in the tree. !                Also, return a flag indicating whether the key is successfully retrieved !                or not.  If the tree is not empty, the returned flag is always true. <br> !  **Usage**: <br> !   --->    Flag = Tree%GetMaxKey(KeyVal) <br> !   --->    IF (.NOT.Tree%GetMaxKey(KeyVal)) DoSomething PROCEDURE :: GetMaxKey => BSTree_GetLargestKey !> **Type-Bound Subroutine**: GetKeys <br> !  **Purpose**:  To return all keys (in the tree or in the specified range) and !                their associated values. <br> !  **Usage**: <br> !   ! return all keys in the tree <br> !   --->    CALL Tree%GetKeys(KeyVals) <br> !   ! return all keys in the specified range <br> !   --->    CALL Tree%GetKeys(LoKeyVal, HiKeyVal, KeyVals) <br> GENERIC :: GetKeys => BSTree_GetKeys_Range , BSTree_GetKeys_All !> **Type-Bound Function**: Floor <br> !  **Purpose**:  To get the largest key (and a value associated with it) in the tree !                less than or equal to the given key.  Also, return a flag indicating !                whether the floor key is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Floor(KeyValIn, KeyValOut) <br> !   --->    IF (.NOT.Tree%Floor(KeyValIn, KeyValOut)) DoSomething PROCEDURE :: Floor => BSTree_Floor !> **Type-Bound Function**: Ceiling <br> !  **Purpose**:  To get the smallest key (and a value associated with it) in the tree !                greater than or equal to the given key.  Also, return a flag indicating !                whether the ceiling key is successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Flag = Tree%Ceiling(KeyValIn, KeyValOut) <br> !   --->    IF (.NOT.Tree%Ceiling(KeyValIn, KeyValOut)) DoSomething PROCEDURE :: Ceiling => BSTree_Ceiling !> **Type-Bound Subroutine**: Select <br> !  **Purpose**:  To get the key (and its associated value) of the specified rank where the !                applicable range of rank is between 0 and TableSize-1. Also, return a flag !                indicating whether the ranked key is successfully retrieved or not. <br> !   --->    Flag = Tree%Select(Rank, KeyVal) <br> !   --->    IF (.NOT.Tree%Select(Rank, KeyVal)) DoSomething PROCEDURE :: Select => BSTree_Select !> **Type-Bound Function**: GetRank <br> !  **Purpose**:  To return the number of keys in the tree strictly less than the given key. <br> !  **Usage**: <br> !   --->    KeyRank = Tree%GetRank(KeyVal) PROCEDURE :: GetRank => BSTree_Rank !> **Type-Bound Function**: Check <br> !  **Purpose**:  To check integrity of the BST data structure. <br> !  **Usage**: <br> !   --->    Flag = Tree%Check() <br> !   --->    IF (.NOT.Tree%Check(ErrMsg)) DoSomething PROCEDURE :: Check => BSTree_CheckBST ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the tree. FINAL :: BSTree_Finalizer ! --------------------------------------------------------------------- END TYPE TreeComparable !** INTERFACE DEFINITIONS: ! abstract interfaces ABSTRACT INTERFACE !> IteratureFunc is a user-suppled procedure used to traverse the tree !  in order to get the tree's keys and values. FUNCTION IteratorFunc ( KeyVal , Done ) RESULT ( ErrStat ) IMPORT tComparable , INTENT ( IN ) :: KeyVal !! key-value pair tLogical , INTENT ( INOUT ) :: Done !&#94; on input, Done is set to .FALSE. <br> !  on exit, set it to .TRUE. if user want to stop the tree traversing. <br> tLogical :: ErrStat ! true if error occurred in the user routine END FUNCTION IteratorFunc !> IteratorLocal is a procedure used (locally in this module) to traverse !  the list in order to get the list's node. FUNCTION IteratorLocal ( Node , Done ) RESULT ( ErrStat ) IMPORT TYPE ( RBNode ), INTENT ( IN ) :: Node !! node tLogical , INTENT ( INOUT ) :: Done !&#94; on input, Done is set to .FALSE. <br> !  on exit, set it to .TRUE. if user want to stop the tree traversing. <br> tLogical :: ErrStat !! true if error occurred in the user routine END FUNCTION IteratorLocal END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   Type-Bound Procedures for RBNode !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE BSTNode_SetNewKeyNValue ( Node , KeyVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set new key-value pair. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RBNode ), INTENT ( INOUT ) :: Node !! RBNode object tComparable , INTENT ( IN ) :: KeyVal !! key-value pair !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ALLOCATE ( Node % KeyVal , SOURCE = KeyVal ) Node % Size = 1_kIndex Node % Color = Red RETURN END SUBROUTINE BSTNode_SetNewKeyNValue !****************************************************************************** SUBROUTINE BSTNode_Destructor ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct RBNode object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( RBNode ), INTENT ( INOUT ) :: Node !! RBNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % Size = 0 Node % Color = Black CALL Node % KeyVal % MemFree () DEALLOCATE ( Node % KeyVal ) NULLIFY ( Node % Left ) NULLIFY ( Node % Right ) RETURN END SUBROUTINE BSTNode_Destructor !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                           Auxiliary Procedures !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ RECURSIVE FUNCTION AddKeyNValue ( InNode , KeyVal ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add the given key-value pair into the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root node of (sub)tree) tComparable , INTENT ( IN ) :: KeyVal !! key-value pair TYPE ( RBNode ), POINTER :: OutNode !! output node (new root node of (sub)tree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the input node is null or not IF (. NOT . ASSOCIATED ( InNode )) THEN ! create new node CALL CreateNewNode ( KeyVal , OutNode ) RETURN END IF ! compare the specified key with the node's key IF ( KeyVal < InNode % KeyVal ) THEN ! add the specified key-value pair to the left subtree InNode % Left => AddKeyNValue ( InNode % Left , KeyVal ) ELSEIF ( KeyVal > InNode % KeyVal ) THEN ! add the specified key-value pair to the right subtree InNode % Right => AddKeyNValue ( InNode % Right , KeyVal ) ELSE ! replace key-value pair InNode % KeyVal = KeyVal END IF ! fix-up any right-leaning links IF ( IsRed ( InNode % Right ). AND .. NOT . IsRed ( InNode % Left )) InNode => LeftRotate ( InNode ) IF ( IsRed ( InNode % Left )) THEN IF ( IsRed ( InNode % Left % Left )) THEN InNode => RightRotate ( InNode ) END IF END IF IF ( IsRed ( InNode % Left ). AND . IsRed ( InNode % Right )) CALL FlipColor ( InNode ) ! update number of nodes in subtree rooted by the output node InNode % Size = NodeSize ( InNode % Left ) + NodeSize ( InNode % Right ) + 1 ! set output node OutNode => InNode RETURN END FUNCTION AddKeyNValue !****************************************************************************** SUBROUTINE CreateNewNode ( KeyVal , Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a new node and then set its key-value pair. !** SUBROUTINE ARGUMENT DECLARATIONS: tComparable , INTENT ( IN ) :: KeyVal !! key-value pair to be set to the node TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: Node !! new node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW ! allocate new node ALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) ! check allocation status and report error if necessary CALL Handle_ErrAlloc ( 'CreateNewNode' , ModName , AllocMsg , AllocStat ) ! set the key-value pair CALL Node % SetNew ( KeyVal ) RETURN END SUBROUTINE CreateNewNode !****************************************************************************** RECURSIVE SUBROUTINE Find_Inorder_Predecessor ( Root , KeyVal , PrvNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To search for the previous node in an inorder traversal of the tree !  of the specified node given by its key. <br> !  Note: The first call of this routine should provide the root of the !        tree as an input node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Root !! input node tComparable , INTENT ( IN ) :: KeyVal !! key of the node TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: PrvNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: Temp => NULL () ! FLOW ! base case IF (. NOT . ASSOCIATED ( Root )) RETURN ! If key is equal to the key of the root IF ( KeyVal == Root % KeyVal ) THEN ! the maximum value in the left subtree is predecessor node IF ( ASSOCIATED ( Root % Left )) THEN ! iteratively search the rightmost node of the left subtree Temp => Root % Left DO WHILE ( ASSOCIATED ( Temp % Right )) Temp => Temp % Right END DO PrvNode => Temp NULLIFY ( Temp ) END IF RETURN END IF IF ( KeyVal < Root % KeyVal ) THEN ! If key is smaller than the key of the root, go to left subtree CALL Find_Inorder_Predecessor ( Root % Left , KeyVal , PrvNode ) ELSE ! Otherwise, go to right subtree PrvNode => Root CALL Find_Inorder_Predecessor ( Root % Right , KeyVal , PrvNode ) END IF RETURN END SUBROUTINE Find_Inorder_Predecessor !****************************************************************************** RECURSIVE SUBROUTINE Find_Inorder_Successor ( Root , KeyVal , NxtNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To search for the next node in an inorder traversal of the tree !  of the specified node given by its key. !  Note: The first call of this routine should provide the root of !        the tree as an input node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Root !! input node tComparable , INTENT ( IN ) :: KeyVal !! key of the node TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: NxtNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: Temp => NULL () ! FLOW ! base case IF (. NOT . ASSOCIATED ( Root )) RETURN ! If key is equal to the key of the root IF ( KeyVal == Root % KeyVal ) THEN ! the minimum value in the right subtree is the successor node IF ( ASSOCIATED ( Root % Right )) THEN ! iteratively search the leftmost node of the right subtree Temp => Root % Right DO WHILE ( ASSOCIATED ( Temp % Left )) Temp => Temp % Left END DO NxtNode => Temp NULLIFY ( Temp ) END IF RETURN END IF IF ( KeyVal < Root % KeyVal ) THEN ! If key is smaller than the key of the root, go to left subtree NxtNode => Root CALL Find_Inorder_Successor ( Root % Left , KeyVal , NxtNode ) ELSE ! Otherwise, go to right subtree CALL Find_Inorder_Successor ( Root % Right , KeyVal , NxtNode ) END IF RETURN END SUBROUTINE Find_Inorder_Successor !****************************************************************************** SUBROUTINE Find_Inorder_PrevNode ( Node , Root , PrvNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To search for the previous node in an inorder traversal of the tree !  of the specified input node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! input node TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Root !! root node TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: PrvNode !! previous node of input node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: CurRoot => NULL () ! FLOW ! If left subtree of node is not NULL, then PrvNode lies in left subtree. ! Thus, go to left subtree and return the node with maximum key value ! in the left subtree. IF ( ASSOCIATED ( Node % Left )) THEN CALL Find_MaxKeyNode ( Node % Left , PrvNode ) RETURN END IF ! start from root and iteratively search for the previous node down the tree PrvNode => NULL () CurRoot => Root DO WHILE ( ASSOCIATED ( CurRoot )) IF ( Node % KeyVal < CurRoot % KeyVal ) THEN ! the previous node should be on the left subtree CurRoot => CurRoot % Left ELSEIF ( Node % KeyVal > CurRoot % KeyVal ) THEN ! the previous node should be on the right subtree PrvNode => CurRoot CurRoot => CurRoot % Right ELSE ! the previous node found EXIT END IF END DO RETURN END SUBROUTINE Find_Inorder_PrevNode !****************************************************************************** SUBROUTINE Find_Inorder_NextNode ( Node , Root , NxtNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To search for the next node in an inorder traversal of the tree !  of the specified input node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! input node TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Root !! root node TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: NxtNode !! next node of input node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: CurRoot => NULL () ! FLOW ! If right subtree of node is not NULL, then NxtNode lies in right subtree. ! Thus, go to right subtree and return the node with minimum key value ! in the right subtree. IF ( ASSOCIATED ( Node % Right )) THEN CALL Find_MinKeyNode ( Node % Right , NxtNode ) RETURN END IF ! start from root and search for the next node down the tree NxtNode => NULL () CurRoot => Root DO WHILE ( ASSOCIATED ( CurRoot )) IF ( Node % KeyVal < CurRoot % KeyVal ) THEN ! the next node should be on the left subtree NxtNode => CurRoot CurRoot => CurRoot % Left ELSEIF ( Node % KeyVal > CurRoot % KeyVal ) THEN ! the next node should be on the right subtree CurRoot => CurRoot % Right ELSE ! the next node found EXIT END IF END DO RETURN END SUBROUTINE Find_Inorder_NextNode !****************************************************************************** SUBROUTINE Find_MinKeyNode ( Node , MinNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the leftmost leaf of the given node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! input node TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: MinNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set pointer for working/output node MinNode => Node ! loop down to find the leftmost leaf DO WHILE ( ASSOCIATED ( MinNode % Left )) MinNode => MinNode % Left END DO RETURN END SUBROUTINE Find_MinKeyNode !****************************************************************************** SUBROUTINE Find_MaxKeyNode ( Node , MaxNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the rightmost leaf of the given node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! input node TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: MaxNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set pointer for working/output node MaxNode => Node ! loop down to find the rightmost leaf DO WHILE ( ASSOCIATED ( MaxNode % Right )) MaxNode => MaxNode % Right END DO RETURN END SUBROUTINE Find_MaxKeyNode !****************************************************************************** RECURSIVE SUBROUTINE FindNode ( InNode , KeyVal , OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To search for the node having the same key as the specified one. !  Return null if the node does not exist. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: InNode !! input node tComparable , INTENT ( IN ) :: KeyVal !! key to be looked for TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( InNode )) THEN ! the node we are looking for does not exist OutNode => NULL () ELSEIF ( KeyVal == InNode % KeyVal ) THEN ! the node found OutNode => InNode ELSEIF ( KeyVal < InNode % KeyVal ) THEN ! the node should be on the left subtree CALL FindNode ( InNode % Left , KeyVal , OutNode ) ELSE ! the node should be on the right subtree CALL FindNode ( InNode % Right , KeyVal , OutNode ) END IF RETURN END SUBROUTINE FindNode !****************************************************************************** RECURSIVE SUBROUTINE Find_FloorNode ( InNode , KeyVal , OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the node containing largest key in the tree !  less than or equal to the specified key. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: InNode !! input node tComparable , INTENT ( IN ) :: KeyVal !! key TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( InNode )) THEN ! the node we are looking for does not exist OutNode => NULL () ELSEIF ( KeyVal == InNode % KeyVal ) THEN ! the node found OutNode => InNode ELSEIF ( KeyVal < InNode % KeyVal ) THEN ! the node should be on the left subtree CALL Find_FloorNode ( InNode % Left , KeyVal , OutNode ) ELSE ! the node should be on the right subtree CALL Find_FloorNode ( InNode % Right , KeyVal , OutNode ) ! if output node is null, return the input node instead IF (. NOT . ASSOCIATED ( OutNode )) OutNode => InNode END IF RETURN END SUBROUTINE Find_FloorNode !****************************************************************************** RECURSIVE SUBROUTINE Find_CeilingNode ( InNode , KeyVal , OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the node containing smallest key in the tree !  greater than or equal to the specified key. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: InNode !! input node tComparable , INTENT ( IN ) :: KeyVal !! key TYPE ( RBNode ), POINTER , INTENT ( OUT ) :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( InNode )) THEN ! the node we are looking for does not exist OutNode => NULL () ELSEIF ( KeyVal == InNode % KeyVal ) THEN ! the node found OutNode => InNode ELSEIF ( KeyVal < InNode % KeyVal ) THEN ! the node should be on the left subtree CALL Find_CeilingNode ( InNode % Left , KeyVal , OutNode ) ! if output node is null, return the input node instead IF (. NOT . ASSOCIATED ( OutNode )) OutNode => InNode ELSE ! the node should be on the right subtree CALL Find_CeilingNode ( InNode % Right , KeyVal , OutNode ) END IF RETURN END SUBROUTINE Find_CeilingNode !****************************************************************************** RECURSIVE FUNCTION SelectKey ( InNode , Rank , KeyVal ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return key in the subtree rooted at InNode of given rank. <br> !  Precondition: rank is in legal range. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: InNode !! input node tIndex , INTENT ( IN ) :: Rank !! rank of the key tComparable , INTENT ( OUT ) :: KeyVal !! key of the given rank tLogical :: Found !! true if the key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: LeftSize ! FLOW IF (. NOT . ASSOCIATED ( InNode )) THEN ! the node we are looking for does not exist Found = FalseVal RETURN END IF ! determine number of keys in the left subtree LeftSize = NodeSize ( InNode % Left ) ! find the node with a given rank IF ( LeftSize > Rank ) THEN ! the node should be on the left subtree Found = SelectKey ( InNode % Left , Rank , KeyVal ) ELSEIF ( LeftSize < Rank ) THEN ! the node should be on the right subtree Found = SelectKey ( InNode % Right , Rank - LeftSize - 1 , KeyVal ) ELSE ! the node is found Found = TrueVal KeyVal = InNode % KeyVal END IF RETURN END FUNCTION SelectKey !****************************************************************************** RECURSIVE FUNCTION KeyRank ( InNode , KeyVal ) RESULT ( Rank ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the rank of the given key (i.e. the number !  of keys in the tree that are less than the given key). !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: InNode !! input node tComparable , INTENT ( IN ) :: KeyVal !! key-value pair tIndex :: Rank !! rank of the key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( InNode )) THEN Rank = 0 RETURN END IF IF ( KeyVal < InNode % KeyVal ) THEN Rank = KeyRank ( InNode % Left , KeyVal ) ELSEIF ( KeyVal > InNode % KeyVal ) THEN Rank = KeyRank ( InNode % Right , KeyVal ) + NodeSize ( InNode % Left ) + 1 ELSE Rank = NodeSize ( InNode % Left ) END IF RETURN END FUNCTION KeyRank !****************************************************************************** RECURSIVE FUNCTION DeleteNode ( InNode , KeyVal ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified key and its associated value from the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root node of (sub)tree) tComparable , INTENT ( IN ) :: KeyVal !! key-value pair TYPE ( RBNode ), POINTER :: OutNode !! output node (new root node of (sub)tree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: MinNode => NULL () ! FLOW ! return if the (sub)tree is empty IF (. NOT . ASSOCIATED ( InNode )) THEN OutNode => NULL () RETURN END IF ! find the node to be deleted IF ( KeyVal < InNode % KeyVal ) THEN ! check whether to move red node to the left IF (. NOT . IsRed ( InNode % Left )) THEN IF ( ASSOCIATED ( InNode % Left )) THEN IF (. NOT . IsRed ( InNode % Left % Left )) InNode => MoveRedLeft ( InNode ) END IF END IF ! find the node on the left subtree InNode % Left => DeleteNode ( InNode % Left , KeyVal ) ELSE ! check whether to perform right rotation IF ( IsRed ( InNode % Left )) InNode => RightRotate ( InNode ) ! check whether the key is found with the null right child of the key node IF (( KeyVal == InNode % KeyVal ). AND .(. NOT . ASSOCIATED ( InNode % Right ))) THEN ! delete node from the tree CALL InNode % Destruct () CALL FreeTreeNode ( InNode ) ! reset the input node InNode => NULL () ! set output node and return OutNode => InNode RETURN END IF ! check whether to move red node to the right IF (. NOT . IsRed ( InNode % Right )) THEN IF ( ASSOCIATED ( InNode % Right )) THEN IF (. NOT . IsRed ( InNode % Right % Left )) InNode => MoveRedRight ( InNode ) END IF END IF IF ( KeyVal == InNode % KeyVal ) THEN ! find inorder successor of InNode CALL Find_MinKeyNode ( InNode % Right , MinNode ) ! set the inorder successor data at the position of the node supposedly to be deleted InNode % KeyVal = MinNode % KeyVal ! actually delete the inorder successor node instead InNode % Right => DeleteMinKeyNode ( InNode % Right ) ! free working pointers NULLIFY ( MinNode ) ELSE ! find the node on the right subtree InNode % Right => DeleteNode ( InNode % Right , KeyVal ) END IF END IF ! rebalance InNode => Rebalance ( InNode ) ! set output node and return OutNode => InNode RETURN END FUNCTION DeleteNode !****************************************************************************** RECURSIVE FUNCTION DeleteMinKeyNode ( InNode , KeyVal ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the smallest key and its associated value from the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root node of (sub)tree) tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! smallest key and its associated value TYPE ( RBNode ), POINTER :: OutNode !! output node (new root node of (sub)tree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . ASSOCIATED ( InNode % Left )) THEN ! smallest key found so get optional output if requested IF ( PRESENT ( KeyVal )) KeyVal = InNode % KeyVal ! delete node from the tree CALL InNode % Destruct () CALL FreeTreeNode ( InNode ) ! reset the input node InNode => NULL () ELSE ! check whether to move red node to the left IF (. NOT . IsRed ( InNode % Left )) THEN IF ( ASSOCIATED ( InNode % Left )) THEN IF (. NOT . IsRed ( InNode % Left % Left )) InNode => MoveRedLeft ( InNode ) END IF END IF ! find the node on the left subtree InNode % Left => DeleteMinKeyNode ( InNode % Left , KeyVal ) ! rebalance InNode => Rebalance ( InNode ) END IF ! set output node OutNode => InNode RETURN END FUNCTION DeleteMinKeyNode !****************************************************************************** RECURSIVE FUNCTION DeleteMaxKeyNode ( InNode , KeyVal ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the largest key and its associated value from the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root node of (sub)tree) tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! largest key and its associated value TYPE ( RBNode ), POINTER :: OutNode !! output node (new root node of (sub)tree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether to perform right rotation IF ( IsRed ( InNode % Left )) InNode => RightRotate ( InNode ) IF (. NOT . ASSOCIATED ( InNode % Right )) THEN ! largest key found so get optional output if requested IF ( PRESENT ( KeyVal )) KeyVal = InNode % KeyVal ! delete node from the tree CALL InNode % Destruct () CALL FreeTreeNode ( InNode ) ! reset the input node InNode => NULL () ELSE ! check whether to move red node to the right IF (. NOT . IsRed ( InNode % Right )) THEN IF ( ASSOCIATED ( InNode % Right )) THEN IF (. NOT . IsRed ( InNode % Right % Left )) InNode => MoveRedRight ( InNode ) END IF END IF ! find the node on the right subtree InNode % Right => DeleteMaxKeyNode ( InNode % Right , KeyVal ) ! rebalance InNode => Rebalance ( InNode ) END IF ! set output node OutNode => InNode RETURN END FUNCTION DeleteMaxKeyNode !****************************************************************************** FUNCTION NodeSize ( Node ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get number of nodes in subtree rooted by this node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! RBNode object tIndex :: Size !! number of nodes in subtree rooted by this node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Node )) THEN Size = Node % Size ELSE Size = 0_kIndex END IF RETURN END FUNCTION NodeSize !****************************************************************************** FUNCTION IsRed ( Node ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the color of this node is red. !  Return FalseVal if the node is not associated. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! RBNode object tLogical :: Flag !! true if the color is red !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Node )) THEN Flag = ( Node % Color . EQV . Red ) ELSE Flag = Black END IF RETURN END FUNCTION IsRed !****************************************************************************** FUNCTION RightRotate ( InNode ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To make a left-leaning link lean to the right. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root of input subtree) TYPE ( RBNode ), POINTER :: OutNode !! output node (root of output subtree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: NodeA => NULL () TYPE ( RBNode ), POINTER :: NodeB => NULL () TYPE ( RBNode ), POINTER :: NodeC => NULL () ! FLOW ! for debugging purpose ASSERT ( ASSOCIATED ( InNode ). AND . IsRed ( InNode % Left ), 'RotateRight' ) ! set working nodes NodeA => InNode NodeB => NodeA % Left NodeC => NodeB % Right ! perform right rotation NodeB % Right => NodeA NodeA % Left => NodeC ! update the number of nodes in subtree rooted by NodeA and NodeB NodeB % Size = NodeA % Size NodeA % Size = NodeSize ( NodeA % Left ) + NodeSize ( NodeA % Right ) + 1 ! update color NodeB % Color = NodeB % Right % Color NodeB % Right % Color = Red ! set output root OutNode => NodeB ! free pointers NULLIFY ( NodeA ) NULLIFY ( NodeB ) NULLIFY ( NodeC ) RETURN END FUNCTION RightRotate !****************************************************************************** FUNCTION LeftRotate ( InNode ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To make a right-leaning link lean to the left. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node (root of input subtree) TYPE ( RBNode ), POINTER :: OutNode !! output node (root of output subtree) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: NodeA => NULL () TYPE ( RBNode ), POINTER :: NodeB => NULL () TYPE ( RBNode ), POINTER :: NodeC => NULL () ! FLOW ! for debugging purpose ASSERT ( ASSOCIATED ( InNode ). AND . IsRed ( InNode % Right ), 'RotateLeft' ) ! set working nodes NodeA => InNode NodeB => NodeA % Right NodeC => NodeB % Left ! perform left rotation NodeB % Left => NodeA NodeA % Right => NodeC ! update the number of nodes in subtree rooted by NodeA and NodeB NodeB % Size = NodeA % Size NodeA % Size = NodeSize ( NodeA % Left ) + NodeSize ( NodeA % Right ) + 1 ! update color NodeB % Color = NodeB % Left % Color NodeB % Left % Color = Red ! set output root OutNode => NodeB ! free pointers NULLIFY ( NodeA ) NULLIFY ( NodeB ) NULLIFY ( NodeC ) RETURN END FUNCTION LeftRotate !****************************************************************************** SUBROUTINE FlipColor ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To flip the colors of a node and its two children. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Node !! RBNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Node % Color = . NOT . Node % Color Node % Left % Color = . NOT . Node % Left % Color Node % Right % Color = . NOT . Node % Right % Color RETURN END SUBROUTINE FlipColor !****************************************************************************** FUNCTION MoveRedLeft ( InNode ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; Assuming that InNode is red and both InNode%Left and InNode%Left%Left !  are black, make InNode%Left or one of its children red. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node TYPE ( RBNode ), POINTER :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! for debugging purpose ASSERT ( ASSOCIATED ( InNode ), 'MoveRedLeft' ) ASSERT ( IsRed ( InNode ). AND .. NOT . IsRed ( InNode % Left ), 'MoveRedLeft' ) #ifdef DebugMode IF ( ASSOCIATED ( InNode % Left )) THEN ASSERT (. NOT . IsRed ( InNode % Left % Left ), 'MoveRedLeft' ) END IF #endif ! move the input node to the left CALL FlipColor ( InNode ) IF ( ASSOCIATED ( InNode % Right )) THEN IF ( IsRed ( InNode % Right % Left )) THEN InNode % Right => RightRotate ( InNode % Right ) InNode => LeftRotate ( InNode ) CALL FlipColor ( InNode ) END IF END IF ! set output node OutNode => InNode RETURN END FUNCTION MoveRedLeft !****************************************************************************** FUNCTION MoveRedRight ( InNode ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; Assuming that InNode is red and both InNode%Right and InNode%Right%Left !  are black, make InNode%Right or one of its children red. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node TYPE ( RBNode ), POINTER :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! for debugging purpose ASSERT ( ASSOCIATED ( InNode ), 'MoveRedRight' ) ASSERT ( IsRed ( InNode ). AND .. NOT . IsRed ( InNode % Right ), 'MoveRedRight' ) #ifdef DebugMode IF ( ASSOCIATED ( InNode % Right )) THEN ASSERT (. NOT . IsRed ( InNode % Right % Left ), 'MoveRedRight' ) END IF #endif ! move the input node to the right CALL FlipColor ( InNode ) IF ( ASSOCIATED ( InNode % Left )) THEN IF ( IsRed ( InNode % Left % Left )) THEN InNode => RightRotate ( InNode ) CALL FlipColor ( InNode ) END IF END IF ! set output node OutNode => InNode RETURN END FUNCTION MoveRedRight !****************************************************************************** FUNCTION Rebalance ( InNode ) RESULT ( OutNode ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To restore red-black tree invariant. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: InNode !! input node TYPE ( RBNode ), POINTER :: OutNode !! output node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! for debugging purpose ASSERT ( ASSOCIATED ( InNode ), 'Rebalance' ) ! check whether to rotate left or not IF ( IsRed ( InNode % Right ). AND .. NOT . IsRed ( InNode % Left )) InNode => LeftRotate ( InNode ) ! check whether to rotate right or not IF ( IsRed ( InNode % Left )) THEN ! note: if the left node is red, it must not be null IF ( IsRed ( InNode % Left % Left )) InNode => RightRotate ( InNode ) END IF ! check whether to flip color or not IF ( IsRed ( InNode % Left ). AND . IsRed ( InNode % Right )) CALL FlipColor ( InNode ) ! set output node size InNode % Size = NodeSize ( InNode % Left ) + NodeSize ( InNode % Right ) + 1 ! set output node OutNode => InNode RETURN END FUNCTION Rebalance !****************************************************************************** SUBROUTINE FreeTreeNode ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To deallocate RBNode pointer. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Node !! RBNode object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: AllocStat tCharLen ( MsgLen ) :: AllocMsg ! FLOW IF ( ASSOCIATED ( Node )) THEN DEALLOCATE ( Node , STAT = AllocStat , ERRMSG = AllocMsg ) NULLIFY ( Node ) CALL Handle_ErrDealloc ( 'FreeTreeNode' , ModName , AllocMsg , AllocStat ) END IF RETURN END SUBROUTINE FreeTreeNode !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                   Type-Bound Procedures for TreeComparable !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE BSTree_ConstructByArray ( Tree , N , KeyVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a tree based on specified arrays. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tIndex , INTENT ( IN ) :: N !! number of key-value pairs tComparable , INTENT ( IN ) :: KeyVal ( N ) !! an array of key-value pairs !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! built tree from input arrays DO I = 1 , N CALL Tree % Insert ( KeyVal ( I )) END DO RETURN END SUBROUTINE BSTree_ConstructByArray !****************************************************************************** SUBROUTINE BSTree_Destructor_I ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the tree and destroy all nodes CALL DestroyNode ( Tree % Root ) ! nullify pointers NULLIFY ( Tree % Root ) NULLIFY ( Tree % Cursor ) RETURN CONTAINS RECURSIVE SUBROUTINE DestroyNode ( Node ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destroy the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Node !! node !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! return if null IF (. NOT . ASSOCIATED ( Node )) RETURN ! recursively remove left and right subtrees CALL DestroyNode ( Node % Left ) CALL DestroyNode ( Node % Right ) ! remove this node CALL Node % Destruct () CALL FreeTreeNode ( Node ) RETURN END SUBROUTINE DestroyNode !************************************************************************** END SUBROUTINE BSTree_Destructor_I !****************************************************************************** SUBROUTINE BSTree_Destructor_II ( Tree , KeyValQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct a tree and get its pair data. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree TYPE ( QueueKeyVal ), INTENT ( OUT ) :: KeyValQ !! a queue of stored key-value pairs !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the tree to get keys and values CALL Tree % Traverse ( Inorder , GetData ) ! destroy all nodes CALL Tree % Destruct () RETURN CONTAINS FUNCTION GetData ( Node , Done ) RESULT ( ErrStat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get key-value pair of the specified node !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), INTENT ( IN ) :: Node !! node tLogical , INTENT ( INOUT ) :: Done !! on input, Done is set to FalseVal !! on exit, set it to TrueVal if user !!   want to stop the queue traversing. tLogical :: ErrStat !! true if error occurred in iterator !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set flag ErrStat = FalseVal Done = FalseVal ! add key-value pair to queues CALL KeyValQ % EnQueue ( Node % KeyVal ) RETURN END FUNCTION GetData !************************************************************************** END SUBROUTINE BSTree_Destructor_II !****************************************************************************** SUBROUTINE BSTree_Finalizer ( Tree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! destroy all nodes and free up memory CALL Tree % Destruct () RETURN END SUBROUTINE BSTree_Finalizer !****************************************************************************** SUBROUTINE BSTree_Insert ( Tree , KeyVal ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To insert the given key-value pair into the tree. !  If the tree already contains the specified key, the !  old value is replaced with the new one. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: KeyVal !! key-value pair to be inserted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! recursively search for place to insert the key-value pair Tree % Root => AddKeyNValue ( Tree % Root , KeyVal ) Tree % Root % Color = Black RETURN END SUBROUTINE BSTree_Insert !****************************************************************************** FUNCTION BSTree_Remove ( Tree , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified key and its associated value from the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: KeyVal !! key-value pair !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_Remove' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! check if the tree contains the specified key IF (. NOT . Tree % Contain ( KeyVal )) RETURN ! if both children of root are black, set root to red IF (. NOT . IsRed ( Tree % Root % Left ). AND .. NOT . IsRed ( Tree % Root % Right )) THEN Tree % Root % Color = Red END IF ! delete node with the given key Tree % Root => DeleteNode ( Tree % Root , KeyVal ) ! update color IF (. NOT . Tree % IsEmpty ()) Tree % Root % Color = Black Flag = TrueVal RETURN END FUNCTION BSTree_Remove !****************************************************************************** FUNCTION BSTree_RemoveMin ( Tree , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the smallest key and its associated value from the tree. !  Optionally, to retrieve the smallest key and its associated value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! smallest key and its associated value !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_RemoveMin' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! if both children of root are black, set root to red IF (. NOT . IsRed ( Tree % Root % Left ). AND .. NOT . IsRed ( Tree % Root % Right )) THEN Tree % Root % Color = Red END IF ! delete node with smallest key Tree % Root => DeleteMinKeyNode ( Tree % Root , KeyVal ) ! update color IF (. NOT . Tree % IsEmpty ()) Tree % Root % Color = Black Flag = TrueVal RETURN END FUNCTION BSTree_RemoveMin !****************************************************************************** FUNCTION BSTree_RemoveMax ( Tree , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the largest key and its associated value from the tree. !  Optionally, to retrieve the largest key and its associated value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! largest key and its associated value !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_RemoveMax' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! if both children of root are black, set root to red IF (. NOT . IsRed ( Tree % Root % Left ). AND .. NOT . IsRed ( Tree % Root % Right )) THEN Tree % Root % Color = Red END IF ! delete node with largest key Tree % Root => DeleteMaxKeyNode ( Tree % Root , KeyVal ) ! update color IF (. NOT . Tree % IsEmpty ()) Tree % Root % Color = Black Flag = TrueVal RETURN END FUNCTION BSTree_RemoveMax !****************************************************************************** SUBROUTINE BSTree_Traverse_I ( Tree , TraverseFlg , IterFunc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To traverse the tree according to traversal flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tSInt32 , INTENT ( IN ) :: TraverseFlg !&#94; traversal flag. <br> ! = 1 -> inorder. <br> ! = 2 -> preorder. <br> ! = 3 -> postorder. <br> PROCEDURE ( IteratorLocal ) :: IterFunc !! user-supplied routine !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Done ! FLOW Done = FalseVal SELECT CASE ( TraverseFlg ) CASE ( Inorder ) CALL Traverse_Inorder ( Tree % Root , IterFunc , Done ) CASE ( Preorder ) CALL Traverse_Preorder ( Tree % Root , IterFunc , Done ) CASE ( Postorder ) CALL Traverse_Postorder ( Tree % Root , IterFunc , Done ) END SELECT RETURN CONTAINS RECURSIVE SUBROUTINE Traverse_Inorder ( Root , IterFunc , Done ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform inorder traversal. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Root !! root node of (sub)tree PROCEDURE ( IteratorLocal ) :: IterFunc !! user-supplied routine tLogical , INTENT ( INOUT ) :: Done !! true if want to stop the traversal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ErrStat ! FLOW ! check whether the root is null or not IF (. NOT . ASSOCIATED ( Root )) RETURN ! traverse the left subtree IF (. NOT . Done ) CALL Traverse_Inorder ( Root % Left , IterFunc , Done ) ! call user-supplied routine to perform user-specified task for the current root IF (. NOT . Done ) ErrStat = IterFunc ( Root , Done ) ! traverse the right subtree IF ((. NOT . Done ). AND .(. NOT . ErrStat )) CALL Traverse_Inorder ( Root % Right , IterFunc , Done ) RETURN END SUBROUTINE Traverse_Inorder !************************************************************************** RECURSIVE SUBROUTINE Traverse_Preorder ( Root , IterFunc , Done ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform preorder traversal. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Root !! root node of (sub)tree PROCEDURE ( IteratorLocal ) :: IterFunc !! user-supplied routine tLogical , INTENT ( INOUT ) :: Done !! true if want to stop the traversal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ErrStat ! FLOW ! check whether the root is null or not IF (. NOT . ASSOCIATED ( Root )) RETURN ! call user-supplied routine to perform user-specified task for the current root ErrStat = IterFunc ( Root , Done ) IF ((. NOT . Done ). AND .(. NOT . ErrStat )) THEN ! traverse the left subtree CALL Traverse_Preorder ( Root % Left , IterFunc , Done ) ! traverse the right subtree IF (. NOT . Done ) CALL Traverse_Preorder ( Root % Right , IterFunc , Done ) END IF RETURN END SUBROUTINE Traverse_Preorder !************************************************************************** RECURSIVE SUBROUTINE Traverse_Postorder ( Root , IterFunc , Done ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform postorder traversal. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Root !! root node of (sub)tree PROCEDURE ( IteratorLocal ) :: IterFunc !! user-supplied routine tLogical , INTENT ( INOUT ) :: Done !! true if want to stop the traversal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ErrStat ! FLOW ! check whether the root is null or not IF (. NOT . ASSOCIATED ( Root )) RETURN ! traverse the left subtree IF (. NOT . Done ) CALL Traverse_Postorder ( Root % Left , IterFunc , Done ) ! traverse the right subtree IF (. NOT . Done ) CALL Traverse_Postorder ( Root % Right , IterFunc , Done ) ! call user-supplied routine to perform user-specified task for the current root IF (. NOT . Done ) ErrStat = IterFunc ( Root , Done ) ! set flag to quit if there is an error IF ( ErrStat ) Done = TrueVal RETURN END SUBROUTINE Traverse_Postorder !************************************************************************** END SUBROUTINE BSTree_Traverse_I !****************************************************************************** SUBROUTINE BSTree_Traverse_II ( Tree , IterFunc ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform inorder traversal. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree PROCEDURE ( IteratorFunc ) :: IterFunc !! iterator function !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tComparable , ALLOCATABLE :: KeyVal tLogical :: EndOfTree tLogical :: ErrStat tLogical :: Done ! FLOW ! check whether the tree is empty or not IF ( Tree % IsEmpty ()) RETURN ! allocate working variable ALLOCATE ( KeyVal , MOLD = Tree % Root % KeyVal ) ! set defaults Done = FalseVal ! traverse to all nodes ErrStat = FalseVal ! start iteration EndOfTree = Tree % StartFirst ( KeyVal ) ! loop over all nodes of the list DO WHILE (. NOT . EndOfTree ) ! call iterator function ErrStat = IterFunc ( KeyVal , Done ) ! report error if necessary IF ( ErrStat ) THEN CALL Handle_ErrLevel ( 'BSTree_Traverse_II' , ModName , ErrSevere , & 'An error occurred during call to iterator function.' ) RETURN END IF ! exit the loop if the user want to stop the traversing IF ( Done ) EXIT ! move to next node in the inorder traversal EndOfTree = Tree % MoveForward ( KeyVal ) END DO RETURN END SUBROUTINE BSTree_Traverse_II !****************************************************************************** FUNCTION BSTree_Move2First ( Tree , KeyVal ) RESULT ( EmptyTree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To restart the iteration at the node with smallest key (and optionally to retrieve !  the key-value pair of that node if requested). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! smallest key and its associated value tLogical :: EmptyTree !! true if the tree is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Tree % Root )) THEN ! set iteration node to the node with the smallest key CALL Find_MinKeyNode ( Tree % Root , Tree % Cursor ) ! set flag EmptyTree = FalseVal ! get key-value pair if requested IF ( PRESENT ( KeyVal )) KeyVal = Tree % Cursor % KeyVal ELSE ! set iteration node to null Tree % Cursor => NULL () ! set flag EmptyTree = TrueVal END IF RETURN END FUNCTION BSTree_Move2First !****************************************************************************** FUNCTION BSTree_Move2NextPair ( Tree , KeyVal ) RESULT ( EndOfTree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next node in inorder traversal (and optionally to retrieve !  the key-value pair of the next node if requested). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! key and its associated value of the next node tLogical :: EndOfTree !&#94; true if the current iteration node is  at the end of tree (i.e. the next node does not exist). !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: NxtNode => NULL () ! FLOW IF ( ASSOCIATED ( Tree % Cursor )) THEN ! find next node CALL Find_Inorder_NextNode ( Tree % Cursor , Tree % Root , NxtNode ) ! check status of NxtNode IF ( ASSOCIATED ( NxtNode )) THEN ! next node exists so set iteration node to NxtNode Tree % Cursor => NxtNode ! set flag EndOfTree = FalseVal ! get key-value pair if requested IF ( PRESENT ( KeyVal )) KeyVal = Tree % Cursor % KeyVal ELSE ! next node does not exist so set iteration node to null Tree % Cursor => NULL () ! set flag EndOfTree = TrueVal END IF ELSE ! current iteration node is null so set flag to true EndOfTree = TrueVal END IF ! nullify working node NULLIFY ( NxtNode ) RETURN END FUNCTION BSTree_Move2NextPair !****************************************************************************** FUNCTION BSTree_Move2Last ( Tree , KeyVal ) RESULT ( EmptyTree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To restart the iteration at the node with largest key (and optionally to retrieve !  the key-value pair of that node if requested). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! the largest key and its associated value tLogical :: EmptyTree !! true if the tree is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ASSOCIATED ( Tree % Root )) THEN ! set iteration node to the node with the largest key CALL Find_MaxKeyNode ( Tree % Root , Tree % Cursor ) ! set flag EmptyTree = FalseVal ! get key-value pair if requested IF ( PRESENT ( KeyVal )) KeyVal = Tree % Cursor % KeyVal ELSE ! set iteration node to null Tree % Cursor => NULL () ! set flag EmptyTree = TrueVal END IF RETURN END FUNCTION BSTree_Move2Last !****************************************************************************** FUNCTION BSTree_Move2PrevPair ( Tree , KeyVal ) RESULT ( EndOfTree ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the previous node in inorder traversal (and optionally to retrieve !  the key-value pair of the previous node if requested). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , OPTIONAL , INTENT ( OUT ) :: KeyVal !! key and its associated value of the previous node tLogical :: EndOfTree !&#94; true if the current iteration node is  at the end of tree (i.e. the previous node does not exist). !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: PrvNode => NULL () ! FLOW IF ( ASSOCIATED ( Tree % Cursor )) THEN ! find previous node CALL Find_Inorder_PrevNode ( Tree % Cursor , Tree % Root , PrvNode ) ! check status of PrvNode IF ( ASSOCIATED ( PrvNode )) THEN ! previous node exists so set iteration node to PrvNode Tree % Cursor => PrvNode ! set flag EndOfTree = FalseVal ! get key-value pair if requested IF ( PRESENT ( KeyVal )) KeyVal = Tree % Cursor % KeyVal ELSE ! previous node does not exist so set iteration node to null Tree % Cursor => NULL () ! set flag EndOfTree = TrueVal END IF ELSE ! current iteration node is null so set flag to true EndOfTree = TrueVal END IF ! nullify working node NULLIFY ( PrvNode ) RETURN END FUNCTION BSTree_Move2PrevPair !****************************************************************************** FUNCTION BSTree_IsEmpty ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the tree is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( IN ) :: Tree !! tree tLogical :: Flag !! true if the tree is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Tree % GetSize () == 0_kIndex ) RETURN END FUNCTION BSTree_IsEmpty !****************************************************************************** FUNCTION BSTree_FindKey ( Tree , KeyVal , KeyNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the specified key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: KeyVal !! the key to be looked for TYPE ( RBNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: KeyNode !! the node containing the specified key tLogical :: Found !! true if the key found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: OutNode => NULL () ! FLOW ! recursively search for the node that have the same key CALL FindNode ( Tree % Root , KeyVal , OutNode ) ! set flag Found = ASSOCIATED ( OutNode ) ! set optional output IF ( PRESENT ( KeyNode )) KeyNode => OutNode ! nullify working node NULLIFY ( OutNode ) RETURN END FUNCTION BSTree_FindKey !****************************************************************************** FUNCTION BSTree_GetSize ( Tree ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( IN ) :: Tree !! tree tIndex :: Size !! size of the tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = NodeSize ( Tree % Root ) RETURN END FUNCTION BSTree_GetSize !****************************************************************************** FUNCTION BSTree_GetSmallestKey ( Tree , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the smallest key and its associated value in the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( OUT ) :: KeyVal !! smallest key and its associated value !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: KeyNode => NULL () ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_GetSmallestKey' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! find node with smallest key CALL Find_MinKeyNode ( Tree % Root , KeyNode ) ! get key-value pair KeyVal = KeyNode % KeyVal ! nullify working node NULLIFY ( KeyNode ) Flag = TrueVal RETURN END FUNCTION BSTree_GetSmallestKey !****************************************************************************** FUNCTION BSTree_GetLargestKey ( Tree , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the largest key and its associated value in the tree. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( OUT ) :: KeyVal !! largest key and its associated value !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: KeyNode => NULL () ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_GetLargestKey' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! find node with largest key CALL Find_MaxKeyNode ( Tree % Root , KeyNode ) ! get key-pair value KeyVal = KeyNode % KeyVal ! nullify working node NULLIFY ( KeyNode ) Flag = TrueVal RETURN END FUNCTION BSTree_GetLargestKey !****************************************************************************** FUNCTION BSTree_Floor ( Tree , InKey , OutKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the largest key in the tree less than or equal to the given key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: InKey !! input key (and its associated value) tComparable , INTENT ( OUT ) :: OutKey !! output key (and its associated value) !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: FloorNode => NULL () ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_Floor' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! find the floor node CALL Find_FloorNode ( Tree % Root , InKey , FloorNode ) ! check whether the floor node exists or not IF (. NOT . ASSOCIATED ( FloorNode )) THEN CALL Handle_ErrLevel ( 'BSTree_Floor' , ModName , ErrWarning , & 'The specified key is too small.' ) RETURN END IF ! get key-value pair OutKey = FloorNode % KeyVal ! nullify working node NULLIFY ( FloorNode ) Flag = TrueVal RETURN END FUNCTION BSTree_Floor !****************************************************************************** FUNCTION BSTree_Ceiling ( Tree , InKey , OutKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the smallest key in the tree greater than or equal to the given key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: InKey !! input key (and its associated value) tComparable , INTENT ( OUT ) :: OutKey !! output key (and its associated value) !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( RBNode ), POINTER :: CeilingNode => NULL () ! FLOW Flag = FalseVal ! check if the tree is empty or not IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_Ceiling' , ModName , ErrWarning , & 'The binary search tree is empty.' ) RETURN END IF ! find the floor node CALL Find_CeilingNode ( Tree % Root , InKey , CeilingNode ) ! check whether the floor node exists or not IF (. NOT . ASSOCIATED ( CeilingNode )) THEN CALL Handle_ErrLevel ( 'BSTree_Ceiling' , ModName , ErrWarning , & 'The specified key is too large.' ) RETURN END IF ! get key-value pair OutKey = CeilingNode % KeyVal ! nullify working node NULLIFY ( CeilingNode ) Flag = TrueVal RETURN END FUNCTION BSTree_Ceiling !****************************************************************************** FUNCTION BSTree_Select ( Tree , Rank , KeyVal ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the key in the tree of a given rank. !  This key has the property that there are rank keys in !  the tree that are smaller. In other words, this key is the !  (rank+1)st smallest key in the tree. <br> !  Note: applicable range of rank is between 0 and tree_size-1. !       (this rank number is zero-based). !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tIndex , INTENT ( IN ) :: Rank !! rank tComparable , INTENT ( OUT ) :: KeyVal !! key-value pair of the given rank !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Found ! FLOW Flag = FalseVal ! check input validity IF ( NOT_IN_RANGE ( Rank , 0 , Tree % GetSize () - 1 )) THEN CALL Handle_ErrLevel ( 'BSTree_Select' , ModName , ErrSevere , & 'The specified rank is not in the applicable range.' ) RETURN END IF ! find the floor node Found = SelectKey ( Tree % Root , Rank , KeyVal ) ! check if the key is found IF (. NOT . Found ) THEN CALL Handle_ErrLevel ( 'BSTree_Select' , ModName , ErrSevere , & 'There is a bug in the code.' ) ELSE Flag = TrueVal END IF RETURN END FUNCTION BSTree_Select !****************************************************************************** FUNCTION BSTree_Rank ( Tree , Key ) RESULT ( Rank ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of keys in the tree strictly less than the given key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: Key !! key (and its associated value) tIndex :: Rank !! rank of key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Rank = KeyRank ( Tree % Root , Key ) RETURN END FUNCTION BSTree_Rank !****************************************************************************** SUBROUTINE BSTree_GetKeys_Range ( Tree , Low , High , KeyValQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return all keys and their associated values in the tree in the given range. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tComparable , INTENT ( IN ) :: Low !! low key tComparable , INTENT ( IN ) :: High !! high key TYPE ( QueueKeyVal ), INTENT ( OUT ) :: KeyValQ !! key-value queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the tree and get all keys in the range CALL GetKeys_Inorder ( Tree % Root , Low , High , KeyValQ ) RETURN CONTAINS FUNCTION IsKeyInRange ( Key , LowLimit , UppLimit ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check if the key is in the specified range. !** SUBROUTINE ARGUMENT DECLARATIONS: tComparable , INTENT ( IN ) :: Key tComparable , INTENT ( IN ) :: LowLimit tComparable , INTENT ( IN ) :: UppLimit tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (( Key < LowLimit ). OR .( Key > UppLimit )) THEN Flag = FalseVal ELSE Flag = TrueVal END IF RETURN END FUNCTION IsKeyInRange !************************************************************************** RECURSIVE SUBROUTINE GetKeys_Inorder ( Node , Lo , Hi , QueueKV ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get inorder key. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( INOUT ) :: Node !! root node of (sub)tree tComparable , INTENT ( IN ) :: Lo !! low key tComparable , INTENT ( IN ) :: Hi !! high key TYPE ( QueueKeyVal ), INTENT ( INOUT ) :: QueueKV !! key-value queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ErrStat ! FLOW ! check whether the root is null or not IF (. NOT . ASSOCIATED ( Node )) RETURN ! traverse the left subtree IF ( Lo < Node % KeyVal ) CALL GetKeys_Inorder ( Node % Left , Lo , Hi , QueueKV ) ! call user-supplied routine to perform user-specified task for the current root IF ( IsKeyInRange ( Node % KeyVal , Lo , Hi )) THEN CALL QueueKV % EnQueue ( Node % KeyVal ) END IF ! traverse the right subtree IF ( Hi > Node % KeyVal ) CALL GetKeys_Inorder ( Node % Right , Lo , Hi , QueueKV ) RETURN END SUBROUTINE GetKeys_Inorder !************************************************************************** END SUBROUTINE BSTree_GetKeys_Range !****************************************************************************** SUBROUTINE BSTree_GetKeys_All ( Tree , KeyValQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return all keys in the tree and optionally all associated values. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree TYPE ( QueueKeyVal ), INTENT ( OUT ) :: KeyValQ !! key-value queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! traverse the tree and get all keys in the range CALL Tree % Traverse ( Inorder , GetKeys ) RETURN CONTAINS FUNCTION GetKeys ( Node , Done ) RESULT ( ErrStat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get key of the specified node !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), INTENT ( IN ) :: Node !! node tLogical , INTENT ( INOUT ) :: Done !! on input, Done is set to FalseVal !! on exit, set it to TrueVal if user !!   want to stop the queue traversing. tLogical :: ErrStat !! true if error occurred in iterator !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! set flag ErrStat = FalseVal Done = FalseVal ! add key to queues CALL KeyValQ % EnQueue ( Node % KeyVal ) RETURN END FUNCTION GetKeys !************************************************************************** END SUBROUTINE BSTree_GetKeys_All !****************************************************************************** FUNCTION BSTree_GetSize_Range ( Tree , Low , High ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of keys in the tree in the given range. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! TreeComparable object tComparable , INTENT ( IN ) :: Low !! low key tComparable , INTENT ( IN ) :: High !! high key tIndex :: Size !! size of the tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = 0_kIndex IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_GetSize_Range' , ModName , ErrWarning , & 'Tree is empty.' ) RETURN END IF IF ( Low > High ) THEN RETURN END IF IF ( Tree % Contain ( High )) THEN Size = Tree % GetRank ( High ) - Tree % GetRank ( Low ) + 1 ELSE Size = Tree % GetRank ( High ) - Tree % GetRank ( Low ) END IF RETURN END FUNCTION BSTree_GetSize_Range !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !               Routines for Checking Integrity of BST Data Structure !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ FUNCTION BSTree_IsRankConsistent ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check that ranks are consistent. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! true if ranks are consistent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I tLogical :: Found tComparable , ALLOCATABLE :: Key tComparable , ALLOCATABLE :: NodeKey ! FLOW IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_IsRankConsistent' , ModName , ErrWarning , 'Tree is empty.' ) Flag = TrueVal RETURN ELSE ALLOCATE ( Key , MOLD = Tree % Root % KeyVal ) ALLOCATE ( NodeKey , MOLD = Tree % Root % KeyVal ) END IF ! check rank of select of I DO I = 0 , Tree % GetSize () - 1 Found = Tree % Select ( I , Key ) IF ((. NOT . Found ). OR .( I /= Tree % GetRank ( Key ))) THEN Flag = FalseVal RETURN END IF END DO Flag = TrueVal ! check select of rank of key CALL Tree % Traverse ( Inorder , CompareKey ) RETURN CONTAINS FUNCTION CompareKey ( Node , Done ) RESULT ( ErrStat ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare key of the specified node. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), INTENT ( IN ) :: Node !! node tLogical , INTENT ( INOUT ) :: Done !! on input, Done is set to FalseVal !! on exit, set it to TrueVal if user !!   want to stop the queue traversing. tLogical :: ErrStat !! true if error occurred in iterator !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Found !** FLOW ! set flag ErrStat = FalseVal Done = FalseVal ! add key to queues Found = Tree % Select ( Tree % GetRank ( Node % KeyVal ), NodeKey ) IF ((. NOT . Found ). OR .( Node % KeyVal /= NodeKey )) THEN Done = TrueVal Flag = FalseVal END IF RETURN END FUNCTION CompareKey !************************************************************************** END FUNCTION BSTree_IsRankConsistent !****************************************************************************** FUNCTION BSTree_IsSizeConsistent ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the size fields are correct or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! true if the size fields are correct !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = IsSizeConsistent ( Tree % Root ) RETURN CONTAINS RECURSIVE FUNCTION IsSizeConsistent ( Node ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the size field is correct or not. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! node tLogical :: Flag !! true if the size fields are correct !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (. NOT . ASSOCIATED ( Node )) THEN Flag = TrueVal ELSEIF ( Node % Size /= ( NodeSize ( Node % Left ) + NodeSize ( Node % Right ) + 1 )) THEN Flag = FalseVal ELSE Flag = ( IsSizeConsistent ( Node % Left ). AND . IsSizeConsistent ( Node % Right )) END IF RETURN END FUNCTION IsSizeConsistent !************************************************************************** END FUNCTION BSTree_IsSizeConsistent !****************************************************************************** FUNCTION BSTree_IsBinarySearchTree ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the inorder keys in the tree are in ascending order or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! true if the inorder keys are sorted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( QueueKeyVal ) :: InorderKeyQ tComparable , ALLOCATABLE :: KeyI , KeyIP1 ! FLOW IF ( Tree % IsEmpty ()) THEN CALL Handle_ErrLevel ( 'BSTree_IsBinarySearchTree' , ModName , ErrWarning , 'Tree is empty.' ) Flag = TrueVal RETURN ELSE ALLOCATE ( KeyI , MOLD = Tree % Root % KeyVal ) ALLOCATE ( KeyIP1 , MOLD = Tree % Root % KeyVal ) END IF ! get inorder keys CALL Tree % GetKeys ( InorderKeyQ ) ! verify that the inorder keys are sorted Flag = Are_Keys_In_Ascending_Order ( InorderKeyQ ) RETURN CONTAINS FUNCTION Are_Keys_In_Ascending_Order ( KeyQ ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether the given keys are sorted in ascending order. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueKeyVal ), INTENT ( INOUT ) :: KeyQ !! key queue tLogical :: Flag !! true if the queue is sorted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Success !** FLOW: ! initialize Flag = TrueVal ! check if the queue is empty or not IF ( KeyQ % IsEmpty ()) RETURN ! get KeyI Success = KeyQ % DeQueue ( KeyI ) DO WHILE (. NOT . KeyQ % IsEmpty ()) ! get KeyIP1 Success = KeyQ % DeQueue ( KeyIP1 ) ! compare keys IF ( KeyIP1 <= KeyI ) THEN Flag = FalseVal CALL KeyQ % Destruct () EXIT END IF ! reset KeyI KeyI = KeyIP1 END DO RETURN END FUNCTION Are_Keys_In_Ascending_Order !************************************************************************** END FUNCTION BSTree_IsBinarySearchTree !****************************************************************************** FUNCTION BSTree_Is23Tree ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the tree is a 2-3 tree. <br> !  => Does the tree have no red right links, and at most one (left) !     red links in a row on any path? !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! true if this is a 2-3 tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = Is23Tree ( Tree % Root ) RETURN CONTAINS RECURSIVE FUNCTION Is23Tree ( Node ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the subtree is a 2-3 tree. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! node tLogical :: Flag !! true if this is a 2-3 tree !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF (. NOT . ASSOCIATED ( Node )) THEN Flag = TrueVal ELSEIF ( IsRed ( Node % Right )) THEN Flag = FalseVal ELSEIF (. NOT . ASSOCIATED ( Node , Tree % Root ). AND . IsRed ( Node ). AND . IsRed ( Node % Left )) THEN Flag = FalseVal ELSE Flag = ( Is23Tree ( Node % Left ). AND . Is23Tree ( Node % Right )) END IF RETURN END FUNCTION Is23Tree !************************************************************************** END FUNCTION BSTree_Is23Tree !****************************************************************************** FUNCTION BSTree_IsBalanced ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the tree is balanced. <br> !  => Do all paths from root to leaf have !     same number of black edges?. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! true if the tree is balanced !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: BlackCount ! number of black links on path from root to min TYPE ( RBNode ), POINTER :: XNode => NULL () ! FLOW BlackCount = 0 XNode => Tree % Root DO WHILE ( ASSOCIATED ( XNode )) IF (. NOT . IsRed ( XNode )) BlackCount = BlackCount + 1 XNode => XNode % Left END DO NULLIFY ( XNode ) Flag = IsBalanced ( Tree % Root , BlackCount ) RETURN CONTAINS RECURSIVE FUNCTION IsBalanced ( Node , BlackCount ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the subtree is balanced. !  => Does every path from the root to a leaf !     have the given number of black links? !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( RBNode ), POINTER , INTENT ( IN ) :: Node !! node tIndex , INTENT ( IN ) :: BlackCount !! number of black links on path from root to min tLogical :: Flag !! true if the tree is balanced !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurrBlackCount !** FLOW CurrBlackCount = BlackCount IF (. NOT . ASSOCIATED ( Node )) THEN Flag = ( CurrBlackCount == 0 ) ELSE IF (. NOT . IsRed ( Node )) CurrBlackCount = CurrBlackCount - 1 Flag = ( IsBalanced ( Node % Left , CurrBlackCount ). AND . & IsBalanced ( Node % Right , CurrBlackCount )) END IF RETURN END FUNCTION IsBalanced !************************************************************************** END FUNCTION BSTree_IsBalanced !****************************************************************************** FUNCTION BSTree_CheckBST ( Tree ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check integrity of BST data structure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeComparable ), INTENT ( INOUT ) :: Tree !! tree tLogical :: Flag !! flag for integrity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: IsBSTree tLogical :: Is23Tree tLogical :: IsBalanced tLogical :: IsRankConsistent tLogical :: IsSizeConsistent ! FLOW IsBSTree = Tree % IsBSTree () Is23Tree = Tree % Is23Tree () IsBalanced = Tree % IsBalanced () IsRankConsistent = Tree % IsRankConsistent () IsSizeConsistent = Tree % IsSizeConsistent () IF (. NOT . IsBSTree ) THEN CALL Handle_ErrLevel ( 'BSTree_CheckBST' , ModName , ErrWarning , & 'Not in symmetric order.' ) END IF IF (. NOT . Is23Tree ) THEN CALL Handle_ErrLevel ( 'BSTree_CheckBST' , ModName , ErrWarning , & 'Not a 2-3 tree.' ) END IF IF (. NOT . IsBalanced ) THEN CALL Handle_ErrLevel ( 'BSTree_CheckBST' , ModName , ErrWarning , & 'Not balanced tree.' ) END IF IF (. NOT . IsRankConsistent ) THEN CALL Handle_ErrLevel ( 'BSTree_CheckBST' , ModName , ErrWarning , & 'Ranks not consistent.' ) END IF IF (. NOT . IsSizeConsistent ) THEN CALL Handle_ErrLevel ( 'BSTree_CheckBST' , ModName , ErrWarning , & 'Subtree counts not consistent.' ) END IF Flag = ( IsBSTree . AND . Is23Tree . AND . IsRankConsistent . AND . IsSizeConsistent ) RETURN END FUNCTION BSTree_CheckBST !****************************************************************************** !** UNDEFINE MACROS ** #undef TreeComparable #undef tComparable #undef tComparable #undef tComparable #undef QueueKeyVal END MODULE MClass_TreeComparable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treecomparable.f90.html"},{"title":"MClass_BaseSymTable.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BaseSymTable !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BaseSymTable* type and its related routines.  The *BaseSymTable* !   type is an abstract data type representing a symbol table, which is a collection that !   associates a *value* with a *key*.  The user can insert key-value pairs into the symbol !   table with the expectation of later being able to search for the value associated with !   a given key. <br> !   The *BaseSymTable* type extends the *BaseCollection* type to define additional methods for !   various common operations of a symbol table.  All other symbol table types (unordered or !   ordered ones) should extend from this base type. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_BaseCollection USE MClass_GenData , ONLY : IsSameDataType , IfacePolyCopy USE MClass_KeyOrdered , ONLY : IsSameKeyOrdered , IsKeyOrdered USE MClass_KeyUnordered , ONLY : IsKeyUnordered IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseSymTable PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_BaseSymTable' !** DERIVED TYPE !> The *BaseSymTable* type is an abstract collection type that defines an API for !  a symbol table, which is a collection that associates a *value* with a *key*. <br> !  It is important to note that, by design, a concrete collection type that extends !  from the *BaseSymTable* type only stores entries of one specific key type and one !  specific value type.  To store entries of another key and/or value types, the !  collection must be cleared and/or destructed. <br> TYPE , ABSTRACT , EXTENDS ( BaseCollection ) :: BaseSymTable PRIVATE CLASS ( * ), ALLOCATABLE :: KeyMold CLASS ( * ), ALLOCATABLE :: ValMold CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *StartFirst* is a deferred procedure to start the *forward* iteration. <br> PROCEDURE ( IfaceStartFirst ), DEFERRED :: StartFirst !> *MoveForward* is a deferred procedure to move to the next iteration. <br> PROCEDURE ( IfaceMoveNext ), DEFERRED :: MoveForward !> *Insert* is a deferred procedure to insert the specified key-value pair to the !   collection. <br> PROCEDURE ( IfaceInsert ), DEFERRED :: Insert !> *Delete* is a deferred procedure to delete the current key-value pair from the !   collection.  This method is intended to be employed in conjunction with the !   *StartFirst* and *MoveForward* methods.  Therefore, after the call to one of !   those methods and then calling this one will result in a removal of the current !   key-value pair of the iteration (i.e. the same key-value pair that can be obtained !   via the *StartFirst* and *MoveForward* methods). <br> PROCEDURE ( IfaceDelete ), DEFERRED :: Delete !> *Remove* is a deferred procedure to remove the specified key (and its associated !   value) from the collection. <br> PROCEDURE ( IfaceRemove ), DEFERRED :: Remove !> *Contain* is a deferred procedure to check whether the specified key is in the !   collection or not. <br> PROCEDURE ( IfaceContain ), DEFERRED :: Contain !> *GetValue* is a deferred procedure to get a value associated with the specified key !   in the collection. <br> PROCEDURE ( IfaceGetVal ), DEFERRED :: GetValue !> *ToArray* is a deferred procedure to retrieve and remove all key-value pairs from !   the collection. <br> PROCEDURE ( IfaceToArray ), DEFERRED :: ToArray !> *GetAll* is a deferred procedure to retrieve all keys and/or all values (without !   removing them) from the collection. <br> PROCEDURE ( IfaceGetAll ), DEFERRED :: GetAll ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all key-value pairs from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() !  **Note**: The *Clear* method provided by the *BaseSymTable* type is !       a simple implementation.   It can be overridden by a better and !       more efficient implementation. PROCEDURE :: Clear => BaseSymTable_ClearEntries !> **Type-Bound Function**: GetKeyPtr <br> !  **Purpose**:  To get a pointer to a key stored in a symbol table.  The pointer is !       intended to be used as a mold for the key (i.e. to provide type of the stored !       keys).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    KeyPtr => Collection%GetKeyPtr() PROCEDURE :: GetKeyPtr => BaseSymTable_GetKeyPtr !> **Type-Bound Function**: GetValPtr <br> !  **Purpose**:  To get a pointer to a value stored in a symbol table.  The pointer is !       intended to be used as a mold for the value (i.e. to provide type of the stored !       values).  Return null pointer if the table is empty. <br> !  **Usage**: <br> !   --->    ValPtr => Collection%GetValPtr() PROCEDURE :: GetValPtr => BaseSymTable_GetValPtr ! --------------------------------------------------------------------- ! -----       Public Procedures To Be Used Internally             ----- ! --------------------------------------------------------------------- !> *SetMolds* is a procedure to set molds of stored keys and values.  This procedure is !   intended to be used only by a subtype of the *BaseSymTable* type, not by a user. PROCEDURE :: SetMolds => BaseSymTable_SetMolds !> *SetMolds* is a procedure to free molds of stored keys and values.  This procedure is !   intended to be used only by a subtype of the *BaseSymTable* type, not by a user. PROCEDURE :: FreeMolds => BaseSymTable_FreeMolds !> *IsKeyOrdered* is a procedure to check whether the specified key is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseSymTable* type, not by !   a user. PROCEDURE :: IsKeyValid => BaseSymTable_IsKeyValid !> *IsValOrdered* is a procedure to check whether the specified value is valid or not.  This !   procedure is intended to be used only by a subtype of the *BaseSymTable* type, not by !   a user. PROCEDURE :: IsValValid => BaseSymTable_IsValValid ! --------------------------------------------------------------------- END TYPE BaseSymTable !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !> IfaceStartFirst is an interface for a procedure to move to the first (starting) !  pair data in a symbol table.  It is provided for an iteration over all key-value !  pairs in a symbol table. <br> !  For an ordered symbol table, the first pair data normally means the key-value pair !  with the smallest key.  For an unordered symbol table, the first pair data can be !  any key-value pair. <br> FUNCTION IfaceStartFirst ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the first key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> the first value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection is empty or not <br> tLogical :: IsEmpty END FUNCTION !> IfaceMoveNext is an interface for a procedure to move to the next pair data in a symbol !  table.  It is provided for an iteration over all key-value pairs in a symbol table. <br> !  For an ordered symbol table, the next pair data normally indicates the key-value pair !  with the so-called successor key.  For an unordered symbol table, the next pair data may !  be any key-value pair. <br> FUNCTION IfaceMoveNext ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the end of the collection is encountered or not <br> tLogical :: IsTheEnd END FUNCTION !> *IfaceInsert* is an interface for a procedure to add a key-value pair into a symbol !  table.  When implementing this procedure, a symbol table should only allow one value !  being associated with each key (i.e. no duplicate keys in the table).  This means that !  when a user puts a key-value pair into a table already containing that key (and its !  associated value), the new value should then replace the old one.  These conventions !  define the associative array abstraction, where we can think of a symbol table as being !  just like an array, where keys are indices and values are array entries. <br> SUBROUTINE IfaceInsert ( Collection , Key , Value ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the key to be added to the collection CLASS ( * ), INTENT ( IN ) :: Key !> the value to be added to the collection CLASS ( * ), INTENT ( IN ) :: Value END SUBROUTINE !> *IfaceDelete* is an interface for a procedure to delete the current key-value pair !  from a symbol table.  This procedure is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to either method !  and then calling this procedure will result in a removal of the current key-value !  pair of the iteration (i.e. the same key-value pair that can be retrieved via those !  iteration methods). <br> SUBROUTINE IfaceDelete ( Collection ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object END SUBROUTINE !> *IfaceRemove* is an interface for a procedure to delete the specified key (and its !  associated value) from a symbol table.  Also, return a flag indicating whether the !  key-value pair is successfully removed or not. <br> FUNCTION IfaceRemove ( Collection , Key ) RESULT ( Success ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the key to be removed from the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Success END FUNCTION IfaceRemove !> *IfaceContain* is an interface for a procedure to check whether the specified key is in !  a symbol table or not.  Return true if the key is found.  Otherwise, return false. <br> FUNCTION IfaceContain ( Collection , Key ) RESULT ( Found ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key is found or not. tLogical :: Found END FUNCTION IfaceContain !> *IfaceGetVal* is an interface for a procedure to obtain a value associated with the !  specified key in a symbol table.  Also, return a flag indicating whether the value !  is successfully retrieved or not. <br> FUNCTION IfaceGetVal ( Collection , Key , Value , ValCopy ) RESULT ( Success ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol-table object !> the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !> the value associated with the specified key CLASS ( * ), INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the value is successfully retrieved or not. tLogical :: Success END FUNCTION IfaceGetVal !> *IfaceToArray* is an interface for a procedure to get and remove all key-value pairs !   from the collection.  Also, return a flag indicating whether the items are successfully !   removed or not. FUNCTION IfaceToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) IMPORT CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! iterable collection object !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success END FUNCTION !> *IfaceGetAll* is an interface for a procedure to get all keys and/or all values from !   the collection.  Also, return a flag indicating whether the keys (and/or values) are !   successfully retrieved or not. FUNCTION IfaceGetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) IMPORT !% iterable collection object CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: !  na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE BaseSymTable_ClearEntries ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the pair data items from the collection. <br> !  This routine provides a basic implementation of the *Clear* !  deferred procedure required by the *BaseCollection* class. !  This routine should be overridden if a better implementation !  is available. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: IsTheEnd !** FLOW: IsTheEnd = Collection % StartFirst () DO WHILE (. NOT . IsTheEnd ) CALL Collection % Delete () IsTheEnd = Collection % MoveForward () END DO RETURN END SUBROUTINE BaseSymTable_ClearEntries !****************************************************************************** FUNCTION BaseSymTable_GetKeyPtr ( Collection ) RESULT ( Key ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a pointer to a key stored in a symbol table.  The pointer is intended to be !  used as a mold for the key (i.e. provides type of the stored keys).  Return null !  pointer if the table is empty. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), TARGET , INTENT ( IN ) :: Collection !! symbol table CLASS ( * ), POINTER :: Key !! pointer to a stored key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Collection % KeyMold )) THEN Key => Collection % KeyMold ELSE Key => NULL () END IF RETURN END FUNCTION BaseSymTable_GetKeyPtr !************************************************************************************** FUNCTION BaseSymTable_GetValPtr ( Collection ) RESULT ( Val ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a pointer to a value stored in a symbol table.  The pointer is intended to be !  used as a mold for the value (i.e. provides type of the stored values).  Return null !  pointer if the table is empty. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), TARGET , INTENT ( IN ) :: Collection !! symbol table CLASS ( * ), POINTER :: Val !! pointer to a stored value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( ALLOCATED ( Collection % ValMold )) THEN Val => Collection % ValMold ELSE Val => NULL () END IF RETURN END FUNCTION BaseSymTable_GetValPtr !************************************************************************************** SUBROUTINE BaseSymTable_SetMolds ( Collection , KeyMold , ValMold ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the \"KeyMold\" and \"ValMold\" components. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), OPTIONAL , INTENT ( IN ) :: KeyMold !! mold for stored keys CLASS ( * ), OPTIONAL , INTENT ( IN ) :: ValMold !! mold for stored values !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: IF ( PRESENT ( KeyMold )) THEN IF (. NOT . ALLOCATED ( Collection % KeyMold )) ALLOCATE ( Collection % KeyMold , MOLD = KeyMold ) END IF IF ( PRESENT ( ValMold )) THEN IF (. NOT . ALLOCATED ( Collection % ValMold )) ALLOCATE ( Collection % ValMold , MOLD = ValMold ) END IF RETURN ENDSUBROUTINE BaseSymTable_SetMolds !************************************************************************************** SUBROUTINE BaseSymTable_FreeMolds ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free the \"KeyMold\" and \"ValMold\" components. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: IF ( ALLOCATED ( Collection % KeyMold )) DEALLOCATE ( Collection % KeyMold ) IF ( ALLOCATED ( Collection % ValMold )) DEALLOCATE ( Collection % ValMold ) RETURN END SUBROUTINE BaseSymTable_FreeMolds !************************************************************************************** FUNCTION BaseSymTable_IsKeyValid ( Collection , Key , IsOrderedKey ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the type of specified key is valid or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: Key !! the key to be checked tLogical , INTENT ( IN ) :: IsOrderedKey !&#94; true if the specified key must be an ordered key; false if the specified key is an unordered key. tLogical :: Valid !! true if type of the specified key is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the mold and the specified key have the same type or not IF ( ALLOCATED ( Collection % KeyMold )) THEN IF ( IsKeyOrdered ( Collection % KeyMold )) THEN ! ordered keys are stored Valid = IsSameKeyOrdered ( Collection % KeyMold , Key ) ELSE ! unordered keys are stored Valid = IsSameDataType ( Collection % KeyMold , Key ) END IF ELSE ! this is the first key inserted so set it as the mold IF ( IsOrderedKey ) THEN ! ordered keys to be stored Valid = IsKeyOrdered ( Key ) ELSE ! unordered keys to be stored Valid = IsKeyUnordered ( Key ) END IF IF ( Valid ) CALL Collection % SetMolds ( KeyMold = Key ) END IF RETURN END FUNCTION BaseSymTable_IsKeyValid !************************************************************************************** FUNCTION BaseSymTable_IsValValid ( Collection , Val ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the type of specified value is valid or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseSymTable ), INTENT ( INOUT ) :: Collection !! symbol table CLASS ( * ), INTENT ( IN ) :: Val !! value to be checked tLogical :: Valid !! true if type of the specified value is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the mold and the specified value have the same type or not IF ( ALLOCATED ( Collection % ValMold )) THEN Valid = IsSameDataType ( Collection % ValMold , Val ) ELSE ! this is the first value so set it as the mold CALL Collection % SetMolds ( ValMold = Val ) Valid = TrueVal END IF RETURN END FUNCTION BaseSymTable_IsValValid !************************************************************************************** END MODULE MClass_BaseSymTable !******************************************************************************","tags":"","loc":"sourcefile\\mclass_basesymtable.f90.html"},{"title":"MClass_TreeInteger8B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeInteger8B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeInteger8B* type and its related helper type and routines. !   The *TreeInteger8B* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeInteger8B* !   type uses the Fortran intrinsic *INTEGER(KIND=kInt64)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeInteger8B* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeInteger8B* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeInteger8B* type but utilizes !   a different implementation.  Also, unlike the *TreeInteger8B* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeInteger8B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        INTEGER(KIND=kInt64) #define KeyTypeB        INTEGER(KIND=kInt64) #define KeyTypeC        INTEGER(KIND=kInt64) #define QueueKey        ListInteger8B #define QueueVal        ListAnyType #define RedBlackTree    TreeInteger8B !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeInteger8B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeInteger8B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treeinteger8b.f90.html"},{"title":"MClass_PQInteger8B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQInteger8B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQInteger8B* type and its related routines. !   The *PQInteger8B* type is a priority-queue container with *INTEGER(KIND=kInt64)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQInteger8B* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQInteger8B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     INTEGER(KIND=kInt64) #define     PQHeap      PQInteger8B !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQInteger8B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQInteger8B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqinteger8b.f90.html"},{"title":"MClass_DynamicArrays.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DynamicArrays !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains *dynamic-array-based* collection types and their related routines. !   A *dynamic-array-based* type is a collection type employing a resizable array (or the !   so-called dynamic array) that can increase or decrease its size depending on the current !   collection size (number of items contained in the collection) relative to the current !   collection capacity.  <br> !   Available collection types based on the dynamic-array concept include:  <br> !   - the *StackArray* type that represents a last-in-first-out (LIFO) stack,  <br> !   - the *QueueArray* type that represents a first-in-first-out (FIFO) queue,  <br> !   - the *DequeArray* type that represents a double-ended queue (deque), and  <br> !   - the *ListArray* type that represents a list where an item can be added, removed or !     retrieved at the (valid) specified index.  <br> !   <br> !   **Usage Notes**:  <br> !   - All *dynamic-array-based* collection types commonly require an explicit construction !     before using other provided operations.  There are two methods provided to create a !     collection.  First, the *CreateEmpty* method constructs an empty collection with the !     specified initial capacity.  Second, the *Construction* method constructs a collection !     based on the given input (either from an array of items or from another collection). <br> !   - All available collection types are subtypes of the *BaseDynArr* abstract type, which is !     a private type that is only available in this module.  The *BaseDynArr* type provides !     the *Growing* (private) method to expand the collection's capacity and the *Shrinking* !     (also private) method to reduce the capacity. <br> !     When the collection is full (its current size is equal to its current capacity), its !     capacity is doubled by default.  However, if the *IncSize* argument is specified during !     a construction of the collection, the collection's capacity increases by the amount !     specified (the specified value must be positive) instead of doubling.  <br> !     When the collection's size is reducing due to removing items from the collection, its !     capacity stays the same by default.  Nevertheless, if the *Shrink* flag is specified !     and its value is true during a construction of the collection, the collection's capacity !     is halved when its current size is one quarter of its capacity.  <br> !   - Instead of using as a deque, the *DequeArray* type can also be used as a FIFO queue or !     a LIFO stack.  <br> !   - Instead of using as a list, the *ListArray* type can also be used as a deque, a FIFO !     queue or a LIFO stack. <br> !   <br> !   **Important Notes**:  <br> !   (1) By design, although all *dynamic-array-based* types are generic containers meaning !       that they can be used to store items of any data types, they must be employed to store !       items of only one specific data type.  To store items of another data type, they must !       be cleared and/or destructed before inserting items of different data type. <br> !   (2) To be able to successfully retrieve stored items, the specified output item must have !       the same (concrete) type as that of stored items. <br> !   (3) Additionally, if type of the stored items is a derived one that is NOT in the *Object* !       class and this type has allocatable and/or pointer components, a user must specify the !       optional *ItemCopy* argument when trying to retrieve the stored items.  The *ItemCopy* !       argument is a user-defined procedure to copy an unlimited polymorphic entity.  It must !       must provide a type-guard statement to check the compatibility of concrete types of its !       arguments.  It must also handle the storage allocation (and/or the assignment) of those !       allocatable (and/or pointer) components as appropriate. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 , ToChar => ToDecStrSigned USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MClass_Object , ONLY : Object , ASSIGNMENT ( = ) USE MClass_MemoryPool USE MClass_BaseCollection USE MClass_BaseIterable USE MClass_GenData USE MClass_CharBuffer IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DequeArray PUBLIC :: ListArray PUBLIC :: QueueArray PUBLIC :: StackArray PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DynamicArrays' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based collection #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS !> The *BaseDynArr* type is an abstract dynamic-array type that provides resizing operations !  to grow or shrink the collection capacity depending on its current size (number of items !  contained).  This is a private type. <br> TYPE , ABSTRACT , EXTENDS ( BaseIterable ) :: BaseDynArr PRIVATE !> incremental size of the collection when the collection is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16_kIndex !> flag to shrink the collection capacity tLogical :: Shrink = FalseVal !> items stored in the collection. TYPE ( GenData ), ALLOCATABLE :: Items (:) !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *Offset* is a deferred procedure to get an offset.  This procedure is intended for !   internal uses only. PROCEDURE ( IfaceOffset ), DEFERRED :: Offset ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: BaseDynArr_CreateByArray PROCEDURE , PRIVATE :: Resize => BaseDynArr_MemResize PROCEDURE , PRIVATE :: Growing => BaseDynArr_Growing PROCEDURE , PRIVATE :: Shrinking => BaseDynArr_Shrinking PROCEDURE , PRIVATE :: BaseCopy => BaseDynArr_BaseCopy PROCEDURE , PRIVATE :: BaseFree => BaseDynArr_BaseFree PROCEDURE , PRIVATE :: BaseReset => BaseDynArr_BaseReset PROCEDURE , PRIVATE :: BaseString => BaseDynArr_ToString PROCEDURE , PRIVATE :: BaseHashCode => BaseDynArr_HashCode ! --------------------------------------------------------------------- ! -----                     public procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty collection. <br> !  **Usage**: <br> !           ! create an empty collection with specified initial capacity <br> !   --->    CALL Collection%CreateEmpty(25) <br> !           ! create a collection and specify the optional incremental size <br> !   --->    CALL Collection%CreateEmpty(25, IncSize=16) <br> !           ! create a collection and specify the optional shrink flag <br> !   --->    CALL Collection%CreateEmpty(25, Shrink=.TRUE.) PROCEDURE :: CreateEmpty => BaseDynArr_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection and specify the optional incremental size <br> !   --->    CALL Collection%Construct(25, Arr, IncSize=16) <br> !   ! create a collection and specify the optional shrink flag <br> !   --->    CALL Collection%Construct(25, Arr, Shrink=.TRUE.) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => BaseDynArr_CreateByArray END TYPE BaseDynArr !> **Description**: <br> !   The *StackArray* type is a collection type that employs a resizable-array implementation !   to provide common operations for a LIFO stack. <br> !  **Usage Overview**: <br> !   The *StackArray* type is a *stack* collection type that provides common operations of a !   LIFO stack.  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of items !         or from another collection, <br> !   (1.2) *CreateEmpty* method - method to construct an empty collection, <br> !   (1.3) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *Push* method - method to insert an item at the top (end) of the collection, <br> !   (2.2) *Pop* method - method to get and remove the top (last) item of the collection, <br> !   (2.3) *Clear* method - method to remove all items from the collection. <br> !   (2.4) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekTop* method - method to retrieve the top (last) item of the collection, <br> !   (3.2) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.3) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.4) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item. TYPE , EXTENDS ( BaseDynArr ) :: StackArray PRIVATE !> pointer to top (last) item of the stack tIndex :: Top = 0_kIndex !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to create a collection from another collection. PROCEDURE :: CopyCollection => StackArray_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => StackArray_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => StackArray_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => StackArray_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => StackArray_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => StackArray_Move2NextElm !> Use the *Push* method in place of the *Insert* method to add an item to the stack. PROCEDURE :: Insert => StackArray_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => StackArray_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => StackArray_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => StackArray_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the top (end) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the top (last) item of the collection. Also, return a !                flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething PROCEDURE :: Pop => StackArray_Pop !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the top (last) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething PROCEDURE :: PeekTop => StackArray_PeekTop ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => StackArray_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => StackArray_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => StackArray_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => StackArray_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => StackArray_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseDynArr Type          ----- ! --------------------------------------------------------------------- !> This procedure is intended for internal uses only. PROCEDURE :: Offset => StackArray_Offset ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: StackArray_Finalize ! --------------------------------------------------------------------- END TYPE StackArray !> **Description**: <br> !   The *QueueArray* type is a collection type that employs a resizable-array implementation !   to provide common operations for a FIFO queue. <br> !  **Usage Overview**: <br> !   The *QueueArray* type is a *queue* collection type that provides common operations of a !   FIFO queue.  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of items !          or from another collection, <br> !   (1.2) *CreateEmpty* method - method to construct an empty collection, <br> !   (1.3) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *Enqueue* method - method to insert an item to the end of the collection, <br> !   (2.2) *Dequeue* method - method to get and remove the first item of the collection, <br> !   (2.3) *Clear* method - method to remove all items from the collection. <br> !   (2.4) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekFirst* method - method to retrieve the first item of the collection, <br> !   (3.2) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.3) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.4) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item. TYPE , EXTENDS ( BaseDynArr ) :: QueueArray PRIVATE !> pointer to first item of the queue tIndex :: First = 1_kIndex !> pointer to next to last item of the queue (i.e. the next available slot) tIndex :: Last = 1_kIndex !> size of the collection (number of items) tIndex :: Size = 0_kIndex !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration (only applicable for deque and list) !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 CONTAINS ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to create a collection from another collection. PROCEDURE :: CopyCollection => QueueArray_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => QueueArray_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => QueueArray_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => QueueArray_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => QueueArray_Move2FirstElm !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => QueueArray_Move2NextElm !> Use the *Enqueue* method in place of the *Insert* method to add an item to the queue. PROCEDURE :: Insert => QueueArray_AddElm !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => QueueArray_DelElm !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => QueueArray_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => QueueArray_GetAll ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Enqueue <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Enqueue(Item) GENERIC :: Enqueue => Insert !> **Type-Bound Function**: Dequeue <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Dequeue(Item) <br> !   --->    IF (.NOT.Collection%Dequeue(Item)) DoSomething PROCEDURE :: Dequeue => QueueArray_Dequeue !> **Type-Bound Function**: PeekFirst <br> !  **Purpose**:  To get the front (first) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekFirst(Item) <br> !   --->    IF (.NOT.Collection%PeekFirst(Item)) DoSomething PROCEDURE :: PeekFirst => QueueArray_PeekFirst ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => QueueArray_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => QueueArray_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => QueueArray_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => QueueArray_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => QueueArray_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseDynArr Type          ----- ! --------------------------------------------------------------------- !> This procedure is intended for internal uses only. PROCEDURE :: Offset => QueueArray_Offset ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: QueueArray_Finalize ! --------------------------------------------------------------------- END TYPE QueueArray !> **Description**: <br> !   The *DequeArray* type is a collection type that employs a resizable-array implementation !   to provide common operations for a double-ended queue (deque).   It can be used as a !   FIFO queue or a LIFO stack as well. <br> !  **Usage Overview**: <br> !   The *DequeArray* type is a *deque* collection type that provides common operations of a !   double-ended queue (deque).  Their operations can be categorized as follows: <br> !   (1) Construction and destruction.  Methods for these operations include <br> !   (1.1) *Construct* method - method to construct the collection either from an array of items !          or from another collection, <br> !   (1.2) *CreateEmpty* method - method to construct an empty collection, <br> !   (1.3) *Destruct* method - method to destruct the collection. <br> !   (2) Insert and remove.  Methods for these operations include <br> !   (2.1) *AddFirst* method - method to insert an item to the front of the collection, <br> !   (2.2) *AddLast* method - method to insert an item to the end of the collection, <br> !   (2.3) *RemoveFirst* method - method to get and remove the first item of the collection, <br> !   (2.4) *RemoveLast* method - method to get and remove the last item of the collection, <br> !   (2.5) *Clear* method - method to remove all items from the collection. <br> !   (2.6) *ToArray* method - method to remove and retrieve all items from the collection. <br> !   (3) Inquiry.  Methods for these operations include <br> !   (3.1) *PeekFirst* method - method to retrieve the first item of the collection, <br> !   (3.2) *PeekLast* method - method to retrieve the last item of the collection, <br> !   (3.3) *GetSize* method - method to get the collection size (number of items stored), <br> !   (3.4) *IsEmpty* method - method to check whether the collection is empty or not. <br> !   (3.5) *GetAll* method - method to retrieve all items from the collection. <br> !   (4) Iteration.  Methods for these operations include <br> !   (4.1) *StartFirst* method - method to start a forward iteration over items, <br> !   (4.2) *MoveForward* method - method to move forward to the next item, <br> !   (4.3) *StartLast* method - method to start a backward iteration over items, <br> !   (4.4) *MoveBackward* method - method to move backward to the previous item. <br> !   The *DequeArray* type also supports the usual *Enqueue*, *Dequeue* and *PeekFirst* !   operations of a FIFO queue as well as the usual *Push*, *Pop* and *PeekTop* operations !   of a LIFO stack.  Therefore, when using as a queue or a stack, these operations can be !   used in place of *insert*, *remove*, *peek* operations of a deque as desired. TYPE , EXTENDS ( QueueArray ) :: DequeArray CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start the *backward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: see *MoveBackward* procedure. PROCEDURE :: StartLast => DequeArray_Move2LastElm !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the next iteration (in reverse order) and return !                a flag indicating whether the cursor pointer has reached the !                end of the collection or not. <br> !  **Usage**: <br> !   The following code snippet illustrates how to typically traverse across the collection !   in reverse order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsEmpty = Collection%StartLast() !   IF (.NOT.IsEmpty) DoSomeThing... !   DO !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward() !       ! check whether we reach the end of the collection or not !       IF (IsTheEnd) EXIT !       ! if not, do the task we need !       DoSomeThing... !   END DO !   </Code></Pre> <br> !   The following code snippet shows another way to iterate over the collection in reverse !   order. !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! start backward iteration (from the last item) !   IsTheEnd = Collection%StartLast(CurrItem) !   DO WHILE (.NOT.IsTheEnd) !       DoSomeThing_With_CurrItem... !       ! move to the next iteration !       IsTheEnd = Collection%MoveBackward(CurrItem) !   END DO !   </Code></Pre> PROCEDURE :: MoveBackward => DequeArray_Move2PrevElm !> **Type-Bound Subroutine**: AddFirst <br> !  **Purpose**:  To insert the specified item at the front of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddFirst(Item) PROCEDURE :: AddFirst => DequeArray_AddFirst !> **Type-Bound Subroutine**: AddLast <br> !  **Purpose**:  To insert the specified item at the end of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%AddLast(Item) GENERIC :: AddLast => Insert !> **Type-Bound Function**: RemoveFirst <br> !  **Purpose**:  To get and remove the front (first) item of the collection. Also, return !                a flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveFirst(Item) <br> !   --->    IF (.NOT.Collection%RemoveFirst(Item)) DoSomething GENERIC :: RemoveFirst => Dequeue !> **Type-Bound Function**: RemoveLast <br> !  **Purpose**:  To get and remove the last item of the collection. Also, return a flag !                indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveLast(Item) <br> !   --->    IF (.NOT.Collection%RemoveLast(Item)) DoSomething PROCEDURE :: RemoveLast => DequeArray_RemoveLast !> **Type-Bound Function**: PeekLast <br> !  **Purpose**:  To get the last item (without removing it from the collection). Also, !                return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekLast(Item) <br> !   --->    IF (.NOT.Collection%PeekLast(Item)) DoSomething PROCEDURE :: PeekLast => DequeArray_PeekLast ! --------------------------------------------------------------------- ! -----             Redefined Stack Operations                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Push <br> !  **Purpose**:  To insert the specified item at the end (top) of the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Push(Item) GENERIC :: Push => Insert !> **Type-Bound Function**: Pop <br> !  **Purpose**:  To get and remove the last (top) item of the collection. Also, return a !                flag indicating whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%Pop(Item) <br> !   --->    IF (.NOT.Collection%Pop(Item)) DoSomething GENERIC :: Pop => RemoveLast !> **Type-Bound Function**: PeekTop <br> !  **Purpose**:  To get the last (top) item (without removing it from the collection). !                Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekTop(Item) <br> !   --->    IF (.NOT.Collection%PeekTop(Item)) DoSomething GENERIC :: PeekTop => PeekLast ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => DequeArray_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: DequeArray_Finalize ! --------------------------------------------------------------------- END TYPE DequeArray !> **Description**: <br> !   The *ListArray* type is a collection type that employs a resizable-array implementation !   to provide common operations for a list. <br> !  **Usage Overview**: <br> !   The *ListArray* type provides insert, remove and peek operations at a specified index !   where the index must be between 1 and the collection size.  The *ListArray* type is !   a subtype of the *DequeArray* type; therefore, all operations available for the !   *DequeArray* type are also available for the *ListArray* type.  As a result, it can !   thus be used as a deque, a FIFO queue or a LIFO stack.  <br> TYPE , EXTENDS ( DequeArray ) :: ListArray CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeArray Type            ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: AddAt <br> !  **Purpose**:  To insert the specified item at the specified index where the index !       must be between 1 and the collection size. Also, return a flag indicating !       whether the item is successfully added. <br> !  **Usage**: <br> !   --->    Success = Collection%AddAt(Index, Item) <br> !   --->    IF (.NOT.Collection%AddAt(Index, Item)) DoSomething PROCEDURE :: AddAt => ListArray_AddAt !> **Type-Bound Function**: RemoveAt <br> !  **Purpose**:  To get and remove the item at the specified index where the index !       must be between 1 and the collection size. Also, return a flag indicating !       whether the item is successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%RemoveAt(Index, Item) <br> !   --->    IF (.NOT.Collection%RemoveAt(Index, Item)) DoSomething PROCEDURE :: RemoveAt => ListArray_RemoveAt !> **Type-Bound Function**: PeekAt <br> !  **Purpose**:  To get the item (without removing it from the collection) at the !       specified index where the index must be between 1 and the collection size. !       Also, return a flag indicating whether the item is available or not. <br> !  **Usage**: <br> !   --->    Success = Collection%PeekAt(Index, Item) <br> !   --->    IF (.NOT.Collection%PeekAt(Index, Item)) DoSomething PROCEDURE :: PeekAt => ListArray_PeekAt ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => ListArray_ToString ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: ListArray_Finalize ! --------------------------------------------------------------------- END TYPE ListArray !** INTERFACE DEFINITIONS: ! abstract interface for BaseDynArr ABSTRACT INTERFACE !> IfaceOffset is an interface for a procedure to get an index of the first item !  in the collection. FUNCTION IfaceOffset ( Collection ) RESULT ( First ) IMPORT CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! collection object tIndex :: First !! index of the first item END FUNCTION END INTERFACE ! interfaces for StackArray INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_Copy ( SrcObj , DstObj , IsDeep ) !&#94; To copy the source object to the destination object. <br> CLASS ( StackArray ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !&#94; To check whether LhsObj and RhsObj are equal or not. <br> CLASS ( StackArray ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_MemFree ( Obj ) !&#94; To free memory of the object. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Obj END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_ToString ( Obj ) RESULT ( Str ) !&#94; To get a string representation of the object. <br> CLASS ( StackArray ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_HashCode ( Obj ) RESULT ( Code ) !&#94; To compute hash code for this object. CLASS ( StackArray ), INTENT ( IN ) :: Obj tIndex :: Code END FUNCTION StackArray_HashCode ! --------------------------------------------------------------------- ! -----      Deferred Procedures from BaseCollection Type         ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_CopyCollection ( This , Other , ItemCopy , ValCopy ) !&#94; To creates a new collection (This) from the given collection (Other). <br> CLASS ( StackArray ), INTENT ( INOUT ) :: This !! collection object to be created CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !! collection object to be copied !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_ClearItems ( Collection ) !&#94; To remove all of the items from the collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_Destroy ( Collection ) !&#94; To destruct the collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_GetSize ( Collection ) RESULT ( Size ) !&#94; To get the collection size (number of items in the collection). <br> CLASS ( StackArray ), INTENT ( IN ) :: Collection !! collection object tIndex :: Size !! number of items END FUNCTION ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseIterable Type         ----- ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_Move2FirstElm ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !&#94; To move to the first element in the collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the first element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection contains no element or not <br> ! - true if the collection is empty. <br> ! - otherwise the first element is available. tLogical :: IsEmpty END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_Move2NextElm ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !&#94; To move to the next element in the collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the next element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the collection occurs or not <br> ! - true if next element is NOT available. <br> ! - otherwise next element is available. tLogical :: IsTheEnd END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_AddElm ( Collection , Item ) !&#94; To insert the specified item at the top (end) of the collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE StackArray_DelElm ( Collection ) !&#94; To delete the current item from a collection. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseDynArr Type         ----- ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_Offset ( Collection ) RESULT ( First ) !&#94; To get an index pointing to the first item. <br> CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object tIndex :: First !! first index END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by StackArray Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_Pop ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the top (last) item of the collection.  Also, return !  a flag indicating whether the item is successfully removed. CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_PeekTop ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the top (last) item (without removing it from the collection). Also, !  return a flag indicating whether the item is successfully retrieved or not. CLASS ( StackArray ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_ToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get and remove all items from the collection.  Also, return !  a flag indicating whether the items are successfully removed. CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION StackArray_GetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get all items (without removing them) from the collection.  Also, !  return a flag indicating whether the items are available. CLASS ( StackArray ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for QueueArray INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_Copy ( SrcObj , DstObj , IsDeep ) !&#94; To copy the source object to the destination object. <br> CLASS ( QueueArray ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !&#94; To check whether LhsObj and RhsObj are equal or not. <br> CLASS ( QueueArray ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_MemFree ( Obj ) !&#94; To free memory of the object. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Obj END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( QueueArray ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_HashCode ( Obj ) RESULT ( Code ) !&#94; To compute hash code for this object. CLASS ( QueueArray ), INTENT ( IN ) :: Obj tIndex :: Code END FUNCTION QueueArray_HashCode ! --------------------------------------------------------------------- ! -----      Deferred Procedures from BaseCollection Type         ----- ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_CopyCollection ( This , Other , ItemCopy , ValCopy ) !&#94; To creates a new collection (This) from the given collection (Other). <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: This !! collection object to be created CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !! collection object to be copied !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_ClearItems ( Collection ) !&#94; To remove all of the items from the collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_Destroy ( Collection ) !&#94; To destruct the collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_GetSize ( Collection ) RESULT ( Size ) !&#94; To get the number of items stored in the collection. <br> CLASS ( QueueArray ), INTENT ( IN ) :: Collection !! collection object tIndex :: Size !! number of items END FUNCTION ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseIterable Type         ----- ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_Move2FirstElm ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !&#94; To move to the first element in the collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the first element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection contains no element or not <br> ! - true if the collection is empty. <br> ! - otherwise the first element is available. tLogical :: IsEmpty END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_Move2NextElm ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !&#94; To move to the next element in the collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the next element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the collection occurs or not <br> ! - true if next element is NOT available. <br> ! - otherwise next element is available. tLogical :: IsTheEnd END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_AddElm ( Collection , Item ) !&#94; To insert the specified item at the end of the collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE ! --------------------------------------------------------------------- MODULE SUBROUTINE QueueArray_DelElm ( Collection ) !&#94; To delete the current item from a collection. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseDynArr Type         ----- ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_Offset ( Collection ) RESULT ( First ) !&#94; To get an index pointing to the first item. <br> CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object tIndex :: First !! first index END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by QueueArray Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_Dequeue ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the first item of the collection.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_PeekFirst ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the first item (without removing it from the collection). Also, return !  a flag indicating whether the item is successfully retrieved or not. CLASS ( QueueArray ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_ToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get and remove all items from the collection.  Also, return !  a flag indicating whether the items are successfully removed. CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION QueueArray_GetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) !&#94; To get all items (without removing them) from the collection.  Also, !  return a flag indicating whether the items are available. CLASS ( QueueArray ), INTENT ( INOUT ) :: Collection !! collection object !> the items to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for DequeArray INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE FUNCTION DequeArray_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( DequeArray ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by DequeArray Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION DequeArray_Move2LastElm ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !&#94; To move to the last element in the collection. <br> CLASS ( DequeArray ), INTENT ( INOUT ) :: Collection !! collection object !> the last element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the collection contains no element or not <br> ! - true if the collection is empty. <br> ! - otherwise the last element is available. tLogical :: IsEmpty END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION DequeArray_Move2PrevElm ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !&#94; To move to the previous element in the collection. <br> CLASS ( DequeArray ), INTENT ( INOUT ) :: Collection !! collection object !> the previous element as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the collection occurs or not <br> ! - true if previous element is NOT available. <br> ! - otherwise previous element is available. tLogical :: IsTheEnd END FUNCTION ! --------------------------------------------------------------------- MODULE SUBROUTINE DequeArray_AddFirst ( Collection , Item ) !&#94; To insert the specified item at the start of the collection. <br> CLASS ( DequeArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item END SUBROUTINE ! --------------------------------------------------------------------- MODULE FUNCTION DequeArray_RemoveLast ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the last item of the collection.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( DequeArray ), INTENT ( INOUT ) :: Collection !! collection object !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved and removed. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION DequeArray_PeekLast ( Collection , Item , ItemCopy ) RESULT ( Success ) !&#94; To get the last item (without removing it from the collection). Also, return !  a flag indicating whether the item is successfully retrieved or not. CLASS ( DequeArray ), INTENT ( IN ) :: Collection !! collection object !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE ! interfaces for ListArray INTERFACE ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- MODULE FUNCTION ListArray_ToString ( Obj ) RESULT ( Str ) !&#94; To get the string representation of the object. <br> CLASS ( ListArray ), INTENT ( IN ) :: Obj tCharAlloc :: Str END FUNCTION ! --------------------------------------------------------------------- ! -----         Specific Procedures by ListArray Type            ----- ! --------------------------------------------------------------------- MODULE FUNCTION ListArray_AddAt ( Collection , Index , Item ) RESULT ( Success ) !&#94; To insert the specified item at the specified position in the collection. CLASS ( ListArray ), INTENT ( INOUT ) :: Collection !! collection object !> index indicating the position in the collection to add the item tIndex , INTENT ( IN ) :: Index !> the item to be added to the collection CLASS ( * ), INTENT ( IN ) :: Item !> flag indicating whether the item is successfully added or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION ListArray_RemoveAt ( Collection , Index , Item , ItemCopy ) RESULT ( Success ) !&#94; To get and remove the item at the specified position.  Also, return a flag !  indicating whether the item is successfully removed. CLASS ( ListArray ), INTENT ( INOUT ) :: Collection !! collection object !> index indicating the position in the collection to retrieve and remove the item tIndex , INTENT ( IN ) :: Index !> the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved and removed. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- MODULE FUNCTION ListArray_PeekAt ( Collection , Index , Item , ItemCopy ) RESULT ( Success ) !&#94; To retrieve the item at the specified position (without removing it from the !  collection). Also, return a flag indicating whether the item is successfully !  retrieved or not. CLASS ( ListArray ), INTENT ( IN ) :: Collection !! collection object !> index indicating the position in the collection to retrieve the item tIndex , INTENT ( IN ) :: Index !> the item to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the item is successfully retrieved or not. tLogical :: Success END FUNCTION ! --------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): SUBROUTINE BaseDynArr_CreateEmpty ( Collection , InitCap , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !! To create an empty collection. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! BaseDynArr object tIndex , INTENT ( IN ) :: InitCap !! initial size of the collection tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of the collection when it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the collection capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'BaseDynArr_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity to 16.' ) Capacity = Collection % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the items in the collection CALL MemAlloc ( Collection % Items , Capacity ) CALL Collection % ItemPool % Construct () ! finally, check optional input data Collection % IncSize = 0_kIndex ! reset it to zero IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) Collection % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) Collection % Shrink = Shrink RETURN END SUBROUTINE BaseDynArr_CreateEmpty !****************************************************************************** SUBROUTINE BaseDynArr_CreateByArray ( Collection , N , Items , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a collection from an array of items. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! BaseDynArr object tIndex , INTENT ( IN ) :: N !! number of items CLASS ( * ), INTENT ( IN ) :: Items (:) !! the items to be added to the collection tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of the collection when it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the collection capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! create empty collection InitCap = N * 2_kIndex ! by default, doubling its capacity IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) InitCap = N + IncSize END IF CALL Collection % CreateEmpty ( InitCap , IncSize , Shrink ) ! add items to the collection CALL Collection % SetMold ( Items ( 1 )) DO I = 1_kIndex , N CALL Collection % Insert ( Items ( I )) END DO RETURN END SUBROUTINE BaseDynArr_CreateByArray !****************************************************************************** SUBROUTINE BaseDynArr_MemResize ( Collection , NewSize ) !** PURPOSE OF THIS SUBROUTINE: !! To re-allocate the array of items of the collection and preserve its data !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! BaseDynArr object tIndex , INTENT ( IN ) :: NewSize !! new size of array !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Offset tIndex :: OldSize ! original size of array tIndex :: PSize ! size of preserved data TYPE ( GenData ), ALLOCATABLE :: Temp (:) ! temporary buffer !** FLOW: ! determine the original size OldSize = SIZE ( Collection % Items ) ! first, allocate the temporary array CALL MemAlloc ( Temp , NewSize ) ! determine the preserving size IF ( NewSize >= OldSize ) THEN PSize = OldSize ELSE PSize = NewSize END IF ! get offset Offset = Collection % Offset () ! *** copy items to the temporary buffer *** IF ( Offset == 1_kIndex ) THEN ! use whole array expression (typical for a stack) Temp ( 1 : PSize ) = Collection % Items ( 1 : PSize ) ELSE ! use do loop (typical for a deque or a queue) BLOCK tIndex :: I , J ! get offset to the first item J = Offset DO I = 1_kIndex , PSize ! copy an item to the buffer Temp ( I ) = Collection % Items ( J ) ! update J and wrap around if necessary J = J + 1_kIndex IF ( J > OldSize ) J = 1_kIndex END DO END BLOCK END IF ! move data from the temporary array back to the array ! (this operation includes deallocate the array, reallocate it to !  the new size and copy data back) CALL MOVE_ALLOC ( Temp , Collection % Items ) RETURN END SUBROUTINE BaseDynArr_MemResize !************************************************************************************** SUBROUTINE BaseDynArr_Growing ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To increase the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! BaseDynArr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity !** FLOW: IF (. NOT . ALLOCATED ( Collection % Items )) THEN ! the collection has not yet been constructed. Capacity = 16_kIndex ! allocate storage for the collections' items CALL MemAlloc ( Collection % Items , Capacity ) ELSE Capacity = SIZE ( Collection % Items ) IF ( Collection % GetSize () == Capacity ) THEN ! increase the collection's capacity IF ( Collection % IncSize > 0_kIndex ) THEN Capacity = Capacity + Collection % IncSize ELSE Capacity = Capacity * 2_kIndex END IF ! check integer overflow IF ( Capacity <= 0_kIndex ) Capacity = MaxCapacity ! resize the collections' items CALL Collection % Resize ( Capacity ) END IF END IF RETURN END SUBROUTINE BaseDynArr_Growing !************************************************************************************** SUBROUTINE BaseDynArr_Shrinking ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Collection !! BaseDynArr object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurCap , CurSize !** FLOW: IF (. NOT . ALLOCATED ( Collection % Items )) THEN ! the collection has not yet been constructed so simply return. RETURN END IF IF ( Collection % Shrink ) THEN CurCap = SIZE ( Collection % Items ) CurSize = Collection % GetSize () IF (( CurSize >= 0_kIndex ). AND .( CurSize <= CurCap / 4_kIndex )) THEN ! halves the collection's capacity CurCap = CurCap / 2_kIndex ! check if the capacity is zero or not IF ( CurCap <= 0_kIndex ) CurCap = 1_kIndex ! resize the collections' items CALL Collection % Resize ( CurCap ) END IF END IF RETURN END SUBROUTINE BaseDynArr_Shrinking !************************************************************************************** SUBROUTINE BaseDynArr_BaseCopy ( SrcObj , DstObj ) !** PURPOSE OF THIS SUBROUTINE: !! To copy components from SrcObj to DstObj. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( IN ) :: SrcObj !! a source CLASS ( BaseDynArr ), INTENT ( INOUT ) :: DstObj !! a destination !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Cap , I CLASS ( * ), POINTER :: MoldPtr ! FLOW DstObj % IncSize = SrcObj % IncSize DstObj % Shrink = SrcObj % Shrink IF ( ALLOCATED ( SrcObj % Items )) THEN Cap = SIZE ( SrcObj % Items ) CALL MemAlloc ( DstObj % Items , Cap ) DO I = 1_kIndex , Cap CALL SrcObj % Items ( I )% Copy ( DstObj % Items ( I )) END DO END IF MoldPtr => SrcObj % GetItemPtr () IF ( ASSOCIATED ( MoldPtr )) CALL DstObj % SetMold ( MoldPtr ) RETURN END SUBROUTINE BaseDynArr_BaseCopy !****************************************************************************** SUBROUTINE BaseDynArr_BaseFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of components of the BaseDynArr object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( Obj % Items )) THEN DO I = 1_kIndex , SIZE ( Obj % Items , KIND = kIndex ) CALL Obj % Items ( I )% MemFree () END DO CALL MemFree ( Obj % Items ) END IF CALL Obj % ItemPool % Destruct () CALL Obj % FreeMold () RETURN END SUBROUTINE BaseDynArr_BaseFree !****************************************************************************** SUBROUTINE BaseDynArr_BaseReset ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To reset the BaseDynArr object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW IF ( ALLOCATED ( Obj % Items )) THEN DO I = 1_kIndex , SIZE ( Obj % Items , KIND = kIndex ) CALL Obj % Items ( I )% MemFree () END DO END IF CALL Obj % FreeMold () RETURN END SUBROUTINE BaseDynArr_BaseReset !****************************************************************************** FUNCTION BaseDynArr_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the base-string representation of the *BaseDynArr* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . Obj % IsEmpty ()) THEN BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: ItemStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 40_kIndex ) CALL ChrBuf % Append ( '[' ) Count = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items , KIND = kIndex ) ! skip if the item is empty IF ( Obj % Items ( I )% IsEmpty ()) CYCLE ! add the string representation of the current item ItemStr = Obj % Items ( I )% ToString () CALL ChrBuf % Append ( ItemStr ( 12 : LEN ( ItemStr ) - 1 )) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO ! add the closing character and get the base-string representation of this object CALL ChrBuf % Append ( ']' ) Str = ChrBuf % AsString () END BLOCK ELSE Str = '[NULL]' END IF RETURN END FUNCTION BaseDynArr_ToString !****************************************************************************** FUNCTION BaseDynArr_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the base hash code for the *BaseDynArr* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseDynArr ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF (. NOT . Obj % IsEmpty ()) THEN BLOCK tIndex :: I , Count ! initialize Count = 0_kIndex Code = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items , KIND = kIndex ) ! skip if the item is empty IF ( Obj % Items ( I )% IsEmpty ()) CYCLE ! add the hash code of the current item Code = Code + Obj % Items ( I )% HashCode () ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count > Obj % GetSize ()) EXIT END DO END BLOCK ELSE Code = 0_kIndex END IF RETURN RETURN END FUNCTION BaseDynArr_HashCode ! --------------------------------------------------------------------- ! -----             Final Procedures                              ----- ! --------------------------------------------------------------------- SUBROUTINE DequeArray_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( DequeArray ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE DequeArray_Finalize !****************************************************************************** SUBROUTINE ListArray_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ListArray ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE ListArray_Finalize !****************************************************************************** SUBROUTINE QueueArray_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( QueueArray ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE QueueArray_Finalize !****************************************************************************** SUBROUTINE StackArray_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( StackArray ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE StackArray_Finalize !****************************************************************************** END MODULE MClass_DynamicArrays !******************************************************************************","tags":"","loc":"sourcefile\\mclass_dynamicarrays.f90.html"},{"title":"MClass_HTabInteger2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabInteger2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabInteger2B* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabInteger2B* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabInteger2B* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabInteger2B* type uses the Fortran intrinsic !   *INTEGER(KIND=kInt16)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabInteger2B* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabInteger2B* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabInteger2B #define     KeyTypeA        INTEGER(KIND=kInt16) #define     KeyTypeB        INTEGER(KIND=kInt16) #define     QueueKey        ListInteger2B #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabInteger2B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabInteger2B' ! Special marker token used to indicate the deletion of a key-value pair tSInt16 , PARAMETER :: DELKEY = ToInt16 ( Z '7FFF' ) ! Special marker token used to indicate the empty of a key-value pair tSInt16 , PARAMETER :: NULKEY = ToInt16 ( Z '8000' ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabInteger2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabinteger2b.f90.html"},{"title":"MClass_DArrRealQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrRealQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrRealQP* type and related routines. !   The *DArrRealQP* type is a container with *REAL(KIND=kQuad)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrRealQP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrRealQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrRealQP #define TypeAlloc       REAL(KIND=kQuad), ALLOCATABLE #define TypeArgmt       REAL(KIND=kQuad) #define TypeOfItem      REAL(KIND=kQuad) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrRealQP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrRealQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrrealqp.f90.html"},{"title":"MClass_PQBinHeap.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQBinHeap !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQBinHeap* type and its related routines.  The *PQBinHeap* type !   is a collection type that employs the binary heap implementation to provide common operations !   for a priority queue.  The *PQBinHeap* type can be used as either a max-priority queue or a !   min-priority queue.  By default, it represents the max-priority queue.  However, a user may !   specify the optional *MinPQ* argument to true when constructing the collection so that the !   *PQBinHeap* type represents the min-priority queue instead. <br> !   The *PQBinHeap* type employs the *KeyOrdered* type to store comparable keys where allowed !   key types include the *CHARACTER*, *INTEGER* and *REAL* intrinsic types as well as any !   derived type that is in the *Comparable* class.  Like other collection types, it must be !   employed to store keys of only one particular data type.  To store keys of another data !   type, it must be destructed before inserting keys of different data type. <br> !   The *PQBinHeap* type is NOT an *ordered* collection type because its stored keys are only !   partially sorted in the so-called heap order, which also depends on the type of the !   priority queue it represents (i.e. max-priority or min-priority queue).  Therefore, the !   *PQBinHeap* type makes no guarantees as to the iteration order of its keys.  In particular, !   it does not guarantee that the order will remain the same over time. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 , ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_Object , ONLY : Object USE MClass_Comparable , ONLY : Comparable USE MClass_GenData , ONLY : IfacePolyCopy USE MClass_KeyOrdered USE MClass_CompNodePool USE MClass_MemoryPool USE MClass_BaseCollection USE MClass_BaseIterable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQBinHeap PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQBinHeap' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based collection #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS !> The *PQBinHeap* type is a collection type that employs a binary heap implementation !  to provide common operations for a priority queue. TYPE , EXTENDS ( BaseCollection ) :: PQBinHeap PRIVATE !> pointer to the last item of the priority queue tIndex :: Last = 0_kIndex !> flag indicating whether the priority queue is implemented as a maximum or a minimum PQ tLogical :: Min = FalseVal !> incremental size of the collection when the collection is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16_kIndex !> flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> stored keys in the priority queue. TYPE ( KeyOrdered ), ALLOCATABLE :: Keys (:) !> memory pool of stored items TYPE ( MemoryPool ) :: KeyPool !> key mold providing the type of stored keys CLASS ( * ), ALLOCATABLE :: Mold !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Private Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Growing => PQBinHeap_Growing PROCEDURE , PRIVATE :: Shrinking => PQBinHeap_Shrinking PROCEDURE , PRIVATE :: SinkDown => PQBinHeap_ReHeapify_TopDown PROCEDURE , PRIVATE :: SwimUp => PQBinHeap_ReHeapify_BottomUp PROCEDURE , PRIVATE :: IsKeyValid => PQBinHeap_IsKeyValid PROCEDURE , PRIVATE :: SwapKeys => PQBinHeap_SwapKeys PROCEDURE , PRIVATE :: PQBinHeap_ConstructorByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => PQBinHeap_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => PQBinHeap_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => PQBinHeap_Destruct !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => PQBinHeap_GetSize ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap)                         ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold <br> !   --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options <br> PROCEDURE :: CreateEmpty => PQBinHeap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL Collection%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> GENERIC :: Construct => PQBinHeap_ConstructorByArray !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key) <br> PROCEDURE :: Insert => PQBinHeap_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => PQBinHeap_RemoveKey !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%Peek(Key) <br> !   --->    IF (.NOT.Collection%Peek(Key)) DoSomething PROCEDURE :: Peek => PQBinHeap_PeekKey !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => PQBinHeap_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => PQBinHeap_GetAll !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) PROCEDURE :: StartFirst => PQBinHeap_Move2FirstKey !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => PQBinHeap_Move2NextKey ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => PQBinHeap_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => PQBinHeap_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => PQBinHeap_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => PQBinHeap_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => PQBinHeap_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQBinHeap_Finalizer ! --------------------------------------------------------------------- END TYPE PQBinHeap !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- SUBROUTINE PQBinHeap_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Cap , I !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( PQBinHeap ) DstObj % Last = SrcObj % Last DstObj % Min = SrcObj % Min DstObj % IncSize = SrcObj % IncSize DstObj % Shrink = SrcObj % Shrink IF ( ALLOCATED ( SrcObj % Keys )) THEN Cap = SIZE ( SrcObj % Keys , KIND = kIndex ) CALL MemAlloc ( DstObj % Keys , Cap ) DO I = 1_kIndex , Cap CALL SrcObj % Keys ( I )% Copy ( DstObj % Keys ( I )) END DO END IF CALL SrcObj % KeyPool % CloneTo ( DstObj % KeyPool ) IF ( ALLOCATED ( SrcObj % Mold )) ALLOCATE ( DstObj % Mold , MOLD = SrcObj % Mold ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'PQBinHeap_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE PQBinHeap_Copy !****************************************************************************** FUNCTION PQBinHeap_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( PQBinHeap ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN BLOCK tIndex :: I DO I = 1 , LhsObj % Last IF (. NOT . LhsObj % Keys ( I )% IsEqualTo ( RhsObj % Keys ( I ))) RETURN END DO END BLOCK END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION PQBinHeap_IsEqualTo !****************************************************************************** SUBROUTINE PQBinHeap_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the PQBinHeap object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! reset components Obj % Last = 0_kIndex Obj % IncSize = 16_kIndex Obj % Shrink = FalseVal Obj % Min = FalseVal Obj % Cursor = 0_kIndex ! free memory IF ( ALLOCATED ( Obj % Keys )) THEN DO I = 1_kIndex , SIZE ( Obj % Keys , KIND = kIndex ) CALL Obj % Keys ( I )% MemFree () END DO CALL MemFree ( Obj % Keys ) END IF IF ( ALLOCATED ( Obj % Mold )) DEALLOCATE ( Obj % Mold ) CALL Obj % KeyPool % Destruct () RETURN END SUBROUTINE PQBinHeap_MemFree !****************************************************************************** FUNCTION PQBinHeap_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the PQBinHeap type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 40_kIndex ) CALL ChrBuf % Append ( '[' ) Count = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Keys , KIND = kIndex ) ! skip if the item is empty IF ( Obj % Keys ( I )% IsEmpty ()) CYCLE ! add the string representation of the current item KeyStr = Obj % Keys ( I )% ToString () CALL ChrBuf % Append ( KeyStr ( 15 : LEN ( KeyStr ) - 1 )) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO ! add the closing character and get the base-string representation of this object CALL ChrBuf % Append ( ']' ) Str = ChrBuf % AsString () END BLOCK END IF Str = '{PQBinHeap with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION PQBinHeap_ToString !****************************************************************************** FUNCTION PQBinHeap_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK tIndex :: I Code = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Keys ) IF ( Obj % Keys ( I )% IsEmpty ()) CYCLE Code = Code + Obj % Keys ( I )% HashCode () END DO END BLOCK END IF RETURN END FUNCTION PQBinHeap_HashCode ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- SUBROUTINE PQBinHeap_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseIterable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( PQBinHeap ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! return if Other is empty IF ( Other % IsEmpty ()) RETURN SELECT TYPE ( Other ) CLASS IS ( PQBinHeap ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseIterable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: Item MoldPtr => Other % GetItemPtr () IF ( IsKeyOrdered ( MoldPtr )) THEN ALLOCATE ( Item , MOLD = MoldPtr ) ! loop through the other collection and get items along the way IsTheEnd = Other % StartFirst ( Item , ItemCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( Item ) IsTheEnd = Other % MoveForward ( Item , ItemCopy ) END DO DEALLOCATE ( Item ) ELSE CALL Handle_ErrLevel ( 'PQBinHeap_CopyCollection' , ModName , ErrSevere , & 'Item type of \"Other\" is NOT a valid key type.' ) END IF NULLIFY ( MoldPtr ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'PQBinHeap_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseIterable\" class.' ) END SELECT RETURN END SUBROUTINE PQBinHeap_CopyCollection !****************************************************************************** SUBROUTINE PQBinHeap_CreateEmpty ( Collection , InitCap , Mold , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( OUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: InitCap !! initial size of priority queue CLASS ( * ), OPTIONAL , INTENT ( IN ) :: Mold !! key mold tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; If present and true, the priority queue is a MinPQ. <br> !  Otherwise, the priority queue is a MaxPQ. <br> tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the collection capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQBinHeap_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity of priority queue to 16.' ) Capacity = Collection % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the keys in the priority queue CALL MemAlloc ( Collection % Keys , Capacity ) CALL Collection % KeyPool % Construct () ! set key mold IF ( PRESENT ( Mold )) ALLOCATE ( Collection % Mold , MOLD = Mold ) ! finally, check optional input data IF ( PRESENT ( MinPQ )) Collection % Min = MinPQ Collection % IncSize = 0_kIndex ! reset it to zero IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) Collection % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) Collection % Shrink = Shrink Collection % Cursor = 0_kIndex RETURN END SUBROUTINE PQBinHeap_CreateEmpty !****************************************************************************** SUBROUTINE PQBinHeap_ConstructorByArray ( Collection , N , Keys , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a priority queue from an array of key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of keys CLASS ( * ), INTENT ( IN ) :: Keys ( 1 : N ) !! key array tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! create empty collection InitCap = N * 2_kIndex ! by default, doubling its capacity IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) InitCap = N + IncSize END IF CALL Collection % CreateEmpty ( InitCap , Keys ( 1 ), MinPQ , IncSize , Shrink ) ! add input keys to the priority queue DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I )) END DO RETURN END SUBROUTINE PQBinHeap_ConstructorByArray !****************************************************************************** SUBROUTINE PQBinHeap_Destruct ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct PQBinHeap object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % MemFree () RETURN END SUBROUTINE PQBinHeap_Destruct !****************************************************************************** SUBROUTINE PQBinHeap_Clear ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the PQBinHeap object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! reset components Collection % Last = 0_kIndex Collection % Cursor = 0_kIndex ! free memory IF ( ALLOCATED ( Collection % Keys )) THEN DO I = 1_kIndex , SIZE ( Collection % Keys , KIND = kIndex ) CALL Collection % Keys ( I )% MemFree () END DO END IF IF ( ALLOCATED ( Collection % Mold )) DEALLOCATE ( Collection % Mold ) RETURN END SUBROUTINE PQBinHeap_Clear !****************************************************************************** SUBROUTINE PQBinHeap_Finalizer ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free up memory and reset components CALL Collection % Destruct () RETURN END SUBROUTINE PQBinHeap_Finalizer !****************************************************************************** SUBROUTINE PQBinHeap_InsertKey ( Collection , NewKey ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new key to the top (or bottom) of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: NewKey !! new key to be added to the priority queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether type of the specified item is valid or not IF (. NOT . Collection % IsKeyValid ( NewKey )) THEN CALL Handle_ErrLevel ( 'PQBinHeap_InsertKey' , ModName , ErrSevere , & 'Type of the specified key is either invalid or NOT the same as that of stored keys.' ) RETURN END IF ! first, grow the collection capacity if necessary CALL Collection % Growing () ! next, update pointer Collection % Last = Collection % Last + 1_kIndex ! then, add new key to the priority queue CALL Collection % Keys ( Collection % Last )% Set ( NewKey , Collection % KeyPool ) ! restore heap order CALL Collection % SwimUp ( Collection % Last ) #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( Collection , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQBinHeap_InsertKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif RETURN END SUBROUTINE PQBinHeap_InsertKey !****************************************************************************** FUNCTION PQBinHeap_RemoveKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved and removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( INOUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key is successfully retrieved and removed or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! first, check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the highest-priority key IF ( Collection % Keys ( 1 )% Get ( HPKey )) THEN !--- remove the highest-priority key from the queue --- ! set flag Success = TrueVal ! swap the highest-priority key with the last one CALL Collection % SwapKeys ( 1_kIndex , Collection % Last ) ! update pointer Collection % Last = Collection % Last - 1_kIndex ! restore heap order CALL Collection % SinkDown ( 1_kIndex , Collection % Last ) ! shrink the collection if necessary CALL Collection % Shrinking () #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( Collection , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQBinHeap_RemoveKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQBinHeap_RemoveKey' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as stored keys.' ) END IF RETURN END FUNCTION PQBinHeap_RemoveKey !****************************************************************************** FUNCTION PQBinHeap_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: Collection !! collection tIndex :: Size !! size (number of keys) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % Last RETURN END FUNCTION PQBinHeap_GetSize !****************************************************************************** FUNCTION PQBinHeap_PeekKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key is successfully retrieved or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the highest-priority key IF ( Collection % Keys ( 1 )% Get ( HPKey )) THEN ! set flag Success = TrueVal ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQBinHeap_PeekKey' , ModName , ErrWarning , & 'Type of the specified key is NOT the same as that of stored keys.' ) END IF RETURN END FUNCTION PQBinHeap_PeekKey !****************************************************************************** FUNCTION PQBinHeap_Move2FirstKey ( Collection , Key ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) key in a collection.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !% the first item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the table contains key or not <br> ! - true if the table is empty. <br> ! - otherwise the first key is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the collection is empty or not IsEmpty = Collection % IsEmpty () IF ( IsEmpty ) RETURN ! set cursor pointer Collection % Cursor = 1_kIndex IF ((. NOT . IsEmpty ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQBinHeap_Move2FirstKey' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQBinHeap_Move2FirstKey !****************************************************************************** FUNCTION PQBinHeap_Move2NextKey ( Collection , Key ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next key in a collection. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !% the next item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next key is NOT available. <br> ! - otherwise next key is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor pointer Collection % Cursor = Collection % Cursor + 1_kIndex ! set return flag IsTheEnd = ( Collection % Cursor > Collection % Last ) IF ((. NOT . IsTheEnd ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQBinHeap_Move2NextKey' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQBinHeap_Move2NextKey !****************************************************************************** FUNCTION PQBinHeap_ToArray ( Collection , Keys ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all keys from the collection.  Also, return ! a flag indicating whether the keys are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% PQBinHeap object CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> flag indicating whether the keys are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Success = Collection % GetAll ( Keys ) ! remove all keys from the collection IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION PQBinHeap_ToArray !************************************************************************************** FUNCTION PQBinHeap_GetAll ( Collection , Keys ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, ! return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% PQBinHeap object CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys ( 1 :) !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , MinSize ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN ELSE ! check whether type of the specified keys is valid or not IF (. NOT . Collection % IsKeyValid ( Keys ( 1 ))) THEN Success = FalseVal CALL Handle_ErrLevel ( 'PQBinHeap_GetAll' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as stored keys.' ) RETURN END IF END IF ! get keys from the collection MinSize = MIN ( Collection % Last , SIZE ( Keys , KIND = kIndex )) DO I = 1 , MinSize Success = Collection % Keys ( I )% Get ( Keys ( I )) IF (. NOT . Success ) EXIT END DO RETURN END FUNCTION PQBinHeap_GetAll ! ----------------------------------------------------------------------------- ! -----                     Auxiliary Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE PQBinHeap_Growing ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To increase the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity !** FLOW: IF (. NOT . ALLOCATED ( Collection % Keys )) THEN ! the collection has not yet been constructed. Capacity = 16_kIndex ! allocate storage for the collections' items CALL MemAlloc ( Collection % Keys , Capacity ) ELSE Capacity = SIZE ( Collection % Keys ) IF ( Collection % GetSize () == Capacity ) THEN ! increase the collection's capacity IF ( Collection % IncSize > 0_kIndex ) THEN Capacity = Capacity + Collection % IncSize ELSE Capacity = Capacity * 2_kIndex END IF ! check integer overflow IF ( Capacity <= 0_kIndex ) Capacity = MaxCapacity ! resize the collections' items CALL MemResize ( Collection % Keys , [ Capacity ]) END IF END IF RETURN END SUBROUTINE PQBinHeap_Growing !****************************************************************************** SUBROUTINE PQBinHeap_Shrinking ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurCap , CurSize !** FLOW: IF (. NOT . ALLOCATED ( Collection % Keys )) THEN ! the collection has not yet been constructed so simply return. RETURN END IF IF ( Collection % Shrink ) THEN CurCap = SIZE ( Collection % Keys ) CurSize = Collection % GetSize () IF (( CurSize >= 0_kIndex ). AND .( CurSize <= CurCap / 4_kIndex )) THEN ! halves the collection's capacity CurCap = CurCap / 2_kIndex ! check if the capacity is zero or not IF ( CurCap <= 0_kIndex ) CurCap = 1_kIndex ! resize the collections' items CALL MemResize ( Collection % Keys , [ CurCap ]) END IF END IF RETURN END SUBROUTINE PQBinHeap_Shrinking !****************************************************************************** SUBROUTINE PQBinHeap_ReHeapify_TopDown ( Collection , Start , Bottom ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by sinking down !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: Start !! starting index tIndex , INTENT ( IN ) :: Bottom !! ending index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyOrdered ) :: Temp tIndex :: I , J !** FLOW: ! initialize CALL Collection % Keys ( Start )% Copy ( Temp ) ! Temp = Collection%Keys(Start) I = Start J = I + I ! do while J <= Bottom IF ( Collection % Min ) THEN ! for MinPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( Collection % Keys ( J ) > Collection % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( Collection % Keys ( J ) >= Temp ) EXIT ! otherwise, demote key and continue. CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) I = J J = I + I END DO ELSE ! for MaxPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( Collection % Keys ( J ) < Collection % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( Collection % Keys ( J ) <= Temp ) EXIT ! otherwise, demote key and continue. CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) I = J J = I + I END DO END IF ! put key into its slot. CALL Temp % Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Temp RETURN END SUBROUTINE PQBinHeap_ReHeapify_TopDown !****************************************************************************** SUBROUTINE PQBinHeap_ReHeapify_BottomUp ( Collection , Start ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by swimming up. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: Start !! starting index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyOrdered ) :: Temp tIndex :: I , J !** FLOW: CALL Collection % Keys ( Start )% Copy ( Temp ) ! Temp = Collection%Keys(Start) I = Start J = I / 2 ! do while k > 1 and key(k/2) < key(k) IF ( Collection % Min ) THEN ! for MinPQ DO WHILE (( I > 1 ). AND .( Collection % Keys ( J ) > Temp )) ! promote key and continue. CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) I = J J = I / 2 END DO ELSE ! for MaxPQ DO WHILE (( I > 1 ). AND .( Collection % Keys ( J ) < Temp )) ! promote key and continue. CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) I = J J = I / 2 END DO END IF ! put key into its slot. CALL Temp % Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Temp RETURN END SUBROUTINE PQBinHeap_ReHeapify_BottomUp !****************************************************************************** RECURSIVE FUNCTION IsHeapOrdered ( Collection , Start ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether the heap is in order or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( IN ) :: Collection !! collection tIndex , INTENT ( IN ) :: Start !! starting index tLogical :: Flag !! true if the heap is in order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Left , Right !** FLOW: IF ( Start > Collection % Last ) THEN Flag = TrueVal RETURN END IF Left = Start + Start Right = Left + 1 IF ( Collection % Min ) THEN ! for MinPQ IF (( Left <= Collection % Last ) . AND . ( Collection % Keys ( Start ) > Collection % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= Collection % Last ) . AND . ( Collection % Keys ( Start ) > Collection % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF ELSE ! for MaxPQ IF (( Left <= Collection % Last ) . AND . ( Collection % Keys ( Start ) < Collection % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= Collection % Last ) . AND . ( Collection % Keys ( Start ) < Collection % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF END IF Flag = ( IsHeapOrdered ( Collection , Left ) . AND . IsHeapOrdered ( Collection , Right )) RETURN END FUNCTION IsHeapOrdered !****************************************************************************** FUNCTION PQBinHeap_IsKeyValid ( Collection , Key ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the type of specified key is valid or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! the key to be checked tLogical :: Valid !! true if type of the specified key is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the mold and the specified key have the same type or not IF ( ALLOCATED ( Collection % Mold )) THEN Valid = IsSameKeyOrdered ( Collection % Mold , Key ) ELSE ! this is the first key inserted so set it as the mold Valid = IsKeyOrdered ( Key ) IF ( Valid ) CALL Collection % CreateEmpty ( 16_kIndex , Mold = Key ) END IF RETURN END FUNCTION PQBinHeap_IsKeyValid !****************************************************************************** SUBROUTINE PQBinHeap_SwapKeys ( Collection , I , J ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To swap key I and key J. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQBinHeap ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: I , J !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyOrdered ) :: Temp ! FLOW CALL Collection % Keys ( I )% Copy ( Temp ) ! Temp = Collection%Keys(I) CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) CALL Temp % Copy ( Collection % Keys ( J )) ! Collection%Keys(J) = Temp RETURN END SUBROUTINE PQBinHeap_SwapKeys !****************************************************************************** END MODULE MClass_PQBinHeap !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqbinheap.f90.html"},{"title":"MClass_ListRealDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListRealDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListRealDP* type and related routines. !   The *ListRealDP* type is a container with *REAL(KIND=kDouble)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListRealDP* type but utilizes a different implementation. !   Also, unlike the *ListRealDP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListRealDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListRealDP #define DLLNode             DLLNodeRealDP #define ItemTypeA           REAL(KIND=kDouble) #define ItemTypeB           REAL(KIND=kDouble) #define ItemTypeC           REAL(KIND=kDouble) #define TypeOfItem          REAL(KIND=kDouble) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListRealDP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListRealDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listrealdp.f90.html"},{"title":"MClass_TreeInteger1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeInteger1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeInteger1B* type and its related helper type and routines. !   The *TreeInteger1B* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeInteger1B* !   type uses the Fortran intrinsic *INTEGER(KIND=kInt8)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeInteger1B* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeInteger1B* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeInteger1B* type but utilizes !   a different implementation.  Also, unlike the *TreeInteger1B* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeInteger1B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        INTEGER(KIND=kInt8) #define KeyTypeB        INTEGER(KIND=kInt8) #define KeyTypeC        INTEGER(KIND=kInt8) #define QueueKey        ListInteger1B #define QueueVal        ListAnyType #define RedBlackTree    TreeInteger1B !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeInteger1B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeInteger1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treeinteger1b.f90.html"},{"title":"MClass_DArrInteger1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrInteger1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrInteger1B* type and related routines. !   The *DArrInteger1B* type is a container with *INTEGER(KIND=kInt8)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrInteger1B* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrInteger1B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrInteger1B #define TypeAlloc       INTEGER(KIND=kInt8), ALLOCATABLE #define TypeArgmt       INTEGER(KIND=kInt8) #define TypeOfItem      INTEGER(KIND=kInt8) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrInteger1B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrInteger1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrinteger1b.f90.html"},{"title":"MClass_DArrLogical.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrLogical !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrLogical* type and related routines. !   The *DArrLogical* type is a container with *LOGICAL* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrLogical* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrLogical PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrLogical #define TypeAlloc       LOGICAL, ALLOCATABLE #define TypeArgmt       LOGICAL #define TypeOfItem      LOGICAL !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrLogical' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrLogical !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrlogical.f90.html"},{"title":"MBase_DoublyLinkedLists.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_DoublyLinkedLists !&#94;  **PURPOSE OF THIS MODULE**: <br> !   This module collectively contains *doubly-linked-list-based* types from other modules. !   It is provided so that a user can refer to this module instead of referring to several !   individual modules when various types are needed concurrently. <br> !   <br> !   **Overview**: <br> !   These doubly-linked-list-based types are container types that employ doubly-linked-list !   implementation.  Each individual type can be used to store items for a specific type !   where the type of stored items is one of Fortran intrinsic types or a derived type in !   the *Object* class (i.e. the *Object* type or its subtypes). <br> !   Available container types are: <br> !   - the <a href=\"../module/mclass_listcharacter.html#type-listcharacter\">ListCharacter</a> type !     for character string type, <br> !   - the <a href=\"../module/mclass_listcmpxsp.html#type-listcmpxsp\">ListCmpxSP</a> type !     for single-precision complex type, <br> !   - the <a href=\"../module/mclass_listcmpxdp.html#type-listcmpxdp\">ListCmpxDP</a> type !     for double-precision complex type, <br> !   - the <a href=\"../module/mclass_listcmpxqp.html#type-listcmpxqp\">ListCmpxQP</a> type !     for quadruple-precision complex type, <br> !   - the <a href=\"../module/mclass_listinteger1b.html#type-listinteger1b\">ListInteger1B</a> type !     for 1-byte (or 8-bit) integer type, <br> !   - the <a href=\"../module/mclass_listinteger2b.html#type-listinteger2b\">ListInteger2B</a> type !     for 2-byte (or 16-bit) integer type, <br> !   - the <a href=\"../module/mclass_listinteger4b.html#type-listinteger4b\">ListInteger4B</a> type !     for 4-byte (or 32-bit) integer type, <br> !   - the <a href=\"../module/mclass_listinteger8b.html#type-listinteger8b\">ListInteger8B</a> type !     for 8-byte (or 64-bit) integer type, <br> !   - the <a href=\"../module/mclass_listlogical.html#type-listlogical\">ListLogical</a> type !     for default logical type, <br> !   - the <a href=\"../module/mclass_listrealsp.html#type-listrealsp\">ListRealSP</a> type !     for single-precision real type, <br> !   - the <a href=\"../module/mclass_listrealdp.html#type-listrealdp\">ListRealDP</a> type !     for double-precision real type, <br> !   - the <a href=\"../module/mclass_listrealqp.html#type-listrealqp\">ListRealQP</a> type !     for quadruple-precision real type, and <br> !   - the <a href=\"../module/mclass_listobject.html#type-listobject\">ListObject</a> type !     for a derived type in the *Object* class, and <br> !   - the <a href=\"../module/mclass_listanytype.html#type-listanytype\">ListAnyType</a> type !     for any data type. <br> !   Each doubly-linked-list-based type can represent various forms of containers including: <br> !   - the last-in-first-out (LIFO) stack container, <br> !   - the first-in-first-out (FIFO) queue container, <br> !   - the double-ended queue (deque) container, and <br> !   - the list container where an item can be added, removed or retrieved !     at the (valid) specified index. <br> !   Each individual type provides various common operations that can be !   categorized as follows. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *Construct* method - method to construct the container from !     an array of items, and <br> !   - *Destruct* method - method to destruct the container by removing !     all items from the container. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *AddFirst* method - method to insert an item to the front of the container, <br> !   - *AddLast* method - method to insert an item to the end of the container, <br> !   - *AddAt* method - method to insert an item at the specified index, <br> !   - *RemoveFirst* method - method to get and remove the first item of the container, <br> !   - *RemoveLast* method - method to get and remove the last item of the container, <br> !   - *RemoveAt* method - method to get and remove an item at the specified index, <br> !   - *Remove* method - method to remove (and optionally get) either the last or !     the first item, <br> !   - *Delete* method - method to remove an item at the current iteration while !     performing an iteration over the container, <br> !   - *Clear* method - method to remove all items from the container. <br> !   - *ToArray* method - method to retrieve and then remove all items from the container. <br> !   - *RemoveDuplicates* method - method to remove duplicated items from the container, <br> !   - *Enqueue* method - same as the *AddLast* method provided when used as a queue, <br> !   - *Dequeue* method - same as the *RemoveFirst* method provided when used as a queue, <br> !   - *Push* method - same as the *AddLast* method provided when used as a stack, and <br> !   - *Pop* method - same as the *RemoveLast* method provided when used as a stack. <br> !   (3) Retrieval.  Methods for this operation include: <br> !   - *PeekFirst* method - method to retrieve the first item of the container, <br> !   - *PeekLast* method - method to retrieve the last item of the container, <br> !   - *PeekAt* method - method to retrieve the item at the specified index, <br> !   - *PeekTop* method - same as the *PeekLast* method provided when used as a stack, and <br> !   - *GetAll* method - method to retrieve all items from the container. <br> !   (4) Inquiry.  Methods for this operation include: <br> !   - *IsEmpty* method - method to check whether the container is empty or not, and <br> !   - *GetSize* method - method to get the container size (number of items stored). <br> !   (5) Iteration.  Methods for this operation include: <br> !   - *StartFirst* method - method to start a forward iteration over items, <br> !   - *MoveForward* method - method to move forward to the next item, <br> !   - *StartLast* method - method to start a backward iteration over items, and <br> !   - *MoveBackward* method - method to move backward to the next item. <br> !   <br> !   **Usage Notes**:  <br> !   The *doubly-linked-list-based* types provided in this module can be considered !   to be the same as those *dynamic-array-based* types provided in the !   <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> module !   although they employ different implementation.  However, the two groups of !   containers have some subtle differences as discussed below. <br> !   - Unlike the *dynamic-array-based* types, all *doubly-linked-list-based* types !     commonly do not require an explicit construction.  Items can be added via the !     *Construction* method (for an array of items) or they can be added by using !     one of the insertion methods provided.  Therefore, the *CreateEmpty* method used !     to construct an empty container is deemed unnecessary and thus NOT provided.  <br> !   - For *doubly-linked-list-based* types, the *Clear* method (which is used to remove !     all items from the container) is equivalent to the *Destruct* method (also used !     to remove all items from the container.  On the other hand, the two methods for !     the *dynamic-array-based* types are not equivalent because the *Destruct* method !     not only removes all items from the container but also performs deallocation of !     the *Items* component used to store items whereas the *Clear* method only removes !     all items from the container. <br> !   Besides methods just discussed above, all other operations provided by both groups !   of containers can be considered to be the same. !** USE STATEMENTS: USE MClass_ListCharacter USE MClass_ListCmpxSP USE MClass_ListCmpxDP USE MClass_ListCmpxQP USE MClass_ListInteger1B USE MClass_ListInteger2B USE MClass_ListInteger4B USE MClass_ListInteger8B USE MClass_ListLogical USE MClass_ListRealSP USE MClass_ListRealDP USE MClass_ListRealQP USE MClass_ListObject USE MClass_ListAnyType END MODULE MBase_DoublyLinkedLists","tags":"","loc":"sourcefile\\mbase_doublylinkedlists.f90.html"},{"title":"MClass_TreeRealQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeRealQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeRealQP* type and its related helper type and routines. !   The *TreeRealQP* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeRealQP* !   type uses the Fortran intrinsic *REAL(KIND=kQuad)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeRealQP* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeRealQP* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeRealQP* type but utilizes !   a different implementation.  Also, unlike the *TreeRealQP* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeRealQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        REAL(KIND=kQuad) #define KeyTypeB        REAL(KIND=kQuad) #define KeyTypeC        REAL(KIND=kQuad) #define QueueKey        ListRealQP #define QueueVal        ListAnyType #define RedBlackTree    TreeRealQP !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeRealQP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeRealQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treerealqp.f90.html"},{"title":"MBase_DynamicArrays.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_DynamicArrays !&#94;  **PURPOSE OF THIS MODULE**: <br> !   This module collectively contains *dynamic-array-based* types from other modules. !   It is provided so that a user can refer to this module instead of referring to several !   individual modules when various types are needed concurrently. <br> !   <br> !   **Overview**: <br> !   These dynamic-array-based types are container types that employ dynamic-array (or !   resizable-array) implementation.  Each individual type can be used to stored items !   for a specific type where the type of stored items is one of Fortran intrinsic types !   or a derived type in the *Object* class (i.e. the *Object* type or its subtypes). <br> !   Available container types are: <br> !   - the <a href=\"../module/mclass_darrcharacter.html#type-darrcharacter\">DArrCharacter</a> type !     for character string type, <br> !   - the <a href=\"../module/mclass_darrcmpxsp.html#type-darrcmpxsp\">DArrCmpxSP</a> type !     for single-precision complex type, <br> !   - the <a href=\"../module/mclass_darrcmpxdp.html#type-darrcmpxdp\">DArrCmpxDP</a> type !     for double-precision complex type, <br> !   - the <a href=\"../module/mclass_darrcmpxqp.html#type-darrcmpxqp\">DArrCmpxQP</a> type !     for quadruple-precision complex type, <br> !   - the <a href=\"../module/mclass_darrinteger1b.html#type-darrinteger1b\">DArrInteger1B</a> type !     for 1-byte (or 8-bit) integer type, <br> !   - the <a href=\"../module/mclass_darrinteger2b.html#type-darrinteger2b\">DArrInteger2B</a> type !     for 2-byte (or 16-bit) integer type, <br> !   - the <a href=\"../module/mclass_darrinteger4b.html#type-darrinteger4b\">DArrInteger4B</a> type !     for 4-byte (or 32-bit) integer type, <br> !   - the <a href=\"../module/mclass_darrinteger8b.html#type-darrinteger8b\">DArrInteger8B</a> type !     for 8-byte (or 64-bit) integer type, <br> !   - the <a href=\"../module/mclass_darrlogical.html#type-darrlogical\">DArrLogical</a> type !     for default logical type, <br> !   - the <a href=\"../module/mclass_darrrealsp.html#type-darrrealsp\">DArrRealSP</a> type !     for single-precision real type, <br> !   - the <a href=\"../module/mclass_darrrealdp.html#type-darrrealdp\">DArrRealDP</a> type !     for double-precision real type, <br> !   - the <a href=\"../module/mclass_darrrealqp.html#type-darrrealqp\">DArrRealQP</a> type !     for quadruple-precision real type, and <br> !   - the <a href=\"../module/mclass_darrobject.html#type-darrobject\">DArrObject</a> type !     for a derived type in the *Object* class. <br> !   Each dynamic-array-based type can represent various forms of containers including: <br> !   - the last-in-first-out (LIFO) stack container, <br> !   - the first-in-first-out (FIFO) queue container, <br> !   - the double-ended queue (deque) container, and <br> !   - the list container where an item can be added, removed or retrieved !     at the (valid) specified index. <br> !   Each individual type provides various common operations that can be !   categorized as follows. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *CreateEmpty* method - method to construct an empty container, <br> !   - *Construct* method - method to construct the container from !     an array of items, and <br> !   - *Destruct* method - method to destruct the container by removing all !     items from the container as well as freeing memory of its component used !     to store items. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *AddFirst* method - method to insert an item to the front of the container, <br> !   - *AddLast* method - method to insert an item to the end of the container, <br> !   - *AddAt* method - method to insert an item at the specified index, <br> !   - *RemoveFirst* method - method to get and remove the first item of the container, <br> !   - *RemoveLast* method - method to get and remove the last item of the container, <br> !   - *RemoveAt* method - method to get and remove an item at the specified index, <br> !   - *Delete* method - method to remove an item at the current iteration while !     performing an iteration over the container, <br> !   - *Clear* method - method to remove all items from the container. <br> !   - *ToArray* method - method to retrieve and then remove all items from the container. <br> !   - *Enqueue* method - same as the *AddLast* method provided when used as a queue, <br> !   - *Dequeue* method - same as the *RemoveFirst* method provided when used as a queue, <br> !   - *Push* method - same as the *AddLast* method provided when used as a stack, and <br> !   - *Pop* method - same as the *RemoveLast* method provided when used as a stack. <br> !   (3) Retrieval.  Methods for this operation include: <br> !   - *PeekFirst* method - method to retrieve the first item of the container, <br> !   - *PeekLast* method - method to retrieve the last item of the container, <br> !   - *PeekAt* method - method to retrieve the item at the specified index, <br> !   - *PeekTop* method - same as the *PeekLast* method provided when used as a stack, and <br> !   - *GetAll* method - method to retrieve all items from the container. <br> !   (4) Inquiry.  Methods for this operation include: <br> !   - *IsEmpty* method - method to check whether the container is empty or not, and <br> !   - *GetSize* method - method to get the container size (number of items stored). <br> !   (5) Iteration.  Methods for this operation include: <br> !   - *StartFirst* method - method to start a forward iteration over items, <br> !   - *MoveForward* method - method to move forward to the next item, <br> !   - *StartLast* method - method to start a backward iteration over items, and <br> !   - *MoveBackward* method - method to move backward to the next item. <br> !   <br> !   **Usage Notes**:  <br> !   The *dynamic-array-based* types provided in this module can be considered !   to be the same as those *doubly-linked-list-based* types provided in the !   <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> module !   although they employ different implementation.  However, the two groups of !   containers have some subtle differences as discussed below. <br> !   - Unlike the *doubly-linked-list-based* types, all *dynamic-array-based* types !     commonly require an explicit construction before using other provided operations. !     As shown above, there are two methods provided to create a container.  First, !     the *CreateEmpty* method constructs an empty container with the specified initial !     capacity.  Second, the *Construction* method constructs a container from an array !     of items.  <br> !   - Also, unlike *doubly-linked-list-based* types where the *Clear* method and the !     *Destruct* method are considered to be equivalent, the *Destruct* method of a !     *dynamic-array-based* type frees memory of its component used to store items !     in addition to removing all items from the container (which is the operation !     of the *Clear* method).  Therefore, after calling the *Destruct* method, a user !     must reconstruct the container (by calling either the *Construction* or the !     *CreateEmpty* method again) before using other operations once more.  Otherwise, !     the container's behavior may not be as expected (or the program may even crash). <br> !   Besides methods just discussed above, all other operations provided by both groups !   of containers can be considered to be the same. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy used !   for growing and shrinking a resizable array, which is similar to the strategy !   employed by all *dynamic-array-based* types provided in this module.  It should !   be noted that all *dynamic-array-based* types provided in the *MClass_DynamicArrays* !   module are functionally similar to those provided in this module.  However, each !   individual type provided in this module can only be used for a specific type of !   items to be stored whereas each individual type in the *MClass_DynamicArrays* !   is a generic container that can be used for various types of items to be stored !   providing that the size (in bytes) of the data item to be stored is known at !   compile time. !** USE STATEMENTS: USE MClass_DArrCharacter USE MClass_DArrCmpxSP USE MClass_DArrCmpxDP USE MClass_DArrCmpxQP USE MClass_DArrInteger1B USE MClass_DArrInteger2B USE MClass_DArrInteger4B USE MClass_DArrInteger8B USE MClass_DArrLogical USE MClass_DArrRealSP USE MClass_DArrRealDP USE MClass_DArrRealQP USE MClass_DArrObject END MODULE MBase_DynamicArrays","tags":"","loc":"sourcefile\\mbase_dynamicarrays.f90.html"},{"title":"MClass_DArrInteger8B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrInteger8B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrInteger8B* type and related routines. !   The *DArrInteger8B* type is a container with *INTEGER(KIND=kInt64)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrInteger8B* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrInteger8B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrInteger8B #define TypeAlloc       INTEGER(KIND=kInt64), ALLOCATABLE #define TypeArgmt       INTEGER(KIND=kInt64) #define TypeOfItem      INTEGER(KIND=kInt64) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrInteger8B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrInteger8B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrinteger8b.f90.html"},{"title":"MClass_ListLogical.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListLogical !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListLogical* type and related routines. !   The *ListLogical* type is a container with *LOGICAL* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListLogical* type but utilizes a different implementation. !   Also, unlike the *ListLogical* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListLogical PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A .EQV. B) #define DblLnkList          ListLogical #define DLLNode             DLLNodeLogical #define ItemTypeA           LOGICAL #define ItemTypeB           LOGICAL #define ItemTypeC           LOGICAL #define TypeOfItem          LOGICAL !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListLogical' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListLogical !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listlogical.f90.html"},{"title":"MClass_HTabRealDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabRealDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabRealDP* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabRealDP* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabRealDP* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabRealDP* type uses the Fortran intrinsic !   *REAL(KIND=kDouble)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabRealDP* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabRealDP* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabRealDP #define     KeyTypeA        REAL(KIND=kDouble) #define     KeyTypeB        REAL(KIND=kDouble) #define     QueueKey        ListRealDP #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabRealDP PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabRealDP' tSInt64 , PARAMETER :: INFVAL = ToInt64 ( Z '7FF0000000000000' ) ! positive infinity tSInt64 , PARAMETER :: NANVAL = ToInt64 ( Z '7FF8000000000000' ) ! quiet NAN ! Special marker token used to indicate the deletion of a key-value pair tRealDP , PARAMETER :: DELKEY = TRANSFER ( INFVAL , 1.0_kDouble ) ! Special marker token used to indicate the empty of a key-value pair tRealDP , PARAMETER :: NULKEY = TRANSFER ( NANVAL , 1.0_kDouble ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabRealDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabrealdp.f90.html"},{"title":"MClass_BaseCollection.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_BaseCollection !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *BaseCollection* type and its related routines.  The *BaseCollection* !   type is an abstract data type (ADT) representing a collection, which is a group of objects, !   known as its items or elements.  Some collections allow duplicate elements while others do not. !   Some are ordered collections and others are unordered collections. <br> !   The *BaseCollection* type defines an application programming interface (API) for various common !   operations.  All other collection types should extend from this base type. <br> !   It is important to note that the *BaseCollection* type is a subtype of the *Object* type. !   Therefore, it inherits all deferred procedures required by a subtype of the *Object* type. <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Object USE MClass_GenData , ONLY : IfacePolyCopy IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: BaseCollection PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_BaseCollection' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE !> The *BaseCollection* type is an abstract collection type that defines !  an API for various common operations.  Some operations are deferred !  while others (with default implementation) can be overridden. TYPE , ABSTRACT , EXTENDS ( Object ) :: BaseCollection CONTAINS ! --------------------------------------------------------------------- ! -----                     Deferred Procedures                   ----- ! --------------------------------------------------------------------- !> *CopyCollection* is a deferred procedure to construct a new collection from another !   collection.  Use the *Construct* method in place of this method. <br> PROCEDURE ( IfaceCreate ), DEFERRED :: CopyCollection !> *Clear* is a deferred procedure to remove all items from the collection. <br> PROCEDURE ( IfaceClear ), DEFERRED :: Clear !> *Destruct* is a deferred procedure to remove all items from the collection and free !   memory storage of items stored in the collection. <br> PROCEDURE ( IfaceDestroy ), DEFERRED :: Destruct !> *GetSize* is a deferred procedure to get the current size of the collection. PROCEDURE ( IfaceSize ), DEFERRED :: GetSize ! --------------------------------------------------------------------- ! -----                     Public Procedures                     ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection. <br> !  **Usage**: <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => CopyCollection !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => BaseCollection_IsEmpty ! --------------------------------------------------------------------- END TYPE BaseCollection !** INTERFACE DEFINITIONS: ! abstract interface for Collection ABSTRACT INTERFACE !> *IfaceCreate* is an interface for a procedure to creates a new collection (This) with !  the same items as the given collection (Other).  In essence, this is a constructor !  that allows the user to copy items from any collection. <br> !  It should be noted that this procedure is slightly different from the *Copy* method !  inherited from the *Object* type such that types of *This* and *Other* collections !  can be different whereas types of *SrcObj* and *DstObj* objects must be the same. <br> SUBROUTINE IfaceCreate ( This , Other , ItemCopy , ValCopy ) IMPORT CLASS ( BaseCollection ), INTENT ( INOUT ) :: This !! collection to be created CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !! collection to be copied from !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy END SUBROUTINE !> *IfaceClear* is an interface for a procedure to remove all items from the collection. SUBROUTINE IfaceClear ( Collection ) IMPORT CLASS ( BaseCollection ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE !> *IfaceDestroy* is an interface for a procedure to destruct the collection where items !  are all removed first (this operation is essentially the same as that of the *Clear* !  method) and the storage of those items are then freed.   For the second operation, !  this may also be done by the *Clear* method for some collections.  However, for others !  (such as dynamic-array-based collections), this must only be done by this procedure. SUBROUTINE IfaceDestroy ( Collection ) IMPORT CLASS ( BaseCollection ), INTENT ( INOUT ) :: Collection !! collection object END SUBROUTINE !> *IfaceSize* is an interface for a procedure to get the current size of the collection, !   which represents the number of items currently stored in the collection. FUNCTION IfaceSize ( Collection ) RESULT ( Size ) IMPORT CLASS ( BaseCollection ), INTENT ( IN ) :: Collection !! collection object tIndex :: Size !! collection size END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): FUNCTION BaseCollection_IsEmpty ( Collection ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !! To check whether the collection is currently empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( BaseCollection ), INTENT ( IN ) :: Collection !! collection object tLogical :: Flag !! true if the collection currently contains no item. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Collection % GetSize () == 0 ) RETURN END FUNCTION BaseCollection_IsEmpty !****************************************************************************** END MODULE MClass_BaseCollection !******************************************************************************","tags":"","loc":"sourcefile\\mclass_basecollection.f90.html"},{"title":"MClass_PQRealQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQRealQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQRealQP* type and its related routines. !   The *PQRealQP* type is a priority-queue container with *REAL(KIND=kQuad)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQRealQP* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQRealQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     REAL(KIND=kQuad) #define     PQHeap      PQRealQP !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQRealQP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQRealQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqrealqp.f90.html"},{"title":"MBase_BalancedTrees.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_BalancedTrees !&#94;  **PURPOSE OF THIS MODULE**: <br> !   This module collectively contains *balanced-tree-based* types from other modules. !   It is provided so that a user can refer to this module instead of referring to several !   individual modules when various types are needed concurrently. <br> !   <br> !   **Overview**: <br> !   These balanced-tree-based types are container types that employ a balanced binary-search-tree !   (BST) implementation to provide common operations for an ordered symbol table.  Specifically, !   all balanced-tree-based types provided here utilize a left-leaning red-black (RB) tree as the !   balanced BST.  Each individual type can be used to store key-value pairs for a specific type !   of keys where the type of stored keys is one of Fortran intrinsic *comparable* types (i.e. !   CHARACTER, INTEGER and REAL) or a derived type in the *Comparable* class (i.e. the *Comparable* !   type or its subtypes).  Most of the balanced-tree-based types (except the *TreeComparable* type) !   use an unlimited polymorphic type to store values; therefore, inserted values can have any types. !   Unlike other balanced-tree-based types, the *TreeComparable* type uses the *Comparable* type to !   represent a key-value pair and requires only one argument (instead of two) when inserting or !   retrieving the key and its associated value.  Therefore, its application programming interface !   (API) is slightly different from the API of other balanced-tree-based types.  <br> !   Available balanced-tree-based container types include: <br> !   - the <a href=\"../module/mclass_treecharacter.html#type-treecharacter\">TreeCharacter</a> type !     for character string key type, <br> !   - the <a href=\"../module/mclass_treeinteger1b.html#type-treeinteger1b\">TreeInteger1B</a> type !     for 1-byte (or 8-bit) integer key type, <br> !   - the <a href=\"../module/mclass_treeinteger2b.html#type-treeinteger2b\">TreeInteger2B</a> type !     for 2-byte (or 16-bit) integer key type, <br> !   - the <a href=\"../module/mclass_treeinteger4b.html#type-treeinteger4b\">TreeInteger4B</a> type !     for 4-byte (or 32-bit) integer key type, <br> !   - the <a href=\"../module/mclass_treeinteger8b.html#type-treeinteger8b\">TreeInteger8B</a> type !     for 8-byte (or 64-bit) integer key type, <br> !   - the <a href=\"../module/mclass_treerealsp.html#type-treerealsp\">TreeRealSP</a> type !     for single-precision real key type, <br> !   - the <a href=\"../module/mclass_treerealdp.html#type-treerealdp\">TreeRealDP</a> type !     for double-precision real key type, <br> !   - the <a href=\"../module/mclass_treerealqp.html#type-treerealqp\">TreeRealQP</a> type !     for quadruple-precision real key type, <br> !   - the <a href=\"../module/mclass_treecomparable.html#type-treecomparable\">TreeComparable</a> !     type for type of key-value pair in *Comparable* class. <br> !   Each balanced-tree-based container type represents an ordered symbol table where various common operations !   are provided and can be categorized as follows. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *Construct* method - method to construct the container from arrays of keys and values, and <br> !   - *Destruct* method - method to destruct the container by removing all key-value pairs from !       the container. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *Insert* method - method to insert a key and its associated value into the container, <br> !   - *Remove* method - method to remove a key (and its associated value) from the container, <br> !   - *RemoveMin* method - method to remove (and optionally retrieve) the smallest key-value pair, and <br> !   - *RemoveMax* method - method to remove (and optionally retrieve) the largest key-value pair. <br> !   (3) Retrieval.  Methods for this operation include: <br> !   - *GetMinKey* method - method to retrieve the smallest key-value pair of the container, <br> !   - *GetMaxKey* method - method to retrieve the largest key-value of the container, <br> !   - *GetKeys* method - method to retrieve all keys (in the tree or in the specified range) and !       their associated values, <br> !   - *Floor* method - method to retrieve the largest key (and a value associated with it) in the !       tree less than or equal to the given key. <br> !   - *Ceiling* method - method to retrieve the smallest key (and a value associated with it) in !       the tree greater than or equal to the given key, and <br> !   - *Select* method - method to retrieve the key-value pair of the specified rank. <br> !   (4) Inquiry.  Methods for this operation include: <br> !   - *IsEmpty* method - method to check whether the container is empty or not, <br> !   - *Contain* method - method to check whether the specified key is in the container or not, <br> !   - *GetSize* method - method to get the container size (number of key-value pairs stored), <br> !   - *GetRangeSize* method - method to get the number of key-value pairs in the specified range, and <br> !   - *GetRank* method - method to get the number of keys in the tree strictly less than the given key. <br> !   (5) Iteration.  Methods for this operation include: <br> !   - *StartFirst* method - method to start a forward iteration over key-value pairs, <br> !   - *MoveForward* method - method to move forward to the next key-value pair, <br> !   - *StartLast* method - method to start a backward iteration over key-value pairs, and <br> !   - *MoveBackward* method - method to move backward to the next key-value pair. <br> !** USE STATEMENTS: USE MClass_TreeCharacter USE MClass_TreeInteger1B USE MClass_TreeInteger2B USE MClass_TreeInteger4B USE MClass_TreeInteger8B USE MClass_TreeRealSP USE MClass_TreeRealDP USE MClass_TreeRealQP USE MClass_TreeComparable END MODULE MBase_BalancedTrees","tags":"","loc":"sourcefile\\mbase_balancedtrees.f90.html"},{"title":"MClass_PQMinMax.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQMinMax !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQMinMax* type and its related routines.  The *PQMinMax* type is !   a collection type that employs an elementary implementation (where its array representation !   is ordered using a sorting algorithm) to provide common operations for a priority queue. !   The *PQMinMax* type is a generalized priority queue that offers combined operations of a !   max-priority queue and a min-priority queue. <br> !   The *PQMinMax* type employs the *KeyOrdered* type to store comparable keys where allowed key !   types include the *CHARACTER*, *INTEGER* and *REAL* intrinsic types as well as any derived !   type that is in the *Comparable* class.  Like other collection types, it must be employed to !   store keys of only one particular data type.  To store keys of another data type, it must be !   destructed before inserting keys of different data type. <br> !   As an *ordered* collection type, the *PQMinMax* type provides an ordered iteration over its !   stored keys, which are sorted according to the natural ordering of its keys.  The *StartMin* !   method (or the *StartMax* method) must first be called to start an iteration for an ascending !   order (or for an descending order).  The *MoveUp* method (or the *MoveDown* method) can then !   be called repeatedly to move to the next keys with lower priorities in the desired order. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 , ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_Object , ONLY : Object , ASSIGNMENT ( = ) USE MClass_Comparable , ONLY : Comparable USE MClass_GenData , ONLY : IfacePolyCopy USE MClass_KeyOrdered USE MClass_CompNodePool USE MClass_MemoryPool USE MClass_BaseCollection USE MClass_BaseIterable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQMinMax PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQMinMax' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based collection #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS !> The *PQMinMax* type is a collection type that employs an ordered array implementation !  to provide common operations for a generalized priority queue. TYPE , EXTENDS ( BaseCollection ) :: PQMinMax PRIVATE !> pointer to the last item of the priority queue tIndex :: Last = 0_kIndex !> flag indicating whether the priority queue is implemented as a maximum or a minimum PQ tLogical :: Min = FalseVal !> incremental size of the collection when the collection is full. !  Its value will be reset to 0 if the optional input is NOT !  specified during construction tIndex :: IncSize = 16_kIndex !> flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> stored keys in the priority queue. TYPE ( KeyOrdered ), ALLOCATABLE :: Keys (:) !> memory pool of stored items TYPE ( MemoryPool ) :: KeyPool !> key mold providing the type of stored keys CLASS ( * ), ALLOCATABLE :: Mold !> pointer to current item of the iteration tIndex :: Cursor = 0_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Private Procedures                   ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: Growing => PQMinMax_Growing PROCEDURE , PRIVATE :: Shrinking => PQMinMax_Shrinking PROCEDURE , PRIVATE :: IsKeyValid => PQMinMax_IsKeyValid PROCEDURE , PRIVATE :: SwapKeys => PQMinMax_SwapKeys PROCEDURE , PRIVATE :: PQMinMax_ConstructorByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => PQMinMax_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => PQMinMax_Clear !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> !  **Note**:  This method is NOT equivalent to the *Clear* method. <br> PROCEDURE :: Destruct => PQMinMax_Destruct !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => PQMinMax_GetSize ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty(InitCap)                         ! use default options  <br> !   --->    CALL Table%CreateEmpty(32, Mold=KeyMold)                ! specify key mold <br> !   --->    CALL Table%CreateEmpty(32, MinPQ=.TRUE.)                ! use min-priority queue <br> !   --->    CALL Table%CreateEmpty(32, IncSize=16)                  ! specify incremental size <br> !   --->    CALL Table%CreateEmpty(32, Shrink=.TRUE.)               ! specify shrinking <br> !   --->    CALL Table%CreateEmpty(32, KeyMold, .TRUE., 16, .TRUE.) ! specify all options <br> PROCEDURE :: CreateEmpty => PQMinMax_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL Collection%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL Collection%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> GENERIC :: Construct => PQMinMax_ConstructorByArray !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key) <br> PROCEDURE :: Insert => PQMinMax_InsertKey !> **Type-Bound Function**: RemoveMin <br> !  **Purpose**:  To retrieve and remove the minimum key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMin(MinKey) <br> !   --->    IF (.NOT.Collection%RemoveMin(MinKey)) DoSomething PROCEDURE :: RemoveMin => PQMinMax_RemoveMinKey !> **Type-Bound Function**: RemoveMax <br> !  **Purpose**:  To retrieve and remove the maximum key from the priority queue.  Also, !       return a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%RemoveMax(MaxKey) <br> !   --->    IF (.NOT.Collection%RemoveMax(MaxKey)) DoSomething PROCEDURE :: RemoveMax => PQMinMax_RemoveMaxKey !> **Type-Bound Function**: PeekMin <br> !  **Purpose**:  To retrieve the minimum key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%PeekMin(MinKey) <br> !   --->    IF (.NOT.Collection%PeekMin(MinKey)) DoSomething PROCEDURE :: PeekMin => PQMinMax_PeekMinKey !> **Type-Bound Function**: PeekMax <br> !  **Purpose**:  To retrieve the maximum key from the priority queue.  Also, return !       a flag indicating whether the key is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = Collection%PeekMax(MaxKey) <br> !   --->    IF (.NOT.Collection%PeekMax(MaxKey)) DoSomething PROCEDURE :: PeekMax => PQMinMax_PeekMaxKey !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !                indicating whether the items are successfully removed. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items, IsDescend=.TRUE.)) DoSomething PROCEDURE :: ToArray => PQMinMax_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are available. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items, IsDescend=.TRUE.)) DoSomething PROCEDURE :: GetAll => PQMinMax_GetAll !> **Type-Bound Function**: StartMin <br> !  **Purpose**:  To start the *ascending* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartMin() <br> !   --->    IsEmpty = Collection%StartMin(MinKey) PROCEDURE :: StartMin => PQMinMax_Move2MinKey !> **Type-Bound Function**: StartMax <br> !  **Purpose**:  To start the *descending* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartMax() <br> !   --->    IsEmpty = Collection%StartMax(MaxKey) PROCEDURE :: StartMax => PQMinMax_Move2MaxKey !> **Type-Bound Function**: MoveUp <br> !  **Purpose**:  To move to the next iteration in ascending order and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveUp() <br> !   --->    IsTheEnd = Collection%MoveUp(NextKey) <br> PROCEDURE :: MoveUp => PQMinMax_MoveUpNext !> **Type-Bound Function**: MoveDown <br> !  **Purpose**:  To move to the next iteration in descending order and return a flag !                indicating whether the cursor pointer has reached the end of the !                collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveDown() <br> !   --->    IsTheEnd = Collection%MoveDown(NextKey) <br> PROCEDURE :: MoveDown => PQMinMax_MoveDownNext ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => PQMinMax_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => PQMinMax_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => PQMinMax_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => PQMinMax_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => PQMinMax_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQMinMax_Finalizer ! --------------------------------------------------------------------- END TYPE PQMinMax !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- SUBROUTINE PQMinMax_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Cap , I !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( PQMinMax ) DstObj % Last = SrcObj % Last DstObj % Min = SrcObj % Min DstObj % IncSize = SrcObj % IncSize DstObj % Shrink = SrcObj % Shrink IF ( ALLOCATED ( SrcObj % Keys )) THEN Cap = SIZE ( SrcObj % Keys , KIND = kIndex ) CALL MemAlloc ( DstObj % Keys , Cap ) DO I = 1_kIndex , Cap CALL SrcObj % Keys ( I )% Copy ( DstObj % Keys ( I )) END DO END IF CALL SrcObj % KeyPool % CloneTo ( DstObj % KeyPool ) IF ( ALLOCATED ( SrcObj % Mold )) ALLOCATE ( DstObj % Mold , MOLD = SrcObj % Mold ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'PQMinMax_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE PQMinMax_Copy !****************************************************************************** FUNCTION PQMinMax_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( PQMinMax ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN BLOCK tIndex :: I DO I = 1 , LhsObj % Last IF (. NOT . LhsObj % Keys ( I )% IsEqualTo ( RhsObj % Keys ( I ))) RETURN END DO END BLOCK END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION PQMinMax_IsEqualTo !****************************************************************************** SUBROUTINE PQMinMax_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the PQMinMax object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! reset components Obj % Last = 0_kIndex Obj % IncSize = 16_kIndex Obj % Shrink = FalseVal Obj % Min = FalseVal Obj % Cursor = 0_kIndex ! free memory IF ( ALLOCATED ( Obj % Keys )) THEN DO I = 1_kIndex , SIZE ( Obj % Keys , KIND = kIndex ) CALL Obj % Keys ( I )% MemFree () END DO CALL MemFree ( Obj % Keys ) END IF IF ( ALLOCATED ( Obj % Mold )) DEALLOCATE ( Obj % Mold ) CALL Obj % KeyPool % Destruct () RETURN END SUBROUTINE PQMinMax_MemFree !****************************************************************************** FUNCTION PQMinMax_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the PQMinMax type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 40_kIndex ) CALL ChrBuf % Append ( '[' ) Count = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Keys , KIND = kIndex ) ! skip if the item is empty IF ( Obj % Keys ( I )% IsEmpty ()) CYCLE ! add the string representation of the current item KeyStr = Obj % Keys ( I )% ToString () CALL ChrBuf % Append ( KeyStr ( 15 : LEN ( KeyStr ) - 1 )) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO ! add the closing character and get the base-string representation of this object CALL ChrBuf % Append ( ']' ) Str = ChrBuf % AsString () END BLOCK END IF Str = '{PQMinMax with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION PQMinMax_ToString !****************************************************************************** FUNCTION PQMinMax_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK tIndex :: I Code = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Keys ) IF ( Obj % Keys ( I )% IsEmpty ()) CYCLE Code = Code + Obj % Keys ( I )% HashCode () END DO END BLOCK END IF RETURN END FUNCTION PQMinMax_HashCode ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- SUBROUTINE PQMinMax_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseIterable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( PQMinMax ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! return if Other is empty IF ( Other % IsEmpty ()) RETURN SELECT TYPE ( Other ) CLASS IS ( PQMinMax ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseIterable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: Item MoldPtr => Other % GetItemPtr () IF ( IsKeyOrdered ( MoldPtr )) THEN ALLOCATE ( Item , MOLD = MoldPtr ) ! loop through the other collection and get items along the way IsTheEnd = Other % StartFirst ( Item , ItemCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( Item ) IsTheEnd = Other % MoveForward ( Item , ItemCopy ) END DO DEALLOCATE ( Item ) ELSE CALL Handle_ErrLevel ( 'PQMinMax_CopyCollection' , ModName , ErrSevere , & 'Item type of \"Other\" is NOT a valid key type.' ) END IF NULLIFY ( MoldPtr ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'PQMinMax_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseIterable\" class.' ) END SELECT RETURN END SUBROUTINE PQMinMax_CopyCollection !****************************************************************************** SUBROUTINE PQMinMax_CreateEmpty ( Collection , InitCap , Mold , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( OUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: InitCap !! initial size of priority queue CLASS ( * ), OPTIONAL , INTENT ( IN ) :: Mold !! key mold tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; If present and true, the priority queue is a MinPQ. <br> !  Otherwise, the priority queue is a MaxPQ. <br> tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; flag to shrink the collection capacity <br> ! - true if want to reduce capacity when the size is less than a quarter of the capacity. <br> ! - otherwise, the capacity stays the same. <br> ! - default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQMinMax_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity of priority queue to 16.' ) Capacity = Collection % IncSize ELSE Capacity = InitCap END IF ! then, allocate space for the keys in the priority queue CALL MemAlloc ( Collection % Keys , Capacity ) CALL Collection % KeyPool % Construct () ! set key mold IF ( PRESENT ( Mold )) ALLOCATE ( Collection % Mold , MOLD = Mold ) ! finally, check optional input data IF ( PRESENT ( MinPQ )) Collection % Min = MinPQ Collection % IncSize = 0_kIndex ! reset it to zero IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) Collection % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) Collection % Shrink = Shrink Collection % Cursor = 0_kIndex RETURN END SUBROUTINE PQMinMax_CreateEmpty !****************************************************************************** SUBROUTINE PQMinMax_ConstructorByArray ( Collection , N , Keys , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a priority queue from an array of key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of keys CLASS ( * ), INTENT ( IN ) :: Keys ( 1 : N ) !! key array tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! create empty collection InitCap = N * 2_kIndex ! by default, doubling its capacity IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) InitCap = N + IncSize END IF CALL Collection % CreateEmpty ( InitCap , Keys ( 1 ), MinPQ , IncSize , Shrink ) ! add input keys to the priority queue DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I )) END DO RETURN END SUBROUTINE PQMinMax_ConstructorByArray !****************************************************************************** SUBROUTINE PQMinMax_Destruct ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct PQMinMax object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % MemFree () RETURN END SUBROUTINE PQMinMax_Destruct !****************************************************************************** SUBROUTINE PQMinMax_Clear ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To clear the PQMinMax object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! reset components Collection % Last = 0_kIndex Collection % Cursor = 0_kIndex ! free memory IF ( ALLOCATED ( Collection % Keys )) THEN DO I = 1_kIndex , SIZE ( Collection % Keys , KIND = kIndex ) CALL Collection % Keys ( I )% MemFree () END DO END IF IF ( ALLOCATED ( Collection % Mold )) DEALLOCATE ( Collection % Mold ) RETURN END SUBROUTINE PQMinMax_Clear !****************************************************************************** SUBROUTINE PQMinMax_Finalizer ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free up memory and reset components CALL Collection % Destruct () RETURN END SUBROUTINE PQMinMax_Finalizer !****************************************************************************** SUBROUTINE PQMinMax_InsertKey ( Collection , NewKey ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new key to the top (or bottom) of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: NewKey !! new key to be added to the priority queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether type of the specified item is valid or not IF (. NOT . Collection % IsKeyValid ( NewKey )) THEN CALL Handle_ErrLevel ( 'PQMinMax_InsertKey' , ModName , ErrSevere , & 'Type of the specified key is either invalid or NOT the same as that of stored keys.' ) RETURN END IF ! first, grow the collection capacity if necessary CALL Collection % Growing () ! next, update pointer Collection % Last = Collection % Last + 1_kIndex ! then, add new key to the priority queue CALL Collection % Keys ( Collection % Last )% Set ( NewKey , Collection % KeyPool ) ! sort the keys CALL SortAscend ( Collection % Keys ( 1 : Collection % Last )) RETURN END SUBROUTINE PQMinMax_InsertKey !****************************************************************************** FUNCTION PQMinMax_RemoveMinKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the minimum key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved and removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( INOUT ) :: HPKey !! the minimum key !> flag indicating whether the specified key is successfully retrieved and removed or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! first, check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the minimum key IF ( Collection % Keys ( 1 )% Get ( HPKey )) THEN !--- remove the minimum key from the queue --- ! set flag Success = TrueVal ! swap the minimum key with the last one CALL Collection % SwapKeys ( 1_kIndex , Collection % Last ) ! update pointer Collection % Last = Collection % Last - 1_kIndex ! sort the keys CALL SortAscend ( Collection % Keys ( 1 : Collection % Last )) ! shrink the collection if necessary CALL Collection % Shrinking () ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQMinMax_RemoveMinKey' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as stored keys.' ) END IF RETURN END FUNCTION PQMinMax_RemoveMinKey !****************************************************************************** FUNCTION PQMinMax_RemoveMaxKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the maximum key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved and removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( INOUT ) :: HPKey !! the maximum key !> flag indicating whether the specified key is successfully retrieved and removed or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! first, check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the maximum key IF ( Collection % Keys ( Collection % Last )% Get ( HPKey )) THEN !--- remove the maximum key from the queue --- ! set flag Success = TrueVal ! update pointer Collection % Last = Collection % Last - 1_kIndex ! shrink the collection if necessary CALL Collection % Shrinking () ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQMinMax_RemoveMaxKey' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as stored keys.' ) END IF RETURN END FUNCTION PQMinMax_RemoveMaxKey !****************************************************************************** FUNCTION PQMinMax_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( IN ) :: Collection !! collection tIndex :: Size !! size (number of keys) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % Last RETURN END FUNCTION PQMinMax_GetSize !****************************************************************************** FUNCTION PQMinMax_PeekMinKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the minimum key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( OUT ) :: HPKey !! the minimum key !> flag indicating whether the specified key is successfully retrieved or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the minimum key IF ( Collection % Keys ( 1 )% Get ( HPKey )) THEN ! set flag Success = TrueVal ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQMinMax_PeekMinKey' , ModName , ErrWarning , & 'Type of the specified key is NOT the same as that of stored keys.' ) END IF RETURN END FUNCTION PQMinMax_PeekMinKey !****************************************************************************** FUNCTION PQMinMax_PeekMaxKey ( Collection , HPKey ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the maximum key from the priority queue.  Also, return !  a flag indicating whether the key is successfully retrieved or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( OUT ) :: HPKey !! the maximum key !> flag indicating whether the specified key is successfully retrieved or not. tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the priority queue is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN END IF ! get the maximum key IF ( Collection % Keys ( Collection % Last )% Get ( HPKey )) THEN ! set flag Success = TrueVal ELSE ! set flag Success = FalseVal ! warning of mismatch types CALL Handle_ErrLevel ( 'PQMinMax_PeekMaxKey' , ModName , ErrWarning , & 'Type of the specified key is NOT the same as that of stored keys.' ) END IF RETURN END FUNCTION PQMinMax_PeekMaxKey !****************************************************************************** FUNCTION PQMinMax_Move2MinKey ( Collection , Key ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the minimum (starting) key in a collection.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !% the minimum key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the table contains key or not <br> ! - true if the table is empty. <br> ! - otherwise the minimu key is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the collection is empty or not IsEmpty = Collection % IsEmpty () IF ( IsEmpty ) RETURN ! set cursor pointer Collection % Cursor = 1_kIndex IF ((. NOT . IsEmpty ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQMinMax_Move2MinKey' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQMinMax_Move2MinKey !****************************************************************************** FUNCTION PQMinMax_Move2MaxKey ( Collection , Key ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the maximum (starting) key in a collection.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !% the maximum key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the table contains key or not <br> ! - true if the table is empty. <br> ! - otherwise the maximum key is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check if the collection is empty or not IsEmpty = Collection % IsEmpty () IF ( IsEmpty ) RETURN ! set cursor pointer Collection % Cursor = Collection % Last IF ((. NOT . IsEmpty ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQMinMax_Move2MaxKey' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQMinMax_Move2MaxKey !****************************************************************************** FUNCTION PQMinMax_MoveUpNext ( Collection , Key ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next key in an ascending order in a collection. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !% the next item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next key is NOT available. <br> ! - otherwise next key is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor pointer Collection % Cursor = Collection % Cursor + 1_kIndex ! set return flag IsTheEnd = ( Collection % Cursor > Collection % Last ) IF ((. NOT . IsTheEnd ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQMinMax_MoveUpNext' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQMinMax_MoveUpNext !****************************************************************************** FUNCTION PQMinMax_MoveDownNext ( Collection , Key ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next key in an descending order in a collection. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !% the next item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next key is NOT available. <br> ! - otherwise next key is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! set cursor pointer Collection % Cursor = Collection % Cursor - 1_kIndex ! set return flag IsTheEnd = ( Collection % Cursor < 1_kIndex ) IF ((. NOT . IsTheEnd ). AND . PRESENT ( Key )) THEN ! get current key IF (. NOT . Collection % Keys ( Collection % Cursor )% Get ( Key )) THEN CALL Handle_ErrLevel ( 'PQMinMax_MoveDownNext' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as stored items.' ) END IF END IF RETURN END FUNCTION PQMinMax_MoveDownNext !****************************************************************************** FUNCTION PQMinMax_ToArray ( Collection , Keys , IsDescend ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all keys from the collection.  Also, return ! a flag indicating whether the keys are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% PQMinMax object CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> If present and true, return the keys in descending order. <br> !  Otherwise, return the keys in ascending order. <br> tLogical , OPTIONAL , INTENT ( IN ) :: IsDescend !> flag indicating whether the keys are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Success = Collection % GetAll ( Keys , IsDescend ) ! remove all keys from the collection IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION PQMinMax_ToArray !************************************************************************************** FUNCTION PQMinMax_GetAll ( Collection , Keys , IsDescend ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, ! return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% PQMinMax object CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys ( 1 :) !> If present and true, return the keys in descending order. <br> !  Otherwise, return the keys in ascending order. <br> tLogical , OPTIONAL , INTENT ( IN ) :: IsDescend !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , MinSize tLogical :: DescendOrder ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN ELSE ! check whether type of the specified keys is valid or not IF (. NOT . Collection % IsKeyValid ( Keys ( 1 ))) THEN Success = FalseVal CALL Handle_ErrLevel ( 'PQMinMax_GetAll' , ModName , ErrSevere , & 'Type of the specified key is NOT the same as stored keys.' ) RETURN END IF END IF DescendOrder = FalseVal IF ( PRESENT ( IsDescend )) DescendOrder = IsDescend ! get keys from the collection MinSize = MIN ( Collection % Last , SIZE ( Keys , KIND = kIndex )) IF ( DescendOrder ) THEN ! get keys in descending order J = Collection % Last DO I = 1 , MinSize Success = Collection % Keys ( J )% Get ( Keys ( I )) IF (. NOT . Success ) EXIT J = J - 1_kIndex END DO ELSE ! get keys in ascending order DO I = 1 , MinSize Success = Collection % Keys ( I )% Get ( Keys ( I )) IF (. NOT . Success ) EXIT END DO END IF RETURN END FUNCTION PQMinMax_GetAll ! ----------------------------------------------------------------------------- ! -----                     Auxiliary Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE PQMinMax_Growing ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To increase the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity !** FLOW: IF (. NOT . ALLOCATED ( Collection % Keys )) THEN ! the collection has not yet been constructed. Capacity = 16_kIndex ! allocate storage for the collections' items CALL MemAlloc ( Collection % Keys , Capacity ) ELSE Capacity = SIZE ( Collection % Keys ) IF ( Collection % GetSize () == Capacity ) THEN ! increase the collection's capacity IF ( Collection % IncSize > 0_kIndex ) THEN Capacity = Capacity + Collection % IncSize ELSE Capacity = Capacity * 2_kIndex END IF ! check integer overflow IF ( Capacity <= 0_kIndex ) Capacity = MaxCapacity ! resize the collections' items CALL MemResize ( Collection % Keys , [ Capacity ]) END IF END IF RETURN END SUBROUTINE PQMinMax_Growing !****************************************************************************** SUBROUTINE PQMinMax_Shrinking ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !! To decrease the collection's capacity if needed. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: CurCap , CurSize !** FLOW: IF (. NOT . ALLOCATED ( Collection % Keys )) THEN ! the collection has not yet been constructed so simply return. RETURN END IF IF ( Collection % Shrink ) THEN CurCap = SIZE ( Collection % Keys ) CurSize = Collection % GetSize () IF (( CurSize >= 0_kIndex ). AND .( CurSize <= CurCap / 4_kIndex )) THEN ! halves the collection's capacity CurCap = CurCap / 2_kIndex ! check if the capacity is zero or not IF ( CurCap <= 0_kIndex ) CurCap = 1_kIndex ! resize the collections' items CALL MemResize ( Collection % Keys , [ CurCap ]) END IF END IF RETURN END SUBROUTINE PQMinMax_Shrinking !****************************************************************************** FUNCTION PQMinMax_IsKeyValid ( Collection , Key ) RESULT ( Valid ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the type of specified key is valid or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! the key to be checked tLogical :: Valid !! true if type of the specified key is valid !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the mold and the specified key have the same type or not IF ( ALLOCATED ( Collection % Mold )) THEN Valid = IsSameKeyOrdered ( Collection % Mold , Key ) ELSE ! this is the first key inserted so set it as the mold Valid = IsKeyOrdered ( Key ) IF ( Valid ) CALL Collection % CreateEmpty ( 16_kIndex , Mold = Key ) END IF RETURN END FUNCTION PQMinMax_IsKeyValid !****************************************************************************** SUBROUTINE PQMinMax_SwapKeys ( Collection , I , J ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To swap key I and key J. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQMinMax ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: I , J !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyOrdered ) :: Temp ! FLOW CALL Collection % Keys ( I )% Copy ( Temp ) ! Temp = Collection%Keys(I) CALL Collection % Keys ( J )% Copy ( Collection % Keys ( I )) ! Collection%Keys(I) = Collection%Keys(J) CALL Temp % Copy ( Collection % Keys ( J )) ! Collection%Keys(J) = Temp RETURN END SUBROUTINE PQMinMax_SwapKeys !****************************************************************************** ! define comparison macro for sorting in ascending order #define COMPARE_GLT(A, B)       (A < B) #define COMPARE_GLE(A, B)       (A <= B) SUBROUTINE SortAscend ( A ) !** PURPOSE OF THIS SUBROUTINE ! To perform sorting of the specified array in an ascending order. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A ( 0 :) ! array to be sorted !** SUBROUTINE PARAMETER DECLARATIONS: ! initial cutoff to insertion sort tIndex , PARAMETER :: Insertion_CutOff = 32_kIndex ! The maximum number of entries in a run stack, good for an array of 2**64 elements. tSInt32 , PARAMETER :: Max_Merge_Stack = INT ( CEILING ( LOG ( 2.0_kFloat ** 64 ) / & LOG ( 1.6180339887_kFloat ))) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyOrdered ), ALLOCATABLE :: Buffer (:) tIndex :: NA ! size of the arrays !** FLOW: ! check whether to use an insertion sort instead NA = SIZE ( A , KIND = kIndex ) IF ( NA <= Insertion_CutOff ) THEN CALL Insert_Guarded ( A , 1 , NA ) RETURN END IF ! Allocate a buffer to use as scratch memory. CALL MemAlloc ( Buffer , NA / 2_kIndex ) ! perform merge sort CALL Rust_MergeSort ( A , NA , Buffer ) RETURN CONTAINS SUBROUTINE Rust_MergeSort ( A , ALen , B ) !** PURPOSE OF THIS SUBROUTINE ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs.  Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using a insertion sort.  The merge process is driven by a stack of ! pending un-merged runs.  Each newly found run is pushed onto the stack, ! and then pairs of adjacent runs are merged until these two invariants ! are satisfied: ! ! 1. for every 'i' in '1..size(runs)-1': 'runlen(i - 1) > runlen(i)' ! 2. for every 'i' in '2..size(runs)-1': 'runlen(i - 2) > runlen(i - 1) + runlen(i)' ! ! The invariants ensure that the total running time is 'O(n log n)' worst-case. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A ( 0 :) tIndex , INTENT ( IN ) :: ALen TYPE ( KeyOrdered ), INTENT ( INOUT ) :: B ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Finish , Min_Run , nRun , R , RCount , Start tIndex :: RunLen ( 0 : Max_Merge_Stack - 1 ) tIndex :: RunBase ( 0 : Max_Merge_Stack - 1 ) tIndex :: LeftLen , LeftBase tIndex :: RightLen , RightBase !** FLOW: ! Very short runs are extended using insertion sort to span at least Min_Run elements. ! Slices of up to this length are sorted using pair-insertion sort. Min_Run = Calc_Min_Run ( ALen ) ! Following Rust sort, natural runs in 'A' are identified by traversing ! it backwards.  By traversing it backward, merges more often go in the ! opposite direction (forwards).  According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards.  Therefore ! identifying runs by traversing backwards should improve performance. RCount = 0_kIndex Finish = ALen - 1_kIndex DO WHILE ( Finish >= 0_kIndex ) ! Find the next natural run, and reverse it if it's strictly descending. Start = Finish IF ( Start > 0_kIndex ) THEN Start = Start - 1_kIndex IF ( COMPARE_GLT ( A ( Start + 1 ), A ( Start ))) THEN Descending : DO WHILE ( Start > 0_kIndex ) IF ( COMPARE_GLE ( A ( Start - 1 ), A ( Start ))) EXIT Descending Start = Start - 1_kIndex END DO Descending CALL Reverse_Order_Base0 ( A , Start , Finish ) ELSE Ascending : DO WHILE ( Start > 0_kIndex ) IF ( COMPARE_GLT ( A ( Start ), A ( Start - 1 ))) EXIT Ascending Start = Start - 1_kIndex END DO Ascending END IF END IF ! compute run length nRun = Finish - Start IF ( nRun < Min_Run ) THEN ! If run is short, extend to MinRun IF ( nRun < Min_Run / 8_kIndex ) THEN ! If nRun is too short, use insertion sort Start = Finish - Min_Run + 1_kIndex IF ( Start < 0_kIndex ) Start = 0_kIndex CALL Insert_Guarded ( A , Start + 1 , Finish + 1 ) ELSE ! nRun is long enough, use insertion sort Insert_Loop : DO WHILE ( Start > 0_kIndex ) IF (( Finish - Start ) >= ( Min_Run - 1_kIndex )) EXIT Insert_Loop Start = Start - 1_kIndex CALL Insert_Head ( A ( Start : Finish )) END DO Insert_Loop IF (( Start == 0_kIndex ). AND .( Finish == ALen - 1_kIndex )) RETURN END IF END IF ! initialize the stack RunBase ( RCount ) = Start RunLen ( RCount ) = Finish - Start + 1_kIndex Finish = Start - 1_kIndex RCount = RCount + 1_kIndex ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_Loop : DO ! examine the stack of runs waiting to be merged R = Collapse ( RunBase ( 0 : RCount - 1 ), RunLen ( 0 : RCount - 1 )) IF (( R < 0_kIndex ). OR .( RCount <= 1_kIndex )) EXIT Merge_Loop LeftLen = RunLen ( R + 1 ) LeftBase = RunBase ( R + 1 ) RightLen = RunLen ( R ) RightBase = RunBase ( R ) ! merge adjacent runs CALL Merging ( A ( LeftBase : RightBase + RightLen - 1 ), LeftLen , B ) ! set the stack RunBase ( R ) = LeftBase RunLen ( R ) = LeftLen + RightLen IF ( R == RCount - 3_kIndex ) THEN RunBase ( R + 1 ) = RunBase ( R + 2 ) RunLen ( R + 1 ) = RunLen ( R + 2 ) END IF RCount = RCount - 1_kIndex END DO Merge_Loop END DO RETURN END SUBROUTINE Rust_MergeSort !****************************************************************** FUNCTION Calc_Min_Run ( N ) RESULT ( Min_Run ) !** PURPOSE OF THIS SUBROUTINE ! To determine the minimum length of a run from 32-63 so that N/MIN_RUN is ! less than or equal to a power of two. See ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: N tIndex :: Min_Run !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Num tIndex :: R !** FLOW: Num = N R = 0_kIndex DO WHILE ( Num >= 64_kIndex ) R = IOR ( R , IAND ( Num , 1 )) Num = SHIFTA ( Num , 1 ) END DO Min_Run = Num + R RETURN END FUNCTION Calc_Min_Run !****************************************************************** FUNCTION Collapse ( Base , Length ) RESULT ( R ) !** PURPOSE OF THIS SUBROUTINE ! To examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: Base ( 0 :) tIndex , INTENT ( IN ) :: Length ( 0 :) tIndex :: R !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N tLogical :: Test !** FLOW: N = MIN ( SIZE ( Base ), SIZE ( Length )) Test = FalseVal IF ( N >= 2_kIndex ) THEN IF (( Base ( N - 1 ) == 0_kIndex ). OR .( Length ( N - 2 ) <= Length ( N - 1 ))) THEN Test = TrueVal ELSEIF ( N >= 3_kIndex ) THEN ! X exists IF ( Length ( N - 3 ) <= ( Length ( N - 2 ) + Length ( N - 1 ))) THEN Test = TrueVal ! |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 ELSEIF ( N >= 4_kIndex ) THEN IF ( Length ( N - 4 ) <= ( Length ( N - 3 ) + Length ( N - 2 ))) THEN Test = TrueVal ! |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 END IF END IF END IF END IF IF ( Test ) THEN ! By default merge Y & Z, rho2 or rho3 IF ( N >= 3_kIndex ) THEN IF ( Length ( N - 3 ) < Length ( N - 1 )) THEN R = N - 3_kIndex ! |X| < |Z| => merge X & Y, rho1 RETURN END IF END IF R = N - 2_kIndex ! |Y| <= |Z| => merge Y & Z, rho4 RETURN ELSE R = - 1_kIndex END IF RETURN END FUNCTION Collapse !****************************************************************** SUBROUTINE Insert_Head ( A ) !** PURPOSE OF THIS SUBROUTINE ! To inserts 'A(0)' into the pre-sorted sequence 'A(1:)' so that the ! whole 'A(0:)' becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I TYPE ( KeyOrdered ) :: Temp !** FLOW: Temp = A ( 0 ) Find_Hole : DO I = 1_kIndex , SIZE ( A , KIND = kIndex ) - 1_kIndex IF ( COMPARE_GLE ( Temp , A ( I ))) EXIT Find_Hole A ( I - 1 ) = A ( I ) END DO Find_Hole A ( I - 1 ) = Temp RETURN END SUBROUTINE Insert_Head !****************************************************************** SUBROUTINE Merging ( A , Mid , B ) !** PURPOSE OF THIS SUBROUTINE ! To merge the two non-decreasing runs 'A(0:Mid-1)' and 'A(Mid:)' ! using 'B' as a temporary storage, and stores the merged runs into ! 'A(0:)'.  'Mid' must be > 0, and < 'SIZE(A)-1'. The buffer 'B' ! must be long enough to hold the shorter of the two runs. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A ( 0 :) tIndex , INTENT ( IN ) :: Mid TYPE ( KeyOrdered ), INTENT ( INOUT ) :: B ( 0 :) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: ALen , I , J , K TYPE ( KeyOrdered ) :: Temp !** FLOW: ALen = SIZE ( A , KIND = kIndex ) ! Merge first copies the shorter run into 'B'. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into 'A'. IF ( Mid <= ( ALen - Mid )) THEN ! The left run is shorter. B ( 0 : Mid - 1 ) = A ( 0 : Mid - 1 ) I = 0_kIndex J = Mid Merge_Lower : DO K = 0_kIndex , ALen - 1_kIndex IF ( COMPARE_GLE ( B ( I ), A ( J ))) THEN A ( K ) = B ( I ) I = I + 1_kIndex IF ( I >= Mid ) EXIT Merge_Lower ELSE A ( K ) = A ( J ) J = J + 1_kIndex IF ( J >= ALen ) THEN A ( K + 1 :) = B ( I : Mid - 1 ) EXIT Merge_Lower END IF END IF END DO Merge_Lower ELSE ! The right run is shorter so check that it is stable B ( 0 : ALen - Mid - 1 ) = A ( Mid : ALen - 1 ) I = Mid - 1_kIndex J = ALen - Mid - 1_kIndex Merge_Upper : DO K = ALen - 1_kIndex , 0_kIndex , - 1_kIndex IF ( COMPARE_GLE ( A ( I ), B ( J ))) THEN A ( K ) = B ( J ) J = J - 1_kIndex IF ( J < 0_kIndex ) EXIT Merge_Upper ELSE A ( K ) = A ( I ) I = I - 1_kIndex IF ( I < 0_kIndex ) THEN A ( 0 : K - 1 ) = B ( 0 : J ) EXIT Merge_Upper END IF END IF END DO Merge_Upper END IF RETURN END SUBROUTINE Merging !****************************************************************** SUBROUTINE Insert_Guarded ( A , Lo , Hi ) !** PURPOSE OF THIS SUBROUTINE ! To sort array using insertion sort algorithm !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A (:) ! array to be sorted tIndex , INTENT ( IN ) :: Lo ! starting index (inclusive) tIndex , INTENT ( IN ) :: Hi ! ending index (inclusive) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , Nxch TYPE ( KeyOrdered ) :: Temp !** FLOW: ! initialize Nxch = 0_kIndex ! put smallest element in position to serve as sentinel DO I = Hi , Lo + 1_kIndex , - 1_kIndex J = I - 1_kIndex IF ( COMPARE_GLT ( A ( I ), A ( J ))) THEN EXCHANGE ( A , I , J ) Nxch = Nxch + 1_kIndex END IF END DO IF ( Nxch == 0_kIndex ) RETURN ! insertion sort with half exchanges DO I = Lo + 2_kIndex , Hi Temp = A ( I ) J = I - 1_kIndex DO WHILE ( COMPARE_GLT ( Temp , A ( J ))) A ( J + 1 ) = A ( J ) J = J - 1_kIndex END DO A ( J + 1 ) = Temp END DO RETURN END SUBROUTINE Insert_Guarded !****************************************************************** SUBROUTINE Reverse_Order_Base0 ( A , IStart , IEnd ) !** PURPOSE OF THIS SUBROUTINE ! To reverse order of a segment of an array in place !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( KeyOrdered ), INTENT ( INOUT ) :: A ( 0 :) ! array to be reverse-ordered tIndex , INTENT ( IN ) :: IStart ! starting index (inclusive) tIndex , INTENT ( IN ) :: IEnd ! ending index (inclusive) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Lo tIndex :: Hi TYPE ( KeyOrdered ) :: Temp !** FLOW: Lo = IStart Hi = IEnd DO WHILE ( Lo < Hi ) EXCHANGE ( A , Lo , Hi ) Lo = Lo + 1_kIndex Hi = Hi - 1_kIndex END DO RETURN END SUBROUTINE Reverse_Order_Base0 !****************************************************************** END SUBROUTINE #undef COMPARE_GLT #undef COMPARE_GLE !****************************************************************************** END MODULE MClass_PQMinMax !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqminmax.f90.html"},{"title":"MClass_ListRealSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListRealSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListRealSP* type and related routines. !   The *ListRealSP* type is a container with *REAL(KIND=kSingle)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListRealSP* type but utilizes a different implementation. !   Also, unlike the *ListRealSP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListRealSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListRealSP #define DLLNode             DLLNodeRealSP #define ItemTypeA           REAL(KIND=kSingle) #define ItemTypeB           REAL(KIND=kSingle) #define ItemTypeC           REAL(KIND=kSingle) #define TypeOfItem          REAL(KIND=kSingle) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListRealSP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListRealSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listrealsp.f90.html"},{"title":"MClass_ListCharacter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListCharacter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListCharacter* type and related routines. !   The *ListCharacter* type is a container with *CHARACTER* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListCharacter* type but utilizes a different implementation. !   Also, unlike the *ListCharacter* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListCharacter PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define ItemType_Is_Character #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListCharacter #define DLLNode             DLLNodeCharacter #define ItemTypeA           CHARACTER(LEN=:), ALLOCATABLE #define ItemTypeB           CHARACTER(LEN=*) #define ItemTypeC           CHARACTER(LEN=:) #define TypeOfItem          CHARACTER !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListCharacter' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef ItemType_Is_Character #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListCharacter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listcharacter.f90.html"},{"title":"MClass_PQRealSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQRealSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQRealSP* type and its related routines. !   The *PQRealSP* type is a priority-queue container with *REAL(KIND=kSingle)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQRealSP* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true  o that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQRealSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     REAL(KIND=kSingle) #define     PQHeap      PQRealSP !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQRealSP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQRealSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqrealsp.f90.html"},{"title":"MClass_TreeSet.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeSet !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeSet* type and its supporting routines and data type. !   The *TreeSet* type is a collection type that employs a balanced binary-search-tree !   (BST) implementation to provide common operations for an ordered set.  Like any other !   set collection types, the *TreeSet* type does not allow duplicated items. <br> !   The *TreeSet* type uses the *KeyOrdered* type to store comparable items where allowed !   item types include the *CHARACTER*, *INTEGER* and *REAL* intrinsic types as well as any !   derived type that is in the *Comparable* class.  Like other collection types, it must !   be employed to store items of only one particular data type.  To store items of another !   data type, it must be destructed before inserting items of different data type. <br> !   As an *ordered* set, the *TreeSet* type provides an ordered iteration over its stored !   items, which are sorted according to the natural ordering of its items.  It can be !   accessed and traversed in either ascending (using the *StartFirst* method) or descending !   (using the *StartLast* method) order. <br> !   Technically, the *TreeSet* type employs a balanced search tree implementation to provide !   common operations for an ordered set.  The *TreeSet* type utilizes the *IntrusiveRBTree* !   type as its component to store its tree nodes.  As an intrusive BST container, the !   *IntrusiveRBTree* type provides common binary-search-tree operations without a memory !   management task.  The memory management task of the inserted tree nodes is handled by !   the *TreeSet* type.  <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveBSTrees USE MClass_Object , ONLY : Object USE MClass_Comparable , ONLY : Comparable USE MClass_KeyOrdered USE MClass_GenData USE MClass_CompNodePool USE MClass_MemoryPool USE MClass_BaseCollection USE MClass_BaseIterable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeSet PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeSet' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !>  *SetNode* is a binary-search-tree node type containing an item as its components.  The !   *KeyOrdered* type is used as a storage for the item.  The *SetNode* type is a subtype !   of the *BSTNode* type and is intended to be used with the *TreeSet* type, which is a !   collection type that utilizes the *IntrusiveRBTree* type. <br> TYPE , EXTENDS ( BSTNode ) :: SetNode TYPE ( KeyOrdered ) :: Item !! stored item CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => SetNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => SetNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => SetNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => SetNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => SetNode_HashCode ! --------------------------------------------------------------------- ! -----         Deferred Procedure from Comparable Type           ----- ! --------------------------------------------------------------------- !> Use a common logical expression to compare two *Comparable* objects. PROCEDURE :: CompareTo => SetNode_CompareItem ! --------------------------------------------------------------------- ! -----         Specific Procedure for SetNode Type               ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: SetItem <br> !  **Purpose**:  To set new item. <br> !  **Usage**: <br> !   --->    Valid = Node%SetItem(Item, MemPool) PROCEDURE :: SetItem => SetNode_SetItem ! --------------------------------------------------------------------- END TYPE SetNode !>  The *TreeSet* type is a collection type that utilizes a balanced BST implementation !   to provide common operations for an ordered set.  The *TreeSet* type employs the !   *IntrusiveRBTree* type as its component to store *SetNode* objects.  As an intrusive !   BST container, the *IntrusiveRBTree* type provides common binary-search-tree operations !   without a memory management task.  The memory management task of the inserted *SetNode* !   objects is handled by the *TreeSet* type.  <br> !   The *TreeSet* type is a subtype of the *BaseIterable* type.  Thus, it implements all !   deferred procedures required by the *BaseIterable* type and all its super classes.  As !   a set container, the *TreeSet* type does not allow duplicated items.  Also, the *TreeSet* !   type, as an *ordered* set, provides an ordered iteration over its stored items, which are !   sorted according to the natural ordering of its items.  It can be traversed in either !   ascending or descending order. <br> !   Because the *IntrusiveRBTree* type is a subtype of the *IntrusiveAVLTree* type, the !   *WrkTree* component can be employed as a red-black tree or an AVL tree.  Therefore, the !   *TreeSet* type allows a user to specify which type of binary-search tree implementation !   to be used.  By default, the red-black tree implementation is used.  The user can call the !   *UseAVLTree* method to change to AVL tree implementation.  The *UseAVLTree* method must !   be called before inserting an object into the set (i.e when the set is empty).  Otherwise, !   the red-black tree implementation is employed.  <br> TYPE , EXTENDS ( BaseIterable ) :: TreeSet PRIVATE !> a flag indicating whether to use the red-black tree implementation !  or the AVL tree implementation tLogical :: IsRBTree = TrueVal !% a working binary-search tree TYPE ( IntrusiveRBTree ) :: WrkTree !> direction of the iteration <br> !  - positive -> forward iteration !  - negative -> backward iteration !  - zero     -> iteration not yet start tSInt32 :: Dir = 0 !> memory pool of tree nodes TYPE ( CompNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindItem <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindItem(Item) <br> !   --->    IF (.NOT.Collection%FindItem(Item)) DoSomething PROCEDURE , PRIVATE :: FindItem => TreeSet_FindItem !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: TreeSet_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => TreeSet_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => TreeSet_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => TreeSet_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => TreeSet_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => TreeSet_Move2FirstItem !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => TreeSet_Move2NextItem !> **Type-Bound Function**: StartLast <br> !  **Purpose**:  To start an iteration in a reversed order and return a flag !                indicating whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartLast() <br> !   --->    IsEmpty = Collection%StartLast(LastItem) <br> PROCEDURE :: StartLast => TreeSet_Move2LastItem !> **Type-Bound Function**: MoveBackward <br> !  **Purpose**:  To move to the previous item and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveBackward() <br> !   --->    IsTheEnd = Collection%MoveBackward(PrevItem) <br> PROCEDURE :: MoveBackward => TreeSet_Move2PrevItem !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified item to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Item) <br> PROCEDURE :: Insert => TreeSet_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => TreeSet_Delete !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !       indicating whether the items are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => TreeSet_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => TreeSet_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => TreeSet_CreateByArray !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Item) <br> !   --->    IF (.NOT.Collection%Contain(Item)) DoSomething PROCEDURE :: Contain => TreeSet_Contain !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified item from the collection.  Also, return a flag !                indicating whether the item is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Item) <br> !   --->    IF (.NOT.Collection%Remove(Item)) DoSomething PROCEDURE :: Remove => TreeSet_Remove !> **Type-Bound Subroutine**: UseAVLTree <br> !  **Purpose**:  To set the working tree component to work as an AVL tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseAVLTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseAVLTree => TreeSet_UseAVLTree !> **Type-Bound Subroutine**: UseRBTree <br> !  **Purpose**:  To set the working tree component to work as an red-black RB tree.  <br> !  **Usage**: <br> !   --->    CALL Collection%UseRBTree() <br> !  *Note*: The collection must be empty when calling this method. PROCEDURE :: UseRBTree => TreeSet_UseRBTree ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TreeSet_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TreeSet_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TreeSet_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TreeSet_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TreeSet_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash set. FINAL :: TreeSet_Finalize ! --------------------------------------------------------------------- END TYPE TreeSet !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 SetNode Procedures                        ----- ! --------------------------------------------------------------------- SUBROUTINE SetNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the SetNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( SetNode ) CALL SrcObj % CopyBSTNode ( DstObj ) CALL SrcObj % Item % Copy ( DstObj % Item , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'SetNode_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"SetNode\" only.' ) RETURN END SELECT RETURN END SUBROUTINE SetNode_Copy !****************************************************************************** FUNCTION SetNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not.  This is a deferred procedure by !  an *Object* object. <br> !  It should be noted that this routine uses all components of the *SetNode* object to !  check equality. Therefore, although (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) !  can return false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( SetNode ) Flag = FalseVal IF (. NOT . LhsObj % Item % IsEqualTo ( RhsObj % Item )) RETURN Flag = LhsObj % IsBSTNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION SetNode_IsEqualTo !****************************************************************************** SUBROUTINE SetNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the SetNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free the key and value components CALL Obj % Item % MemFree () ! reset the \"BSTNode\" components CALL Obj % ResetBSTNode () RETURN END SUBROUTINE SetNode_MemFree !****************************************************************************** FUNCTION SetNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{SetNode: ' // Obj % Item % ToString () // '}' RETURN END FUNCTION SetNode_ToString !****************************************************************************** FUNCTION SetNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: AdjNode ! FLOW ! get code from left node AdjNode => Obj % GetLeft () SELECT TYPE ( Left => AdjNode ) TYPE IS ( SetNode ) Code = Left % Item % HashCode () END SELECT ! add code from this node Code = Code + Obj % Item % HashCode () ! add code from right node AdjNode => Obj % GetRight () SELECT TYPE ( Right => AdjNode ) TYPE IS ( SetNode ) Code = Code + Right % Item % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION SetNode_HashCode !****************************************************************************** FUNCTION SetNode_CompareItem ( A , B ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compare *A* and *B* and return <br> !   1 if *A* is greater than *B*, <br> !   0 if *A* is equal to *B*, <br> !  -1 if *A* is less than *B*, <br> !  -999 if type of *B* is invalid. <br> !  Also, write an error message to the default log file if this happens. <br> !  This is a deferred procedure by an *Comparable* object. <br> !  It is important to note that this routine only uses the key component !  of the *SetNode* object.  Thus, even though (A%CompareTo(B) == 0) !  is true, A%IsEqualTo(B) may be false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( IN ) :: A CLASS ( Comparable ), INTENT ( IN ) :: B tSInt32 :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( B ) TYPE IS ( SetNode ) Flag = A % Item % CompareTo ( B % Item ) CLASS DEFAULT Flag = - 999 CALL Handle_ErrLevel ( 'SetNode_CompareItem' , ModName , ErrSevere , 'Type of B is valid.' ) END SELECT RETURN END FUNCTION SetNode_CompareItem !****************************************************************************** SUBROUTINE SetNode_SetItem ( Node , Key , Pool ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the key and value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetNode ), INTENT ( INOUT ) :: Node !! SetNode object CLASS ( * ), INTENT ( IN ) :: Key !! the key TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !! memory pool for both key and value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Item % Set ( Key , Pool ) RETURN END SUBROUTINE SetNode_SetItem ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- SUBROUTINE TreeSet_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( TreeSet ) DstObj % Dir = SrcObj % Dir DstObj % IsRBTree = SrcObj % IsRBTree CALL SrcObj % NodePool % Copy ( DstObj % NodePool , IsDeep ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) CALL SrcObj % WrkTree % CloneTo ( DstObj % WrkTree ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TreeSet_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE TreeSet_Copy !****************************************************************************** FUNCTION TreeSet_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( TreeSet ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN ! implementation note:  we cannot use the iteration methods here !   due to the intent of the input data. BLOCK CLASS ( BSTNode ), POINTER :: LhsNode , LhsNext , LhsRoot CLASS ( BSTNode ), POINTER :: RhsNode , RhsNext , RhsRoot tLogical :: ReturnNow ReturnNow = FalseVal ! start iteration LhsNode => LhsObj % WrkTree % GetMinNode () RhsNode => RhsObj % WrkTree % GetMinNode () LhsRoot => LhsObj % WrkTree % GetRoot () RhsRoot => RhsObj % WrkTree % GetRoot () Loop : DO WHILE ( ASSOCIATED ( LhsNode ). AND . ASSOCIATED ( RhsNode )) ! get successor nodes CALL Find_Inorder_Successor ( LhsRoot , LhsNode , LhsNext ) CALL Find_Inorder_Successor ( RhsRoot , RhsNode , RhsNext ) ! check key and value equalities SELECT TYPE ( LhsNode ) TYPE IS ( SetNode ) SELECT TYPE ( RhsNode ) TYPE IS ( SetNode ) IF (. NOT . LhsNode % IsEqualTo ( RhsNode )) THEN ReturnNow = TrueVal EXIT Loop END IF END SELECT END SELECT ! move to the next iteration LhsNode => LhsNext RhsNode => RhsNext END DO Loop NULLIFY ( LhsNode , RhsNode ) NULLIFY ( LhsNext , RhsNext ) NULLIFY ( LhsRoot , RhsRoot ) IF ( ReturnNow ) RETURN END BLOCK ELSE RETURN END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TreeSet_IsEqualTo !****************************************************************************** SUBROUTINE TreeSet_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TreeSet object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % WrkTree % Clear () CALL Obj % NodePool % MemFree () CALL Obj % ItemPool % Destruct () CALL Obj % FreeMold () RETURN END SUBROUTINE TreeSet_MemFree !****************************************************************************** FUNCTION TreeSet_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the TreeSet type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE ! implementation note:  we cannot use the iteration methods here ! due to the intent of the input data. BLOCK CLASS ( BSTNode ), POINTER :: CurrNode , NextNode , RootNode TYPE ( CharBuffer ) :: ChrBuf tCharAlloc :: ItemStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) ! start iteration CurrNode => Obj % WrkTree % GetMinNode () RootNode => Obj % WrkTree % GetRoot () Loop : DO WHILE ( ASSOCIATED ( CurrNode )) ! get successor nodes CALL Find_Inorder_Successor ( RootNode , CurrNode , NextNode ) ! get string representation of the stored item of the current node SELECT TYPE ( CurrNode ) TYPE IS ( SetNode ) ItemStr = CurrNode % Item % ToString () CALL ChrBuf % Append ( ItemStr ( 15 : LEN ( ItemStr ) - 1 )) IF ( ASSOCIATED ( NextNode )) CALL ChrBuf % Append ( ', ' ) END SELECT ! move to the next iteration CurrNode => NextNode END DO Loop NULLIFY ( CurrNode , NextNode , RootNode ) CALL ChrBuf % Append ( ']' ) Str = ChrBuf % AsString () END BLOCK END IF Str = '{TreeSet with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION TreeSet_ToString !****************************************************************************** FUNCTION TreeSet_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK CLASS ( CompNode ), POINTER :: PoolNodes (:) tIndex :: I ! initialize CALL Obj % NodePool % GetAllNodes ( PoolNodes ) Code = 0_kIndex ! compute hash code SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( SetNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Item % IsEmpty ()) CYCLE Code = Code + Nodes ( I )% Item % HashCode () END DO END SELECT END BLOCK END IF RETURN END FUNCTION TreeSet_HashCode ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- SUBROUTINE TreeSet_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseIterable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( TreeSet ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! return if Other is empty IF ( Other % IsEmpty ()) RETURN SELECT TYPE ( Other ) CLASS IS ( TreeSet ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseIterable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: Item MoldPtr => Other % GetItemPtr () ALLOCATE ( Item , MOLD = MoldPtr ) ! loop through the other collection and get items along the way IsTheEnd = Other % StartFirst ( Item , ItemCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( Item ) IsTheEnd = Other % MoveForward ( Item , ItemCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( Item ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'TreeSet_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseIterable\" class.' ) END SELECT RETURN END SUBROUTINE TreeSet_CopyCollection !****************************************************************************** SUBROUTINE TreeSet_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free components of the items from the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! simply return if the collection is empty IF ( Collection % IsEmpty ()) RETURN ! clear elements CALL Collection % WrkTree % Clear () ! reset components Collection % Dir = 0 CALL Collection % NodePool % Reset () ! free mold CALL Collection % FreeMold () RETURN END SUBROUTINE TreeSet_ClearItems !****************************************************************************** SUBROUTINE TreeSet_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE TreeSet_Destroy !****************************************************************************** FUNCTION TreeSet_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of items currently in the hash set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( IN ) :: Collection !! collection tIndex :: Size !! the number of items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % WrkTree % GetSize () RETURN END FUNCTION TreeSet_GetSize ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseIterable Type         ----- ! --------------------------------------------------------------------- FUNCTION TreeSet_Move2FirstItem ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) item in a collection.   For the hash set, which is !  an unordered set, the starting item is the first item found in the non-empty bucket.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection !% the first item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the table contains no item or not <br> ! - true if the table is empty. <br> ! - otherwise the first item is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Item )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTree % StartMin ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN SELECT TYPE ( CurrNode ) TYPE IS ( SetNode ) ! get key if requested IF ( PRESENT ( Item )) THEN IF (. NOT . CurrNode % Item % Get ( Item )) THEN CALL Handle_ErrLevel ( 'TreeSet_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTree % StartMin () END IF ! set direction IF (. NOT . IsEmpty ) Collection % Dir = 1 RETURN END FUNCTION TreeSet_Move2FirstItem !****************************************************************************** FUNCTION TreeSet_Move2NextItem ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next item in a collection.  For the hash set, which is an unordered set, !  the next item is a item inserted in the first non-empty bucket after the previous one.  <br> !  The routine will report an error if an alteration to stored item(s) (either by an insertion !  or a removal) has been occurred during current iteration.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection !% the next item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next item is NOT available. <br> ! - otherwise next item is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Item )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! move to next iteration IsTheEnd = Collection % WrkTree % MoveForward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( SetNode ) ! get key if requested IF ( PRESENT ( Item )) THEN IF (. NOT . CurrNode % Item % Get ( Item )) THEN CALL Handle_ErrLevel ( 'TreeSet_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! move to next iteration IsTheEnd = Collection % WrkTree % MoveForward () END IF ! set direction IF (. NOT . IsTheEnd ) THEN Collection % Dir = 1 ELSE Collection % Dir = 0 END IF RETURN END FUNCTION TreeSet_Move2NextItem !****************************************************************************** FUNCTION TreeSet_Move2LastItem ( Collection , Item ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the last (starting in a reversed order) item in a symbol table. For the !  *TreeSet*, which is an ordered symbol table, the starting item in a reversed order !  is the item with greatest key.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !% the greatest key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the collection contains no item or not <br> ! - true if the collection is empty. <br> ! - otherwise the first item is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Item )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTree % StartMax ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( SetNode ) ! get key if requested IF ( PRESENT ( Item )) THEN IF (. NOT . CurrNode % Item % Get ( Item )) THEN CALL Handle_ErrLevel ( 'TreeSet_Move2LastItem' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTree % StartMax () END IF ! set direction IF (. NOT . IsEmpty ) Collection % Dir = - 1 RETURN END FUNCTION TreeSet_Move2LastItem !****************************************************************************** FUNCTION TreeSet_Move2PrevItem ( Collection , Item ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the previous item in a symbol table.  For the *TreeSet*, which is an !  ordered symbol table,  the previous item is the so-called predecessor item.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !% the previous key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next item is NOT available. <br> ! - otherwise next item is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Item )) THEN BLOCK ! block variable CLASS ( BSTNode ), POINTER :: CurrNode ! start iteration IsTheEnd = Collection % WrkTree % MoveBackward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( SetNode ) ! get key if requested IF ( PRESENT ( Item )) THEN IF (. NOT . CurrNode % Item % Get ( Item )) THEN CALL Handle_ErrLevel ( 'TreeSet_Move2PrevItem' , ModName , ErrWarning , & 'Type of the specified key is likely NOT the same as that of stored keys.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsTheEnd = Collection % WrkTree % MoveBackward () END IF ! set direction IF (. NOT . IsTheEnd ) THEN Collection % Dir = - 1 ELSE Collection % Dir = 0 END IF RETURN END FUNCTION TreeSet_Move2PrevItem !****************************************************************************** SUBROUTINE TreeSet_Insert ( Collection , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add an item into the hash set.  If the specified item is already stored !  in the set, report severe error and return immediately.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be inserted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: ItemFound TYPE ( SetNode ), POINTER :: ItemNode CLASS ( CompNode ), POINTER :: NewNode ! FLOW ! check the specified item IF (. NOT . IsKeyOrdered ( Item )) THEN CALL Handle_ErrLevel ( 'TreeSet_Insert' , ModName , ErrSevere , & 'Type of the specified item is NOT valid.' ) RETURN ELSEIF (. NOT . Collection % IsItemValid ( Item )) THEN CALL Handle_ErrLevel ( 'HashSet_Insert' , ModName , ErrSevere , & 'Only items of the same type are allowed in a collection.' ) RETURN END IF ! check whether the key is already stored in the collection or not IF ( Collection % IsEmpty ()) THEN ItemFound = FalseVal ELSE ItemFound = Collection % FindItem ( Item , ItemNode ) END IF IF ( ItemFound ) THEN ! no duplicated items are allowed. CALL Handle_ErrLevel ( 'TreeSet_Insert' , ModName , ErrSevere , & 'The specified item is already stored in the set.' ) RETURN ELSE ! +++ new item +++ ! check for first-time insertion IF (. NOT . Collection % NodePool % IsReady ()) THEN CALL Collection % NodePool % Construct ( ItemNode ) CALL Collection % ItemPool % Construct () END IF ! get new node from the node's pool CALL Collection % NodePool % GetNewNode ( NewNode ) SELECT TYPE ( NewNode ) TYPE IS ( SetNode ) ItemNode => NewNode END SELECT ! set key and value to the node ! (no need to check the valid flag since we have already done that in the beginning) CALL ItemNode % SetItem ( Item , Collection % ItemPool ) ! insert the new node to the working tree IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. CALL Collection % WrkTree % Insert ( ItemNode ) ELSE ! WrkTree is an AVL tree. CALL Collection % WrkTree % IntrusiveAVLTree % Insert ( ItemNode ) END IF END IF ! free working pointer NULLIFY ( ItemNode , NewNode ) RETURN END SUBROUTINE TreeSet_Insert !****************************************************************************** SUBROUTINE TreeSet_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a item of the current iteration from a collection. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( BSTNode ), POINTER :: CurrNode tLogical :: Success tLogical :: IsTheEnd ! FLOW ! get the cursor node CurrNode => Collection % WrkTree % GetCursor () ! check if the node is associated IF ( ASSOCIATED ( CurrNode )) THEN ! reset cursor IF ( Collection % Dir == 1 ) THEN ! forward iteration so move cursor backward IsTheEnd = Collection % WrkTree % MoveBackward () ELSE ! backward iteration so move cursor forward IsTheEnd = Collection % WrkTree % MoveForward () END IF IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. Success = Collection % WrkTree % Remove ( CurrNode ) ELSE ! WrkTree is an AVL tree. Success = Collection % WrkTree % IntrusiveAVLTree % Remove ( CurrNode ) END IF ! check if remove the node successfully or not IF ( Success ) THEN ! return the node to the node's pool SELECT TYPE ( DelNode => CurrNode ) TYPE IS ( SetNode ) CALL Collection % NodePool % ReturnNode ( DelNode ) END SELECT ELSE CALL Handle_ErrLevel ( 'TreeSet_Delete' , ModName , ErrWarning , & 'Check the Remove method of the intrusive tree for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( CurrNode ) RETURN END SUBROUTINE TreeSet_Delete !************************************************************************************** FUNCTION TreeSet_ToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all items from the collection.  Also, return !  a flag indicating whether the items are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeSet object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !% the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Items , ItemCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION TreeSet_ToArray !************************************************************************************** FUNCTION TreeSet_GetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all items (without removing them) from the collection.  Also, !  return a flag indicating whether the items are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TreeSet object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !% the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF (. NOT . Collection % IsItemValid ( Items ( 1 ))) THEN Success = FalseVal CALL Handle_ErrLevel ( 'TreeSet_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = TrueVal END IF IF (. NOT . Success ) RETURN BLOCK tIndex :: I , ArrSize tLogical :: IsTheEnd ! initialize local variables ArrSize = SIZE ( Items , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % StartFirst ( Items ( I )) DO WHILE ((. NOT . IsTheEnd ). AND .( I < ArrSize )) I = I + 1_kIndex IsTheEnd = Collection % MoveForward ( Items ( I )) END DO END BLOCK RETURN END FUNCTION TreeSet_GetAll ! ----------------------------------------------------------------------------- ! -----                        Common Procedures                          ----- ! ----------------------------------------------------------------------------- FUNCTION TreeSet_FindItem ( Collection , Item , ItemNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified item is currently stored in a hash set or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be looked for !% the node containing the specified item; null pointer if the item is not found TYPE ( SetNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: ItemNode !> flag indicating whether the specified item is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SetNode ) :: InNode CLASS ( BSTNode ), POINTER :: StoredNode ! FLOW ! initialize Found = Falseval IF ( PRESENT ( ItemNode )) ItemNode => NULL () ! check the specified key and return quickly if not valid IF (. NOT . IsKeyOrdered ( Item )) RETURN IF (. NOT . Collection % IsItemValid ( Item )) RETURN ! set key for search node CALL InNode % SetItem ( Item , Collection % ItemPool ) ! find the stored node equal to input node Found = Collection % WrkTree % Contain ( InNode , StoredNode ) IF ( PRESENT ( ItemNode ). AND . Found ) THEN SELECT TYPE ( StoredNode ) TYPE IS ( SetNode ) ItemNode => StoredNode END SELECT END IF ! free working pointer NULLIFY ( StoredNode ) RETURN END FUNCTION TreeSet_FindItem !****************************************************************************** SUBROUTINE TreeSet_CreateByArray ( Collection , N , Items ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of items. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of items CLASS ( * ), INTENT ( IN ) :: Items ( N ) !! the items to be added to the set !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! add items to the set DO I = 1_kIndex , N CALL Collection % Insert ( Items ( I )) END DO RETURN END SUBROUTINE TreeSet_CreateByArray !****************************************************************************** SUBROUTINE TreeSet_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the collection. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % Destruct () RETURN END SUBROUTINE TreeSet_Finalize !****************************************************************************** FUNCTION TreeSet_Remove ( Collection , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified item (and its associated value) from a collection.  Also, !  return a flag indicating whether the item is successfully removed or not. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be removed !> flag indicating whether the specified item and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SetNode ), POINTER :: ItemNode tLogical :: Success ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindItem ( Item , ItemNode ) END IF IF ( Flag ) THEN IF ( Collection % IsRBTree ) THEN ! WrkTree is a red-black tree. Success = Collection % WrkTree % Remove ( ItemNode ) ELSE ! WrkTree is an AVL tree. Success = Collection % WrkTree % IntrusiveAVLTree % Remove ( ItemNode ) END IF ! check if remove the node successfully or not IF ( Success ) THEN ! return the node to the node's pool CALL Collection % NodePool % ReturnNode ( ItemNode ) ELSE CALL Handle_ErrLevel ( 'TreeSet_Remove' , ModName , ErrWarning , & 'Check the Remove method of the intrusive tree for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( ItemNode ) RETURN END FUNCTION TreeSet_Remove !****************************************************************************** FUNCTION TreeSet_Contain ( Collection , Item ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified item is currently stored in a collection.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be looked for !% flag indicating whether the specified item is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSE Found = Collection % FindItem ( Item ) END IF RETURN END FUNCTION TreeSet_Contain !****************************************************************************** SUBROUTINE TreeSet_UseAVLTree ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the *IsRBTree* component to false. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Collection % IsRBTree = FalseVal RETURN END SUBROUTINE TreeSet_UseAVLTree !****************************************************************************** SUBROUTINE TreeSet_UseRBTree ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the *IsRBTree* component to true. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object CLASS ( TreeSet ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: Collection % IsRBTree = TrueVal RETURN END SUBROUTINE TreeSet_UseRBTree !****************************************************************************** END MODULE MClass_TreeSet !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treeset.f90.html"},{"title":"MClass_PQCharacter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQCharacter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQCharacter* type and its related routines. !   The *PQCharacter* type is a priority-queue container with *CHARACTER* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQCharacter* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQCharacter PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQCharacter' !** DERIVED TYPE DEFINITIONS !> The *PQCharacter* type is a container type that employs a binary heap implementation !  to provide common operations for a priority queue. TYPE PQCharacter PRIVATE !% pointer to last item of the priority queue tIndex :: Last = 0_kIndex !% incremental size of priority queue if it is full tIndex :: IncSize = 16_kIndex !% flag to shrink priority queue capacity tLogical :: Shrink = FalseVal !> flag indicating whether the priority queue is implemented as !  a maximum PQ or a minimum PQ. <br> !  default -> a maximum PQ. tLogical :: Min = FalseVal !% stored keys in the priority queue. tCharAlloc :: Keys (:) !% length of character string tIndex :: CharLen = 80_kIndex CONTAINS ! --------------------------------------------------------------------- ! -----                      Public Procedures                    ----- ! --------------------------------------------------------------------- ! -----     constructor and destructor procedures   ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%CreateEmpty(CharLen, InitCap)            ! use default options  <br> !   --->    CALL PQ%CreateEmpty(72, 32, MinPQ=.TRUE.)        ! use min-priority queue <br> !   --->    CALL PQ%CreateEmpty(72, 32, IncSize=16)          ! specify incremental size <br> !   --->    CALL PQ%CreateEmpty(72, 32, Shrink=.TRUE.)       ! specify shrinking <br> !   --->    CALL PQ%CreateEmpty(72, 32, .TRUE., 16, .TRUE.)  ! specify all options <br> PROCEDURE :: CreateEmpty => PQHeap_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a priority queue from the specified key arrays. <br> !  **Usage**: <br> !   ! use default options  <br> !   --->    CALL PQ%Construct(40, KeyArr) <br> !   ! specify all options (initial capacity is array size plus incremental size) <br> !   --->    CALL PQ%Construct(20, KeyArr, MinPQ, IncSize, Shrink) <br> PROCEDURE :: Construct => PQHeap_ConstructorByArray !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all stored keys and free all memory currently used by the priority !       queue.  Optionally, stored keys can be retrieved. <br> !  **Usage**: <br> !   --->    CALL PQ%Destruct() <br> !   --->    CALL PQ%Destruct(StoredKeys) <br> PROCEDURE :: Destruct => PQHeap_Destructor ! ------------------------------------------------------- ! -----         adding and removing procedures      ----- ! ------------------------------------------------------- !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key to the priority queue. <br> !  **Usage**: <br> !   --->    CALL PQ%Insert(Key) <br> PROCEDURE :: Insert => PQHeap_InsertKey !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To retrieve and remove the highest-priority key from the priority queue.  Also, !       return a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Remove(Key) <br> !   --->    IF (.NOT.PQ%Remove(Key)) DoSomething PROCEDURE :: Remove => PQHeap_RemoveKey ! ------------------------------------------------------- ! -----               inquiry procedures            ----- ! ------------------------------------------------------- !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the priority queue is empty or not. <br> !  **Usage**: <br> !   --->    Flag = PQ%IsEmpty() <br> !   --->    IF (.NOT.PQ%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => PQHeap_IsEmpty !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size (number of stored keys) of the priority queue. <br> !  **Usage**: <br> !   --->    Size = PQ%GetSize() PROCEDURE :: GetSize => PQHeap_GetSize !> **Type-Bound Function**: Peek <br> !  **Purpose**:  To retrieve the highest-priority key from the priority queue.  Also, return !       a flag indicating whether the key-value pair is successfully removed or not.  <br> !  **Usage**: <br> !   --->    Flag = PQ%Peek(Key) <br> !   --->    IF (.NOT.PQ%Peek(Key)) DoSomething PROCEDURE :: Peek => PQHeap_PeekKey ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: PQHeap_Finalizer ! --------------------------------------------------------------------- END TYPE PQCharacter !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ !                           Routines for PQCharacter !++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ SUBROUTINE PQHeap_CreateEmpty ( PQ , CharLen , InitCap , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tIndex , INTENT ( IN ) :: CharLen !! length of character string tIndex , INTENT ( IN ) :: InitCap !! initial size of priority queue tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! first, check required input data IF ( InitCap < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQHeap_CreateEmpty' , ModName , ErrWarning , & 'Invalid InitCap (< 1).  Set the initial capacity of priority queue to 16.' ) Capacity = PQ % IncSize ELSE Capacity = InitCap END IF IF ( CharLen < 1_kIndex ) THEN CALL Handle_ErrLevel ( 'PQHeap_CreateEmpty' , ModName , ErrWarning , & 'Invalid CharLen (< 1).  Set length of the character string to 80.' ) ELSE PQ % CharLen = CharLen END IF ! then, allocate space for the keys in the priority queue CALL MemAlloc ( PQ % Keys , PQ % CharLen , [ Capacity ]) ! finally, check optional input data IF ( PRESENT ( MinPQ )) PQ % Min = MinPQ IF ( PRESENT ( IncSize )) THEN IF ( IncSize > 0_kIndex ) PQ % IncSize = IncSize END IF IF ( PRESENT ( Shrink )) PQ % Shrink = Shrink RETURN END SUBROUTINE PQHeap_CreateEmpty !****************************************************************************** SUBROUTINE PQHeap_ConstructorByArray ( PQ , N , Keys , MinPQ , IncSize , Shrink ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To construct a priority queue from an array of key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tIndex , INTENT ( IN ) :: N !! number of keys tCharStar , INTENT ( IN ) :: Keys ( N ) !! key array tLogical , OPTIONAL , INTENT ( IN ) :: MinPQ !&#94; true if the priority queue to be implemented as a MinPQ; default -> a MaxPQ tIndex , OPTIONAL , INTENT ( IN ) :: IncSize !! incremental size of priority queue if it is full tLogical , OPTIONAL , INTENT ( IN ) :: Shrink !&#94; true if want to reduce capacity when size is less than a quarter of the capacity; !  default is false. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , InitCap ! FLOW ! simply return if N is less than 1 IF ( N <= 0_kIndex ) RETURN ! create empty priority queue IF ( PRESENT ( IncSize )) THEN InitCap = N + IncSize ELSE InitCap = N + PQ % IncSize END IF CALL PQ % CreateEmpty ( LEN ( Keys ( 1 ), kIndex ), InitCap , MinPQ , IncSize , Shrink ) ! add input keys to the priority queue DO I = 1_kIndex , N CALL PQ % Insert ( Keys ( I )) END DO RETURN END SUBROUTINE PQHeap_ConstructorByArray !****************************************************************************** SUBROUTINE PQHeap_Destructor ( PQ , Keys ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct PQCharacter object and get its keys if requested. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tCharLen (:), ALLOCATABLE , OPTIONAL , INTENT ( OUT ) :: Keys (:) !! array of keys !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: N , ID tLogical :: Success ! FLOW IF (. NOT . PQ % IsEmpty ()) THEN IF ( PRESENT ( Keys )) THEN ! get keys (and free memory of components of keys if applicable) N = PQ % Last CALL MemAlloc ( Keys , PQ % CharLen , [ N ]) DO ID = 1_kIndex , N Success = PQ % Remove ( Keys ( ID )) END DO END IF END IF ! reset components PQ % Last = 0_kIndex PQ % IncSize = 10_kIndex PQ % Shrink = FalseVal PQ % Min = FalseVal ! free memory of priority queue keys IF ( ALLOCATED ( PQ % Keys )) DEALLOCATE ( PQ % Keys ) RETURN END SUBROUTINE PQHeap_Destructor !****************************************************************************** SUBROUTINE PQHeap_Finalizer ( PQ ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free up memory and reset components CALL PQ % Destruct () RETURN END SUBROUTINE PQHeap_Finalizer !****************************************************************************** SUBROUTINE PQHeap_InsertKey ( PQ , NewKey ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a new key to the top (or bottom) of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tCharStar , INTENT ( IN ) :: NewKey !! new key to be added to the priority queue !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity ! FLOW ! check capacity of the priority queue Capacity = SIZE ( PQ % Keys ) IF ( PQ % Last == Capacity ) THEN ! increase the priority queue capacity Capacity = Capacity + PQ % IncSize ! resize the priority queue CALL MemResize ( PQ % Keys , [ Capacity ]) END IF ! increment the pointer PQ % Last = PQ % Last + 1_kIndex ! then, add new key to the priority queue PQ % Keys ( PQ % Last ) = NewKey ! restore heap order CALL ReHeapify_BottomUp ( PQ , PQ % Last ) #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( PQ , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQHeap_InsertKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif RETURN END SUBROUTINE PQHeap_InsertKey !****************************************************************************** FUNCTION PQHeap_RemoveKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve and remove the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tCharLen ( PQ % CharLen ), INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Capacity tCharLen ( PQ % CharLen ) :: Temp ! FLOW ! first, check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal RETURN ELSE Flag = TrueVal END IF ! get the highest-priority key HPKey = PQ % Keys ( 1 ) !--- remove the highest-priority key from the queue --- ! swap the highest-priority key with the last one EXCHANGE ( PQ % Keys , 1_kIndex , PQ % Last ) ! update pointer PQ % Last = PQ % Last - 1_kIndex ! restore heap order CALL ReHeapify_TopDown ( PQ , 1_kIndex , PQ % Last ) ! shrink capacity of the priority queue if necessary IF ( PQ % Shrink ) THEN Capacity = SIZE ( PQ % Keys , KIND = kIndex ) IF (( PQ % Last > 0_kIndex ). AND .( PQ % Last == Capacity / 4_kIndex )) THEN ! reduce the priority queue capacity Capacity = Capacity / 2_kIndex ! resize the priority queue CALL MemResize ( PQ % Keys , [ Capacity ]) END IF END IF #ifdef DebugMode ! for debugging purpose IF (. NOT . IsHeapOrdered ( PQ , 1_kIndex )) THEN CALL Handle_ErrLevel ( 'PQHeap_RemoveKey' , ModName , ErrWarning , & 'The heap is NOT in order.' ) END IF #endif RETURN END FUNCTION PQHeap_RemoveKey !****************************************************************************** FUNCTION PQHeap_IsEmpty ( PQ ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the priority queue is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( IN ) :: PQ !! PQCharacter object tLogical :: Flag !! true if the priority queue is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( PQ % Last == 0 ) RETURN END FUNCTION PQHeap_IsEmpty !****************************************************************************** FUNCTION PQHeap_GetSize ( PQ ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get size of the priority queue. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( IN ) :: PQ !! PQCharacter object tIndex :: Size !! size (number of keys) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = PQ % Last RETURN END FUNCTION PQHeap_GetSize !****************************************************************************** FUNCTION PQHeap_PeekKey ( PQ , HPKey ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To retrieve the highest-priority key from the priority queue.  Also, return !  a flag indicating whether the key-value pair is successfully removed or not.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tCharLen ( PQ % CharLen ), INTENT ( OUT ) :: HPKey !! the highest-priority key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check whether the priority queue is empty or not IF ( PQ % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = TrueVal ! get the highest-priority key HPKey = PQ % Keys ( 1 ) END IF RETURN END FUNCTION PQHeap_PeekKey !****************************************************************************** SUBROUTINE ReHeapify_TopDown ( PQ , Start , Bottom ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by sinking down !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tIndex , INTENT ( IN ) :: Start !! starting index tIndex , INTENT ( IN ) :: Bottom !! ending index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J tCharLen ( PQ % CharLen ) :: Temp !** FLOW: Temp = PQ % Keys ( Start ) I = Start J = I + I ! do while j <= bottom IF ( PQ % Min ) THEN ! for MinPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( PQ % Keys ( J ) > PQ % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( PQ % Keys ( J ) >= Temp ) EXIT ! otherwise, demote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I + I END DO ELSE ! for MaxPQ DO IF ( J > Bottom ) EXIT IF ( J < Bottom ) THEN ! compare to the better underling IF ( PQ % Keys ( J ) < PQ % Keys ( J + 1 )) THEN J = J + 1 END IF END IF ! found key's level. Terminate the sift-down. IF ( PQ % Keys ( J ) <= Temp ) EXIT ! otherwise, demote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I + I END DO END IF ! put key into its slot. PQ % Keys ( I ) = Temp RETURN END SUBROUTINE ReHeapify_TopDown !****************************************************************************** SUBROUTINE ReHeapify_BottomUp ( PQ , Start ) !** PURPOSE OF THIS SUBROUTINE !&#94; To restore heap order by swimming up. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( INOUT ) :: PQ !! PQCharacter object tIndex , INTENT ( IN ) :: Start !! starting index !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J tCharLen ( PQ % CharLen ) :: Temp !** FLOW: Temp = PQ % Keys ( Start ) I = Start J = I / 2 ! do while k > 1 and key(k/2) < key(k) IF ( PQ % Min ) THEN ! for MinPQ DO WHILE (( I > 1 ). AND .( PQ % Keys ( J ) > Temp )) ! promote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I / 2 END DO ELSE ! for MaxPQ DO WHILE (( I > 1 ). AND .( PQ % Keys ( J ) < Temp )) ! promote key and continue. PQ % Keys ( I ) = PQ % Keys ( J ) I = J J = I / 2 END DO END IF ! put key into its slot. PQ % Keys ( I ) = Temp RETURN END SUBROUTINE ReHeapify_BottomUp !****************************************************************************** RECURSIVE FUNCTION IsHeapOrdered ( PQ , Start ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE !&#94; To check whether the heap is in order or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( PQCharacter ), INTENT ( IN ) :: PQ !! PQCharacter object tIndex , INTENT ( IN ) :: Start !! starting index tLogical :: Flag !! true if the heap is in order !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: Left , Right !** FLOW: IF ( Start > PQ % Last ) THEN Flag = TrueVal RETURN END IF Left = Start + Start Right = Left + 1 IF ( PQ % Min ) THEN ! for MinPQ IF (( Left <= PQ % Last ) . AND . ( PQ % Keys ( Start ) > PQ % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= PQ % Last ) . AND . ( PQ % Keys ( Start ) > PQ % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF ELSE ! for MaxPQ IF (( Left <= PQ % Last ) . AND . ( PQ % Keys ( Start ) < PQ % Keys ( Left ))) THEN Flag = FalseVal RETURN END IF IF (( Right <= PQ % Last ) . AND . ( PQ % Keys ( Start ) < PQ % Keys ( Right ))) THEN Flag = FalseVal RETURN END IF END IF Flag = ( IsHeapOrdered ( PQ , Left ) . AND . IsHeapOrdered ( PQ , Right )) RETURN END FUNCTION IsHeapOrdered !****************************************************************************** END MODULE MClass_PQCharacter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqcharacter.f90.html"},{"title":"MClass_HTabRealQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabRealQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabRealQP* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabRealQP* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabRealQP* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabRealQP* type uses the Fortran intrinsic !   *REAL(KIND=kQuad)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabRealQP* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabRealQP* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabRealQP #define     KeyTypeA        REAL(KIND=kQuad) #define     KeyTypeB        REAL(KIND=kQuad) #define     QueueKey        ListRealQP #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabRealQP PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabRealQP' ! positive infinity (assuming little-endian order) tSInt64 , PARAMETER :: INFVAL ( 2 ) = [ ToInt64 ( Z '0000000000000000' ), ToInt64 ( Z '7FFF000000000000' )] ! quiet NAN (assuming little-endian order) tSInt64 , PARAMETER :: NANVAL ( 2 ) = [ ToInt64 ( Z '0000000000000000' ), ToInt64 ( Z '7FFF800000000000' )] ! Special marker token used to indicate the deletion of a key-value pair tRealQP , PARAMETER :: DELKEY = TRANSFER ( INFVAL , 1.0_kQuad ) ! Special marker token used to indicate the empty of a key-value pair tRealQP , PARAMETER :: NULKEY = TRANSFER ( NANVAL , 1.0_kQuad ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabRealQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabrealqp.f90.html"},{"title":"MClass_ListInteger8B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListInteger8B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListInteger8B* type and related routines. !   The *ListInteger8B* type is a container with *INTEGER(KIND=kI8B)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListInteger8B* type but utilizes a different implementation. !   Also, unlike the *ListInteger8B* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListInteger8B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListInteger8B #define DLLNode             DLLNodeInteger8B #define ItemTypeA           INTEGER(KIND=kInt64) #define ItemTypeB           INTEGER(KIND=kInt64) #define ItemTypeC           INTEGER(KIND=kInt64) #define TypeOfItem          INTEGER(KIND=kInt64) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListInteger8B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListInteger8B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listinteger8b.f90.html"},{"title":"MClass_HashList.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HashList !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HashList* type and its supporting routines and data type. !   The *HashList* type is a collection type that employs a separate-chaining hash table !   implementation to provide common operations for an unordered symbol table. <br> !   The *HashList* type uses the *KeyUnordered* type to store its keys and the *GenData* !   type to store its values.  Therefore, it can be used to store key-value pairs of any !   data types (except the *LOGICAL* type for the keys).  Like other collection types, !   however, it must be employed to store key-value pairs of only specific key type and !   one specific value type.  To store key-value pairs of another key type (or another !   value type), it must be destructed before inserting items of different key type (or !   different value type). <br> !   As a symbol table, the *HashList* type does not allow duplicated keys.  Therefore, if !   an inserted key is equal to a key stored in the table, an associated value of the stored !   key is replaced by an associated value of the inserted key.  As an *unordered* symbol !   table, the *HashList* type makes no guarantees as to the iteration order of the table. !   In particular, it does not guarantee that the order will remain the same over time. <br> !   Technically, the *HashList* type utilizes the *IntrusiveHashList* type as its component !   to store its hash-list nodes.  As an *intrusive* container, the *IntrusiveHashList* type, !   which is based on a separate-chaining hash table implementation, provides common hash-table !   operations without a memory management task.  The memory management task of the inserted !   hash-list nodes is handled by the *HashList* type.  <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_IntrusiveLinkedLists , ONLY : DoublyLinkedNode USE MClass_IntrusiveHashList USE MClass_Object , ONLY : Object USE MClass_BaseNodePool USE MClass_MemoryPool USE MClass_GenData USE MClass_KeyUnordered USE MClass_BaseCollection USE MClass_BaseSymTable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HashList PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HashList' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! default initial capacity tIndex , PARAMETER :: DfltInitCap = 64_kIndex !** DERIVED TYPE DEFINITIONS !> *TabNode* is a doubly-linked-list node type containing key and value as its components. !   The *KeyUnordered* type is used as a storage for the key and the *GenData* type is used !   as a storage for the value.  The *TabNode* type is a subtype of the *HashListNode* type !   and is intended to be used with the *HashList* type, which is a collection type that !   utilizes the *IntrusiveHashList* type. <br> TYPE , EXTENDS ( HashListNode ) :: TabNode TYPE ( KeyUnordered ) :: Key !! stored key TYPE ( GenData ) :: Value !! stored value CONTAINS ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => TabNode_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => TabNode_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => TabNode_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => TabNode_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => TabNode_HashCode ! --------------------------------------------------------------------- ! -----         Specific Procedure for TabNode Type               ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: SetKeyNVal <br> !  **Purpose**:  To set new key and value. <br> !  **Usage**: <br> !   --->    Valid = Node%SetKeyNVal(Key, Value, MemPool) PROCEDURE :: SetKeyNVal => TabNode_SetKeyNVal !> **Type-Bound Function**: IsKeyEqual <br> !  **Purpose**:  To check whether the specified key is equal to the node's key. <br> !  **Usage**: <br> !   --->    Flag = Node%IsKeyEqual(Key) PROCEDURE :: IsKeyEqual => TabNode_IsKeyEqual !> **Type-Bound Function**: IsEqualKey <br> !  **Purpose**:  To check whether the specified key is equal to the node's key. <br> !  **Usage**: <br> !   --->    Flag = Node%IsEqualKey(Key) PROCEDURE :: IsEqualKey => TabNode_IsEqualKey ! --------------------------------------------------------------------- END TYPE TabNode !> The *HashList* type is a collection type that employs a separate-chaining hash table !  implementation to provide common operations for an unordered symbol table.  The *HashList* !  type utilizes the *IntrusiveHashList* type as its component to store *TabNode* objects. !  As an intrusive container, the *IntrusiveHashList* type provides common operations for !  hash table without a memory management task.  The memory management task of the inserted !  *TabNode* objects is handled by the *HashList* type. <br> !  As an unordered symbol table, the *HashList* type directly extends the *BaseSymTable* !  type and implements all deferred procedures required by the *BaseSymTable* type and all !  its super classes.  As a symbol table, the *HashList* type does not allow duplicated keys; !  therefore, if an inserted key is equal to a key stored in the table, an associated value !  of the stored key is replaced by an associated value of the inserted key. <br> TYPE , EXTENDS ( BaseSymTable ) :: HashList PRIVATE ! a working hash table TYPE ( IntrusiveHashList ) :: WrkTab !> memory pool of hash-list nodes TYPE ( BaseNodePool ) :: NodePool !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindKey <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindKey(Key, KeyNode) <br> !   --->    IF (.NOT.Collection%FindKey(Key)) DoSomething PROCEDURE , PRIVATE :: FindKey => HashList_FindKey !> To retrieve all stored keys PROCEDURE , PRIVATE :: GetAllKeys => HashList_GetAllKeys !> To retrieve all stored values PROCEDURE , PRIVATE :: GetAllVals => HashList_GetAllVals !> To retrieve all stored keys and values PROCEDURE , PRIVATE :: GetAllPairs => HashList_GetAllPairs !> Use the *Construct* method to construct the collection from an array of key-value pairs. PROCEDURE , PRIVATE :: HashList_CreateByArray ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseCollection Type      ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashList_CopyCollection !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashList_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashList_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start an iteration and return a flag indicating whether !                the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey) <br> !   --->    IsEmpty = Collection%StartFirst(Value=FirstVal) <br> !   --->    IsEmpty = Collection%StartFirst(FirstKey, FirstVal) PROCEDURE :: StartFirst => HashList_Move2FirstPair !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next key-value pair and return a flag !                indicating whether the cursor pointer has reached the end of !                the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey) <br> !   --->    IsTheEnd = Collection%MoveForward(Value=NextVal) <br> !   --->    IsTheEnd = Collection%MoveForward(NextKey, NextVal) PROCEDURE :: MoveForward => HashList_Move2NextPair !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified key-value pair to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Key, Value) <br> PROCEDURE :: Insert => HashList_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current key-value pair from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the !  *StartFirst* and *MoveForward* methods.  Therefore, after the call to !  one of those methods and then calling this one will result in a removal !  of the current pair data of the iteration (i.e. the same key-value pair !  that can be retrieved via the *StartFirst* and *MoveForward* methods). PROCEDURE :: Delete => HashList_Delete !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified key (and its associated value) from !                the collection.  Also, return a flag indicating whether the !                key-value pair is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Key) <br> !   --->    IF (.NOT.Collection%Remove(Key)) DoSomething PROCEDURE :: Remove => HashList_Remove !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified key in the collection.  Return true if !                the specified key is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Key) <br> !   --->    IF (.NOT.Collection%Contain(Key)) DoSomething PROCEDURE :: Contain => HashList_Contain !> **Type-Bound Function**: GetValue <br> !  **Purpose**:  To get a value associated with the specified key in the collection. !                Also, return a flag indicating whether the key-value pair is !                successfully found or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%GetValue(Key, Value) <br> !   --->    IF (.NOT.Collection%GetValue(Key, Value)) DoSomething PROCEDURE :: GetValue => HashList_GetValue !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all key-value pairs from the collection.  Also, return !       a flag indicating whether the pairs are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Keys, Values) <br> !   --->    IF (.NOT.Collection%ToArray(Keys, Values)) DoSomething PROCEDURE :: ToArray => HashList_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all keys and/or all values (without removing them) from the collection. !       Also, return a flag indicating whether the keys and/or the values are successfully !       retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Keys, Values) <br> !   --->    IF (.NOT.Collection%GetAll(Keys, Values)) DoSomething PROCEDURE :: GetAll => HashList_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()            ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)  ! specify initial capacity <br> PROCEDURE :: CreateEmpty => HashList_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) <br> GENERIC :: Construct => HashList_CreateByArray ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashList_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashList_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashList_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashList_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashList_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the object. FINAL :: HashList_Finalize ! --------------------------------------------------------------------- END TYPE HashList !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! --------------------------------------------------------------------- ! -----                 TabNode Procedures                        ----- ! --------------------------------------------------------------------- SUBROUTINE TabNode_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To copy the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! copy Key and Value components SELECT TYPE ( DstObj ) TYPE IS ( TabNode ) CALL SrcObj % CopyHashNode ( DstObj ) CALL SrcObj % Key % Copy ( DstObj % Key , IsDeep ) CALL SrcObj % Value % Copy ( DstObj % Value , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'TabNode_Copy' , ModName , ErrSevere , & 'Type of the destination object must be \"TabNode\" only.' ) RETURN END SELECT RETURN END SUBROUTINE TabNode_Copy !****************************************************************************** FUNCTION TabNode_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure by an *Object* object. <br> !  It should be noted that this routine uses all components of !  the *TabNode* object to check equality. Therefore, although !  (A%CompareTo(B) == 0) returns true, (A%IsEqualTo(B)) can return !  false. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! check key and value equalities SELECT TYPE ( RhsObj ) TYPE IS ( TabNode ) Flag = FalseVal IF (. NOT . LhsObj % Key % IsEqualTo ( RhsObj % Key )) RETURN IF (. NOT . LhsObj % Value % IsEqualTo ( RhsObj % Value )) RETURN Flag = LhsObj % IsHashNodeEqual ( RhsObj ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabNode_IsEqualTo !****************************************************************************** SUBROUTINE TabNode_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the TabNode object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! free the key and value components CALL Obj % Key % MemFree () CALL Obj % Value % MemFree () ! reset the node's components CALL Obj % ResetHashNode () RETURN END SUBROUTINE TabNode_MemFree !****************************************************************************** FUNCTION TabNode_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !  This is a deferred procedure by an *Object* object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{TabNode: {' // Obj % Key % ToString () // ' : ' // Obj % Value % ToString () // '}}' RETURN END FUNCTION TabNode_ToString !****************************************************************************** FUNCTION TabNode_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( DoublyLinkedNode ), POINTER :: AdjNode ! FLOW ! get code from previous node AdjNode => Obj % GetPrevious () SELECT TYPE ( PrevNode => AdjNode ) TYPE IS ( TabNode ) Code = PrevNode % Key % HashCode () END SELECT ! add code from this node Code = Code + Obj % Key % HashCode () ! add code from next node AdjNode => Obj % GetNext () SELECT TYPE ( NextNode => AdjNode ) TYPE IS ( TabNode ) Code = Code + NextNode % Key % HashCode () END SELECT ! free pointer NULLIFY ( AdjNode ) RETURN END FUNCTION TabNode_HashCode !****************************************************************************** FUNCTION TabNode_IsKeyEqual ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is equal to the node's key. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: LhsObj !! an object CLASS ( HashListNode ), INTENT ( INOUT ) :: RhsObj !! another object tLogical :: Flag !! true if keys of both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( TabNode ) Flag = LhsObj % Key % IsEqualTo ( RhsObj % Key ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION TabNode_IsKeyEqual !****************************************************************************** SUBROUTINE TabNode_SetKeyNVal ( Node , Key , Value , Pool ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set the key and value. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( TabNode ), INTENT ( INOUT ) :: Node !! TabNode object CLASS ( * ), INTENT ( IN ) :: Key !! the key CLASS ( * ), INTENT ( IN ) :: Value !! the associated value TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !! memory pool for both key and value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Node % Key % Set ( Key , Pool ) CALL Node % Value % Set ( Value , Pool ) RETURN END SUBROUTINE TabNode_SetKeyNVal !****************************************************************************** FUNCTION TabNode_IsEqualKey ( Node , Key , Pool ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is equal to the node's key. !** SUBROUTINE ARGUMENT DECLARATIONS: !% TabNode object CLASS ( TabNode ), INTENT ( IN ) :: Node !% the key to be retrieved CLASS ( * ), INTENT ( IN ) :: Key !% memory pool TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool !% true if the keys are equal; otherwise, false. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( GenData ) :: KeyInp !** FLOW: CALL KeyInp % Set ( Key , Pool ) Flag = Node % Key % IsEqualTo ( KeyInp ) CALL KeyInp % MemFree () RETURN END FUNCTION TabNode_IsEqualKey ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type          ----- ! --------------------------------------------------------------------- SUBROUTINE HashList_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !  *Note*:  SrcObj must be in the *HashList* class. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( HashList ) CALL SrcObj % NodePool % Copy ( DstObj % NodePool , IsDeep ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) CALL SrcObj % WrkTab % CloneTo ( DstObj % WrkTab ) CLASS DEFAULT CALL Handle_ErrLevel ( 'HashList_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE HashList_Copy !****************************************************************************** FUNCTION HashList_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashList ) Flag = FalseVal IF ( LhsObj % GetSize () /= RhsObj % GetSize ()) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN ! implementation note:  we cannot use the iteration methods here !   due to the intent of the input data. BLOCK tIndex :: I CLASS ( BaseNode ), POINTER :: LhsNodes (:), RhsNodes (:) ! initialize CALL LhsObj % NodePool % GetAllNodes ( LhsNodes ) CALL RhsObj % NodePool % GetAllNodes ( RhsNodes ) IF ( SIZE ( LhsNodes , KIND = kIndex ) == SIZE ( RhsNodes , KIND = kIndex )) THEN SELECT TYPE ( LhsNodes ) TYPE IS ( TabNode ) SELECT TYPE ( RhsNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( LhsNodes , KIND = kIndex ) Flag = LhsNodes ( I )% IsEqualTo ( RhsNodes ( I )) IF (. NOT . Flag ) EXIT END DO END SELECT END SELECT END IF NULLIFY ( LhsNodes , RhsNodes ) END BLOCK END IF CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashList_IsEqualTo !****************************************************************************** SUBROUTINE HashList_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the HashList object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Obj % WrkTab % Destruct () CALL Obj % NodePool % MemFree () CALL Obj % ItemPool % Destruct () CALL Obj % FreeMolds () RETURN END SUBROUTINE HashList_MemFree !****************************************************************************** FUNCTION HashList_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the HashList type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: KeyStr , ValStr , ItemStr CLASS ( BaseNode ), POINTER :: PoolNodes (:) ! initialize Count = 0_kIndex CALL Obj % NodePool % GetAllNodes ( PoolNodes ) CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 60_kIndex ) CALL ChrBuf % Append ( '[' ) SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE IF ( Nodes ( I )% Value % IsEmpty ()) CYCLE KeyStr = Nodes ( I )% Key % ToString () ValStr = Nodes ( I )% Value % ToString () ItemStr = '{' // KeyStr ( 17 : LEN ( KeyStr ) - 1 ) // ' : ' // ValStr ( 12 : LEN ( ValStr ) - 1 ) // '}' CALL ChrBuf % Append ( ItemStr ) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO END SELECT NULLIFY ( PoolNodes ) CALL ChrBuf % Append ( ']' ) BaseStr = ChrBuf % AsString () END BLOCK END IF Str = '{HashList with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION HashList_ToString !****************************************************************************** FUNCTION HashList_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK CLASS ( BaseNode ), POINTER :: PoolNodes (:) tIndex :: I ! initialize CALL Obj % NodePool % GetAllNodes ( PoolNodes ) Code = 0_kIndex ! compute hash code SELECT TYPE ( Nodes => PoolNodes ) TYPE IS ( TabNode ) DO I = 1_kIndex , SIZE ( Nodes , KIND = kIndex ) IF ( Nodes ( I )% Key % IsEmpty ()) CYCLE Code = Code + Nodes ( I )% Key % HashCode () END DO END SELECT END BLOCK END IF RETURN END FUNCTION HashList_HashCode ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseCollection Type       ----- ! --------------------------------------------------------------------- SUBROUTINE HashList_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). <br> !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( HashList ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items (or keys) for a derived type not in the !  *Object* class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( Other ) TYPE IS ( HashList ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseSymTable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: KeyItem CLASS ( * ), ALLOCATABLE :: ValItem ! get key and value molds MoldPtr => Other % GetKeyPtr () ALLOCATE ( KeyItem , MOLD = MoldPtr ) MoldPtr => Other % GetValPtr () ALLOCATE ( ValItem , MOLD = MoldPtr ) ! loop through the other collection and get key-value pairs along the way IsTheEnd = Other % StartFirst ( KeyItem , ValItem , ItemCopy , ValCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( KeyItem , ValItem ) IsTheEnd = Other % MoveForward ( KeyItem , ValItem , ItemCopy , ValCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( KeyItem , ValItem ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'HashList_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseSymTable\" class.' ) END SELECT RETURN END SUBROUTINE HashList_CopyCollection !****************************************************************************** SUBROUTINE HashList_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove all of the items from the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! simply return if the collection is empty IF ( Collection % IsEmpty ()) RETURN ! clear elements CALL Collection % WrkTab % Clear () ! reset components CALL Collection % NodePool % Reset () ! free mold CALL Collection % FreeMolds () RETURN END SUBROUTINE HashList_ClearItems !****************************************************************************** SUBROUTINE HashList_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the collection. <br> ! This is a deferred procedure by the *BaseCollection* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE HashList_Destroy !****************************************************************************** FUNCTION HashList_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the number of items in the collection. !  This is a deferred procedure inherited from the *BaseCollection* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( IN ) :: Collection tIndex :: Size !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % WrkTab % GetSize () RETURN END FUNCTION HashList_GetSize ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseSymTable Type        ----- ! --------------------------------------------------------------------- FUNCTION HashList_Move2FirstPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a symbol table. !  For the *HashList*, which is an unordered symbol table, !  the starting pair is the first pair inserted.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the first key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the first value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the collection contains no pair data or not <br> ! - true if the collection is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( HashListNode ), POINTER :: CurrNode ! start iteration IsEmpty = Collection % WrkTab % StartFirst ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashList_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashList_Move2FirstPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! start iteration IsEmpty = Collection % WrkTab % StartFirst () END IF RETURN END FUNCTION HashList_Move2FirstPair !****************************************************************************** FUNCTION HashList_Move2NextPair ( Collection , Key , Value , KeyCopy , ValCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a symbol table. !  For the *HashList*, which is an unordered symbol table, !  the next pair is the pair inserted after the previous one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the next key as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Key !% the next value as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Value !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> a flag indicating whether the move to the end of the !  collection occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( PRESENT ( Key ). OR . PRESENT ( Value )) THEN BLOCK ! block variable CLASS ( HashListNode ), POINTER :: CurrNode ! move to next iteration IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) IF ( ASSOCIATED ( CurrNode )) THEN ! get the item stored in the node SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( PRESENT ( Key )) THEN IF (. NOT . CurrNode % Key % Get ( Key , KeyCopy )) THEN CALL Handle_ErrLevel ( 'HashList_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) END IF END IF IF ( PRESENT ( Value )) THEN IF (. NOT . CurrNode % Value % Get ( Value , ValCopy )) THEN CALL Handle_ErrLevel ( 'HashList_Move2NextPair' , ModName , ErrWarning , & 'Type of the specified value is NOT the same as that of stored values.' ) END IF END IF END SELECT END IF NULLIFY ( CurrNode ) END BLOCK ELSE ! move to next iteration IsTheEnd = Collection % WrkTab % MoveForward () END IF RETURN END FUNCTION HashList_Move2NextPair !****************************************************************************** SUBROUTINE HashList_Insert ( Collection , Key , Value ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add a key-value pair into a symbol table.  If the specified key is already !  stored in the table, replace the old value with the new one.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the key to be added to the collection CLASS ( * ), INTENT ( IN ) :: Key !% the associated value to be added to the collection CLASS ( * ), INTENT ( IN ) :: Value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: KeyFound TYPE ( TabNode ), POINTER :: KeyNode CLASS ( BaseNode ), POINTER :: NewNode ! FLOW ! check the specified key and value IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) THEN CALL Handle_ErrLevel ( 'HashList_Insert' , ModName , ErrSevere , & 'Type of the specified key is invalid or is NOT the same as that of stored keys.' ) RETURN ELSEIF (. NOT . Collection % IsValValid ( Value )) THEN CALL Handle_ErrLevel ( 'HashList_Insert' , ModName , ErrSevere , & 'Only values of the same type are allowed in a collection.' ) RETURN END IF ! check whether the key is already stored in the collection or not IF ( Collection % IsEmpty ()) THEN KeyFound = FalseVal ELSE KeyFound = Collection % FindKey ( Key , KeyNode ) END IF IF ( KeyFound ) THEN ! replace the current value with the new one CALL KeyNode % Value % Set ( Value , Collection % ItemPool ) ELSE ! +++ new key-value pair +++ ! check for first-time insertion IF (. NOT . Collection % NodePool % IsReady ()) THEN CALL Collection % CreateEmpty ( DfltInitCap ) END IF ! get new node from the node's pool CALL Collection % NodePool % GetNewNode ( NewNode ) SELECT TYPE ( NewNode ) TYPE IS ( TabNode ) KeyNode => NewNode END SELECT ! set key and value to the node ! (no need to check the valid flag since we have already done that in the beginning) CALL KeyNode % SetKeyNVal ( Key , Value , Collection % ItemPool ) ! append the new node to the working hash table CALL Collection % WrkTab % Insert ( KeyNode ) END IF ! free working pointer NULLIFY ( KeyNode , NewNode ) RETURN END SUBROUTINE HashList_Insert !****************************************************************************** SUBROUTINE HashList_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a key-value pair from a symbol table.  This procedure is intended !  to be used in conjunction with the *StartFirst* and *MoveForward* procedures. !  Therefore, after the call to either procedure and then calling this procedure !  will result in a removal of the current key-value pair of the iteration (i.e. !  the same key-value pair that can be retrieved via those *Move* procedures). <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: CLASS ( HashListNode ), POINTER :: DelNode ! FLOW ! remove node of the current iteration CALL Collection % WrkTab % Delete ( DelNode ) ! return the node to the nodes' pool IF ( ASSOCIATED ( DelNode )) THEN SELECT TYPE ( DelNode ) TYPE IS ( TabNode ) CALL Collection % NodePool % ReturnNode ( DelNode ) END SELECT END IF NULLIFY ( DelNode ) RETURN END SUBROUTINE HashList_Delete !****************************************************************************** FUNCTION HashList_Remove ( Collection , Key ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete the specified key (and its associated value) from a symbol !  table.  Also, return a flag indicating whether the key-value pair is !  successfully removed or not.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the key to be removed from the collection CLASS ( * ), INTENT ( IN ) :: Key !> flag indicating whether the specified key and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF IF ( Flag ) THEN ! check if remove the node successfully or not IF ( Collection % WrkTab % Remove ( KeyNode )) THEN ! return the node to the node's pool CALL Collection % NodePool % ReturnNode ( KeyNode ) ELSE CALL Handle_ErrLevel ( 'HashList_Remove' , ModName , ErrWarning , & 'Check the Remove method of the intrusive list for possible bug(s).' ) END IF END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION HashList_Remove !****************************************************************************** FUNCTION HashList_Contain ( Collection , Key ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified key is currently stored in a symbol table.  <br> !  This is a deferred procedure by the *BaseSymTable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSE Found = Collection % FindKey ( Key ) END IF RETURN END FUNCTION HashList_Contain !****************************************************************************** FUNCTION HashList_GetValue ( Collection , Key , Value , ValCopy ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get a value associated with the specified key in a symbol table. !  Also, return a flag indicating whether the key-value pair is successfully !  found or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the value associated with the specified key CLASS ( * ), INTENT ( INOUT ) :: Value !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !% flag indicating whether the key-value pair is found or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ), POINTER :: KeyNode ! FLOW ! check whether the key is stored in the collection or not IF ( Collection % IsEmpty ()) THEN Flag = FalseVal ELSE Flag = Collection % FindKey ( Key , KeyNode ) END IF ! get value if key is found IF ( Flag ) THEN Flag = KeyNode % Value % Get ( Value , ValCopy ) END IF ! free working pointer NULLIFY ( KeyNode ) RETURN END FUNCTION HashList_GetValue !************************************************************************************** FUNCTION HashList_ToArray ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all key-value pairs from the collection.  Also, return a flag !  indicating whether the pairs are successfully retrieved and removed or not. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values associated with the keys CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Keys , Values , KeyCopy , ValCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION HashList_ToArray !************************************************************************************** FUNCTION HashList_GetAll ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys and/or all values (without removing them) from the collection.  Also, !  return a flag indicating whether the keys and/or values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Keys ( 1 :) !% the values associated with the keys CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Values ( 1 :) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: SameKeyType , SameValType ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal ELSEIF ( PRESENT ( Keys ). AND . PRESENT ( Values )) THEN SameKeyType = Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal ) SameValType = Collection % IsValValid ( Values ( 1 )) ! check whether types of the specified keys and values are valid or not IF ( SameKeyType . AND . SameValType ) THEN Success = Collection % GetAllPairs ( Keys , Values , KeyCopy , ValCopy ) ELSEIF ( SameKeyType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashList_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) ELSEIF ( SameValType ) THEN Success = FalseVal CALL Handle_ErrLevel ( 'HashList_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashList_GetAll' , ModName , ErrSevere , & 'Types of both keys and values are NOT the same as those of stored pairs.' ) END IF ELSEIF ( PRESENT ( Keys )) THEN ! check whether type of the specified keys is valid or not IF ( Collection % IsKeyValid ( Keys ( 1 ), IsOrderedKey = FalseVal )) THEN Success = Collection % GetAllKeys ( Keys , KeyCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashList_GetAll' , ModName , ErrSevere , & 'Type of the specified keys is NOT the same as that of stored keys.' ) END IF ELSEIF ( PRESENT ( Values )) THEN ! check whether type of the specified values is valid or not IF ( Collection % IsValValid ( Values ( 1 ))) THEN Success = Collection % GetAllVals ( Values , ValCopy ) ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashList_GetAll' , ModName , ErrSevere , & 'Type of the specified values is NOT the same as that of stored values.' ) END IF END IF RETURN END FUNCTION HashList_GetAll !************************************************************************************** FUNCTION HashList_GetAllPairs ( Collection , Keys , Values , KeyCopy , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all key-value pairs (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , KeySize , ValSize tLogical :: IsTheEnd CLASS ( HashListNode ), POINTER :: CurrNode ! FLOW ! initialize local variables KeySize = SIZE ( Keys , KIND = kIndex ) ValSize = SIZE ( Values , KIND = kIndex ) IF (( KeySize < 1_kindex ). AND .( ValSize < 1_kindex )) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) IF ( I <= KeySize ) Success = CurrNode % Key % Get ( Keys ( I ), KeyCopy ) IF ( Success . AND .( I <= ValSize )) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashList_GetAllPairs !************************************************************************************** FUNCTION HashList_GetAllKeys ( Collection , Keys , KeyCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all keys (without removing them) from the collection.  Also, !  return a flag indicating whether the keys are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the keys to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Keys (:) !> a procedure to copy stored keys for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: KeyCopy !> flag indicating whether the keys are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( HashListNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Keys , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the keys along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Key % Get ( Keys ( I ), KeyCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashList_GetAllKeys !************************************************************************************** FUNCTION HashList_GetAllVals ( Collection , Values , ValCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all values (without removing them) from the collection.  Also, !  return a flag indicating whether the values are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashList object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the values to be retrieved and removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Values (:) !> a procedure to copy stored values for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !> flag indicating whether the values are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , ArrSize tLogical :: IsTheEnd CLASS ( HashListNode ), POINTER :: CurrNode ! FLOW ! initialize local variables ArrSize = SIZE ( Values , KIND = kIndex ) IF ( ArrSize < 1_kindex ) RETURN I = 1_kindex ! loop through the collection and get the values along the way IsTheEnd = Collection % WrkTab % StartFirst ( CurrNode ) DO WHILE ((. NOT . IsTheEnd ). AND . ASSOCIATED ( CurrNode )) SELECT TYPE ( CurrNode ) TYPE IS ( TabNode ) Success = CurrNode % Value % Get ( Values ( I ), ValCopy ) IF (. NOT . Success ) EXIT I = I + 1_kIndex IF ( I > ArrSize ) EXIT END SELECT IsTheEnd = Collection % WrkTab % MoveForward ( CurrNode ) END DO RETURN END FUNCTION HashList_GetAllVals ! --------------------------------------------------------------------- ! -----                 Specific Procedures                       ----- ! --------------------------------------------------------------------- SUBROUTINE HashList_CreateEmpty ( Collection , InitCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty hash table. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( INOUT ) :: Collection !! collection tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !! initial capacity of the hash table !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: NodeMold !** FLOW: ! construct working hash table CALL Collection % WrkTab % Construct ( InitCap ) ! construct nodes' pool CALL Collection % NodePool % Construct ( NodeMold ) ! construct items' pool CALL Collection % ItemPool % Construct () RETURN END SUBROUTINE HashList_CreateEmpty !****************************************************************************** SUBROUTINE HashList_CreateByArray ( Collection , N , Keys , Values ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of key-value pairs. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashList ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of key-value pairs !% the keys to be added to the table CLASS ( * ), INTENT ( IN ) :: Keys ( N ) !% the associated values to be added to the table CLASS ( * ), INTENT ( IN ) :: Values ( N ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! create empty symbol table with capacity twice of the key size CALL Collection % CreateEmpty ( N * 2_kIndex ) ! add key-value pairs to the table DO I = 1_kIndex , N CALL Collection % Insert ( Keys ( I ), Values ( I )) END DO RETURN END SUBROUTINE HashList_CreateByArray !****************************************************************************** FUNCTION HashList_FindKey ( Collection , Key , KeyNode ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the specified key in a symbol table. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashList ), INTENT ( INOUT ) :: Collection !% the key to be looked for in the collection CLASS ( * ), INTENT ( IN ) :: Key !% the node containing the specified key; null pointer if the key is not found TYPE ( TabNode ), OPTIONAL , POINTER , INTENT ( OUT ) :: KeyNode !% flag indicating whether the specified key is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( TabNode ) :: InNode CLASS ( HashListNode ), POINTER :: StoredNode ! FLOW ! initialize Found = Falseval IF ( PRESENT ( KeyNode )) KeyNode => NULL () ! check the specified key and return quickly if not valid IF (. NOT . Collection % IsKeyValid ( Key , IsOrderedKey = FalseVal )) RETURN ! set key for search node CALL InNode % Key % Set ( Key , Collection % ItemPool ) ! find the stored node equal to input node Found = Collection % WrkTab % FindNode ( InNode , StoredNode ) IF ( PRESENT ( KeyNode ). AND . Found ) THEN SELECT TYPE ( StoredNode ) TYPE IS ( TabNode ) KeyNode => StoredNode END SELECT END IF ! free working pointer NULLIFY ( StoredNode ) RETURN END FUNCTION HashList_FindKey ! --------------------------------------------------------------------- ! -----             Final Procedures                              ----- ! --------------------------------------------------------------------- SUBROUTINE HashList_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the object. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashList ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW CALL Collection % Destruct () RETURN END SUBROUTINE HashList_Finalize !****************************************************************************** END MODULE MClass_HashList !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hashlist.f90.html"},{"title":"MClass_HTabInteger8B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HTabInteger8B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HTabInteger8B* type, the *TabItem* type and their !   related routines.  The *TabItem* type is a helper and private type used to !   store a key-value pair.  The *HTabInteger8B* type is a container type that !   employs an open-addressing hash table implementation to provide common !   operations for an unordered symbol table. <br> !   Unlike the *list-based* and *tree-based* types, which can be used instantly !   by inserting objects into a container, the *HTabInteger8B* type requires an !   explicit construction before using other provided operations.  There are two !   methods provided to create the container.  The *CreateEmpty* method constructs !   an empty table with optional multiple arguments (including an initial capacity, !   a load factor, a probing algorithm, and a hash function used to compute !   a hash code of a key) whereas the *Construct* method constructs a table from !   arrays of keys and values. <br> !   As an unordered symbol table, the *HTabInteger8B* type uses the Fortran intrinsic !   *INTEGER(KIND=kInt64)* type as the type of its stored keys and an unlimited polymorphic type !   as the type of its stored values.  As a symbol table, the *HTabInteger8B* type !   does not allow duplicated keys.  Therefore, if an inserted key is equal to a key !   stored in the table, an associated value of the stored key is replaced by an !   associated value of the inserted key. <br> !   Technically, the *HTabInteger8B* type employs the open-addressing as a collision !   resolution technique where the hash resolution is performed through probing.  It !   provides three probing algorithms: linear probing, quadratic probing and double !   hashing.  By default, the linear probing algorithm is used.  However, a user can !   specify other probing algorithm during the construction of the table. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !---------------------------------------------------------- #define     HashTable       HTabInteger8B #define     KeyTypeA        INTEGER(KIND=kInt64) #define     KeyTypeB        INTEGER(KIND=kInt64) #define     QueueKey        ListInteger8B #define     QueueVal        ListAnyType !---------------------------------------------------------- !** USE STATEMENTS: USE MBase_Common USE ISO_C_BINDING , ONLY : C_SIZEOF USE MBase_ErrHandlers USE MBase_SIntUtil USE MBase_MathUtil USE MBase_DoublyLinkedLists #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : HashFuncDefault => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : HashFuncDefault => Hash64_FNV1a #endif IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HTabInteger8B PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HTabInteger8B' ! Special marker token used to indicate the deletion of a key-value pair tSInt64 , PARAMETER :: DELKEY = ToInt64 ( Z '7FFFFFFFFFFFFFFF' ) ! Special marker token used to indicate the empty of a key-value pair tSInt64 , PARAMETER :: NULKEY = ToInt64 ( Z '8000000000000000' ) !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic HashTable - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic HashTable - Implementation.f90\" !** UNDEFINE MACROS ** #undef tHash #undef HashTable #undef KeyTypeA #undef KeyTypeB END MODULE MClass_HTabInteger8B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_htabinteger8b.f90.html"},{"title":"MClass_DArrInteger4B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrInteger4B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrInteger4B* type and related routines. !   The *DArrInteger4B* type is a container with *INTEGER(KIND=kInt32)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrInteger4B* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrInteger4B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrInteger4B #define TypeAlloc       INTEGER(KIND=kInt32), ALLOCATABLE #define TypeArgmt       INTEGER(KIND=kInt32) #define TypeOfItem      INTEGER(KIND=kInt32) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrInteger4B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrInteger4B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrinteger4b.f90.html"},{"title":"MClass_ListInteger2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListInteger2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListInteger2B* type and related routines. !   The *ListInteger2B* type is a container with *INTEGER(KIND=kI2B)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListInteger2B* type but utilizes a different implementation. !   Also, unlike the *ListInteger2B* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListInteger2B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListInteger2B #define DLLNode             DLLNodeInteger2B #define ItemTypeA           INTEGER(KIND=kInt16) #define ItemTypeB           INTEGER(KIND=kInt16) #define ItemTypeC           INTEGER(KIND=kInt16) #define TypeOfItem          INTEGER(KIND=kInt16) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListInteger2B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListInteger2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listinteger2b.f90.html"},{"title":"MClass_TreeInteger4B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeInteger4B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeInteger4B* type and its related helper type and routines. !   The *TreeInteger4B* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeInteger4B* !   type uses the Fortran intrinsic *INTEGER(KIND=kInt32)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeInteger4B* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeInteger4B* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeInteger4B* type but utilizes !   a different implementation.  Also, unlike the *TreeInteger4B* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeInteger4B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        INTEGER(KIND=kInt32) #define KeyTypeB        INTEGER(KIND=kInt32) #define KeyTypeC        INTEGER(KIND=kInt32) #define QueueKey        ListInteger4B #define QueueVal        ListAnyType #define RedBlackTree    TreeInteger4B !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeInteger4B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeInteger4B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treeinteger4b.f90.html"},{"title":"MClass_DArrCmpxSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrCmpxSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrCmpxSP* type and related routines. !   The *DArrCmpxSP* type is a container with *COMPLEX(KIND=kSingle)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrCmpxSP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrCmpxSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrCmpxSP #define TypeAlloc       COMPLEX(KIND=kSingle), ALLOCATABLE #define TypeArgmt       COMPLEX(KIND=kSingle) #define TypeOfItem      COMPLEX(KIND=kSingle) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrCmpxSP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrCmpxSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrcmpxsp.f90.html"},{"title":"MClass_ListCmpxSP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListCmpxSP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListCmpxSP* type and related routines. !   The *ListCmpxSP* type is a container with *COMPLEX(KIND=kSingle)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListCmpxSP* type but utilizes a different implementation. !   Also, unlike the *ListCmpxSP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListCmpxSP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListCmpxSP #define DLLNode             DLLNodeCmpxSP #define ItemTypeA           COMPLEX(KIND=kSingle) #define ItemTypeB           COMPLEX(KIND=kSingle) #define ItemTypeC           COMPLEX(KIND=kSingle) #define TypeOfItem          COMPLEX(KIND=kSingle) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListCmpxSP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListCmpxSP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listcmpxsp.f90.html"},{"title":"MClass_ListInteger4B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListInteger4B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListInteger4B* type and related routines. !   The *ListInteger4B* type is a container with *INTEGER(KIND=kI4B)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListInteger4B* type but utilizes a different implementation. !   Also, unlike the *ListInteger4B* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListInteger4B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListInteger4B #define DLLNode             DLLNodeInteger4B #define ItemTypeA           INTEGER(KIND=kInt32) #define ItemTypeB           INTEGER(KIND=kInt32) #define ItemTypeC           INTEGER(KIND=kInt32) #define TypeOfItem          INTEGER(KIND=kInt32) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListInteger4B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListInteger4B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listinteger4b.f90.html"},{"title":"MClass_DArrCmpxQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrCmpxQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrCmpxQP* type and related routines. !   The *DArrCmpxQP* type is a container with *COMPLEX(KIND=kQuad)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrCmpxQP* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrCmpxQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrCmpxQP #define TypeAlloc       COMPLEX(KIND=kQuad), ALLOCATABLE #define TypeArgmt       COMPLEX(KIND=kQuad) #define TypeOfItem      COMPLEX(KIND=kQuad) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrCmpxQP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrCmpxQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrcmpxqp.f90.html"},{"title":"MClass_ListInteger1B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListInteger1B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListInteger1B* type and related routines. !   The *ListInteger1B* type is a container with *INTEGER(KIND=kI1B)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListInteger1B* type but utilizes a different implementation. !   Also, unlike the *ListInteger1B* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListInteger1B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListInteger1B #define DLLNode             DLLNodeInteger1B #define ItemTypeA           INTEGER(KIND=kInt8) #define ItemTypeB           INTEGER(KIND=kInt8) #define ItemTypeC           INTEGER(KIND=kInt8) #define TypeOfItem          INTEGER(KIND=kInt8) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListInteger1B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListInteger1B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listinteger1b.f90.html"},{"title":"MClass_TreeCharacter.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeCharacter !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeCharacter* type and its related helper type and routines. !   The *TreeCharacter* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeCharacter* !   type uses the Fortran intrinsic *CHARACTER* type as the type of its stored keys and an !   unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeCharacter* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeCharacter* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeCharacter* type but utilizes !   a different implementation.  Also, unlike the *TreeCharacter* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeCharacter PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        CHARACTER(LEN=:), ALLOCATABLE #define KeyTypeB        CHARACTER(LEN=*) #define KeyTypeC        CHARACTER(LEN=:) #define QueueKey        ListCharacter #define QueueVal        ListAnyType #define RedBlackTree    TreeCharacter !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeCharacter' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeCharacter !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treecharacter.f90.html"},{"title":"MClass_ListRealQP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ListRealQP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ListRealQP* type and related routines. !   The *ListRealQP* type is a container with *REAL(KIND=kQuad)* as the type !   of its stored items.  It employs a conventional doubly-linked list !   implementation. <br> !   See the <a href=\"../module/mbase_doublylinkedlists.html\">MBase_DoublyLinkedLists</a> !   module for an overview and usage notes of a *doubly-linked-list-based* type. !   A user may use the *MBase_DoublyLinkedLists* module instead of using this !   module directly. <br> !   See the <a href=\"../module/mclass_linkedlists.html\">MClass_LinkedLists</a> !   module for doubly-linked-list-based types of containers that are functionally !   similar to the *ListRealQP* type but utilizes a different implementation. !   Also, unlike the *ListRealQP* type, these container types are designed as !   generic containers that can be used to store various data types providing that !   the size (in bytes) of the data to be stored is known at compile time. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: ListRealQP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define IS_EQUAL(A, B)      (A == B) #define DblLnkList          ListRealQP #define DLLNode             DLLNodeRealQP #define ItemTypeA           REAL(KIND=kQuad) #define ItemTypeB           REAL(KIND=kQuad) #define ItemTypeC           REAL(KIND=kQuad) #define TypeOfItem          REAL(KIND=kQuad) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_ListRealQP' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic List - Declaraction.f90\" !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic List - Implementation.f90\" !** UNDEFINE MACROS ** #undef DblLnkList #undef DLLNode #undef ItemTypeA #undef ItemTypeB #undef ItemTypeC #undef TypeOfItem END MODULE MClass_ListRealQP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_listrealqp.f90.html"},{"title":"MClass_TreeInteger2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_TreeInteger2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *TreeInteger2B* type and its related helper type and routines. !   The *TreeInteger2B* type is a container type representing an ordered symbol table, which !   is a container that associates a *value* with a *key* where keys are stored in a sorted !   order.  It employs a balanced binary-search-tree (BST) implementation to provide common !   operations for an ordered symbol table.  As an ordered symbol table, the *TreeInteger2B* !   type uses the Fortran intrinsic *INTEGER(KIND=kInt16)* type as the type of its stored keys !   and an unlimited polymorphic type as the type of its stored values. <br> !   As a symbol table, the *TreeInteger2B* type does not allow duplicated keys.  Therefore, !   if an inserted key is equal to a key stored in the table, an associated value of the !   stored key is replaced by an associated value of the inserted key.  Technically, the !   *TreeInteger2B* type employs a left-leaning red-black (RB) tree as the balanced BST. <br> !   See the <a href=\"../module/mbase_balancedtrees.html\">MBase_BalancedTrees</a> module !   for an overview of a *balanced-tree-based* type.  A user may use the *MBase_BalancedTrees* !   module instead of using this module directly. <br> !   See the <a href=\"../module/mclass_treetable.html\">MClass_TreeTable</a> module for a balanced !   tree container type that is functionally similar to the *TreeInteger2B* type but utilizes !   a different implementation.  Also, unlike the *TreeInteger2B* type, the *TreeTable* type !   is designed as a generic ordered symbol table that allows keys with various types to be !   inserted into the table. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_MemHandlers USE MBase_ErrHandlers USE MBase_SIntUtil , ONLY : ToChar => ToDecStrSigned USE MBase_DoublyLinkedLists USE MClass_Object IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: TreeInteger2B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define KeyTypeA        INTEGER(KIND=kInt16) #define KeyTypeB        INTEGER(KIND=kInt16) #define KeyTypeC        INTEGER(KIND=kInt16) #define QueueKey        ListInteger2B #define QueueVal        ListAnyType #define RedBlackTree    TreeInteger2B !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_TreeInteger2B' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic Tree - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic Tree - Implementation.f90\" !** UNDEFINE MACROS ** #undef RedBlackTree #undef KeyTypeA #undef KeyTypeB #undef KeyTypeC #undef QueueKey #undef QueueVal END MODULE MClass_TreeInteger2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_treeinteger2b.f90.html"},{"title":"MClass_HashSet.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_HashSet !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *HashSet* type and its supporting routines and data type. !   The *HashSet* type is a collection type that employs an open-addressing hash table !   implementation to provide common operations for an unordered set.  Like any other !   set collection types, the *HashSet* type does not allow duplicated items. <br> !   The *HashSet* type requires an explicit construction before using other provided !   operations.  There are two methods provided to create a collection.  The *CreateEmpty* !   method constructs an empty set with optional multiple arguments (including an initial !   capacity, a load factor, a probing algorithm, and a hash function used to compute !   a hash code of an item) whereas the *Construct* method constructs a set from an array !   items.  As an unordered set, the *HashSet* type makes no guarantees as to the iteration !   order of the set.  In particular, it does not guarantee that the order will remain !   the same over time. <br> !   The *HashSet* type uses the *KeyUnordered* type to store its set items.  Therefore, it !   can be used to store items of any data type, except the *LOGICAL* type.  Like other !   collection types, however, it must be employed to store items of only one particular !   data type.  To store items of another data type, it must be destructed before inserting !   items of different data type. <br> !   Technically, the *HashSet* type employs the open-addressing as a collision resolution !   technique where the hash resolution is performed through probing.  It provides three !   probing algorithms: linear probing, quadratic probing and double hashing.  By default, !   the linear probing algorithm is used.  However, a user can specify other probing !   algorithm during the construction of the hash set. <br> !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define     tHash           tIndex !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MClass_CharBuffer USE MBase_ByteUtil , ONLY : AnyType_GetByteSize USE MBase_SIntUtil , ToChar => ToDecStrSigned USE MBase_MathUtil #ifdef Indx32Bits USE MBase_SimpleHash32 , ONLY : ComputeHash => Hash32_FNV1a #else USE MBase_SimpleHash64 , ONLY : ComputeHash => Hash64_FNV1a #endif USE MClass_Object , ONLY : Object USE MClass_GenData USE MClass_MemoryPool USE MClass_KeyUnordered USE MClass_BaseCollection USE MClass_BaseIterable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: HashSet PRIVATE ! by default, hide all data and routines except those declared explicitly !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_HashSet' ! status of the SetItem tCharLen ( 3 ), PARAMETER :: STAT_DEL = 'DEL' tCharLen ( 3 ), PARAMETER :: STAT_NUL = 'NUL' tCharLen ( 3 ), PARAMETER :: STAT_GEN = 'GEN' ! default capacity tIndex , PARAMETER :: DefaultCapacity = 7 ! default load factor tRealDP , PARAMETER :: DefaultLoadFactor = 0.65_kDouble tSInt32 , PARAMETER :: LinearProbing = 1 tSInt32 , PARAMETER :: QuadraticProbing = 2 tSInt32 , PARAMETER :: DoubleHashing = 3 ! This is the linear constant used in the linear probing, it can be ! any positive number. The table capacity will be adjusted so that ! the GCD(capacity, LinearConstant) = 1 so that all buckets can be probed. tIndex , PARAMETER :: LinearConstant = 17_kIndex ! seed for computation of hash code #ifdef Indx32Bits tSInt32 , PARAMETER :: HashSeed = 313131_kInt32 #else tSInt64 , PARAMETER :: HashSeed = 313131_kInt64 #endif ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 !** DERIVED TYPE DEFINITIONS !> *SetItem* is a data type containing the stored item as its component. TYPE , EXTENDS ( Object ) :: SetItem tCharLen ( 3 ) :: Stat = STAT_NUL !! current status of the object TYPE ( KeyUnordered ) :: Store !! storage of item (or value) CONTAINS ! --------------------------------------------------------------------- ! -----         Specific Procedures for SetItem Type              ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: SetItem_SetData PROCEDURE , PRIVATE :: SetItem_SetStore GENERIC :: Set => SetItem_SetData , SetItem_SetStore PROCEDURE :: IsItemEqual => SetItem_IsItemEqual ! --------------------------------------------------------------------- ! -----         Deferred Procedures from Object Type              ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => SetItem_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => SetItem_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => SetItem_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => SetItem_ToString ! --------------------------------------------------------------------- ! -----                     Overridden Procedure                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => SetItem_HashCode ! --------------------------------------------------------------------- END TYPE SetItem !> The *HashSet* type is a collection type that employs an open-addressing hash table !  implementation to provide common operations for an unordered set.  It makes no !  guarantees as to the iteration order of the set; in particular, it does not guarantee !  that the order will remain constant over time. TYPE , EXTENDS ( BaseIterable ) :: HashSet PRIVATE !% current capacity of the hash set tIndex :: Capacity = DefaultCapacity !% working table items used to store items TYPE ( SetItem ), ALLOCATABLE :: Items (:) !% current index into the working items (used for iteration purpose) tIndex :: Indx = 0_kIndex !% the number of items not yet visited (used for iteration purpose) tIndex :: ItemLeft = 0_kIndex !% current modification count (used for iteration purpose) tIndex :: IterModCount = 0_kIndex !% load factor tRealDP :: LoadFactor = DefaultLoadFactor !% threshold for resizing tIndex :: Threshold = 0_kIndex !% modification count tIndex :: ModCount = 0_kIndex !% the total number of used buckets inside the hash set (including cells marked as deleted). tIndex :: UsedBuckets = 0_kIndex !% the total number of unique items currently inside the hash set. tIndex :: ItemCount = 0_kIndex !% probing algorithm tSInt32 :: ProbAlgo = LinearProbing !% index for double hashing tHash :: HashIndx = 0_kIndex !> memory pool of stored items TYPE ( MemoryPool ) :: ItemPool !> pointer to a hash function PROCEDURE ( HashFunc ), NOPASS , POINTER :: HashCalc => NULL () !> pointer to a procedure to copy stored data for a derived type not in the Object class; !  required if this type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), NOPASS , POINTER :: ItemCopy => NULL () CONTAINS ! --------------------------------------------------------------------- ! -----                     Private Procedures                    ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: FindItem <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%FindItem(Item) <br> !   --->    IF (.NOT.Collection%FindItem(Item)) DoSomething PROCEDURE , PRIVATE :: FindItem => HashSet_FindItem !> **Type-Bound Subroutine**: Resize <br> !  **Purpose**:  To resize the collection to the specified capacity. <br> !  **Usage**: <br> !   --->    CALL Collection%Resize(64) PROCEDURE , PRIVATE :: Resize => HashSet_Resize !> Use the *Construct* method to construct the collection from an array of items. PROCEDURE , PRIVATE :: HashSet_CreateByArray ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- !> Use the *Construct* method to construct the collection from another collection. PROCEDURE :: CopyCollection => HashSet_CopyCollection !> **Type-Bound Subroutine**: Clear <br> !  **Purpose**:  To remove all items from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Clear() PROCEDURE :: Clear => HashSet_ClearItems !> **Type-Bound Subroutine**: Destruct <br> !  **Purpose**:  To remove all items from the collection and free memory !                of items stored in the collection.<br> !  **Usage**: <br> !   --->    CALL Collection%Destruct() <br> PROCEDURE :: Destruct => HashSet_Destroy !> **Type-Bound Function**: GetSize <br> !  **Purpose**:  To get the current size of the collection. <br> !  **Usage**: <br> !   --->    Size = Collection%GetSize() PROCEDURE :: GetSize => HashSet_GetSize !> **Type-Bound Function**: IsEmpty <br> !  **Purpose**:  To check whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%IsEmpty() <br> !   --->    IF (.NOT.Collection%IsEmpty()) DoSomeThing PROCEDURE :: IsEmpty => HashSet_IsEmpty ! --------------------------------------------------------------------- ! -----         Deferred Procedures from BaseIterable Type        ----- ! --------------------------------------------------------------------- !> **Type-Bound Function**: StartFirst <br> !  **Purpose**:  To start the *forward* iteration and return a flag indicating !                whether the collection is empty or not. <br> !  **Usage**: <br> !   --->    IsEmpty = Collection%StartFirst() <br> !   --->    IsEmpty = Collection%StartFirst(FirstItem) PROCEDURE :: StartFirst => HashSet_Move2FirstItem !> **Type-Bound Function**: MoveForward <br> !  **Purpose**:  To move to the next iteration and return a flag indicating whether !                the cursor pointer has reached the end of the collection or not. <br> !  **Usage**: <br> !   --->    IsTheEnd = Collection%MoveForward() <br> !   --->    IsTheEnd = Collection%MoveForward(NextItem) <br> !  **Note**: See the <a href=\"../module/mclass_baseiterable.html\">BaseIterable</a> type !            for illustrations of an iteration over a collection using the *StartFirst* !            and *MoveForward* methods.<br> PROCEDURE :: MoveForward => HashSet_Move2NextItem !> **Type-Bound Subroutine**: Insert <br> !  **Purpose**:  To insert the specified item to the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Insert(Item) <br> PROCEDURE :: Insert => HashSet_Insert !> **Type-Bound Subroutine**: Delete <br> !  **Purpose**:  To delete the current item from the collection. <br> !  **Usage**: <br> !   --->    CALL Collection%Delete() <br> !  **Note**: This method is intended to be used in conjunction with the *StartFirst* and !       *MoveForward* methods.  Therefore, after the call to one of those methods and then !       calling this one will result in a removal of the current item of the iteration !       (i.e. the same item that can be retrieved via the *StartFirst* and *MoveForward* !       methods). <br> PROCEDURE :: Delete => HashSet_Delete !> **Type-Bound Function**: ToArray <br> !  **Purpose**:  To get and remove all items from the collection.  Also, return a flag !       indicating whether the items are successfully retrieved and removed or not. <br> !  **Usage**: <br> !   --->    Success = Collection%ToArray(Items) <br> !   --->    IF (.NOT.Collection%ToArray(Items)) DoSomething PROCEDURE :: ToArray => HashSet_ToArray !> **Type-Bound Function**: GetAll <br> !  **Purpose**:  To get all items (without removing them) from the collection. Also, return !                a flag indicating whether the items are successfully retrieved or not. <br> !  **Usage**: <br> !   --->    Success = Collection%GetAll(Items) <br> !   --->    IF (.NOT.Collection%GetAll(Items)) DoSomething PROCEDURE :: GetAll => HashSet_GetAll ! --------------------------------------------------------------------- ! -----                      Specific Procedures                  ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: CreateEmpty <br> !  **Purpose**:  To construct an empty table. <br> !  **Usage**: <br> !   --->    CALL Table%CreateEmpty()                                     ! use default options  <br> !   --->    CALL Table%CreateEmpty(InitCap=25)                           ! specify initial capacity <br> !   --->    CALL Table%CreateEmpty(LoadFactor=0.5)                       ! specify load factor <br> !   --->    CALL Table%CreateEmpty(ProbAlgo=2)                           ! specify probing algorithm <br> !   --->    CALL Table%CreateEmpty(HashCal=Murmur3_Hash32_Opt)           ! specify hash function <br> !   --->    CALL Table%CreateEmpty(ItemCopy=CopyProc)                    ! specify copy procedure <br> !   --->    CALL Table%CreateEmpty(30, 0.75, 3, XX_Hash64_Opt, CopyProc) ! specify all options <br> !  **Note1**: Any suitable hash function routine from the *ModBase_SimpleHash32*, !       *ModBase_SimpleHash64*, *ModBase_ReferenceHash32*, *ModBase_ReferenceHash64* !       *ModBase_OptimalHash32*, and *ModBase_OptimalHash64* modules can be used to !       specify the *HashCal* argument.  The term *suitable* means that any routine !       that has exactly the same interface as the *HashFunc* abstract function !       is the suitable one.  <br> !  **Note2**: Depending on a type of indices defined in the '*Macro - Basic Definitions.f90*' !       file, a 32-bit hash-function routine is a suitable one for 32-bit integer indices !       while a 64-bit hash-function routine is a suitable one for 64-bit integer indices. !       This is a compile-time choice.  <br> PROCEDURE :: CreateEmpty => HashSet_CreateEmpty !> **Type-Bound Subroutine**: Construct <br> !  **Purpose**:  To construct a new collection from an array of items or from another !                collection. <br> !  **Usage**: <br> !   ! create a collection from an array of 25 items <br> !   --->    CALL Collection%Construct(25, Arr) <br> !   ! create a collection and specify the optional arguments (see the *CreateEmpy* method) <br> !   --->    CALL Collection%Construct(25, Arr, LoadFactor, ProbAlgo, HashCalc, ItemCopy) <br> !   ! create a collection from another collection <br> !   --->    CALL Collection%Construct(OtherCollection) GENERIC :: Construct => HashSet_CreateByArray !> **Type-Bound Function**: Contain <br> !  **Purpose**:  To find the specified item in the collection.  Return true if !                the specified item is found.  Otherwise, return false. <br> !  **Usage**: <br> !   --->    Flag = Collection%Contain(Item) <br> !   --->    IF (.NOT.Collection%Contain(Item)) DoSomething PROCEDURE :: Contain => HashSet_Contain !> **Type-Bound Function**: Remove <br> !  **Purpose**:  To remove the specified item from the collection.  Also, return a flag !                indicating whether the item is successfully removed or not. <br> !  **Usage**: <br> !   --->    Flag = Collection%Remove(Item) <br> !   --->    IF (.NOT.Collection%Remove(Item)) DoSomething PROCEDURE :: Remove => HashSet_Remove ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Copy <br> !  **Purpose**: To make a copy of the source object. <br> !  **Usage**: <br> !   --->    CALL SrcObj%Copy(DstObj) <br> PROCEDURE :: Copy => HashSet_Copy !> **Type-Bound Function**: IsEqualTo <br> !  **Purpose**: To check whether two objects are equal to one another or not. <br> !  **Usage**: <br> !   --->    Flag = ObjA%IsEqualTo(ObjB) <br> !   --->    IF (ObjA%IsEqualTo(ObjB)) DoSomething PROCEDURE :: IsEqualTo => HashSet_IsEqualTo !> **Type-Bound Subroutine**: MemFree <br> !  **Purpose**: To free memory/storage occupied by the object. <br> !  **Usage**: <br> !   --->    CALL Obj%MemFree() <br> PROCEDURE :: MemFree => HashSet_MemFree !> **Type-Bound Function**: ToString <br> !  **Purpose**:  To return the string representation of this object. <br> !  **Usage**: <br> !   --->    Str = Obj%ToString() <br> PROCEDURE :: ToString => HashSet_ToString !> **Type-Bound Function**: HashCode <br> !  **Purpose**:  To compute the hash code of this object. <br> !  **Usage**: <br> !   --->    Code = Obj%HashCode() <br> PROCEDURE :: HashCode => HashSet_HashCode ! --------------------------------------------------------------------- ! -----                   Finalize Procedure                      ----- ! --------------------------------------------------------------------- !> To perform finalization of the hash set. FINAL :: HashSet_Finalize ! --------------------------------------------------------------------- END TYPE HashSet !** INTERFACE DEFINITIONS: ABSTRACT INTERFACE !---------------------------------------------------------------------- !&#94; *HashFunc* is a generic interface for a procedure to compute the hash value. FUNCTION HashFunc ( Input , InpSize , StartHash , RemoveSign ) RESULT ( HashCode ) IMPORT TYPE ( * ), CONTIGUOUS , INTENT ( IN ) :: Input (..) !! input (any type and rank) tIndex , INTENT ( IN ) :: InpSize !! size of the input (in bytes) tHash , OPTIONAL , INTENT ( IN ) :: StartHash !! optional starting hash for continued hashing tLogical , OPTIONAL , INTENT ( IN ) :: RemoveSign !&#94; flag indicating whether to remove sign bit or not. <br> !  - If true, always returns a positive value of the hash code. <br> !  - If false, returns either a positive or negative value of the hash code. <br> !  - default is false. tHash :: HashCode !! hash code END FUNCTION HashFunc !---------------------------------------------------------------------- END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): ! ----------------------------------------------------------------------------- ! -----                       SetItem Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE SetItem_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF THIS SUBROUTINE: !! To copy the SetItem object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( DstObj ) TYPE IS ( SetItem ) DstObj % Stat = SrcObj % Stat CALL SrcObj % Store % Copy ( DstObj % Store , IsDeep ) CLASS DEFAULT CALL Handle_ErrLevel ( 'SetItem_Copy' , ModName , ErrSevere , & 'Type of the source object is NOT valid.' ) END SELECT RETURN END SUBROUTINE SetItem_Copy !****************************************************************************** FUNCTION SetItem_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( SetItem ) Flag = FalseVal IF ( LhsObj % Stat /= RhsObj % Stat ) RETURN Flag = LhsObj % Store % IsEqualTo ( RhsObj % Store ) CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION SetItem_IsEqualTo !****************************************************************************** SUBROUTINE SetItem_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !! To free memory of the SetItem object.  This is a deferred procedure. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Obj % Stat = STAT_NUL CALL Obj % Store % MemFree () RETURN END SUBROUTINE SetItem_MemFree !****************************************************************************** FUNCTION SetItem_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the string representation of this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( IN ) :: Obj tCharAlloc :: Str !! string representation of the object !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Str = '{SetItem : ' // Obj % Store % ToString () // '}' RETURN END FUNCTION SetItem_ToString !****************************************************************************** FUNCTION SetItem_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Code = Obj % Store % HashCode () RETURN END FUNCTION SetItem_HashCode !****************************************************************************** SUBROUTINE SetItem_SetData ( This , Status , Pool , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set data of the specified input. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( INOUT ) :: This tCharLen ( 3 ), INTENT ( IN ) :: Status TYPE ( MemoryPool ), OPTIONAL , INTENT ( INOUT ) :: Pool CLASS ( * ), OPTIONAL , INTENT ( IN ) :: Item !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: This % Stat = Status IF ( PRESENT ( Item ). AND . PRESENT ( Pool )) CALL This % Store % Set ( Item , Pool ) RETURN END SUBROUTINE SetItem_SetData !****************************************************************************** SUBROUTINE SetItem_SetStore ( This , Status , Other ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set data of the specified input. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( INOUT ) :: This tCharLen ( 3 ), INTENT ( IN ) :: Status TYPE ( SetItem ), INTENT ( IN ) :: Other !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: This % Stat = Status CALL Other % Store % Copy ( This % Store ) RETURN END SUBROUTINE SetItem_SetStore !****************************************************************************** FUNCTION SetItem_IsItemEqual ( This , Item , Pool ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified item is equal to the stored item. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( SetItem ), INTENT ( IN ) :: This CLASS ( * ), INTENT ( IN ) :: Item TYPE ( MemoryPool ), INTENT ( INOUT ) :: Pool tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( KeyUnordered ) :: Other !** FLOW: CALL Other % Set ( Item , Pool ) Flag = This % Store % IsEqualTo ( Other ) CALL Other % MemFree () RETURN END FUNCTION SetItem_IsItemEqual ! --------------------------------------------------------------------- ! -----     Deferred/Overridden Procedures from Object Type       ----- ! --------------------------------------------------------------------- SUBROUTINE HashSet_Copy ( SrcObj , DstObj , IsDeep ) !** PURPOSE OF DstObj SUBROUTINE: !&#94; To copy the source object to the destination object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: SrcObj !! source object CLASS ( Object ), INTENT ( OUT ) :: DstObj !! destination object tLogical , OPTIONAL , INTENT ( IN ) :: IsDeep !&#94; Flag indicating whether to perform deep copy or shallow copy. <br> !  - If present and true, perform a deep copy. <br> !  - If present and false, perform a shallow copy. <br> !  - If not present, perform either a shallow or a deep copy that is naturally most !    suitable for the object's components. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT TYPE ( DstObj ) TYPE IS ( HashSet ) DstObj % Capacity = SrcObj % Capacity DstObj % Indx = SrcObj % Indx DstObj % ItemLeft = SrcObj % ItemLeft DstObj % IterModCount = SrcObj % IterModCount DstObj % LoadFactor = SrcObj % LoadFactor DstObj % Threshold = SrcObj % Threshold DstObj % ModCount = SrcObj % ModCount DstObj % UsedBuckets = SrcObj % UsedBuckets DstObj % ItemCount = SrcObj % ItemCount DstObj % ProbAlgo = SrcObj % ProbAlgo DstObj % HashIndx = SrcObj % HashIndx DstObj % HashCalc => SrcObj % HashCalc DstObj % ItemCopy => SrcObj % ItemCopy ALLOCATE ( DstObj % Items , SOURCE = SrcObj % Items ) CALL SrcObj % ItemPool % CloneTo ( DstObj % ItemPool ) ASSOCIATE ( Dummy => IsDeep ); END ASSOCIATE CLASS DEFAULT CALL Handle_ErrLevel ( 'HashSet_Copy' , ModName , ErrSevere , & 'Type of the DstObj collection is NOT valid.' ) END SELECT RETURN END SUBROUTINE HashSet_Copy !****************************************************************************** FUNCTION HashSet_IsEqualTo ( LhsObj , RhsObj ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether LhsObj and RhsObj are equal or not. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: LhsObj !! an object CLASS ( Object ), INTENT ( IN ) :: RhsObj !! another object tLogical :: Flag !! true if both objects are equal !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW SELECT TYPE ( RhsObj ) TYPE IS ( HashSet ) Flag = FalseVal IF ( LhsObj % Capacity /= RhsObj % Capacity ) RETURN IF ( LhsObj % ItemCount /= RhsObj % ItemCount ) RETURN IF (. NOT . LhsObj % IsEmpty ()) THEN BLOCK tIndex :: I DO I = 1_kIndex , SIZE ( LhsObj % Items ) IF (. NOT . LhsObj % Items ( I )% IsEqualTo ( RhsObj % Items ( I ))) RETURN END DO END BLOCK END IF Flag = TrueVal CLASS DEFAULT Flag = FalseVal END SELECT RETURN END FUNCTION HashSet_IsEqualTo !****************************************************************************** SUBROUTINE HashSet_MemFree ( Obj ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free memory of the HashSet object. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Obj !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! first free items' components and then free of the items themselves IF ( ALLOCATED ( Obj % Items )) THEN DO I = 0_kIndex , Obj % Capacity - 1_kIndex CALL Obj % Items ( I )% MemFree () END DO DEALLOCATE ( Obj % Items ) END IF ! reset all components Obj % Capacity = DefaultCapacity Obj % Indx = 0_kIndex Obj % ItemLeft = 0_kIndex Obj % IterModCount = 0_kIndex Obj % LoadFactor = DefaultLoadFactor Obj % Threshold = 0_kIndex Obj % ModCount = 0_kIndex Obj % UsedBuckets = 0_kIndex Obj % ItemCount = 0_kIndex Obj % ProbAlgo = LinearProbing Obj % HashIndx = 0_kIndex NULLIFY ( Obj % HashCalc ) NULLIFY ( Obj % ItemCopy ) CALL Obj % FreeMold () CALL Obj % ItemPool % Destruct () RETURN END SUBROUTINE HashSet_MemFree !****************************************************************************** FUNCTION HashSet_ToString ( Obj ) RESULT ( Str ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the name of the HashSet type. !  This is a deferred procedure inherited from the *Object* type. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: Obj tCharAlloc :: Str !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tCharAlloc :: BaseStr ! FLOW ! get base string IF ( Obj % IsEmpty ()) THEN BaseStr = '[NULL]' ELSE BLOCK TYPE ( CharBuffer ) :: ChrBuf tIndex :: I , Count tCharAlloc :: ItemStr ! initialize CALL ChrBuf % CreateEmpty ( InitCap = Obj % GetSize () * 40_kIndex ) CALL ChrBuf % Append ( '[' ) Count = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items ) ! skip if the item is empty IF ( Obj % Items ( I )% Stat /= STAT_GEN ) CYCLE ! add the string representation of the current item ItemStr = Obj % Items ( I )% Store % ToString () CALL ChrBuf % Append ( ItemStr ( 17 : LEN ( ItemStr ) - 1 )) ! update Count and add comma between items if needed Count = Count + 1_kIndex IF ( Count < Obj % GetSize ()) THEN CALL ChrBuf % Append ( ', ' ) ELSEIF ( Count > Obj % GetSize ()) THEN EXIT END IF END DO CALL ChrBuf % Append ( ']' ) BaseStr = ChrBuf % AsString () END BLOCK END IF Str = '{HashSet with ' // ToChar ( Obj % GetSize ()) // ' items : ' // BaseStr // '}' RETURN END FUNCTION HashSet_ToString !****************************************************************************** FUNCTION HashSet_HashCode ( Obj ) RESULT ( Code ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute hash code for this object. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: Obj tIndex :: Code !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Obj % IsEmpty ()) THEN BLOCK tCharAlloc :: BaseStr BaseStr = Obj % ToString () Code = ComputeHash ( BaseStr , AnyType_GetByteSize ( BaseStr )) END BLOCK ELSE BLOCK tIndex :: I Code = 0_kIndex DO I = 1_kIndex , SIZE ( Obj % Items ) IF ( Obj % Items ( I )% Stat /= STAT_GEN ) CYCLE Code = Code + Obj % Items ( I )% Store % HashCode () END DO END BLOCK END IF RETURN END FUNCTION HashSet_HashCode ! --------------------------------------------------------------------- ! -----  Deferred/Overridden Procedures from BaseCollection Type  ----- ! --------------------------------------------------------------------- SUBROUTINE HashSet_CopyCollection ( This , Other , ItemCopy , ValCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To creates a new collection (This) with the same items as the given collection (Other). !  This is a deferred procedure by the *BaseCollection* class. <br> !  *Note*:  Other must be in the *BaseIterable* class. !** SUBROUTINE ARGUMENT DECLARATIONS: !% collection object to be created CLASS ( HashSet ), INTENT ( INOUT ) :: This !% collection object to be copied CLASS ( BaseCollection ), INTENT ( INOUT ) :: Other !> a helper procedure to copy stored items for a derived type not in the *Object* class; !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a helper procedure to copy stored values for a derived type not in the *Object* !  class; required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ValCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! return if Other is empty IF ( Other % IsEmpty ()) RETURN SELECT TYPE ( Other ) CLASS IS ( HashSet ) ! same type of collection CALL Other % Copy ( This ) CLASS IS ( BaseIterable ) ! different types of collection BLOCK ! block variables tLogical :: IsTheEnd CLASS ( * ), POINTER :: MoldPtr CLASS ( * ), ALLOCATABLE :: Item MoldPtr => Other % GetItemPtr () ALLOCATE ( Item , MOLD = MoldPtr ) ! loop through the other collection and get items along the way IsTheEnd = Other % StartFirst ( Item , ItemCopy ) DO WHILE (. NOT . IsTheEnd ) ! add an item to this collection CALL This % Insert ( Item ) IsTheEnd = Other % MoveForward ( Item , ItemCopy ) END DO NULLIFY ( MoldPtr ) DEALLOCATE ( Item ) END BLOCK CLASS DEFAULT CALL Handle_ErrLevel ( 'HashSet_CopyCollection' , ModName , ErrSevere , & 'Type of \"Other\" must be in the \"BaseIterable\" class.' ) END SELECT RETURN END SUBROUTINE HashSet_CopyCollection !****************************************************************************** SUBROUTINE HashSet_ClearItems ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To free components of the items from the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I !** FLOW: IF ( ALLOCATED ( Collection % Items )) THEN DO I = 0_kIndex , Collection % Capacity - 1_kIndex CALL Collection % Items ( I )% MemFree () END DO END IF Collection % Indx = 0_kIndex Collection % ItemLeft = 0_kIndex Collection % IterModCount = 0_kIndex Collection % Threshold = 0_kIndex Collection % ItemCount = 0_kIndex Collection % UsedBuckets = 0_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % FreeMold () NULLIFY ( Collection % ItemCopy ) RETURN END SUBROUTINE HashSet_ClearItems !****************************************************************************** SUBROUTINE HashSet_Destroy ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To destruct the set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % MemFree () RETURN END SUBROUTINE HashSet_Destroy !****************************************************************************** FUNCTION HashSet_GetSize ( Collection ) RESULT ( Size ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To return the number of items currently in the hash set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: Collection !! collection tIndex :: Size !! the number of items !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Size = Collection % ItemCount RETURN END FUNCTION HashSet_GetSize !****************************************************************************** FUNCTION HashSet_IsEmpty ( Collection ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the hash set is empty or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( IN ) :: Collection !! collection tLogical :: Flag !! true if the set is empty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Flag = ( Collection % ItemCount == 0_kIndex ) RETURN END FUNCTION HashSet_IsEmpty ! --------------------------------------------------------------------- ! -----        Deferred Procedures from BaseIterable Type         ----- ! --------------------------------------------------------------------- FUNCTION HashSet_Move2FirstItem ( Collection , Item , ItemCopy ) RESULT ( IsEmpty ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the first (starting) pair data in a collection.   For the hash set, which is !  an unordered set, the starting pair is the first pair found in the non-empty bucket.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !% the first item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the table contains no pair data or not <br> ! - true if the table is empty. <br> ! - otherwise the first pair data is available. tLogical :: IsEmpty !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN IsEmpty = TrueVal RETURN ELSE IsEmpty = FalseVal END IF ! initialize iteration-related components Collection % Indx = 0_kIndex Collection % ItemLeft = Collection % ItemCount Collection % IterModCount = Collection % ModCount ! start iteration by looking for the first non-empty slot DO WHILE ( Collection % Items ( Collection % Indx )% Stat /= STAT_GEN ) Collection % Indx = Collection % Indx + 1_kIndex END DO ! update ItemLelf Collection % ItemLeft = Collection % ItemLeft - 1_kIndex ! get item if requested IF ( PRESENT ( Item ). AND . PRESENT ( ItemCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Store % Get ( Item , ItemCopy )) THEN CALL Handle_ErrLevel ( 'HashSet_Move2FirstItem' , ModName , ErrWarning , & 'Type of the specified item is likely NOT the same as that of stored items.' ) END IF ELSEIF ( PRESENT ( Item )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Store % Get ( Item , Collection % ItemCopy )) THEN CALL Handle_ErrLevel ( 'HashSet_Move2FirstItem' , ModName , ErrWarning , & 'Type of the specified item is likely NOT the same as that of stored items.' ) END IF END IF RETURN END FUNCTION HashSet_Move2FirstItem !****************************************************************************** FUNCTION HashSet_Move2NextItem ( Collection , Item , ItemCopy ) RESULT ( IsTheEnd ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To move to the next pair data in a collection.  For the hash set, which is an unordered set, !  the next pair is a pair inserted in the first non-empty bucket after the previous one.  <br> !  The routine will report an error if an alteration to stored item(s) (either by an insertion !  or a removal) has been occurred during current iteration.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !% the next item as output if requested (and available) CLASS ( * ), OPTIONAL , INTENT ( INOUT ) :: Item !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> a flag indicating whether the move to the end of the table occurs or not <br> ! - true if next pair data is NOT available. <br> ! - otherwise next pair data is available. tLogical :: IsTheEnd !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IterModCount /= Collection % ModCount ) THEN CALL Handle_ErrLevel ( 'HashSet_Move2NextItem' , ModName , ErrWarning , & \"Must re-start the iteration because the stored items have been altered.\" ) RETURN END IF ! check for empty table IF ( Collection % IsEmpty ()) THEN IsTheEnd = TrueVal RETURN ELSEIF ( Collection % ItemLeft == 0_kIndex ) THEN IsTheEnd = TrueVal RETURN END IF ! update Indx and set flag Collection % Indx = Collection % Indx + 1 IsTheEnd = FalseVal ! start iteration by looking for the next non-empty slot DO WHILE ( Collection % Items ( Collection % Indx )% Stat /= STAT_GEN ) Collection % Indx = Collection % Indx + 1_kIndex END DO ! update ItemLelf Collection % ItemLeft = Collection % ItemLeft - 1_kIndex ! get item if requested IF ( PRESENT ( Item ). AND . PRESENT ( ItemCopy )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Store % Get ( Item , ItemCopy )) THEN CALL Handle_ErrLevel ( 'HashSet_Move2NextItem' , ModName , ErrWarning , & 'Type of the specified item is likely NOT the same as that of stored items.' ) END IF ELSEIF ( PRESENT ( Item )) THEN IF (. NOT . Collection % Items ( Collection % Indx )% Store % Get ( Item , Collection % ItemCopy )) THEN CALL Handle_ErrLevel ( 'HashSet_Move2NextItem' , ModName , ErrWarning , & 'Type of the specified item is likely NOT the same as that of stored items.' ) END IF END IF RETURN END FUNCTION HashSet_Move2NextItem !****************************************************************************** SUBROUTINE HashSet_Insert ( Collection , Item ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To add an item into the hash set.  If the specified item is already stored !  in the set, report severe error and return immediately.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be inserted !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J tIndex :: ItemSize ! FLOW ! check the specified item IF (. NOT . IsKeyUnordered ( Item )) THEN CALL Handle_ErrLevel ( 'HashSet_Insert' , ModName , ErrSevere , & 'Type of the specified item is NOT valid.' ) RETURN ELSEIF (. NOT . Collection % IsItemValid ( Item )) THEN CALL Handle_ErrLevel ( 'HashSet_Insert' , ModName , ErrSevere , & 'Only items of the same type are allowed in a collection.' ) RETURN END IF IF (. NOT . ALLOCATED ( Collection % Items )) THEN ! not constructed yet so check type of the specified item IF ( GetDataType ( Item ) == TYPE_DERIVED ) THEN CALL Collection % FreeMold () CALL Handle_ErrLevel ( 'HashSet_Insert' , ModName , ErrSevere , & 'The collection must be explicitly constructed before using any other method(s).' ) RETURN END IF ! construct empty collection with default options CALL Collection % CreateEmpty () ELSEIF ( Collection % FindItem ( Item )) THEN ! no duplicated items are allowed. CALL Handle_ErrLevel ( 'HashSet_Insert' , ModName , ErrSevere , & 'The specified item is already stored in the set.' ) RETURN END IF ! resize the capacity if needed IF ( Collection % UsedBuckets >= Collection % Threshold ) CALL Collection % Resize ( MoreCap = TrueVal ) ! set up the probing if needed CALL SetupProbing ( Collection , Item ) ! compute the hash code and offset ItemSize = AnyType_GetByteSize ( Item ) HashCode = Collection % HashCalc ( Item , ItemSize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! The current bucket was previously deleted IF ( J == - 1_kIndex ) J = I ELSEIF ( Collection % Items ( I )% Stat == STAT_NUL ) THEN ! The current bucket is null so an insertion/update can occur IF ( J == - 1_kIndex ) THEN ! No previously encountered deleted buckets Collection % UsedBuckets = Collection % UsedBuckets + 1_kIndex CALL Collection % Items ( I )% Set ( STAT_GEN , Collection % ItemPool , Item ) ELSE ! Previously seen deleted bucket. Instead of inserting ! the new element at i where the null element is insert ! it where the deleted token was found. CALL Collection % Items ( J )% Set ( STAT_GEN , Collection % ItemPool , Item ) END IF Collection % ItemCount = Collection % ItemCount + 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END SUBROUTINE HashSet_Insert !****************************************************************************** SUBROUTINE HashSet_Delete ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To delete a item of the current iteration from a collection. !** SUBROUTINE ARGUMENT DECLARATIONS: !% symbol-table collection object CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW Collection % ItemCount = Collection % ItemCount - 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % Items ( Collection % Indx )% Set ( STAT_DEL ) RETURN END SUBROUTINE HashSet_Delete !************************************************************************************** FUNCTION HashSet_ToArray ( Collection , Items , ItemCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get and remove all items from the collection.  Also, return !  a flag indicating whether the items are successfully removed. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashSet object CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !% the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items (:) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved and removed. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! retrieve all items Success = Collection % GetAll ( Items , ItemCopy ) ! remove all items IF ( Success ) CALL Collection % Clear () RETURN END FUNCTION HashSet_ToArray !************************************************************************************** FUNCTION HashSet_GetAll ( Collection , Items , ItemCopy ) RESULT ( Success ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get all items (without removing them) from the collection.  Also, !  return a flag indicating whether the items are successfully retrieved. !** SUBROUTINE ARGUMENT DECLARATIONS: !% HashSet object CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !% the item to be removed from the collection CLASS ( * ), INTENT ( INOUT ) :: Items ( 1 :) !> a procedure to copy stored items for a derived type not in the *Object* class; <br> !  required if the derived type has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !> flag indicating whether the items are successfully retrieved. <br> tLogical :: Success !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I , J , ArrSize PROCEDURE ( IfacePolyCopy ), POINTER :: CopyProc ! FLOW ! check whether the collection is empty or not IF ( Collection % IsEmpty ()) THEN Success = FalseVal RETURN ELSE ! check whether type of the specified items is valid or not IF ( Collection % IsItemValid ( Items ( 1 ))) THEN Success = TrueVal ELSE Success = FalseVal CALL Handle_ErrLevel ( 'HashSet_GetAll' , ModName , ErrSevere , & 'Type of the specified items is NOT the same as that of stored items.' ) RETURN END IF END IF ! set a pointer to copy procedure IF ( PRESENT ( ItemCopy )) THEN CopyProc => ItemCopy ELSE CopyProc => Collection % ItemCopy END IF ! initialize local variables ArrSize = SIZE ( Items , KIND = kIndex ) I = 1_kindex ! loop through all buckets DO J = 1_kIndex , SIZE ( Collection % Items , KIND = kIndex ) ! skip the rest if the bucket is empty IF ( Collection % Items ( J )% Stat /= STAT_GEN ) CYCLE IF (. NOT . Collection % Items ( J )% Store % Get ( Items ( I ), CopyProc )) THEN CALL Handle_ErrLevel ( 'HashSet_GetAll' , ModName , ErrSevere , & 'Unable to retrieve an item.  This is likely a bug.' ) Success = FalseVal EXIT END IF ! update I I = I + 1_kIndex ! if we got all items requested, quit the loop IF ( I > ArrSize ) EXIT END DO ! free pointer NULLIFY ( CopyProc ) RETURN END FUNCTION HashSet_GetAll ! ----------------------------------------------------------------------------- ! -----                        Common Procedures                          ----- ! ----------------------------------------------------------------------------- SUBROUTINE HashSet_Resize ( Collection , MoreCap ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To resize the capacity of the hash set according the specified flag. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection tLogical , INTENT ( IN ) :: MoreCap !&#94; true if increasing the capacity; otherwise, decreasing the capacity !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: TYPE ( SetItem ), ALLOCATABLE :: OldItems (:) tIndex :: OldCap , I tLogical :: Success CLASS ( * ), POINTER :: ItemMold CLASS ( * ), ALLOCATABLE :: Item !** FLOW: OldCap = Collection % Capacity IF ( MoreCap ) THEN CALL IncreaseCapacity ( Collection ) ELSE ! halving the capacity Collection % Capacity = Collection % Capacity / 2_kIndex END IF CALL AdjustCapacity ( Collection ) ! update threshold Collection % Threshold = ToIndex ( Collection % Capacity * Collection % LoadFactor ) ! move currently stored objects to temporary variable CALL MOVE_ALLOC ( Collection % Items , OldItems ) ! allocate working items to new capacity ALLOCATE ( Collection % Items ( 0 : Collection % Capacity - 1_kIndex )) ! set status to null Collection % Items (:)% Stat = STAT_NUL ! Reset the item count and buckets used since we are about to ! re-insert all the items into the hash-table. Collection % ItemCount = 0_kIndex Collection % UsedBuckets = 0_kIndex ! loop over the temporary variable (OldItems) to move stored objects (Items) ! back to the hash set ItemMold => Collection % GetItemPtr () ALLOCATE ( Item , MOLD = ItemMold ) DO I = 0_kIndex , OldCap - 1_kIndex IF ( OldItems ( I )% Stat == STAT_GEN ) THEN ! get an item back Success = OldItems ( I )% Store % Get ( Item , Collection % ItemCopy ) ! re-insert the item IF ( Success ) THEN CALL Collection % Insert ( Item ) ELSE CALL Handle_ErrLevel ( 'HashSet_Resize' , ModName , ErrSevere , & 'Unable to get an old item.  This is likely due to invalid copy procedure.' ) EXIT END IF END IF CALL OldItems ( I )% MemFree () END DO ! free local variables DEALLOCATE ( OldItems ) NULLIFY ( ItemMold ) DEALLOCATE ( Item ) RETURN END SUBROUTINE HashSet_Resize !****************************************************************************** FUNCTION HashSet_FindItem ( Collection , Item ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified item is currently stored in a hash set or not. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be looked for !> flag indicating whether the specified item is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I , J tIndex :: ItemSize ! FLOW ! set up the probing if needed CALL SetupProbing ( Collection , Item ) ! compute the hash code and offset ItemSize = AnyType_GetByteSize ( Item ) HashCode = Collection % HashCalc ( Item , ItemSize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset J = - 1_kIndex Indx = 1_kIndex ! Start at the original hash value and probe until we find a spot where our item ! is or hit a null element in which case our element does not exist. DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! Ignore deleted buckets, but record where the first index ! of a deleted bucket is found to perform lazy relocation later. IF ( J == - 1_kIndex ) J = I ELSEIF ( Collection % Items ( I )% Stat /= STAT_NUL ) THEN ! found the item we want to remove IF ( J /= - 1_kIndex ) THEN ! If J /= -1 this means we previously encountered a deleted cell. ! We can perform an optimization by swapping the entries in cells ! I and J so that the next time we search for this item it will be ! found faster. This is called lazy deletion/relocation. CALL Collection % Items ( J )% Set ( STAT_GEN , Collection % Items ( I )) CALL Collection % Items ( I )% Set ( STAT_DEL ) END IF Found = TrueVal EXIT ELSE ! the item was not found Found = FalseVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO RETURN END FUNCTION HashSet_FindItem !****************************************************************************** SUBROUTINE HashSet_CreateEmpty ( Collection , InitCap , LoadFactor , ProbAlgo , HashCalc , ItemCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create an empty hash set. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection tIndex , OPTIONAL , INTENT ( IN ) :: InitCap !! initial capacity of the hash set tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !! load factor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !> hash function to compute the hash value of the item; if not present, use default one. PROCEDURE ( HashFunc ), OPTIONAL :: HashCalc !> a procedure to copy stored data for a derived type not in the Object class; !  required if the type of items to be stored has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: ! determine initial capacity IF ( PRESENT ( InitCap )) THEN IF ( InitCap < 0_kIndex ) THEN Collection % Capacity = DefaultCapacity ELSE Collection % Capacity = MAX ( DefaultCapacity , InitCap ) END IF ELSE Collection % Capacity = DefaultCapacity END IF ! determine load factor IF ( PRESENT ( LoadFactor )) THEN IF ( InitCap < 0.0_kDouble ) THEN Collection % LoadFactor = DefaultLoadFactor ELSE Collection % LoadFactor = LoadFactor END IF ELSE Collection % LoadFactor = DefaultLoadFactor END IF ! determine probing algorithm IF ( PRESENT ( ProbAlgo )) THEN SELECT CASE ( ProbAlgo ) CASE ( 1 : 3 ) Collection % ProbAlgo = ProbAlgo CASE DEFAULT Collection % ProbAlgo = LinearProbing END SELECT ELSE Collection % ProbAlgo = LinearProbing END IF ! set hash function pointer IF ( PRESENT ( HashCalc )) THEN ! use supplied function Collection % HashCalc => HashCalc ELSE ! use default algorithm Collection % HashCalc => ComputeHash END IF ! set pointer to copy procedure IF ( PRESENT ( ItemCopy )) THEN Collection % ItemCopy => ItemCopy ELSE Collection % ItemCopy => NULL () END IF ! adjust the capacity according to the probing algorithm CALL AdjustCapacity ( Collection ) ! compute threshold Collection % Threshold = ToIndex ( Collection % Capacity * Collection % LoadFactor ) ! allocate memory of item storages ALLOCATE ( Collection % Items ( 0 : Collection % Capacity - 1 )) ! set status to null Collection % Items (:)% Stat = STAT_NUL ! construct items' pool CALL Collection % ItemPool % Construct () RETURN END SUBROUTINE HashSet_CreateEmpty !****************************************************************************** SUBROUTINE HashSet_CreateByArray ( Collection , N , Items , LoadFactor , ProbAlgo , HashCalc , ItemCopy ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To create a table from an array of items. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: N !! number of items CLASS ( * ), INTENT ( IN ) :: Items ( N ) !! the items to be added to the set tRealDP , OPTIONAL , INTENT ( IN ) :: LoadFactor !! load factor !% probing algorithm (1 = Linear, 2 = Quadratic, 3 = Double Hashing) tSInt32 , OPTIONAL , INTENT ( IN ) :: ProbAlgo !> hash function to compute the hash value of the item; if not present, use default one. PROCEDURE ( HashFunc ), OPTIONAL :: HashCalc !> a procedure to copy stored data for a derived type not in the Object class; required if !  the type of specified items to be stored has allocatable/pointer component(s). PROCEDURE ( IfacePolyCopy ), OPTIONAL :: ItemCopy !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tIndex :: I ! FLOW ! create empty collection with capacity twice of the item size CALL Collection % CreateEmpty ( N * 2_kIndex , LoadFactor , ProbAlgo , HashCalc , ItemCopy ) ! add items to the set DO I = 1_kIndex , N CALL Collection % Insert ( Items ( I )) END DO RETURN END SUBROUTINE HashSet_CreateByArray !****************************************************************************** SUBROUTINE HashSet_Finalize ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To perform finalization of the collection. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: CALL Collection % Destruct () RETURN END SUBROUTINE HashSet_Finalize !****************************************************************************** FUNCTION HashSet_Remove ( Collection , Item ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To remove the specified item (and its associated value) from a collection.  Also, !  return a flag indicating whether the item is successfully removed or not. <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be removed !> flag indicating whether the specified item and its associated !  value are successfully removed or not. tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tHash :: HashCode tIndex :: Indx , Offset , I tIndex :: ItemSize ! FLOW ! return quickly if possible IF ( Collection % IsEmpty ()) THEN Flag = FalseVal RETURN ELSEIF (. NOT . Collection % IsItemValid ( Item )) THEN Flag = FalseVal CALL Handle_ErrLevel ( 'HashSet_Remove' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as that of stored items.' ) RETURN END IF ! set up the probing if needed CALL SetupProbing ( Collection , Item ) ! compute the hash code and offset ItemSize = AnyType_GetByteSize ( Item ) HashCode = Collection % HashCalc ( Item , ItemSize , HashSeed , RemoveSign = TrueVal ) Offset = ComputeIndex ( HashCode , Collection % Capacity ) ! initialize indices I = Offset Indx = 1_kIndex ! Starting at the original hash probe until we find a spot where our item is ! or we hit a null element in which case our element does not exist. DO IF ( Collection % Items ( I )% Stat == STAT_DEL ) THEN ! ignore deleted bucket so do nothing here ELSEIF ( Collection % Items ( I )% Stat == STAT_NUL ) THEN ! the item was not found Flag = FalseVal EXIT ELSEIF ( Collection % Items ( I )% IsItemEqual ( Item , Collection % ItemPool )) THEN ! found the item we want to remove Collection % ItemCount = Collection % ItemCount - 1_kIndex Collection % ModCount = Collection % ModCount + 1_kIndex CALL Collection % Items ( I )% Set ( STAT_DEL ) Flag = TrueVal EXIT END IF I = ComputeIndex ( Offset + Probe ( Collection , Indx ), Collection % Capacity ) Indx = Indx + 1_kIndex END DO ! halve the hash set capacity if it is 12.5% full or less IF (( Collection % ItemCount > 0_kIndex ). AND .( Collection % ItemCount <= Collection % Capacity / 8 )) THEN CALL Collection % Resize ( MoreCap = FalseVal ) END IF RETURN END FUNCTION HashSet_Remove !****************************************************************************** FUNCTION HashSet_Contain ( Collection , Item ) RESULT ( Found ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the specified item is currently stored in a collection.  <br> !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Item !! item to be looked for !% flag indicating whether the specified item is found or not. tLogical :: Found !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( Collection % IsEmpty ()) THEN Found = FalseVal ELSEIF (. NOT . Collection % IsItemValid ( Item )) THEN Found = FalseVal CALL Handle_ErrLevel ( 'HashSet_Contain' , ModName , ErrSevere , & 'Type of the specified item is NOT the same as that of stored items.' ) RETURN ELSE ! find the item Found = Collection % FindItem ( Item ) END IF RETURN END FUNCTION HashSet_Contain ! ----------------------------------------------------------------------------- ! -----             Procedures Dependent On Probing Algorithm             ----- ! ----------------------------------------------------------------------------- SUBROUTINE SetupProbing ( Collection , Key ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To set up the probing according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection CLASS ( * ), INTENT ( IN ) :: Key !! key !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! no setup required CASE ( QuadraticProbing ) ! no setup required CASE ( DoubleHashing ) BLOCK tIndex :: HashCode tIndex :: KeySize ! Cache second hash value. KeySize = AnyType_GetByteSize ( Key ) HashCode = Collection % HashCalc ( Key , KeySize , HashSeed , RemoveSign = TrueVal ) Collection % HashIndx = ComputeIndex ( HashCode , Collection % Capacity ) ! Fail safe to avoid infinite loop IF ( Collection % HashIndx == 0_kIndex ) Collection % HashIndx = 1_kIndex END BLOCK END SELECT RETURN END SUBROUTINE SetupProbing !****************************************************************************** FUNCTION Probe ( Collection , IdIn ) RESULT ( IdOut ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To look for the next available bucket according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection tIndex , INTENT ( IN ) :: IdIn !! starting index for the probing tIndex :: IdOut !! index of available bucket !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) IdOut = LinearConstant * IdIn CASE ( QuadraticProbing ) ! Quadratic probing function (x**2 + x) / 2 IdOut = SHIFTR ( IdIn * IdIn + IdIn , 1 ) CASE ( DoubleHashing ) IdOut = Collection % HashIndx * IdIn END SELECT RETURN END FUNCTION Probe !****************************************************************************** SUBROUTINE AdjustCapacity ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To adjust capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! Adjust the capacity so that the linear constant and ! the set capacity are relatively prime. DO WHILE ( ComputeGCD ( LinearConstant , Collection % Capacity ) /= 1_kIndex ) Collection % Capacity = Collection % Capacity + 1_kIndex END DO CASE ( QuadraticProbing ) ! Adjust the capacity of the hash set to be a power of two. BLOCK tIndex :: Pow2 Pow2 = HighestOneBit ( Collection % Capacity ) IF ( Collection % Capacity /= Pow2 ) THEN CALL IncreaseCapacity ( Collection ) END IF END BLOCK CASE ( DoubleHashing ) ! Adjust the capacity until it is a prime number. The reason for ! doing this is to help ensure that the GCD(hash, capacity) = 1 when ! probing so that all the cells can be reached. IF (. NOT . IsPrime ( Collection % Capacity )) THEN Collection % Capacity = NextPrime ( Collection % Capacity ) END IF END SELECT RETURN END SUBROUTINE AdjustCapacity !****************************************************************************** SUBROUTINE IncreaseCapacity ( Collection ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To increase capacity according to the probing algorithm. !** SUBROUTINE ARGUMENT DECLARATIONS: CLASS ( HashSet ), INTENT ( INOUT ) :: Collection !! collection !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW: SELECT CASE ( Collection % ProbAlgo ) CASE ( LinearProbing ) ! doubling the capacity Collection % Capacity = Collection % Capacity * 2_kIndex + 1_kIndex CASE ( QuadraticProbing ) ! increase the capacity of the hash set to the next power of two. Collection % Capacity = SHIFTL ( HighestOneBit ( Collection % Capacity ), 1 ) CASE ( DoubleHashing ) ! doubling the capacity Collection % Capacity = Collection % Capacity * 2_kIndex + 1_kIndex END SELECT RETURN END SUBROUTINE IncreaseCapacity ! ----------------------------------------------------------------------------- ! -----                     Auxiliary Procedures                          ----- ! ----------------------------------------------------------------------------- FUNCTION ComputeIndex ( HashCode , Capacity ) RESULT ( Indx ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To compute the index of working items of the hash set for !  the specified hash code.  Returns value between 0 and !  Capacity-1 (assumes Capacity is a power of 2). !** SUBROUTINE ARGUMENT DECLARATIONS: tHash , INTENT ( IN ) :: HashCode tIndex , INTENT ( IN ) :: Capacity tIndex :: Indx !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW ! Note: the sign of the hash code must have already been removed. Indx = IAND ( HashCode , Capacity - 1_kIndex ) RETURN END FUNCTION ComputeIndex !****************************************************************************** RECURSIVE FUNCTION ComputeGCD ( A , B ) RESULT ( C ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To find the greatest common denominator of A and B. !** SUBROUTINE ARGUMENT DECLARATIONS: tIndex , INTENT ( IN ) :: A , B tIndex :: C !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na ! FLOW IF ( B == 0_kIndex ) THEN C = A ELSE C = ComputeGCD ( B , MOD ( A , B )) END IF RETURN END FUNCTION ComputeGCD !****************************************************************************** END MODULE MClass_HashSet !******************************************************************************","tags":"","loc":"sourcefile\\mclass_hashset.f90.html"},{"title":"MBase_PriorityQueues.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_PriorityQueues !&#94;  **PURPOSE OF THIS MODULE**: <br> !   This module collectively contains *priority-queue* container types from other modules. !   It is provided so that a user can refer to this module instead of referring to several !   individual modules when various types are needed concurrently. <br> !   <br> !   **Overview**: <br> !   These priority-queue container types are container types that employ a binary heap !   implementation (with the exception of the *PQBasic* type, which employs an elementary !   implementation) to provide common operations for a priority queue.  They can be used as !   a max-priority queue or a min-priority queue.  By default, each type represents the !   max-priority queue but a user can specify the optional *MinPQ* argument to true when !   constructing the container so that it can be employed as the min-priority queue instead. <br> !   Each individual type can be used to store keys for a specific type of keys.   The allowed !   type of stored keys is one of Fortran intrinsic *comparable* types (i.e. CHARACTER, INTEGER !   and REAL) or any derived type in the *Comparable* class. <br> !   Specifically, available priority-queue container types include: <br> !   - the <a href=\"../module/mclass_pqcharacter.html#type-pqcharacter\">PQCharacter</a> type !     for character string key type, <br> !   - the <a href=\"../module/mclass_pqinteger1b.html#type-pqinteger1b\">PQInteger1B</a> type !     for 1-byte (or 8-bit) integer key type, <br> !   - the <a href=\"../module/mclass_pqinteger2b.html#type-pqinteger2b\">PQInteger2B</a> type !     for 2-byte (or 16-bit) integer key type, <br> !   - the <a href=\"../module/mclass_pqinteger4b.html#type-pqinteger4b\">PQInteger4B</a> type !     for 4-byte (or 32-bit) integer key type, <br> !   - the <a href=\"../module/mclass_pqinteger8b.html#type-pqinteger8b\">PQInteger8B</a> type !     for 8-byte (or 64-bit) integer key type, <br> !   - the <a href=\"../module/mclass_pqrealsp.html#type-pqrealsp\">PQRealSP</a> type !     for single-precision real key type, <br> !   - the <a href=\"../module/mclass_pqrealdp.html#type-pqrealdp\">PQRealDP</a> type !     for double-precision real key type, <br> !   - the <a href=\"../module/mclass_pqrealqp.html#type-pqrealqp\">PQRealQP</a> type !     for quadruple-precision real key type, <br> !   - the <a href=\"../module/mclass_pqheap.html#type-pqheap\">PQHeap</a> type for type !     of key in *Comparable* class, and <br> !   - the <a href=\"../module/mclass_pqbasic.html#type-pqbasic\">PQBasic</a> type for type !     of key in *Comparable* class. <br> !   Each priority-queue container type represents a priority queue where various common !   operations are provided and can be categorized as follows. <br> !   (1) Construction and Destruction.  Methods for these operations include: <br> !   - *CreateEmpty* method - method to construct an empty container, <br> !   - *Construct* method - method to construct a container from an array of keys, and <br> !   - *Destruct* method - method to destruct a container by removing all keys from !       the container as well as free memory storage occupied by the container. <br> !   (2) Insertion and Removal.  Methods for these operations include: <br> !   - *Insert* method - method to insert a new key into a container, and <br> !   - *Remove* method - method to remove a top-priority key from a container. <br> !   (3) Retrieval.  A method for this operation is: <br> !   - *Peek* method - method to retrieve a top-priority key from a container. <br> !   (4) Inquiry.  Methods for this operation include: <br> !   - *IsEmpty* method - method to check whether the container is empty or not, and <br> !   - *GetSize* method - method to get the container size (number of key-value pairs stored). <br> !** USE STATEMENTS: USE MClass_PQCharacter USE MClass_PQInteger1B USE MClass_PQInteger2B USE MClass_PQInteger4B USE MClass_PQInteger8B USE MClass_PQRealSP USE MClass_PQRealDP USE MClass_PQRealQP USE MClass_PQHeap USE MClass_PQBasic END MODULE MBase_PriorityQueues","tags":"","loc":"sourcefile\\mbase_priorityqueues.f90.html"},{"title":"MClass_DArrInteger2B.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_DArrInteger2B !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *DArrInteger2B* type and related routines. !   The *DArrInteger2B* type is a container with *INTEGER(KIND=kInt16)* as the type !   of its stored items.  It employs a dynamic-array implementation where !   items are stored as a resizable array. <br> !   See the <a href=\"../module/mclass_dynamicarrays.html\">MClass_DynamicArrays</a> !   module for discussions about the *Dynamic-Array* concept and its strategy !   used for growing and shrinking the array, which is similar to the strategy !   employed by the *DArrInteger2B* type. <br> !   See the <a href=\"../module/mbase_dynamicarrays.html\">MBase_DynamicArrays</a> !   module for an overview and usage notes of a *dynamic-array-based* type.   A user !   may use the *MBase_DynamicArrays* module instead of using this module directly. !** USE STATEMENTS: USE MBase_Common USE MBase_SIntUtil , ONLY : MAX_I32 , MAX_I64 USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: DArrInteger2B PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #define DynArr          DArrInteger2B #define TypeAlloc       INTEGER(KIND=kInt16), ALLOCATABLE #define TypeArgmt       INTEGER(KIND=kInt16) #define TypeOfItem      INTEGER(KIND=kInt16) !** MODULE PARAMETERS: ! name of module tCharStar , PARAMETER :: ModName = 'MClass_DArrInteger2B' ! Size of character variable for storing error messages returned from ! ALLOCATE and DEALLOCATE statement. tSInt32 , PARAMETER :: MsgLen = 128 ! maximum capacity of a dynamic-array-based container #ifdef Indx64Bits tIndex , PARAMETER :: MaxCapacity = MAX_I64 #else tIndex , PARAMETER :: MaxCapacity = MAX_I32 #endif !** DERIVED TYPE DEFINITIONS: !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic DynArr - Declaraction.f90\" !** INTERFACE DEFINITIONS: ! na !** MODULE VARIABLE DECLARATIONS: tCharAlloc :: SubName ! routine name tCharAlloc :: ErrMsg ! error message CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic DynArr - Implementation.f90\" !** UNDEFINE MACROS ** #undef DynArr #undef TypeAlloc #undef TypeArgmt #undef TypeOfItem END MODULE MClass_DArrInteger2B !******************************************************************************","tags":"","loc":"sourcefile\\mclass_darrinteger2b.f90.html"},{"title":"MClass_PQRealDP.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_PQRealDP !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *PQRealDP* type and its related routines. !   The *PQRealDP* type is a priority-queue container with *REAL(KIND=kDouble)* !   as the type of its stored keys.  It employs a binary heap implementation !   to order its stored keys. <br> !   The *PQRealDP* type can represent either the max-priority queue or the !   min-priority queue.  By default, it represents the max-priority queue but !   a user can specify the *MinPQ* argument to true so that it represents !   the min-priority queue instead. <br> !   See the <a href=\"../module/mbase_priorityqueues.html\">MBase_PriorityQueues</a> !   module for an overview of a *priority-queue-based* type. A user may use the !   *MBase_PriorityQueues* module instead of using this module directly. <br> !** USE STATEMENTS: USE MBase_Common USE MBase_ErrHandlers USE MBase_MemHandlers IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS PUBLIC :: PQRealDP PRIVATE ! by default, hide all data and routines except those declared explicitly !*** MACRO DEFINITIONS: #include    \"../../../MacroDef/Macro - Basic Definitions.f90\" #include    \"../../../MacroDef/Macro - Util Definitions.f90\" #define     KeyType     REAL(KIND=kDouble) #define     PQHeap      PQRealDP !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MClass_PQRealDP' !** INCLUDE FILE FOR DECLARATION PART** #include \"Includes/Intrinsic PQHeap - Declaraction.f90\" CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !** INCLUDE FILE FOR IMPLEMENTATION PART ** #include \"Includes/Intrinsic PQHeap - Implementation.f90\" END MODULE MClass_PQRealDP !******************************************************************************","tags":"","loc":"sourcefile\\mclass_pqrealdp.f90.html"}]}
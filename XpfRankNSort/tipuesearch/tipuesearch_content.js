var tipuesearch = {"pages":[{"title":" eXPerimental Fortran Library (XpfLib) Documentation ","text":"eXPerimental Fortran Library (XpfLib) Documentation XpfRankNSort: eXPerimental Fortran RankNSort Package XpfRankNSort is an experimenal package written in Fortran.   It is a sub-package of the XpfGeneral package (a larger package within the XpfLib library), which contains a large collection of general-purpose modules.  The XpfRankNSort package consists of three modules (and a number of submodules) that provides a large number of routines for ranking and sorting arrays of comparable types.   Allowed comparable types include CHARACTER , INTEGER and REAL Fortran intrinsic types as well as any derived type that is a subtype of the Comparable type. The source code of the XpfRankNSort package is organized into 3 module files and 4 subfolders of the XpfRankNSort folder.   A brief overview of the source code is given below. The MBase_Ranking module provides interfaces to a large number of routines that can be used to rank an array in an ascending order.  The Ranking subfolder contains a number of submodules where each submodule contains the ranking routines implemented for a specific data type. The MBase_SortAscend module provides interfaces to a large number of routines that can be used to sort an array in an ascending order. The SortAscend subfolder contains a number of submodules where each submodule contains the sorting routines implemented for a specific data type. The MBase_SortDescend module provides interfaces to a large number of routines that can be used to sort an array in an descending order. The SortDescend subfolder contains a number of submodules where each submodule contains the sorting routines implemented for a specific data type. The Includes subfolder contains two template files that consist of the actual implementations of the ranking and sorting routines. Dependencies The XpfRankNSort pacakge is primarily dependent on the XpfBase package. Documentation The FORD program can be used to automatically generate the documentation of the XpfRankNSort package via ford XpfRankNSortDoc.md . Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"WiseSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseSort Subroutine Interface : WiseSort Purpose :  To sort an array in a desired order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSort(A) Technical Information : The WiseSort algorithm is a hybrid algorithm originated in this library\n  ( XpfLib ).  The algorithm sorts the given array using a variety of sorting\n  algorithms based on the pattern of the data.  First, it carefully and wisely\n  inspects the specified array by checking if there is any pattern in the given\n  array.  Next, it decides which sorting algorithm is most suitable for the array.\n  It then sorts the array using the chosen algorithm. The selection of a sorting algorithm is based on the following facts. - An Insertion sort algorithm usually performs well for an array with\n    small size. - If the data is already sorted, no sorting algorithm is needed. - If the data is already sorted but in an order opposite to the desired one,\n    a reversion of the array is the most optimal sorting algorithm. - A quicksort algorithm typically performs well for a totally randomized array. - A mergesort algorithm generally performs well for a mostly ordered array. Based on the aforementioned facts, the WiseSort algorithm utilizes various\n  sorting algorithms including: 1. Pair-insertion-sort-based algorithms consisting of - guarded version for a left-most sub-array or the whole array with small size, - unguarded version for a non-left-most sub-array with small size. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered\n      array (i.e. an array having a very long ordered run, either in ascending or\n      descending order). For this particular implementation, it is found that Rust's mergesort performs\n      very well for an array when more than 50% of the first or last elements of the\n      array are already sorted. 3. Quick-sort-based algorithms where various partitioning schemes are employed\n      including: - Hoare's partitioning scheme for a NOT highly structured array, i.e. a\n      partly-ordered and partly-randomized array (an array having not very long\n      and not very short ordered runs), - Median-of-three partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements), - Ninther (median of medians or pseudo-median of nine) partitioning scheme for\n      worst-case situations (when the quicksort algorithm converges too slowly, it\n      switches from Hoare's or median-of-three partitioning scheme to the ninther\n      partitioning scheme), - Three-way (or Dutch's national flag) partitioning scheme for an array with\n      many equal elements (when the quick sort algorithm detects that many elements\n      are equal, it switches from Hoare's or median-of-three partitioning scheme to\n      the three-way partitioning scheme). As previously mentioned, the selection of an appropriate algorithm is based on\n  a careful and wise inspection of the given array.  The routine responsible for\n  this task will try to predict a suitable algorithm for any given array according\n  to its pattern found.  The following list provides an overview of the routine. - The routine will mostly try to scan just a very few runs and quit very quickly.\n      Only, the highly structured array (the one sorted by Java's merge runs) is\n      entirely scanned since all the runs are needed by the selected algorithm. - If the routine detects that the current run is in an order opposite to the\n      desired one, it will only reverse the run if necessary (i.e. the chosen\n      algorithm will benefit from the reversion of the run). - The prediction of a proper algorithm is quite accurate for most known cases.\n      However, there are certain known cases that the routine may not choose\n      the BEST algorithm.  For example, if highly-order parts of the given array\n      are in the middle while randomized parts are in the beginning and in the end,\n      the routine will typically select a quick sort algorithm.  However, if the\n      highly-ordered parts are long enough (e.g. more than 50% of the array size),\n      Rust/TimSort algorithms might be better algorithms.  For these certain cases,\n      nonetheless, it is not worth scanning the whole array just so we can choose\n      the BEST algorithm because the overhead will surely be very expensive. Subroutines private module subroutine Wise_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Wise_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Wise_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Wise_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Wise_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Wise_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Wise_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Wise_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Wise_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\wisesort.html"},{"title":"WiseSortStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseSortStable Subroutine Interface : WiseSortStable Purpose :  To sort an array in a desired order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSortStable(A) Technical Information : Similar to the WiseSort algorithm, the WiseSort-Stable algorithm is\n  a hybrid algorithm originated in this library( XpfLib ).  Unlike the WiseSort algorithm, which is an unstable algorithm, the WiseSort-Stable algorithm (as the name implied) is a stable algorithm that sorts the given\n  array using a variety of stable sorting algorithms.  Similar to the WiseSort algorithm, the WiseSort-Stable algorithm first inspects the specified\n  array by checking if there is any pattern in the given array and then decides\n  which stable sorting algorithm is most suitable for the array.  It then sorts\n  the array using the chosen algorithm. The selection of a stable sorting algorithm is based on the same facts given\n  in the WiseSort section; hence, the WiseSort-Stable algorithm employs\n  various stable sorting algorithms including: 1. Insertion sort algorithm (guarded version only) for a small-size (sub)array. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered\n      array (an array having a very long ordered run, either in ascending or\n      descending order), - Merge sort with half-copying for a small-size array or a partially randomized\n      array (an array with one not-too-short and not-too-long run and many very-very\n      short runs). 3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements). 4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array\n      with many not-too-short and not-too-long runs). Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm\n      that switches to the mergesort with half-copying algorithm for the smaller\n      sub-array after the stable partitioning process while it recurs on the larger\n      sub-array. Subroutines private module subroutine WiseStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine WiseStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine WiseStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine WiseStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine WiseStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine WiseStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine WiseStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine WiseStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine WiseStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\wisesortstable.html"},{"title":"IntroSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IntroSort Subroutine Interface : IntroSort Purpose :  To sort an array in a desired order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroSort(A) Technical Information : The IntroSort algorithm is a hybrid algorithm developed by David Musser [1].\n  The algorithm starts sorting the given array using the quicksort algorithm\n  with the median-of-three partitioning scheme.  It then switches to the heapsort\n  algorithm when the recursion depth exceeds its limit (which is dependent on the\n  array size).  It also switches to the pair-insertion sort algorithm if the\n  (sub)array size falls below a certain threshold (called insertion cutoff). References : [1] Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.\n      Software: Practice and Experience. 27(8):983-993. Subroutines private module subroutine Intro_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Intro_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Intro_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Intro_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Intro_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Intro_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Intro_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Intro_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Intro_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\introsort.html"},{"title":"JavaSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface JavaSort Subroutine Interface : JavaSort Purpose :  To sort an array in a desired order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaSort(A) Technical Information : The JavaSort algorithm is a hybrid algorithm based on Java's sorting\n  algorithm [1].  The algorithm employs the dual-pivot quicksort as the\n  main algorithm.  The algorithm is a variant of the IntroSort algorithm\n  where the heapsort algorithm is used when the recursion depth exceeds its\n  limit and the mixed insertion sort algorithm is utilized when the number\n  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,\n  the JavaSort algorithm (with a routine that inspects the pattern of the\n  specified array) employs a variant of the mergesort algorithm (a merging of\n  runs) if the given array is found to be highly structured. References : [1] Java's DualPivotQuicksort class. Subroutines private module subroutine Java_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Java_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Java_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Java_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Java_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Java_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Java_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Java_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Java_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\javasort.html"},{"title":"PDQSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface PDQSort Subroutine Interface : PDQSort Purpose :  To sort an array in a desired order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQSort(A) Technical Information : The PDQSort (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm\n  developed by Orson Peters [1].  The algorithm is a variant of the IntroSort algorithm with various improvements including median-of-three pivoting scheme, BlockQuickSort partitioning scheme to lesson the branch mis-prediction penalties,\n  an adaptive sort to deals with an array with certain patterns, and a shuffling\n  of array elements to help the heapsort works better. References : [1] Peters, O.R.L. 2021.\n      Pattern-defeating Quicksort. Subroutines private module subroutine PDQ_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine PDQ_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine PDQ_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine PDQ_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine PDQ_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine PDQ_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine PDQ_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine PDQ_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine PDQ_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\pdqsort.html"},{"title":"TimSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TimSort Subroutine Interface : TimSort Purpose :  To sort an array in a desired order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimSort(A) Technical Information : The TimSort algorithm is a hybrid stable algorithm developed by Tim\n  Peters [1].  The algorithm is an adaptive, natural mergesort that works\n  well for many kinds of partially ordered arrays.  As implemented here,\n  the Timsort algorithm employs the insertion sort for small arrays and\n  the adaptive mergesort for large arrays. References : [1] Timsort by\n      Tim Peters. Subroutines private module subroutine Tim_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout), TARGET :: A (:) private module subroutine Tim_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout), TARGET :: A (:)","tags":"","loc":"interface\\timsort.html"},{"title":"RustSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RustSort Subroutine Interface : RustSort Purpose :  To sort an array in a desired order using the RustSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL RustSort(A) Technical Information : The RustSort algorithm is a hybrid stable algorithm based on the Rust's\n  mergesort algorithm [1].  The algorithm can be considered as a simplified TimSort algorithm where the galloping mode is not utilized.  Similar to\n  the Timsort algorithm, the RustSort algorithm employs the insertion sort\n  for small arrays and the adaptive mergesort for large arrays. References : [1] Rust's mergesort. Subroutines private module subroutine Rust_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Rust_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Rust_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Rust_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Rust_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Rust_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Rust_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Rust_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Rust_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\rustsort.html"},{"title":"QuickSortHoare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortHoare Subroutine Interface : QuickSortHoare Purpose :  To sort an array in a desired order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickSortHoare(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Hoare's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine QuickHoare_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickHoare_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickHoare_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickHoare_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickHoare_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickHoare_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickHoare_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickHoare_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickHoare_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksorthoare.html"},{"title":"QuickSortLomuto – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortLomuto Subroutine Interface : QuickSortLomuto Purpose :  To sort an array in a desired order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickSortLomuto(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine QuickLomuto_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickLomuto_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortlomuto.html"},{"title":"QuickSortMo3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortMo3 Subroutine Interface : QuickSortMo3 Purpose :  To sort an array in a desired order using the QuickSort algorithm with the median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortMo3(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with median-of-three partitioning scheme [1] is\n  employed for large (sub)array(s).  Unlike other QuickSort procedures,\n  the algorithm for QuickSortMo3 procedures uses a pure recursion instead\n  of a tail recursion since it appears experimentally that the pure recursion\n  provides a better performance for this particular implementation of the\n  median-of-three partitioning scheme. References : [1] Quicksort. Subroutines private module subroutine QuickMo3_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickMo3_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickMo3_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickMo3_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickMo3_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickMo3_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickMo3_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickMo3_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickMo3_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortmo3.html"},{"title":"QuickSort3Way – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSort3Way Subroutine Interface : QuickSort3Way Purpose :  To sort an array in a desired order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickSort3Way(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Bentley and McIlroy's three-way partitioning\n  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses\n  a tail recursion (instead of a pure recursion) to minimize the recursive\n  depth and make sure at most O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine Quick3Way_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Quick3Way_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Quick3Way_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Quick3Way_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Quick3Way_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Quick3Way_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Quick3Way_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Quick3Way_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Quick3Way_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksort3way.html"},{"title":"QuickSortVowels – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortVowels Subroutine Interface : QuickSortVowels Purpose :  To sort an array in a desired order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version)\n      by R.A. Vowels [1]. Usage : --->    CALL QuickSortVowels(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm based on the QuickSort Version 3 (the professional\n  version) by R.A. Vowels [1] is employed for large (sub)array(s). References : [1] Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,\n      Unicomp. Subroutines private module subroutine QuickVowels_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickVowels_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickVowels_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickVowels_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickVowels_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickVowels_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickVowels_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickVowels_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickVowels_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortvowels.html"},{"title":"QuickSortStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortStable Subroutine Interface : QuickSortStable Purpose :  To sort an array in a desired order using the QuickSort algorithm with a stable partitioning scheme. Usage : --->    CALL QuickSortStable(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with a stable partitioning scheme is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion\n  (instead of a pure recursion) to minimize the recursive depth and make\n  sure at most O(log(n)) space is used [1]. It is important to note that although the pair-insertion sort algorithm\n  should conceptually be a stable algorithm, its implementation in this\n  library seems to be unstable .  Therefore, for all hybrid stable algorithms, the insertion sort is used in place of the pair-insertion\n  sort although the pair-insertion sort typically provides better overall\n  performance. References : [1] How to Boost QuickSort Performance? Subroutines private module subroutine QuickStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortstable.html"},{"title":"QuickSortIterative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortIterative Subroutine Interface : QuickSortIterative Purpose :  To sort an array in a desired order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortIterative(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the iterative quicksort algorithm with median-of-three partitioning\n  scheme is employed for large (sub)array(s).  The implementation of the\n  iterative quicksort algorithm is based mainly on the Sort subroutine\n  of Numerical Recipes in Fortran 90 [1]. References : [1] Numerical\n      Recipes Books Online. Subroutines private module subroutine QuickIterative_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickIterative_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickIterative_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickIterative_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickIterative_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickIterative_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickIterative_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickIterative_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickIterative_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortiterative.html"},{"title":"QuickSortJava – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortJava Subroutine Interface : QuickSortJava Purpose :  To sort an array in a desired order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm [1]. Usage : --->    CALL QuickSortJava(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the dual-pivot quicksort algorithm is employed for large (sub)array(s).\n  The implementation of the dual-pivot quicksort algorithm is based mainly\n  on Java's sorting algorithm [1]. References : [1] Java's DualPivotQuicksort class. Subroutines private module subroutine QuickJava_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickJava_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickJava_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickJava_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickJava_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickJava_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickJava_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickJava_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickJava_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortjava.html"},{"title":"MergeSortTopDown – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortTopDown Subroutine Interface : MergeSortTopDown Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeSortTopDown(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] is employed for large (sub)array(s).\n  The algorithm also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeTopDown_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeTopDown_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesorttopdown.html"},{"title":"MergeSortBottomUp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortBottomUp Subroutine Interface : MergeSortBottomUp Purpose :  To sort an array in a desired order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeSortBottomUp(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). References : [1] Merge sort. Subroutines private module subroutine MergeBottomUp_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesortbottomup.html"},{"title":"MergeSortRealQPSplit – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortRealQPSplit Subroutine Interface : MergeSortRealQPSplit Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeSortRealQPSplit(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] with quad split.  The algorithm\n  also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeQuadSplit_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesortrealqpsplit.html"},{"title":"MergeSortHalfCopy – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortHalfCopy Subroutine Interface : MergeSortHalfCopy Purpose :  To sort an array in a desired order using a fast mergesort algorithm based on half-copying merge algorithm\n      by C. Juszczak [1]. Usage : --->    CALL MergeSortHalfCopy(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm with a half-copying merging [1]\n  is employed for large (sub)array(s).  The algorithm also considers\n  other improvements as suggested in [2]. References : [1] Juszczak, C. 2007.  Fast mergesort implementation based on half-copying\n      merge algorithm. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeHalfCopy_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesorthalfcopy.html"},{"title":"IsSortedDescend – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsSortedDescend Function Interface : IsSortedDescend Purpose :  To check whether the specified array is sorted in\n      the desired order. Usage : --->    Flag = IsSortedDescend(A) --->    IF (.NOT.IsSortedDescend(A)) DoSomething Functions private module function IsSortedDescend_Char(A) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I8(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I16(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I32(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I64(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R32(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R64(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R128(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_Comp(A) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: A (:) Return Value logical","tags":"","loc":"interface\\issorteddescend.html"},{"title":"WiseRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseRank Subroutine Interface : WiseRank Purpose :  To rank an array in an ascending order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseRank(AVal, AInd) Technical Information : See the WiseSort interface\n  for the technical information of the WiseSort algorithm. Subroutines private module subroutine Wise_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\wiserank.html"},{"title":"WiseRankStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseRankStable Subroutine Interface : WiseRankStable Purpose :  To rank an array in an ascending order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseRankStable(AVal, AInd) Technical Information : See the WiseSortStable interface\n  for the technical information of the WiseSort-Stable algorithm. Subroutines private module subroutine WiseStable_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\wiserankstable.html"},{"title":"IntroRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IntroRank Subroutine Interface : IntroRank Purpose :  To rank an array in an ascending order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroRank(AVal, AInd) Technical Information : See the IntroSort interface\n  for the technical information of the IntroSort algorithm. Subroutines private module subroutine Intro_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\introrank.html"},{"title":"JavaRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface JavaRank Subroutine Interface : JavaRank Purpose :  To rank an array in an ascending order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaRank(AVal, AInd) Technical Information : See the JavaSort interface\n  for the technical information of the JavaSort algorithm. Subroutines private module subroutine Java_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\javarank.html"},{"title":"PDQRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface PDQRank Subroutine Interface : PDQRank Purpose :  To rank an array in an ascending order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQRank(AVal, AInd) Technical Information : See the PDQSort interface\n  for the technical information of the PDQSort algorithm. Subroutines private module subroutine PDQ_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\pdqrank.html"},{"title":"TimRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TimRank Subroutine Interface : TimRank Purpose :  To rank an array in an ascending order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimRank(AVal, AInd) Technical Information : See the TimSort interface\n  for the technical information of the TimSort algorithm. Subroutines private module subroutine Tim_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal))","tags":"","loc":"interface\\timrank.html"},{"title":"RustRank – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RustRank Subroutine Interface : RustRank Purpose :  To rank an array in an ascending order using the RustSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL RustRank(AVal, AInd) Technical Information : See the RustSort interface\n  for the technical information of the RustSort algorithm. Subroutines private module subroutine Rust_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\rustrank.html"},{"title":"QuickRankHoare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankHoare Subroutine Interface : QuickRankHoare Purpose :  To rank an array in an ascending order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickRankHoare(AVal, AInd) Technical Information : See the QuickSortHoare interface for the technical information of the QuickSort algorithm\n  with Hoare's partitioning scheme. Subroutines private module subroutine QuickHoare_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankhoare.html"},{"title":"QuickRankLomuto – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankLomuto Subroutine Interface : QuickRankLomuto Purpose :  To rank an array in an ascending order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickRankLomuto(AVal, AInd) Technical Information : See the QuickSortLomuto interface for the technical information of the QuickSort algorithm\n  with Lomuto's partitioning scheme. Subroutines private module subroutine QuickLomuto_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickranklomuto.html"},{"title":"QuickRankMo3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankMo3 Subroutine Interface : QuickRankMo3 Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the median-of-three (Mo3)\n      partitioning scheme. Usage : --->    CALL QuickRankMo3(AVal, AInd) Technical Information : See the QuickSortMo3 interface for the technical information of the QuickSort algorithm\n  with the median-of-three partitioning scheme. Subroutines private module subroutine QuickMo3_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankmo3.html"},{"title":"QuickRank3Way – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRank3Way Subroutine Interface : QuickRank3Way Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickRank3Way(AVal, AInd) Technical Information : See the QuickSort3Way interface for the technical information of the QuickSort algorithm\n  with the three-way partitioning scheme. Subroutines private module subroutine Quick3Way_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrank3way.html"},{"title":"QuickRankVowels – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankVowels Subroutine Interface : QuickRankVowels Purpose :  To rank an array in an ascending order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version) by R.A. Vowels. Usage : --->    CALL QuickRankVowels(AVal, AInd) Technical Information : See the QuickSortVowels interface for the technical information of the Vowels' QuickSort algorithm. Subroutines private module subroutine QuickVowels_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankvowels.html"},{"title":"QuickRankStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankStable Subroutine Interface : QuickRankStable Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the stable partitioning scheme. Usage : --->    CALL QuickRankStable(AVal, AInd) Technical Information : See the QuickSortStable interface for the technical information of the QuickSort algorithm\n  with the stable partitioning scheme. Subroutines private module subroutine QuickStable_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankstable.html"},{"title":"QuickRankIterative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankIterative Subroutine Interface : QuickRankIterative Purpose :  To rank an array in an ascending order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickRankIterative(AVal, AInd) Technical Information : See the QuickSortIterative interface for the technical information of the iterative Quicksort algorithm with median-of-three partitioning scheme. Subroutines private module subroutine QuickIterative_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankiterative.html"},{"title":"QuickRankJava – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickRankJava Subroutine Interface : QuickRankJava Purpose :  To rank an array in an ascending order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm. Usage : --->    CALL QuickRankJava(AVal, AInd) Technical Information : See the QuickSortJava interface for the technical information of the Java's dual-pivot\n  QuickSort algorithm. Subroutines private module subroutine QuickJava_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\quickrankjava.html"},{"title":"MergeRankTopDown – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeRankTopDown Subroutine Interface : MergeRankTopDown Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeRankTopDown(AVal, AInd) Technical Information : See the MergeSortTopDown interface for the technical information of the top-down merge sort algorithm. Subroutines private module subroutine MergeTopDown_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\mergeranktopdown.html"},{"title":"MergeRankBottomUp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeRankBottomUp Subroutine Interface : MergeRankBottomUp Purpose :  To rank an array in an ascending order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeRankBottomUp(AVal, AInd) Technical Information : See the MergeSortBottomUp interface for the technical information of the bottom-up merge sort algorithm. Subroutines private module subroutine MergeBottomUp_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\mergerankbottomup.html"},{"title":"MergeRankQuadSplit – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeRankQuadSplit Subroutine Interface : MergeRankQuadSplit Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeRankQuadSplit(AVal, AInd) Technical Information : See the MergeSortRealQPSplit interface for the technical information of the top-down merge sort algorithm with quad split. Subroutines private module subroutine MergeQuadSplit_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\mergerankquadsplit.html"},{"title":"MergeRankHalfCopy – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeRankHalfCopy Subroutine Interface : MergeRankHalfCopy Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm with half-copying merge algorithm. Usage : --->    CALL MergeRankHalfCopy(AVal, AInd) Technical Information : See the MergeSortHalfCopy interface for the technical information of the top-down merge sort algorithm with half-copying merge algorithm. Subroutines private module subroutine MergeHalfCopy_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\mergerankhalfcopy.html"},{"title":"MergeRankOrderPack – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeRankOrderPack Subroutine Interface : MergeRankOrderPack Purpose :  To rank an array in an ascending order using a merge sort algorithm based on the ' MrgRnk ' routine in the OrderPack 2.0\n      library by Olagnon [1]. Usage : --->    CALL MergeRankOrderPack(AVal, AInd) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small arrays and the\n  Orderpack's merge sort algorithm [1] is employed for large arrays. References : [1] ORDERPACK 2.0: Unconditional,\n      Unique, and Partial Ranking, Sorting, and Permutation Downloadable Fortran90\n      source code. Subroutines private module subroutine MergeOrderPack_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal))","tags":"","loc":"interface\\mergerankorderpack.html"},{"title":"IsRanked – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsRanked Function Interface : IsRanked Purpose :  To check whether the specified array is ranked in\n      the ascending order. Usage : --->    Flag = IsRanked(AVal, AInd) --->    IF (.NOT.IsRanked(AVal, AInd)) DoSomething Functions private module function IsRanked_Char(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I8(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I16(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I32(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I64(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R32(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R64(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R128(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_Comp(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical","tags":"","loc":"interface\\isranked.html"},{"title":"WiseSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseSort Subroutine Interface : WiseSort Purpose :  To sort an array in a desired order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSort(A) Technical Information : The WiseSort algorithm is a hybrid algorithm originated in this library\n  ( XpfLib ).  The algorithm sorts the given array using a variety of sorting\n  algorithms based on the pattern of the data.  First, it carefully and wisely\n  inspects the specified array by checking if there is any pattern in the given\n  array.  Next, it decides which sorting algorithm is most suitable for the array.\n  It then sorts the array using the chosen algorithm. The selection of a sorting algorithm is based on the following facts. - An Insertion sort algorithm usually performs well for an array with\n    small size. - If the data is already sorted, no sorting algorithm is needed. - If the data is already sorted but in an order opposite to the desired one,\n    a reversion of the array is the most optimal sorting algorithm. - A quicksort algorithm typically performs well for a totally randomized array. - A mergesort algorithm generally performs well for a mostly ordered array. Based on the aforementioned facts, the WiseSort algorithm utilizes various\n  sorting algorithms including: 1. Pair-insertion-sort-based algorithms consisting of - guarded version for a left-most sub-array or the whole array with small size, - unguarded version for a non-left-most sub-array with small size. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered\n      array (i.e. an array having a very long ordered run, either in ascending or\n      descending order). For this particular implementation, it is found that Rust's mergesort performs\n      very well for an array when more than 50% of the first or last elements of the\n      array are already sorted. 3. Quick-sort-based algorithms where various partitioning schemes are employed\n      including: - Hoare's partitioning scheme for a NOT highly structured array, i.e. a\n      partly-ordered and partly-randomized array (an array having not very long\n      and not very short ordered runs), - Median-of-three partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements), - Ninther (median of medians or pseudo-median of nine) partitioning scheme for\n      worst-case situations (when the quicksort algorithm converges too slowly, it\n      switches from Hoare's or median-of-three partitioning scheme to the ninther\n      partitioning scheme), - Three-way (or Dutch's national flag) partitioning scheme for an array with\n      many equal elements (when the quick sort algorithm detects that many elements\n      are equal, it switches from Hoare's or median-of-three partitioning scheme to\n      the three-way partitioning scheme). As previously mentioned, the selection of an appropriate algorithm is based on\n  a careful and wise inspection of the given array.  The routine responsible for\n  this task will try to predict a suitable algorithm for any given array according\n  to its pattern found.  The following list provides an overview of the routine. - The routine will mostly try to scan just a very few runs and quit very quickly.\n      Only, the highly structured array (the one sorted by Java's merge runs) is\n      entirely scanned since all the runs are needed by the selected algorithm. - If the routine detects that the current run is in an order opposite to the\n      desired one, it will only reverse the run if necessary (i.e. the chosen\n      algorithm will benefit from the reversion of the run). - The prediction of a proper algorithm is quite accurate for most known cases.\n      However, there are certain known cases that the routine may not choose\n      the BEST algorithm.  For example, if highly-order parts of the given array\n      are in the middle while randomized parts are in the beginning and in the end,\n      the routine will typically select a quick sort algorithm.  However, if the\n      highly-ordered parts are long enough (e.g. more than 50% of the array size),\n      Rust/TimSort algorithms might be better algorithms.  For these certain cases,\n      nonetheless, it is not worth scanning the whole array just so we can choose\n      the BEST algorithm because the overhead will surely be very expensive. Subroutines private module subroutine Wise_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Wise_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Wise_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Wise_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Wise_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Wise_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Wise_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Wise_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Wise_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\wisesort~2.html"},{"title":"WiseSortStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface WiseSortStable Subroutine Interface : WiseSortStable Purpose :  To sort an array in a desired order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSortStable(A) Technical Information : Similar to the WiseSort algorithm, the WiseSort-Stable algorithm is\n  a hybrid algorithm originated in this library( XpfLib ).  Unlike the WiseSort algorithm, which is an unstable algorithm, the WiseSort-Stable algorithm (as the name implied) is a stable algorithm that sorts the given\n  array using a variety of stable sorting algorithms.  Similar to the WiseSort algorithm, the WiseSort-Stable algorithm first inspects the specified\n  array by checking if there is any pattern in the given array and then decides\n  which stable sorting algorithm is most suitable for the array.  It then sorts\n  the array using the chosen algorithm. The selection of a stable sorting algorithm is based on the same facts given\n  in the WiseSort section; hence, the WiseSort-Stable algorithm employs\n  various stable sorting algorithms including: 1. Insertion sort algorithm (guarded version only) for a small-size (sub)array. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered\n      array (an array having a very long ordered run, either in ascending or\n      descending order), - Merge sort with half-copying for a small-size array or a partially randomized\n      array (an array with one not-too-short and not-too-long run and many very-very\n      short runs). 3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements). 4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array\n      with many not-too-short and not-too-long runs). Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm\n      that switches to the mergesort with half-copying algorithm for the smaller\n      sub-array after the stable partitioning process while it recurs on the larger\n      sub-array. Subroutines private module subroutine WiseStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine WiseStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine WiseStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine WiseStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine WiseStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine WiseStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine WiseStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine WiseStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine WiseStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\wisesortstable~2.html"},{"title":"IntroSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IntroSort Subroutine Interface : IntroSort Purpose :  To sort an array in a desired order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroSort(A) Technical Information : The IntroSort algorithm is a hybrid algorithm developed by David Musser [1].\n  The algorithm starts sorting the given array using the quicksort algorithm\n  with the median-of-three partitioning scheme.  It then switches to the heapsort\n  algorithm when the recursion depth exceeds its limit (which is dependent on the\n  array size).  It also switches to the pair-insertion sort algorithm if the\n  (sub)array size falls below a certain threshold (called insertion cutoff). References : [1] Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.\n      Software: Practice and Experience. 27(8):983-993. Subroutines private module subroutine Intro_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Intro_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Intro_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Intro_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Intro_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Intro_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Intro_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Intro_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Intro_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\introsort~2.html"},{"title":"JavaSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface JavaSort Subroutine Interface : JavaSort Purpose :  To sort an array in a desired order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaSort(A) Technical Information : The JavaSort algorithm is a hybrid algorithm based on Java's sorting\n  algorithm [1].  The algorithm employs the dual-pivot quicksort as the\n  main algorithm.  The algorithm is a variant of the IntroSort algorithm\n  where the heapsort algorithm is used when the recursion depth exceeds its\n  limit and the mixed insertion sort algorithm is utilized when the number\n  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,\n  the JavaSort algorithm (with a routine that inspects the pattern of the\n  specified array) employs a variant of the mergesort algorithm (a merging of\n  runs) if the given array is found to be highly structured. References : [1] Java's DualPivotQuicksort class. Subroutines private module subroutine Java_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Java_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Java_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Java_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Java_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Java_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Java_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Java_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Java_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\javasort~2.html"},{"title":"PDQSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface PDQSort Subroutine Interface : PDQSort Purpose :  To sort an array in a desired order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQSort(A) Technical Information : The PDQSort (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm\n  developed by Orson Peters [1].  The algorithm is a variant of the IntroSort algorithm with various improvements including median-of-three pivoting scheme, BlockQuickSort partitioning scheme to lesson the branch mis-prediction penalties,\n  an adaptive sort to deals with an array with certain patterns, and a shuffling\n  of array elements to help the heapsort works better. References : [1] Peters, O.R.L. 2021.\n      Pattern-defeating Quicksort. Subroutines private module subroutine PDQ_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine PDQ_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine PDQ_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine PDQ_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine PDQ_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine PDQ_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine PDQ_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine PDQ_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine PDQ_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\pdqsort~2.html"},{"title":"TimSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TimSort Subroutine Interface : TimSort Purpose :  To sort an array in a desired order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimSort(A) Technical Information : The TimSort algorithm is a hybrid stable algorithm developed by Tim\n  Peters [1].  The algorithm is an adaptive, natural mergesort that works\n  well for many kinds of partially ordered arrays.  As implemented here,\n  the Timsort algorithm employs the insertion sort for small arrays and\n  the adaptive mergesort for large arrays. References : [1] Timsort by\n      Tim Peters. Subroutines private module subroutine Tim_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout), TARGET :: A (:) private module subroutine Tim_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout), TARGET :: A (:)","tags":"","loc":"interface\\timsort~2.html"},{"title":"RustSort – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RustSort Subroutine Interface : RustSort Purpose :  To sort an array in a desired order using the RustSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL RustSort(A) Technical Information : The RustSort algorithm is a hybrid stable algorithm based on the Rust's\n  mergesort algorithm [1].  The algorithm can be considered as a simplified TimSort algorithm where the galloping mode is not utilized.  Similar to\n  the Timsort algorithm, the RustSort algorithm employs the insertion sort\n  for small arrays and the adaptive mergesort for large arrays. References : [1] Rust's mergesort. Subroutines private module subroutine Rust_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Rust_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Rust_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Rust_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Rust_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Rust_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Rust_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Rust_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Rust_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\rustsort~2.html"},{"title":"QuickSortHoare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortHoare Subroutine Interface : QuickSortHoare Purpose :  To sort an array in a desired order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickSortHoare(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Hoare's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine QuickHoare_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickHoare_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickHoare_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickHoare_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickHoare_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickHoare_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickHoare_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickHoare_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickHoare_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksorthoare~2.html"},{"title":"QuickSortLomuto – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortLomuto Subroutine Interface : QuickSortLomuto Purpose :  To sort an array in a desired order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickSortLomuto(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine QuickLomuto_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickLomuto_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortlomuto~2.html"},{"title":"QuickSortMo3 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortMo3 Subroutine Interface : QuickSortMo3 Purpose :  To sort an array in a desired order using the QuickSort algorithm with the median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortMo3(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with median-of-three partitioning scheme [1] is\n  employed for large (sub)array(s).  Unlike other QuickSort procedures,\n  the algorithm for QuickSortMo3 procedures uses a pure recursion instead\n  of a tail recursion since it appears experimentally that the pure recursion\n  provides a better performance for this particular implementation of the\n  median-of-three partitioning scheme. References : [1] Quicksort. Subroutines private module subroutine QuickMo3_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickMo3_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickMo3_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickMo3_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickMo3_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickMo3_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickMo3_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickMo3_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickMo3_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortmo3~2.html"},{"title":"QuickSort3Way – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSort3Way Subroutine Interface : QuickSort3Way Purpose :  To sort an array in a desired order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickSort3Way(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Bentley and McIlroy's three-way partitioning\n  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses\n  a tail recursion (instead of a pure recursion) to minimize the recursive\n  depth and make sure at most O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? Subroutines private module subroutine Quick3Way_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Quick3Way_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Quick3Way_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Quick3Way_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Quick3Way_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Quick3Way_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Quick3Way_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Quick3Way_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Quick3Way_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksort3way~2.html"},{"title":"QuickSortVowels – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortVowels Subroutine Interface : QuickSortVowels Purpose :  To sort an array in a desired order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version)\n      by R.A. Vowels [1]. Usage : --->    CALL QuickSortVowels(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm based on the QuickSort Version 3 (the professional\n  version) by R.A. Vowels [1] is employed for large (sub)array(s). References : [1] Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,\n      Unicomp. Subroutines private module subroutine QuickVowels_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickVowels_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickVowels_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickVowels_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickVowels_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickVowels_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickVowels_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickVowels_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickVowels_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortvowels~2.html"},{"title":"QuickSortStable – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortStable Subroutine Interface : QuickSortStable Purpose :  To sort an array in a desired order using the QuickSort algorithm with a stable partitioning scheme. Usage : --->    CALL QuickSortStable(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with a stable partitioning scheme is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion\n  (instead of a pure recursion) to minimize the recursive depth and make\n  sure at most O(log(n)) space is used [1]. It is important to note that although the pair-insertion sort algorithm\n  should conceptually be a stable algorithm, its implementation in this\n  library seems to be unstable .  Therefore, for all hybrid stable algorithms, the insertion sort is used in place of the pair-insertion\n  sort although the pair-insertion sort typically provides better overall\n  performance. References : [1] How to Boost QuickSort Performance? Subroutines private module subroutine QuickStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortstable~2.html"},{"title":"QuickSortIterative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortIterative Subroutine Interface : QuickSortIterative Purpose :  To sort an array in a desired order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortIterative(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the iterative quicksort algorithm with median-of-three partitioning\n  scheme is employed for large (sub)array(s).  The implementation of the\n  iterative quicksort algorithm is based mainly on the Sort subroutine\n  of Numerical Recipes in Fortran 90 [1]. References : [1] Numerical\n      Recipes Books Online. Subroutines private module subroutine QuickIterative_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickIterative_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickIterative_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickIterative_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickIterative_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickIterative_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickIterative_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickIterative_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickIterative_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortiterative~2.html"},{"title":"QuickSortJava – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface QuickSortJava Subroutine Interface : QuickSortJava Purpose :  To sort an array in a desired order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm [1]. Usage : --->    CALL QuickSortJava(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the dual-pivot quicksort algorithm is employed for large (sub)array(s).\n  The implementation of the dual-pivot quicksort algorithm is based mainly\n  on Java's sorting algorithm [1]. References : [1] Java's DualPivotQuicksort class. Subroutines private module subroutine QuickJava_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickJava_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickJava_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickJava_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickJava_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickJava_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickJava_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickJava_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickJava_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\quicksortjava~2.html"},{"title":"MergeSortTopDown – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortTopDown Subroutine Interface : MergeSortTopDown Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeSortTopDown(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] is employed for large (sub)array(s).\n  The algorithm also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeTopDown_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeTopDown_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesorttopdown~2.html"},{"title":"MergeSortBottomUp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortBottomUp Subroutine Interface : MergeSortBottomUp Purpose :  To sort an array in a desired order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeSortBottomUp(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). References : [1] Merge sort. Subroutines private module subroutine MergeBottomUp_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesortbottomup~2.html"},{"title":"MergeSortRealQPSplit – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortRealQPSplit Subroutine Interface : MergeSortRealQPSplit Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeSortRealQPSplit(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] with quad split.  The algorithm\n  also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeQuadSplit_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesortrealqpsplit~2.html"},{"title":"MergeSortHalfCopy – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MergeSortHalfCopy Subroutine Interface : MergeSortHalfCopy Purpose :  To sort an array in a desired order using a fast mergesort algorithm based on half-copying merge algorithm\n      by C. Juszczak [1]. Usage : --->    CALL MergeSortHalfCopy(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm with a half-copying merging [1]\n  is employed for large (sub)array(s).  The algorithm also considers\n  other improvements as suggested in [2]. References : [1] Juszczak, C. 2007.  Fast mergesort implementation based on half-copying\n      merge algorithm. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. Subroutines private module subroutine MergeHalfCopy_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:)","tags":"","loc":"interface\\mergesorthalfcopy~2.html"},{"title":"IsSortedAscend – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsSortedAscend Function Interface : IsSortedAscend Purpose :  To check whether the specified array is sorted in\n      the desired order. Usage : --->    Flag = IsSortedAscend(A) --->    IF (.NOT.IsSortedAscend(A)) DoSomething Functions private module function IsSortedAscend_Char(A) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I8(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I16(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I32(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I64(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R32(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R64(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R128(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_Comp(A) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: A (:) Return Value logical","tags":"","loc":"interface\\issortedascend.html"},{"title":"MBase_SortDescend – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains routines that can be used to sort an array in a descending order.  The specified array can be of any type that is comparable.  For Fortran\n  intrinsic types, CHARACTER , INTEGER and REAL types are considered valid\n  comparable types.  For derived types, any types that extend from the Comparable type are valid comparable types. See the MBase_SortAscend module\n  for routines that perform sorting of an array in an ascending order.  Also, the MBase_SortAscend module gives an overview of available sorting algorithms, which\n  are the same as the algorithms available in this module.  For ranking an array in\n  an ascending order, see the MBase_Ranking module. Uses MBase_Common MClass_Comparable Interfaces public        interface WiseSort Subroutine Interface : WiseSort Purpose :  To sort an array in a desired order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSort(A) Technical Information : The WiseSort algorithm is a hybrid algorithm originated in this library\n  ( XpfLib ).  The algorithm sorts the given array using a variety of sorting\n  algorithms based on the pattern of the data.  First, it carefully and wisely\n  inspects the specified array by checking if there is any pattern in the given\n  array.  Next, it decides which sorting algorithm is most suitable for the array.\n  It then sorts the array using the chosen algorithm. The selection of a sorting algorithm is based on the following facts. - An Insertion sort algorithm usually performs well for an array with\n    small size. - If the data is already sorted, no sorting algorithm is needed. - If the data is already sorted but in an order opposite to the desired one,\n    a reversion of the array is the most optimal sorting algorithm. - A quicksort algorithm typically performs well for a totally randomized array. - A mergesort algorithm generally performs well for a mostly ordered array. Based on the aforementioned facts, the WiseSort algorithm utilizes various\n  sorting algorithms including: 1. Pair-insertion-sort-based algorithms consisting of - guarded version for a left-most sub-array or the whole array with small size, - unguarded version for a non-left-most sub-array with small size. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered\n      array (i.e. an array having a very long ordered run, either in ascending or\n      descending order). For this particular implementation, it is found that Rust's mergesort performs\n      very well for an array when more than 50% of the first or last elements of the\n      array are already sorted. 3. Quick-sort-based algorithms where various partitioning schemes are employed\n      including: - Hoare's partitioning scheme for a NOT highly structured array, i.e. a\n      partly-ordered and partly-randomized array (an array having not very long\n      and not very short ordered runs), - Median-of-three partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements), - Ninther (median of medians or pseudo-median of nine) partitioning scheme for\n      worst-case situations (when the quicksort algorithm converges too slowly, it\n      switches from Hoare's or median-of-three partitioning scheme to the ninther\n      partitioning scheme), - Three-way (or Dutch's national flag) partitioning scheme for an array with\n      many equal elements (when the quick sort algorithm detects that many elements\n      are equal, it switches from Hoare's or median-of-three partitioning scheme to\n      the three-way partitioning scheme). As previously mentioned, the selection of an appropriate algorithm is based on\n  a careful and wise inspection of the given array.  The routine responsible for\n  this task will try to predict a suitable algorithm for any given array according\n  to its pattern found.  The following list provides an overview of the routine. - The routine will mostly try to scan just a very few runs and quit very quickly.\n      Only, the highly structured array (the one sorted by Java's merge runs) is\n      entirely scanned since all the runs are needed by the selected algorithm. - If the routine detects that the current run is in an order opposite to the\n      desired one, it will only reverse the run if necessary (i.e. the chosen\n      algorithm will benefit from the reversion of the run). - The prediction of a proper algorithm is quite accurate for most known cases.\n      However, there are certain known cases that the routine may not choose\n      the BEST algorithm.  For example, if highly-order parts of the given array\n      are in the middle while randomized parts are in the beginning and in the end,\n      the routine will typically select a quick sort algorithm.  However, if the\n      highly-ordered parts are long enough (e.g. more than 50% of the array size),\n      Rust/TimSort algorithms might be better algorithms.  For these certain cases,\n      nonetheless, it is not worth scanning the whole array just so we can choose\n      the BEST algorithm because the overhead will surely be very expensive. private module subroutine Wise_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Wise_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Wise_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Wise_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Wise_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Wise_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Wise_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Wise_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Wise_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface WiseSortStable Subroutine Interface : WiseSortStable Purpose :  To sort an array in a desired order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSortStable(A) Technical Information : Similar to the WiseSort algorithm, the WiseSort-Stable algorithm is\n  a hybrid algorithm originated in this library( XpfLib ).  Unlike the WiseSort algorithm, which is an unstable algorithm, the WiseSort-Stable algorithm (as the name implied) is a stable algorithm that sorts the given\n  array using a variety of stable sorting algorithms.  Similar to the WiseSort algorithm, the WiseSort-Stable algorithm first inspects the specified\n  array by checking if there is any pattern in the given array and then decides\n  which stable sorting algorithm is most suitable for the array.  It then sorts\n  the array using the chosen algorithm. The selection of a stable sorting algorithm is based on the same facts given\n  in the WiseSort section; hence, the WiseSort-Stable algorithm employs\n  various stable sorting algorithms including: 1. Insertion sort algorithm (guarded version only) for a small-size (sub)array. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered\n      array (an array having a very long ordered run, either in ascending or\n      descending order), - Merge sort with half-copying for a small-size array or a partially randomized\n      array (an array with one not-too-short and not-too-long run and many very-very\n      short runs). 3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements). 4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array\n      with many not-too-short and not-too-long runs). Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm\n      that switches to the mergesort with half-copying algorithm for the smaller\n      sub-array after the stable partitioning process while it recurs on the larger\n      sub-array. private module subroutine WiseStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine WiseStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine WiseStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine WiseStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine WiseStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine WiseStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine WiseStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine WiseStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine WiseStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface IntroSort Subroutine Interface : IntroSort Purpose :  To sort an array in a desired order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroSort(A) Technical Information : The IntroSort algorithm is a hybrid algorithm developed by David Musser [1].\n  The algorithm starts sorting the given array using the quicksort algorithm\n  with the median-of-three partitioning scheme.  It then switches to the heapsort\n  algorithm when the recursion depth exceeds its limit (which is dependent on the\n  array size).  It also switches to the pair-insertion sort algorithm if the\n  (sub)array size falls below a certain threshold (called insertion cutoff). References : [1] Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.\n      Software: Practice and Experience. 27(8):983-993. private module subroutine Intro_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Intro_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Intro_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Intro_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Intro_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Intro_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Intro_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Intro_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Intro_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface JavaSort Subroutine Interface : JavaSort Purpose :  To sort an array in a desired order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaSort(A) Technical Information : The JavaSort algorithm is a hybrid algorithm based on Java's sorting\n  algorithm [1].  The algorithm employs the dual-pivot quicksort as the\n  main algorithm.  The algorithm is a variant of the IntroSort algorithm\n  where the heapsort algorithm is used when the recursion depth exceeds its\n  limit and the mixed insertion sort algorithm is utilized when the number\n  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,\n  the JavaSort algorithm (with a routine that inspects the pattern of the\n  specified array) employs a variant of the mergesort algorithm (a merging of\n  runs) if the given array is found to be highly structured. References : [1] Java's DualPivotQuicksort class. private module subroutine Java_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Java_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Java_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Java_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Java_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Java_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Java_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Java_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Java_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface PDQSort Subroutine Interface : PDQSort Purpose :  To sort an array in a desired order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQSort(A) Technical Information : The PDQSort (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm\n  developed by Orson Peters [1].  The algorithm is a variant of the IntroSort algorithm with various improvements including median-of-three pivoting scheme, BlockQuickSort partitioning scheme to lesson the branch mis-prediction penalties,\n  an adaptive sort to deals with an array with certain patterns, and a shuffling\n  of array elements to help the heapsort works better. References : [1] Peters, O.R.L. 2021.\n      Pattern-defeating Quicksort. private module subroutine PDQ_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine PDQ_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine PDQ_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine PDQ_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine PDQ_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine PDQ_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine PDQ_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine PDQ_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine PDQ_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface TimSort Subroutine Interface : TimSort Purpose :  To sort an array in a desired order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimSort(A) Technical Information : The TimSort algorithm is a hybrid stable algorithm developed by Tim\n  Peters [1].  The algorithm is an adaptive, natural mergesort that works\n  well for many kinds of partially ordered arrays.  As implemented here,\n  the Timsort algorithm employs the insertion sort for small arrays and\n  the adaptive mergesort for large arrays. References : [1] Timsort by\n      Tim Peters. private module subroutine Tim_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout), TARGET :: A (:) private module subroutine Tim_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout), TARGET :: A (:) public        interface RustSort Subroutine Interface : RustSort Purpose :  To sort an array in a desired order using the RustSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL RustSort(A) Technical Information : The RustSort algorithm is a hybrid stable algorithm based on the Rust's\n  mergesort algorithm [1].  The algorithm can be considered as a simplified TimSort algorithm where the galloping mode is not utilized.  Similar to\n  the Timsort algorithm, the RustSort algorithm employs the insertion sort\n  for small arrays and the adaptive mergesort for large arrays. References : [1] Rust's mergesort. private module subroutine Rust_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Rust_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Rust_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Rust_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Rust_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Rust_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Rust_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Rust_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Rust_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortHoare Subroutine Interface : QuickSortHoare Purpose :  To sort an array in a desired order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickSortHoare(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Hoare's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine QuickHoare_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickHoare_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickHoare_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickHoare_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickHoare_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickHoare_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickHoare_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickHoare_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickHoare_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortLomuto Subroutine Interface : QuickSortLomuto Purpose :  To sort an array in a desired order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickSortLomuto(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine QuickLomuto_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickLomuto_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortMo3 Subroutine Interface : QuickSortMo3 Purpose :  To sort an array in a desired order using the QuickSort algorithm with the median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortMo3(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with median-of-three partitioning scheme [1] is\n  employed for large (sub)array(s).  Unlike other QuickSort procedures,\n  the algorithm for QuickSortMo3 procedures uses a pure recursion instead\n  of a tail recursion since it appears experimentally that the pure recursion\n  provides a better performance for this particular implementation of the\n  median-of-three partitioning scheme. References : [1] Quicksort. private module subroutine QuickMo3_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickMo3_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickMo3_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickMo3_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickMo3_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickMo3_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickMo3_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickMo3_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickMo3_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSort3Way Subroutine Interface : QuickSort3Way Purpose :  To sort an array in a desired order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickSort3Way(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Bentley and McIlroy's three-way partitioning\n  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses\n  a tail recursion (instead of a pure recursion) to minimize the recursive\n  depth and make sure at most O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine Quick3Way_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Quick3Way_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Quick3Way_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Quick3Way_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Quick3Way_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Quick3Way_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Quick3Way_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Quick3Way_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Quick3Way_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortVowels Subroutine Interface : QuickSortVowels Purpose :  To sort an array in a desired order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version)\n      by R.A. Vowels [1]. Usage : --->    CALL QuickSortVowels(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm based on the QuickSort Version 3 (the professional\n  version) by R.A. Vowels [1] is employed for large (sub)array(s). References : [1] Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,\n      Unicomp. private module subroutine QuickVowels_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickVowels_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickVowels_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickVowels_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickVowels_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickVowels_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickVowels_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickVowels_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickVowels_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortStable Subroutine Interface : QuickSortStable Purpose :  To sort an array in a desired order using the QuickSort algorithm with a stable partitioning scheme. Usage : --->    CALL QuickSortStable(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with a stable partitioning scheme is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion\n  (instead of a pure recursion) to minimize the recursive depth and make\n  sure at most O(log(n)) space is used [1]. It is important to note that although the pair-insertion sort algorithm\n  should conceptually be a stable algorithm, its implementation in this\n  library seems to be unstable .  Therefore, for all hybrid stable algorithms, the insertion sort is used in place of the pair-insertion\n  sort although the pair-insertion sort typically provides better overall\n  performance. References : [1] How to Boost QuickSort Performance? private module subroutine QuickStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortIterative Subroutine Interface : QuickSortIterative Purpose :  To sort an array in a desired order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortIterative(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the iterative quicksort algorithm with median-of-three partitioning\n  scheme is employed for large (sub)array(s).  The implementation of the\n  iterative quicksort algorithm is based mainly on the Sort subroutine\n  of Numerical Recipes in Fortran 90 [1]. References : [1] Numerical\n      Recipes Books Online. private module subroutine QuickIterative_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickIterative_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickIterative_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickIterative_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickIterative_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickIterative_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickIterative_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickIterative_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickIterative_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortJava Subroutine Interface : QuickSortJava Purpose :  To sort an array in a desired order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm [1]. Usage : --->    CALL QuickSortJava(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the dual-pivot quicksort algorithm is employed for large (sub)array(s).\n  The implementation of the dual-pivot quicksort algorithm is based mainly\n  on Java's sorting algorithm [1]. References : [1] Java's DualPivotQuicksort class. private module subroutine QuickJava_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickJava_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickJava_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickJava_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickJava_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickJava_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickJava_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickJava_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickJava_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortTopDown Subroutine Interface : MergeSortTopDown Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeSortTopDown(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] is employed for large (sub)array(s).\n  The algorithm also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeTopDown_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeTopDown_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortBottomUp Subroutine Interface : MergeSortBottomUp Purpose :  To sort an array in a desired order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeSortBottomUp(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). References : [1] Merge sort. private module subroutine MergeBottomUp_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortRealQPSplit Subroutine Interface : MergeSortRealQPSplit Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeSortRealQPSplit(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] with quad split.  The algorithm\n  also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeQuadSplit_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortHalfCopy Subroutine Interface : MergeSortHalfCopy Purpose :  To sort an array in a desired order using a fast mergesort algorithm based on half-copying merge algorithm\n      by C. Juszczak [1]. Usage : --->    CALL MergeSortHalfCopy(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm with a half-copying merging [1]\n  is employed for large (sub)array(s).  The algorithm also considers\n  other improvements as suggested in [2]. References : [1] Juszczak, C. 2007.  Fast mergesort implementation based on half-copying\n      merge algorithm. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeHalfCopy_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface IsSortedDescend Function Interface : IsSortedDescend Purpose :  To check whether the specified array is sorted in\n      the desired order. Usage : --->    Flag = IsSortedDescend(A) --->    IF (.NOT.IsSortedDescend(A)) DoSomething private module function IsSortedDescend_Char(A) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I8(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I16(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I32(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_I64(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R32(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R64(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_R128(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: A (:) Return Value logical private module function IsSortedDescend_Comp(A) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: A (:) Return Value logical","tags":"","loc":"module\\mbase_sortdescend.html"},{"title":"MBase_Ranking – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains routines that can be used to rank an array in an ascending order.  The specified array can be of any type that is comparable.  For Fortran\n  intrinsic types, CHARACTER , INTEGER and REAL types are considered valid\n  comparable types.  For derived types, any types that extend from the Comparable type are valid comparable types. After the ranking, a user can use the returned indices to sort the array and its\n  associated variable(s) in a desired order.  The following code snippet illustrates\n  how to typically sort the array and its associated variable(s). ! sort AVal and BVal in an ascending order using AInd indices\n  XVal = AVal(AInd(:))\n  YVal = BVal(AInd(:))\n\n  ! sort AVal and BVal in a descending order using AInd indices\n  DO I = 1, ASize\n      XVal(I) = AVal(AInd(ASize-I+1))\n      YVal(I) = BVal(AInd(ASize-I+1))\n  END DO See the MBase_SortAscend and the MBase_SortDescend modules for\n  routines that perform sorting of an array in an ascending and descending order,\n  respectively.  The MBase_SortAscend module also gives an overview of available\n  sorting algorithms, which are mostly the same as the ranking algorithms available\n  in this module. Uses MBase_Common MClass_Comparable Interfaces public        interface WiseRank Subroutine Interface : WiseRank Purpose :  To rank an array in an ascending order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseRank(AVal, AInd) Technical Information : See the WiseSort interface\n  for the technical information of the WiseSort algorithm. private module subroutine Wise_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Wise_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface WiseRankStable Subroutine Interface : WiseRankStable Purpose :  To rank an array in an ascending order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseRankStable(AVal, AInd) Technical Information : See the WiseSortStable interface\n  for the technical information of the WiseSort-Stable algorithm. private module subroutine WiseStable_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine WiseStable_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface IntroRank Subroutine Interface : IntroRank Purpose :  To rank an array in an ascending order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroRank(AVal, AInd) Technical Information : See the IntroSort interface\n  for the technical information of the IntroSort algorithm. private module subroutine Intro_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Intro_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface JavaRank Subroutine Interface : JavaRank Purpose :  To rank an array in an ascending order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaRank(AVal, AInd) Technical Information : See the JavaSort interface\n  for the technical information of the JavaSort algorithm. private module subroutine Java_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Java_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface PDQRank Subroutine Interface : PDQRank Purpose :  To rank an array in an ascending order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQRank(AVal, AInd) Technical Information : See the PDQSort interface\n  for the technical information of the PDQSort algorithm. private module subroutine PDQ_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine PDQ_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface TimRank Subroutine Interface : TimRank Purpose :  To rank an array in an ascending order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimRank(AVal, AInd) Technical Information : See the TimSort interface\n  for the technical information of the TimSort algorithm. private module subroutine Tim_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) private module subroutine Tim_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout), TARGET :: AInd (SIZE(AVal)) public        interface RustRank Subroutine Interface : RustRank Purpose :  To rank an array in an ascending order using the RustSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL RustRank(AVal, AInd) Technical Information : See the RustSort interface\n  for the technical information of the RustSort algorithm. private module subroutine Rust_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Rust_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankHoare Subroutine Interface : QuickRankHoare Purpose :  To rank an array in an ascending order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickRankHoare(AVal, AInd) Technical Information : See the QuickSortHoare interface for the technical information of the QuickSort algorithm\n  with Hoare's partitioning scheme. private module subroutine QuickHoare_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickHoare_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankLomuto Subroutine Interface : QuickRankLomuto Purpose :  To rank an array in an ascending order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickRankLomuto(AVal, AInd) Technical Information : See the QuickSortLomuto interface for the technical information of the QuickSort algorithm\n  with Lomuto's partitioning scheme. private module subroutine QuickLomuto_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickLomuto_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankMo3 Subroutine Interface : QuickRankMo3 Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the median-of-three (Mo3)\n      partitioning scheme. Usage : --->    CALL QuickRankMo3(AVal, AInd) Technical Information : See the QuickSortMo3 interface for the technical information of the QuickSort algorithm\n  with the median-of-three partitioning scheme. private module subroutine QuickMo3_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickMo3_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRank3Way Subroutine Interface : QuickRank3Way Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickRank3Way(AVal, AInd) Technical Information : See the QuickSort3Way interface for the technical information of the QuickSort algorithm\n  with the three-way partitioning scheme. private module subroutine Quick3Way_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine Quick3Way_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankVowels Subroutine Interface : QuickRankVowels Purpose :  To rank an array in an ascending order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version) by R.A. Vowels. Usage : --->    CALL QuickRankVowels(AVal, AInd) Technical Information : See the QuickSortVowels interface for the technical information of the Vowels' QuickSort algorithm. private module subroutine QuickVowels_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickVowels_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankStable Subroutine Interface : QuickRankStable Purpose :  To rank an array in an ascending order using the QuickSort algorithm with the stable partitioning scheme. Usage : --->    CALL QuickRankStable(AVal, AInd) Technical Information : See the QuickSortStable interface for the technical information of the QuickSort algorithm\n  with the stable partitioning scheme. private module subroutine QuickStable_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickStable_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankIterative Subroutine Interface : QuickRankIterative Purpose :  To rank an array in an ascending order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickRankIterative(AVal, AInd) Technical Information : See the QuickSortIterative interface for the technical information of the iterative Quicksort algorithm with median-of-three partitioning scheme. private module subroutine QuickIterative_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickIterative_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface QuickRankJava Subroutine Interface : QuickRankJava Purpose :  To rank an array in an ascending order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm. Usage : --->    CALL QuickRankJava(AVal, AInd) Technical Information : See the QuickSortJava interface for the technical information of the Java's dual-pivot\n  QuickSort algorithm. private module subroutine QuickJava_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine QuickJava_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface MergeRankTopDown Subroutine Interface : MergeRankTopDown Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeRankTopDown(AVal, AInd) Technical Information : See the MergeSortTopDown interface for the technical information of the top-down merge sort algorithm. private module subroutine MergeTopDown_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeTopDown_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface MergeRankBottomUp Subroutine Interface : MergeRankBottomUp Purpose :  To rank an array in an ascending order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeRankBottomUp(AVal, AInd) Technical Information : See the MergeSortBottomUp interface for the technical information of the bottom-up merge sort algorithm. private module subroutine MergeBottomUp_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeBottomUp_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface MergeRankQuadSplit Subroutine Interface : MergeRankQuadSplit Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeRankQuadSplit(AVal, AInd) Technical Information : See the MergeSortRealQPSplit interface for the technical information of the top-down merge sort algorithm with quad split. private module subroutine MergeQuadSplit_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeQuadSplit_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface MergeRankHalfCopy Subroutine Interface : MergeRankHalfCopy Purpose :  To rank an array in an ascending order using a top-down\n      merge sort algorithm with half-copying merge algorithm. Usage : --->    CALL MergeRankHalfCopy(AVal, AInd) Technical Information : See the MergeSortHalfCopy interface for the technical information of the top-down merge sort algorithm with half-copying merge algorithm. private module subroutine MergeHalfCopy_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeHalfCopy_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface MergeRankOrderPack Subroutine Interface : MergeRankOrderPack Purpose :  To rank an array in an ascending order using a merge sort algorithm based on the ' MrgRnk ' routine in the OrderPack 2.0\n      library by Olagnon [1]. Usage : --->    CALL MergeRankOrderPack(AVal, AInd) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small arrays and the\n  Orderpack's merge sort algorithm [1] is employed for large arrays. References : [1] ORDERPACK 2.0: Unconditional,\n      Unique, and Partial Ranking, Sorting, and Permutation Downloadable Fortran90\n      source code. private module subroutine MergeOrderPack_RankChar(AVal, AInd) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI8(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI16(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI32(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankI64(AVal, AInd) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR32(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR64(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankR128(AVal, AInd) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) private module subroutine MergeOrderPack_RankComp(AVal, AInd) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(inout) :: AInd (SIZE(AVal)) public        interface IsRanked Function Interface : IsRanked Purpose :  To check whether the specified array is ranked in\n      the ascending order. Usage : --->    Flag = IsRanked(AVal, AInd) --->    IF (.NOT.IsRanked(AVal, AInd)) DoSomething private module function IsRanked_Char(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I8(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I16(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I32(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_I64(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R32(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R64(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_R128(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical private module function IsRanked_Comp(AVal, AInd) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: AVal (:) integer(kind=kInt32), intent(in) :: AInd (SIZE(AVal)) Return Value logical","tags":"","loc":"module\\mbase_ranking.html"},{"title":"MBase_SortAscend – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains routines that can be used to sort an array in an ascending order.  The specified array can be of any type that is comparable.  For Fortran\n  intrinsic types, CHARACTER , INTEGER and REAL types are considered valid\n  comparable types.  For derived types, any types that extend from the Comparable type are valid comparable types. Various sorting algorithms are available and are summarized as follows. 1. WiseSort and WiseSort-Stable algorithms are hybrid sorting algorithms that\n      employ multiple sorting algorithms.  As the names suggested, the WiseSort-Stable algorithm can be used for stable sorting whereas the WiseSort algorithm cannot.\n      Both algorithms are originated in this library (XpfLib) and they sort the given\n      array using a variety of sorting algorithms based on the pattern of the data.\n      First, they carefully and wisely inspect the specified array by checking if there\n      is any pattern in the given array.  Next, they decide which sorting algorithm is\n      most suitable for the array.  They then sort the array using the chosen algorithm.\n      For more information regarding the selection of a preferred algorithm and the various\n      algorithms employed by either the WiseSort or the WiseSort-Stable algorithm, see\n      the Technical Information section of each algorithm. 2. Hybrid sorting algorithms include the IntroSort , JavaSort , PDQSort , TimSort ,\n      and RustSort algorithms.  These hybrid algorithms commonly employ multiple algorithms\n      and can be classified into two groups: stable and unstable sorting algorithms.  The stable algorithms include the TimSort and RustSort algorithms whereas the other\n      three algorithms are unstable.  For more information, see the Technical Information section of each algorithm. 3. Quicksort-based sorting algorithms are actually hybrid algorithms that utilize a\n      quicksort algorithm as its main algorithm and employ an insertion sort algorithm\n      (mostly the pair-insertion sort) to deal with small (sub)array(s).  All of these\n      algorithms, with the exception of the QuickSortStable algorithm, are unstable.\n      For more information, see the Technical Information section of each algorithm. 4. Mergesort-based sorting algorithms are actually hybrid algorithms that employ a\n      mergesort algorithm as its main algorithm and use an insertion sort algorithm to\n      deal with small (sub)array(s).  All of these algorithms are considered stable.\n      For more information, see the Technical Information section of each algorithm. See the MBase_SortDescend module\n  for routines that perform sorting of an array in a descending order.  Also, see\n  the MBase_Ranking module for routines\n  that perform ranking of an array in an ascending order. Uses MBase_Common MClass_Comparable Interfaces public        interface WiseSort Subroutine Interface : WiseSort Purpose :  To sort an array in a desired order using the WiseSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSort(A) Technical Information : The WiseSort algorithm is a hybrid algorithm originated in this library\n  ( XpfLib ).  The algorithm sorts the given array using a variety of sorting\n  algorithms based on the pattern of the data.  First, it carefully and wisely\n  inspects the specified array by checking if there is any pattern in the given\n  array.  Next, it decides which sorting algorithm is most suitable for the array.\n  It then sorts the array using the chosen algorithm. The selection of a sorting algorithm is based on the following facts. - An Insertion sort algorithm usually performs well for an array with\n    small size. - If the data is already sorted, no sorting algorithm is needed. - If the data is already sorted but in an order opposite to the desired one,\n    a reversion of the array is the most optimal sorting algorithm. - A quicksort algorithm typically performs well for a totally randomized array. - A mergesort algorithm generally performs well for a mostly ordered array. Based on the aforementioned facts, the WiseSort algorithm utilizes various\n  sorting algorithms including: 1. Pair-insertion-sort-based algorithms consisting of - guarded version for a left-most sub-array or the whole array with small size, - unguarded version for a non-left-most sub-array with small size. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered\n      array (i.e. an array having a very long ordered run, either in ascending or\n      descending order). For this particular implementation, it is found that Rust's mergesort performs\n      very well for an array when more than 50% of the first or last elements of the\n      array are already sorted. 3. Quick-sort-based algorithms where various partitioning schemes are employed\n      including: - Hoare's partitioning scheme for a NOT highly structured array, i.e. a\n      partly-ordered and partly-randomized array (an array having not very long\n      and not very short ordered runs), - Median-of-three partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements), - Ninther (median of medians or pseudo-median of nine) partitioning scheme for\n      worst-case situations (when the quicksort algorithm converges too slowly, it\n      switches from Hoare's or median-of-three partitioning scheme to the ninther\n      partitioning scheme), - Three-way (or Dutch's national flag) partitioning scheme for an array with\n      many equal elements (when the quick sort algorithm detects that many elements\n      are equal, it switches from Hoare's or median-of-three partitioning scheme to\n      the three-way partitioning scheme). As previously mentioned, the selection of an appropriate algorithm is based on\n  a careful and wise inspection of the given array.  The routine responsible for\n  this task will try to predict a suitable algorithm for any given array according\n  to its pattern found.  The following list provides an overview of the routine. - The routine will mostly try to scan just a very few runs and quit very quickly.\n      Only, the highly structured array (the one sorted by Java's merge runs) is\n      entirely scanned since all the runs are needed by the selected algorithm. - If the routine detects that the current run is in an order opposite to the\n      desired one, it will only reverse the run if necessary (i.e. the chosen\n      algorithm will benefit from the reversion of the run). - The prediction of a proper algorithm is quite accurate for most known cases.\n      However, there are certain known cases that the routine may not choose\n      the BEST algorithm.  For example, if highly-order parts of the given array\n      are in the middle while randomized parts are in the beginning and in the end,\n      the routine will typically select a quick sort algorithm.  However, if the\n      highly-ordered parts are long enough (e.g. more than 50% of the array size),\n      Rust/TimSort algorithms might be better algorithms.  For these certain cases,\n      nonetheless, it is not worth scanning the whole array just so we can choose\n      the BEST algorithm because the overhead will surely be very expensive. private module subroutine Wise_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Wise_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Wise_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Wise_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Wise_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Wise_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Wise_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Wise_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Wise_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface WiseSortStable Subroutine Interface : WiseSortStable Purpose :  To sort an array in a desired order using the WiseSort-Stable algorithm, which is a hybrid stable algorithm that employs various\n      sorting algorithms including the insertion sort , mergesort and quicksort algorithms. Usage : --->    CALL WiseSortStable(A) Technical Information : Similar to the WiseSort algorithm, the WiseSort-Stable algorithm is\n  a hybrid algorithm originated in this library( XpfLib ).  Unlike the WiseSort algorithm, which is an unstable algorithm, the WiseSort-Stable algorithm (as the name implied) is a stable algorithm that sorts the given\n  array using a variety of stable sorting algorithms.  Similar to the WiseSort algorithm, the WiseSort-Stable algorithm first inspects the specified\n  array by checking if there is any pattern in the given array and then decides\n  which stable sorting algorithm is most suitable for the array.  It then sorts\n  the array using the chosen algorithm. The selection of a stable sorting algorithm is based on the same facts given\n  in the WiseSort section; hence, the WiseSort-Stable algorithm employs\n  various stable sorting algorithms including: 1. Insertion sort algorithm (guarded version only) for a small-size (sub)array. 2. Merge-sort-based algorithms consisting of - Java's merging runs for a highly structured array (an array with a certain\n      recognized pattern, e.g. saw- or wave-like pattern), - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered\n      array (an array having a very long ordered run, either in ascending or\n      descending order), - Merge sort with half-copying for a small-size array or a partially randomized\n      array (an array with one not-too-short and not-too-long run and many very-very\n      short runs). 3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array\n      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than\n      4 elements). 4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array\n      with many not-too-short and not-too-long runs). Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm\n      that switches to the mergesort with half-copying algorithm for the smaller\n      sub-array after the stable partitioning process while it recurs on the larger\n      sub-array. private module subroutine WiseStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine WiseStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine WiseStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine WiseStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine WiseStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine WiseStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine WiseStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine WiseStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine WiseStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface IntroSort Subroutine Interface : IntroSort Purpose :  To sort an array in a desired order using the IntroSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the pair-insertion sort , quicksort and heapsort algorithms. Usage : --->    CALL IntroSort(A) Technical Information : The IntroSort algorithm is a hybrid algorithm developed by David Musser [1].\n  The algorithm starts sorting the given array using the quicksort algorithm\n  with the median-of-three partitioning scheme.  It then switches to the heapsort\n  algorithm when the recursion depth exceeds its limit (which is dependent on the\n  array size).  It also switches to the pair-insertion sort algorithm if the\n  (sub)array size falls below a certain threshold (called insertion cutoff). References : [1] Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.\n      Software: Practice and Experience. 27(8):983-993. private module subroutine Intro_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Intro_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Intro_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Intro_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Intro_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Intro_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Intro_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Intro_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Intro_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface JavaSort Subroutine Interface : JavaSort Purpose :  To sort an array in a desired order using the JavaSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the mixed-insertion sort , quicksort , heapsort , and merging algorithms. Usage : --->    CALL JavaSort(A) Technical Information : The JavaSort algorithm is a hybrid algorithm based on Java's sorting\n  algorithm [1].  The algorithm employs the dual-pivot quicksort as the\n  main algorithm.  The algorithm is a variant of the IntroSort algorithm\n  where the heapsort algorithm is used when the recursion depth exceeds its\n  limit and the mixed insertion sort algorithm is utilized when the number\n  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,\n  the JavaSort algorithm (with a routine that inspects the pattern of the\n  specified array) employs a variant of the mergesort algorithm (a merging of\n  runs) if the given array is found to be highly structured. References : [1] Java's DualPivotQuicksort class. private module subroutine Java_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Java_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Java_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Java_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Java_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Java_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Java_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Java_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Java_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface PDQSort Subroutine Interface : PDQSort Purpose :  To sort an array in a desired order using the PDQSort algorithm, which is a hybrid (unstable) algorithm that employs\n      various sorting algorithms including the insertion sort , quicksort , and heapsort algorithms. Usage : --->    CALL PDQSort(A) Technical Information : The PDQSort (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm\n  developed by Orson Peters [1].  The algorithm is a variant of the IntroSort algorithm with various improvements including median-of-three pivoting scheme, BlockQuickSort partitioning scheme to lesson the branch mis-prediction penalties,\n  an adaptive sort to deals with an array with certain patterns, and a shuffling\n  of array elements to help the heapsort works better. References : [1] Peters, O.R.L. 2021.\n      Pattern-defeating Quicksort. private module subroutine PDQ_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine PDQ_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine PDQ_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine PDQ_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine PDQ_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine PDQ_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine PDQ_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine PDQ_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine PDQ_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface TimSort Subroutine Interface : TimSort Purpose :  To sort an array in a desired order using the TimSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL TimSort(A) Technical Information : The TimSort algorithm is a hybrid stable algorithm developed by Tim\n  Peters [1].  The algorithm is an adaptive, natural mergesort that works\n  well for many kinds of partially ordered arrays.  As implemented here,\n  the Timsort algorithm employs the insertion sort for small arrays and\n  the adaptive mergesort for large arrays. References : [1] Timsort by\n      Tim Peters. private module subroutine Tim_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout), TARGET :: A (:) private module subroutine Tim_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout), TARGET :: A (:) private module subroutine Tim_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout), TARGET :: A (:) private module subroutine Tim_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout), TARGET :: A (:) public        interface RustSort Subroutine Interface : RustSort Purpose :  To sort an array in a desired order using the RustSort algorithm, which is a hybrid stable algorithm that employs an insertion sort and an adaptive mergesort algorithms. Usage : --->    CALL RustSort(A) Technical Information : The RustSort algorithm is a hybrid stable algorithm based on the Rust's\n  mergesort algorithm [1].  The algorithm can be considered as a simplified TimSort algorithm where the galloping mode is not utilized.  Similar to\n  the Timsort algorithm, the RustSort algorithm employs the insertion sort\n  for small arrays and the adaptive mergesort for large arrays. References : [1] Rust's mergesort. private module subroutine Rust_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Rust_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Rust_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Rust_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Rust_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Rust_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Rust_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Rust_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Rust_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortHoare Subroutine Interface : QuickSortHoare Purpose :  To sort an array in a desired order using the QuickSort algorithm with Hoare's partitioning scheme. Usage : --->    CALL QuickSortHoare(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Hoare's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine QuickHoare_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickHoare_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickHoare_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickHoare_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickHoare_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickHoare_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickHoare_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickHoare_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickHoare_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortLomuto Subroutine Interface : QuickSortLomuto Purpose :  To sort an array in a desired order using the QuickSort algorithm with Lomuto's partitioning scheme. Usage : --->    CALL QuickSortLomuto(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead\n  of a pure recursion) to minimize the recursive depth and make sure at most\n  O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine QuickLomuto_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickLomuto_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickLomuto_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickLomuto_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortMo3 Subroutine Interface : QuickSortMo3 Purpose :  To sort an array in a desired order using the QuickSort algorithm with the median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortMo3(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with median-of-three partitioning scheme [1] is\n  employed for large (sub)array(s).  Unlike other QuickSort procedures,\n  the algorithm for QuickSortMo3 procedures uses a pure recursion instead\n  of a tail recursion since it appears experimentally that the pure recursion\n  provides a better performance for this particular implementation of the\n  median-of-three partitioning scheme. References : [1] Quicksort. private module subroutine QuickMo3_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickMo3_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickMo3_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickMo3_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickMo3_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickMo3_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickMo3_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickMo3_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickMo3_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSort3Way Subroutine Interface : QuickSort3Way Purpose :  To sort an array in a desired order using the QuickSort algorithm with the three-way partitioning scheme. Usage : --->    CALL QuickSort3Way(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with Bentley and McIlroy's three-way partitioning\n  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses\n  a tail recursion (instead of a pure recursion) to minimize the recursive\n  depth and make sure at most O(log(n)) space is used [2]. References : [1] Quicksort. [2] How to Boost QuickSort Performance? private module subroutine Quick3Way_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine Quick3Way_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine Quick3Way_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine Quick3Way_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine Quick3Way_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine Quick3Way_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine Quick3Way_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine Quick3Way_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine Quick3Way_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortVowels Subroutine Interface : QuickSortVowels Purpose :  To sort an array in a desired order using the QuickSort algorithm based on the QuickSort Version 3 (the professional version)\n      by R.A. Vowels [1]. Usage : --->    CALL QuickSortVowels(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm based on the QuickSort Version 3 (the professional\n  version) by R.A. Vowels [1] is employed for large (sub)array(s). References : [1] Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,\n      Unicomp. private module subroutine QuickVowels_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickVowels_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickVowels_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickVowels_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickVowels_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickVowels_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickVowels_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickVowels_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickVowels_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortStable Subroutine Interface : QuickSortStable Purpose :  To sort an array in a desired order using the QuickSort algorithm with a stable partitioning scheme. Usage : --->    CALL QuickSortStable(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the quicksort algorithm with a stable partitioning scheme is employed\n  for large (sub)array(s).  Also, the algorithm uses a tail recursion\n  (instead of a pure recursion) to minimize the recursive depth and make\n  sure at most O(log(n)) space is used [1]. It is important to note that although the pair-insertion sort algorithm\n  should conceptually be a stable algorithm, its implementation in this\n  library seems to be unstable .  Therefore, for all hybrid stable algorithms, the insertion sort is used in place of the pair-insertion\n  sort although the pair-insertion sort typically provides better overall\n  performance. References : [1] How to Boost QuickSort Performance? private module subroutine QuickStable_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickStable_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickStable_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickStable_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickStable_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickStable_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickStable_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickStable_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickStable_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortIterative Subroutine Interface : QuickSortIterative Purpose :  To sort an array in a desired order using an iterative\n      Quicksort algorithm with median-of-three (Mo3) partitioning scheme. Usage : --->    CALL QuickSortIterative(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the iterative quicksort algorithm with median-of-three partitioning\n  scheme is employed for large (sub)array(s).  The implementation of the\n  iterative quicksort algorithm is based mainly on the Sort subroutine\n  of Numerical Recipes in Fortran 90 [1]. References : [1] Numerical\n      Recipes Books Online. private module subroutine QuickIterative_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickIterative_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickIterative_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickIterative_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickIterative_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickIterative_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickIterative_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickIterative_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickIterative_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface QuickSortJava Subroutine Interface : QuickSortJava Purpose :  To sort an array in a desired order using a dual-pivot\n      Quicksort algorithm based on Java's sorting algorithm [1]. Usage : --->    CALL QuickSortJava(A) Technical Information : The algorithm used here is actually a hybrid (unstable) algorithm where\n  the pair-insertion sort algorithm is utilized for small (sub)array(s) and\n  the dual-pivot quicksort algorithm is employed for large (sub)array(s).\n  The implementation of the dual-pivot quicksort algorithm is based mainly\n  on Java's sorting algorithm [1]. References : [1] Java's DualPivotQuicksort class. private module subroutine QuickJava_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine QuickJava_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine QuickJava_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine QuickJava_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine QuickJava_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine QuickJava_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine QuickJava_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine QuickJava_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine QuickJava_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortTopDown Subroutine Interface : MergeSortTopDown Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm. Usage : --->    CALL MergeSortTopDown(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] is employed for large (sub)array(s).\n  The algorithm also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeTopDown_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeTopDown_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeTopDown_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeTopDown_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortBottomUp Subroutine Interface : MergeSortBottomUp Purpose :  To sort an array in a desired order using a bottom-up\n      merge sort algorithm. Usage : --->    CALL MergeSortBottomUp(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). References : [1] Merge sort. private module subroutine MergeBottomUp_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeBottomUp_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortRealQPSplit Subroutine Interface : MergeSortRealQPSplit Purpose :  To sort an array in a desired order using a top-down\n      merge sort algorithm where the given array is split into four\n      sub-arrays instead of two sub-arrays. Usage : --->    CALL MergeSortRealQPSplit(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm [1] with quad split.  The algorithm\n  also considers other improvements as suggested in [2]. References : [1] Merge sort. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeQuadSplit_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeQuadSplit_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface MergeSortHalfCopy Subroutine Interface : MergeSortHalfCopy Purpose :  To sort an array in a desired order using a fast mergesort algorithm based on half-copying merge algorithm\n      by C. Juszczak [1]. Usage : --->    CALL MergeSortHalfCopy(A) Technical Information : The algorithm used here is actually a hybrid stable algorithm where\n  the insertion sort algorithm is utilized for small (sub)array(s) and\n  the top-down merge sort algorithm with a half-copying merging [1]\n  is employed for large (sub)array(s).  The algorithm also considers\n  other improvements as suggested in [2]. References : [1] Juszczak, C. 2007.  Fast mergesort implementation based on half-copying\n      merge algorithm. [2] Section 2.2 Merge sort\n      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. private module subroutine MergeHalfCopy_SortChar(A) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI8(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI16(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI32(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortI64(A) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR32(A) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR64(A) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortR128(A) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(inout) :: A (:) private module subroutine MergeHalfCopy_SortComp(A) Arguments Type Intent Optional Attributes Name class(Comparable), intent(inout) :: A (:) public        interface IsSortedAscend Function Interface : IsSortedAscend Purpose :  To check whether the specified array is sorted in\n      the desired order. Usage : --->    Flag = IsSortedAscend(A) --->    IF (.NOT.IsSortedAscend(A)) DoSomething private module function IsSortedAscend_Char(A) result(Flag) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I8(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt8), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I16(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt16), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I32(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_I64(A) result(Flag) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R32(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R64(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_R128(A) result(Flag) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: A (:) Return Value logical private module function IsSortedAscend_Comp(A) result(Flag) Arguments Type Intent Optional Attributes Name class(Comparable), intent(in) :: A (:) Return Value logical","tags":"","loc":"module\\mbase_sortascend.html"},{"title":"MBase_SortDescend.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_SortDescend !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains routines that can be used to sort an array in a *descending* !   order.  The specified array can be of any type that is comparable.  For *Fortran !   intrinsic* types, *CHARACTER*, *INTEGER* and *REAL* types are considered valid !   comparable types.  For derived types, any types that extend from the *Comparable* !   type are valid comparable types. <br> !   See the <a href=\"../module/mbase_sortascend.html\">MBase_SortAscend</a> module !   for routines that perform sorting of an array in an *ascending* order.  Also, the !   *MBase_SortAscend* module gives an overview of available sorting algorithms, which !   are the same as the algorithms available in this module.  For ranking an array in !   an *ascending* order, see the <a href=\"../module/mbase_ranking.html\">MBase_Ranking</a> !   module. <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Comparable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! hybrid PUBLIC :: WiseSort PUBLIC :: WiseSortStable PUBLIC :: IntroSort PUBLIC :: JavaSort PUBLIC :: PDQSort PUBLIC :: TimSort PUBLIC :: RustSort ! quick PUBLIC :: QuickSortHoare PUBLIC :: QuickSortLomuto PUBLIC :: QuickSortMo3 PUBLIC :: QuickSort3Way PUBLIC :: QuickSortVowels PUBLIC :: QuickSortStable PUBLIC :: QuickSortIterative PUBLIC :: QuickSortJava ! merge PUBLIC :: MergeSortTopDown PUBLIC :: MergeSortBottomUp PUBLIC :: MergeSortRealQPSplit PUBLIC :: MergeSortHalfCopy ! auxiliary PUBLIC :: IsSortedDescend PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharParam :: ModName = 'MBase_SortDescend' !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ! hybrid INTERFACE WiseSort !&#94; **Subroutine Interface**: WiseSort <br> !  **Purpose**:  To sort an array in a desired order using the *WiseSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *mergesort* and *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseSort(A) <br> !  **Technical Information**: <br> !   The *WiseSort* algorithm is a hybrid algorithm originated in this library !   (*XpfLib*).  The algorithm sorts the given array using a variety of sorting !   algorithms based on the pattern of the data.  First, it carefully and wisely !   inspects the specified array by checking if there is any pattern in the given !   array.  Next, it decides which sorting algorithm is most suitable for the array. !   It then sorts the array using the chosen algorithm. <br> !   The selection of a sorting algorithm is based on the following facts. <br> !   - An *Insertion sort* algorithm usually performs well for an array with !     small size. <br> !   - If the data is already sorted, no sorting algorithm is needed. <br> !   - If the data is already sorted but in an order opposite to the desired one, !     a reversion of the array is the most optimal sorting algorithm. <br> !   - A quicksort algorithm typically performs well for a totally randomized array. <br> !   - A mergesort algorithm generally performs well for a mostly ordered array. <br> !   Based on the aforementioned facts, the *WiseSort* algorithm utilizes various !   sorting algorithms including: <br> !   1. *Pair-insertion-sort-based* algorithms consisting of <br> !     - guarded version for a left-most sub-array or the whole array with small size, <br> !     - unguarded version for a non-left-most sub-array with small size. <br> !   2. *Merge-sort-based* algorithms consisting of <br> !     - Java's merging runs for a highly structured array (an array with a certain !       recognized pattern, e.g. saw- or wave-like pattern), <br> !     - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered !       array (i.e. an array having a very long ordered run, either in ascending or !       descending order). <br> !       For this particular implementation, it is found that Rust's mergesort performs !       very well for an array when more than 50% of the first or last elements of the !       array are already sorted. <br> !   3. *Quick-sort-based* algorithms where various partitioning schemes are employed !       including: <br> !     - Hoare's partitioning scheme for a NOT highly structured array, i.e. a !       partly-ordered and partly-randomized array (an array having not very long !       and not very short ordered runs), <br> !     - Median-of-three partitioning scheme for a totally-randomized array !       (an array having VERY SHORT ordered runs, e.g. an ordered run with less than !       4 elements), <br> !     - Ninther (median of medians or pseudo-median of nine) partitioning scheme for !       worst-case situations (when the quicksort algorithm converges too slowly, it !       switches from Hoare's or median-of-three partitioning scheme to the ninther !       partitioning scheme), <br> !     - Three-way (or Dutch's national flag) partitioning scheme for an array with !       many equal elements (when the quick sort algorithm detects that many elements !       are equal, it switches from Hoare's or median-of-three partitioning scheme to !       the three-way partitioning scheme). <br> !   As previously mentioned, the selection of an appropriate algorithm is based on !   a careful and wise inspection of the given array.  The routine responsible for !   this task will try to predict a suitable algorithm for any given array according !   to its pattern found.  The following list provides an overview of the routine. <br> !     - The routine will mostly try to scan just a very few runs and quit very quickly. !       Only, the highly structured array (the one sorted by Java's merge runs) is !       entirely scanned since all the runs are needed by the selected algorithm. <br> !     - If the routine detects that the current run is in an order opposite to the !       desired one, it will only reverse the run if necessary (i.e. the chosen !       algorithm will benefit from the reversion of the run). <br> !     - The prediction of a proper algorithm is quite accurate for most known cases. !       However, there are certain known cases that the routine may not choose !       the *BEST* algorithm.  For example, if highly-order parts of the given array !       are in the middle while randomized parts are in the beginning and in the end, !       the routine will typically select a quick sort algorithm.  However, if the !       highly-ordered parts are long enough (e.g. more than 50% of the array size), !       Rust/TimSort algorithms might be better algorithms.  For these certain cases, !       nonetheless, it is not worth scanning the whole array just so we can choose !       the *BEST* algorithm because the overhead will surely be very expensive. <br> MODULE SUBROUTINE Wise_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE WiseSortStable !&#94; **Subroutine Interface**: WiseSortStable <br> !  **Purpose**:  To sort an array in a desired order using the *WiseSort-Stable* !       algorithm, which is a hybrid *stable* algorithm that employs various !       sorting algorithms including the *insertion sort*, *mergesort* and !       *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseSortStable(A) <br> !  **Technical Information**: <br> !   Similar to the *WiseSort* algorithm, the *WiseSort-Stable* algorithm is !   a hybrid algorithm originated in this library(*XpfLib*).  Unlike the !   *WiseSort* algorithm, which is an unstable algorithm, the *WiseSort-Stable* !   algorithm (as the name implied) is a stable algorithm that sorts the given !   array using a variety of *stable* sorting algorithms.  Similar to the *WiseSort* !   algorithm, the *WiseSort-Stable* algorithm first inspects the specified !   array by checking if there is any pattern in the given array and then decides !   which stable sorting algorithm is most suitable for the array.  It then sorts !   the array using the chosen algorithm. <br> !   The selection of a stable sorting algorithm is based on the same facts given !   in the *WiseSort* section; hence, the *WiseSort-Stable* algorithm employs !   various stable sorting algorithms including: <br> !   1. *Insertion sort* algorithm (guarded version only) for a small-size (sub)array. <br> !   2. *Merge-sort-based* algorithms consisting of <br> !     - Java's merging runs for a highly structured array (an array with a certain !       recognized pattern, e.g. saw- or wave-like pattern), <br> !     - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered !       array (an array having a very long ordered run, either in ascending or !       descending order), <br> !     - Merge sort with half-copying for a small-size array or a partially randomized !       array (an array with one not-too-short and not-too-long run and many very-very !       short runs). <br> !   3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array !       (an array having VERY SHORT ordered runs, e.g. an ordered run with less than !       4 elements). <br> !   4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array !       with many not-too-short and not-too-long runs). <br> !   Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm !       that switches to the mergesort with half-copying algorithm for the smaller !       sub-array after the stable partitioning process while it recurs on the larger !       sub-array. <br> MODULE SUBROUTINE WiseStable_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE IntroSort !&#94; **Subroutine Interface**: IntroSort <br> !  **Purpose**:  To sort an array in a desired order using the *IntroSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *quicksort* and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL IntroSort(A) <br> !  **Technical Information**: <br> !   The *IntroSort* algorithm is a hybrid algorithm developed by David Musser [1]. !   The algorithm starts sorting the given array using the quicksort algorithm !   with the median-of-three partitioning scheme.  It then switches to the heapsort !   algorithm when the recursion depth exceeds its limit (which is dependent on the !   array size).  It also switches to the pair-insertion sort algorithm if the !   (sub)array size falls below a certain threshold (called insertion cutoff). <br> !  **References**: <br> !   [1] <a href=\"https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps\"> !       Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms. !       Software: Practice and Experience. 27(8):983-993. </a> <br> MODULE SUBROUTINE Intro_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE JavaSort !&#94; **Subroutine Interface**: JavaSort <br> !  **Purpose**:  To sort an array in a desired order using the *JavaSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *mixed-insertion sort*, !       *quicksort*, *heapsort*, and *merging* algorithms. <br> !  **Usage**: <br> !   --->    CALL JavaSort(A) <br> !  **Technical Information**: <br> !   The *JavaSort* algorithm is a hybrid algorithm based on Java's sorting !   algorithm [1].  The algorithm employs the dual-pivot quicksort as the !   main algorithm.  The algorithm is a variant of the *IntroSort* algorithm !   where the heapsort algorithm is used when the recursion depth exceeds its !   limit and the mixed insertion sort algorithm is utilized when the number !   of elements of the (sub)array(s) is below the insertion cutoff.  In addition, !   the *JavaSort* algorithm (with a routine that inspects the pattern of the !   specified array) employs a variant of the mergesort algorithm (a merging of !   runs) if the given array is found to be highly structured. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java\"> !       Java's DualPivotQuicksort class. </a> <br> MODULE SUBROUTINE Java_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE PDQSort !&#94; **Subroutine Interface**: PDQSort <br> !  **Purpose**:  To sort an array in a desired order using the *PDQSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *insertion sort*, !       *quicksort*, and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL PDQSort(A) <br> !  **Technical Information**: <br> !   The *PDQSort* (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm !   developed by Orson Peters [1].  The algorithm is a variant of the *IntroSort* !   algorithm with various improvements including median-of-three pivoting scheme, !   *BlockQuickSort* partitioning scheme to lesson the branch mis-prediction penalties, !   an adaptive sort to deals with an array with certain patterns, and a shuffling !   of array elements to help the heapsort works better. <br> !  **References**: <br> !   [1] <a href=\"https://arxiv.org/abs/2106.05123\">Peters, O.R.L. 2021. !       Pattern-defeating Quicksort. </a> <br> MODULE SUBROUTINE PDQ_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE TimSort !&#94; **Subroutine Interface**: TimSort <br> !  **Purpose**:  To sort an array in a desired order using the *TimSort* !       algorithm, which is a hybrid *stable* algorithm that employs an !       *insertion sort* and an *adaptive mergesort* algorithms. <br> !  **Usage**: <br> !   --->    CALL TimSort(A) <br> !  **Technical Information**: <br> !   The *TimSort* algorithm is a hybrid stable algorithm developed by Tim !   Peters [1].  The algorithm is an adaptive, natural mergesort that works !   well for many kinds of partially ordered arrays.  As implemented here, !   the *Timsort* algorithm employs the insertion sort for small arrays and !   the adaptive mergesort for large arrays. <br> !  **References**: <br> !   [1] <a href=\"https://bugs.python.org/file4451/timsort.txt\">Timsort by !       Tim Peters. </a> <br> MODULE SUBROUTINE Tim_SortChar ( A ) tCharStar , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI8 ( A ) tSInt8 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI16 ( A ) tSInt16 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI32 ( A ) tSInt32 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI64 ( A ) tSInt64 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR32 ( A ) tRealSP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR64 ( A ) tRealDP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR128 ( A ) tRealQP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE END INTERFACE INTERFACE RustSort !&#94; **Subroutine Interface**: RustSort <br> !  **Purpose**:  To sort an array in a desired order using the *RustSort* !       algorithm, which is a hybrid *stable* algorithm that employs an !       *insertion sort* and an *adaptive mergesort* algorithms. <br> !  **Usage**: <br> !   --->    CALL RustSort(A) <br> !  **Technical Information**: <br> !   The *RustSort* algorithm is a hybrid stable algorithm based on the Rust's !   mergesort algorithm [1].  The algorithm can be considered as a simplified !   *TimSort* algorithm where the galloping mode is not utilized.  Similar to !   the *Timsort* algorithm, the *RustSort* algorithm employs the insertion sort !   for small arrays and the adaptive mergesort for large arrays. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\"> !       Rust's mergesort. </a> <br> MODULE SUBROUTINE Rust_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! quick INTERFACE QuickSortHoare !&#94; **Subroutine Interface**: QuickSortHoare <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with Hoare's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortHoare(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Hoare's partitioning scheme [1] is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead !   of a pure recursion) to minimize the recursive depth and make sure at most !   O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickHoare_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortLomuto !&#94; **Subroutine Interface**: QuickSortLomuto <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with Lomuto's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortLomuto(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Lomuto's partitioning scheme [1] is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead !   of a pure recursion) to minimize the recursive depth and make sure at most !   O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickLomuto_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortMo3 !&#94; **Subroutine Interface**: QuickSortMo3 <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with the median-of-three (Mo3) partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortMo3(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with median-of-three partitioning scheme [1] is !   employed for large (sub)array(s).  Unlike other *QuickSort* procedures, !   the algorithm for *QuickSortMo3* procedures uses a pure recursion instead !   of a tail recursion since it appears experimentally that the pure recursion !   provides a better performance for this particular implementation of the !   median-of-three partitioning scheme. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> MODULE SUBROUTINE QuickMo3_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSort3Way !&#94; **Subroutine Interface**: QuickSort3Way <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with the three-way partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSort3Way(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Bentley and McIlroy's three-way partitioning !   scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses !   a tail recursion (instead of a pure recursion) to minimize the recursive !   depth and make sure at most O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE Quick3Way_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortVowels !&#94; **Subroutine Interface**: QuickSortVowels <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm based on the *QuickSort Version 3* (the professional version) !       by R.A. Vowels [1]. <br> !  **Usage**: <br> !   --->    CALL QuickSortVowels(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm based on the *QuickSort Version 3* (the professional !   version) by R.A. Vowels [1] is employed for large (sub)array(s). <br> !  **References**: <br> !   [1] <a href=\"http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html\"> !       Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran, !       Unicomp. </a> <br> MODULE SUBROUTINE QuickVowels_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortStable !&#94; **Subroutine Interface**: QuickSortStable <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with a stable partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortStable(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid *stable* algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with a stable partitioning scheme is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion !   (instead of a pure recursion) to minimize the recursive depth and make !   sure at most O(log(n)) space is used [1]. <br> !   It is important to note that although the pair-insertion sort algorithm !   should conceptually be a stable algorithm, its implementation in this !   library seems to be *unstable*.  Therefore, for all *hybrid stable* !   algorithms, the insertion sort is used in place of the pair-insertion !   sort although the pair-insertion sort typically provides better overall !   performance. <br> !  **References**: <br> !   [1] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickStable_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortIterative !&#94; **Subroutine Interface**: QuickSortIterative <br> !  **Purpose**:  To sort an array in a desired order using an *iterative !       Quicksort* algorithm with median-of-three (Mo3) partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortIterative(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the *iterative* quicksort algorithm with median-of-three partitioning !   scheme is employed for large (sub)array(s).  The implementation of the !   iterative quicksort algorithm is based mainly on the *Sort* subroutine !   of Numerical Recipes in Fortran 90 [1]. <br> !  **References**: <br> !   [1] <a href=\"http://numerical.recipes/oldverswitcher.html\">Numerical !       Recipes Books Online. </a> <br> MODULE SUBROUTINE QuickIterative_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortJava !&#94; **Subroutine Interface**: QuickSortJava <br> !  **Purpose**:  To sort an array in a desired order using a *dual-pivot !       Quicksort* algorithm based on Java's sorting algorithm [1]. <br> !  **Usage**: <br> !   --->    CALL QuickSortJava(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the *dual-pivot* quicksort algorithm is employed for large (sub)array(s). !   The implementation of the dual-pivot quicksort algorithm is based mainly !   on Java's sorting algorithm [1]. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java\"> !       Java's DualPivotQuicksort class. </a> <br> MODULE SUBROUTINE QuickJava_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! merge INTERFACE MergeSortTopDown !&#94; **Subroutine Interface**: MergeSortTopDown <br> !  **Purpose**:  To sort an array in a desired order using a *top-down !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeSortTopDown(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm [1] is employed for large (sub)array(s). !   The algorithm also considers other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeTopDown_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortBottomUp !&#94; **Subroutine Interface**: MergeSortBottomUp <br> !  **Purpose**:  To sort an array in a desired order using a *bottom-up !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeSortBottomUp(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> MODULE SUBROUTINE MergeBottomUp_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortRealQPSplit !&#94; **Subroutine Interface**: MergeSortRealQPSplit <br> !  **Purpose**:  To sort an array in a desired order using a *top-down !       merge sort* algorithm where the given array is split into four !       sub-arrays instead of two sub-arrays. <br> !  **Usage**: <br> !   --->    CALL MergeSortRealQPSplit(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm [1] with quad split.  The algorithm !   also considers other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeQuadSplit_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortHalfCopy !&#94; **Subroutine Interface**: MergeSortHalfCopy <br> !  **Purpose**:  To sort an array in a desired order using a fast !       *mergesort* algorithm based on *half-copying merge* algorithm !       by C. Juszczak [1]. <br> !  **Usage**: <br> !   --->    CALL MergeSortHalfCopy(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm with a *half-copying* merging [1] !   is employed for large (sub)array(s).  The algorithm also considers !   other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf\"> !       Juszczak, C. 2007.  Fast mergesort implementation based on half-copying !       merge algorithm. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeHalfCopy_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! auxiliary INTERFACE IsSortedDescend !&#94; **Function Interface**: IsSortedDescend <br> !  **Purpose**:  To check whether the specified array is sorted in !       the desired order. <br> !  **Usage**: <br> !   --->    Flag = IsSortedDescend(A) <br> !   --->    IF (.NOT.IsSortedDescend(A)) DoSomething <br> MODULE FUNCTION IsSortedDescend_Char ( A ) RESULT ( Flag ) tCharStar , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_I8 ( A ) RESULT ( Flag ) tSInt8 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_I16 ( A ) RESULT ( Flag ) tSInt16 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_I32 ( A ) RESULT ( Flag ) tSInt32 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_I64 ( A ) RESULT ( Flag ) tSInt64 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_R32 ( A ) RESULT ( Flag ) tRealSP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_R64 ( A ) RESULT ( Flag ) tRealDP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_R128 ( A ) RESULT ( Flag ) tRealQP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedDescend_Comp ( A ) RESULT ( Flag ) CLASS ( Comparable ), INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na END MODULE MBase_SortDescend !******************************************************************************","tags":"","loc":"sourcefile\\mbase_sortdescend.f90.html"},{"title":"MBase_Ranking.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_Ranking !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains routines that can be used to rank an array in an *ascending* !   order.  The specified array can be of any type that is comparable.  For *Fortran !   intrinsic* types, *CHARACTER*, *INTEGER* and *REAL* types are considered valid !   comparable types.  For derived types, any types that extend from the *Comparable* !   type are valid comparable types. <br> !   After the ranking, a user can use the returned indices to sort the array and its !   associated variable(s) in a desired order.  The following code snippet illustrates !   how to typically sort the array and its associated variable(s). !   <Pre><Code style=\"color:MidnightBlue;\"> !   ! sort AVal and BVal in an ascending order using AInd indices !   XVal = AVal(AInd(:)) !   YVal = BVal(AInd(:)) ! !   ! sort AVal and BVal in a descending order using AInd indices !   DO I = 1, ASize !       XVal(I) = AVal(AInd(ASize-I+1)) !       YVal(I) = BVal(AInd(ASize-I+1)) !   END DO !   </Code></Pre> !   See the <a href=\"../module/mbase_sortascend.html\">MBase_SortAscend</a> and the !   <a href=\"../module/mbase_sortdescend.html\">MBase_SortDescend</a> modules for !   routines that perform sorting of an array in an *ascending* and *descending* order, !   respectively.  The *MBase_SortAscend* module also gives an overview of available !   sorting algorithms, which are mostly the same as the ranking algorithms available !   in this module. <br> !** USE STATEMENTS: USE MBase_Common USE MClass_Comparable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! hybrid PUBLIC :: WiseRank PUBLIC :: Wise_RankChar PUBLIC :: Wise_RankComp PUBLIC :: WiseRankStable PUBLIC :: WiseStable_RankChar PUBLIC :: WiseStable_RankComp PUBLIC :: IntroRank PUBLIC :: Intro_RankChar PUBLIC :: Intro_RankComp PUBLIC :: JavaRank PUBLIC :: Java_RankChar PUBLIC :: Java_RankComp PUBLIC :: PDQRank PUBLIC :: PDQ_RankChar PUBLIC :: PDQ_RankComp PUBLIC :: TimRank PUBLIC :: Tim_RankChar PUBLIC :: Tim_RankComp PUBLIC :: RustRank PUBLIC :: Rust_RankChar PUBLIC :: Rust_RankComp ! quick PUBLIC :: QuickRankHoare PUBLIC :: QuickHoare_RankChar PUBLIC :: QuickHoare_RankComp PUBLIC :: QuickRankLomuto PUBLIC :: QuickLomuto_RankChar PUBLIC :: QuickLomuto_RankComp PUBLIC :: QuickRankMo3 PUBLIC :: QuickMo3_RankChar PUBLIC :: QuickMo3_RankComp PUBLIC :: QuickRank3Way PUBLIC :: Quick3Way_RankChar PUBLIC :: Quick3Way_RankComp PUBLIC :: QuickRankVowels PUBLIC :: QuickVowels_RankChar PUBLIC :: QuickVowels_RankComp PUBLIC :: QuickRankStable PUBLIC :: QuickStable_RankChar PUBLIC :: QuickStable_RankComp PUBLIC :: QuickRankIterative PUBLIC :: QuickIterative_RankChar PUBLIC :: QuickIterative_RankComp PUBLIC :: QuickRankJava PUBLIC :: QuickJava_RankChar PUBLIC :: QuickJava_RankComp ! merge PUBLIC :: MergeRankTopDown PUBLIC :: MergeTopDown_RankChar PUBLIC :: MergeTopDown_RankComp PUBLIC :: MergeRankBottomUp PUBLIC :: MergeBottomUp_RankChar PUBLIC :: MergeBottomUp_RankComp PUBLIC :: MergeRankQuadSplit PUBLIC :: MergeQuadSplit_RankChar PUBLIC :: MergeQuadSplit_RankComp PUBLIC :: MergeRankHalfCopy PUBLIC :: MergeHalfCopy_RankChar PUBLIC :: MergeHalfCopy_RankComp PUBLIC :: MergeRankOrderPack PUBLIC :: MergeOrderPack_RankChar PUBLIC :: MergeOrderPack_RankComp ! auxiliary PUBLIC :: IsRanked PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharParam :: ModName = 'MBase_Ranking' !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ! hybrid INTERFACE WiseRank !&#94; **Subroutine Interface**: WiseRank <br> !  **Purpose**:  To rank an array in an ascending order using the *WiseSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *mergesort* and *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/wisesort.html\">WiseSort</a> interface !   for the technical information of the *WiseSort* algorithm. <br> MODULE SUBROUTINE Wise_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Wise_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE WiseRankStable !&#94; **Subroutine Interface**: WiseRankStable <br> !  **Purpose**:  To rank an array in an ascending order using the *WiseSort-Stable* !       algorithm, which is a hybrid *stable* algorithm that employs various !       sorting algorithms including the *insertion sort*, *mergesort* and !       *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseRankStable(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/wisesortstable.html\">WiseSortStable</a> interface !   for the technical information of the *WiseSort-Stable* algorithm. <br> MODULE SUBROUTINE WiseStable_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE WiseStable_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE IntroRank !&#94; **Subroutine Interface**: IntroRank <br> !  **Purpose**:  To rank an array in an ascending order using the *IntroSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *quicksort* and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL IntroRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/introsort.html\">IntroSort</a> interface !   for the technical information of the *IntroSort* algorithm. <br> MODULE SUBROUTINE Intro_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Intro_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE JavaRank !&#94; **Subroutine Interface**: JavaRank <br> !  **Purpose**:  To rank an array in an ascending order using the *JavaSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *mixed-insertion sort*, !       *quicksort*, *heapsort*, and *merging* algorithms. <br> !  **Usage**: <br> !   --->    CALL JavaRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/javasort.html\">JavaSort</a> interface !   for the technical information of the *JavaSort* algorithm. <br> MODULE SUBROUTINE Java_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Java_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE PDQRank !&#94; **Subroutine Interface**: PDQRank <br> !  **Purpose**:  To rank an array in an ascending order using the *PDQSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *insertion sort*, !       *quicksort*, and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL PDQRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/pdqsort.html\">PDQSort</a> interface !   for the technical information of the *PDQSort* algorithm. <br> MODULE SUBROUTINE PDQ_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE PDQ_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE TimRank !&#94; **Subroutine Interface**: TimRank <br> !  **Purpose**:  To rank an array in an ascending order using the *TimSort* !       algorithm, which is a hybrid *stable* algorithm that employs an !       *insertion sort* and an *adaptive mergesort* algorithms. <br> !  **Usage**: <br> !   --->    CALL TimRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/timsort.html\">TimSort</a> interface !   for the technical information of the *TimSort* algorithm. <br> MODULE SUBROUTINE Tim_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Tim_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , TARGET , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE RustRank !&#94; **Subroutine Interface**: RustRank <br> !  **Purpose**:  To rank an array in an ascending order using the *RustSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *mixed-insertion sort*, !       *quicksort*, *heapsort*, and *merging* algorithms. <br> !  **Usage**: <br> !   --->    CALL RustRank(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/rustsort.html\">RustSort</a> interface !   for the technical information of the *RustSort* algorithm. <br> MODULE SUBROUTINE Rust_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Rust_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE ! quick INTERFACE QuickRankHoare !&#94; **Subroutine Interface**: QuickRankHoare <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm with Hoare's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRankHoare(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksorthoare.html\">QuickSortHoare</a> !   interface for the technical information of the *QuickSort* algorithm !   with Hoare's partitioning scheme. <br> MODULE SUBROUTINE QuickHoare_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickHoare_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankLomuto !&#94; **Subroutine Interface**: QuickRankLomuto <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm with Lomuto's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRankLomuto(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortlomuto.html\">QuickSortLomuto</a> !   interface for the technical information of the *QuickSort* algorithm !   with Lomuto's partitioning scheme. <br> MODULE SUBROUTINE QuickLomuto_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankMo3 !&#94; **Subroutine Interface**: QuickRankMo3 <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm with the median-of-three (Mo3) !       partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRankMo3(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortmo3.html\">QuickSortMo3</a> !   interface for the technical information of the *QuickSort* algorithm !   with the median-of-three partitioning scheme. <br> MODULE SUBROUTINE QuickMo3_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickMo3_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRank3Way !&#94; **Subroutine Interface**: QuickRank3Way <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm with the three-way partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRank3Way(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksort3way.html\">QuickSort3Way</a> !   interface for the technical information of the *QuickSort* algorithm !   with the three-way partitioning scheme. <br> MODULE SUBROUTINE Quick3Way_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE Quick3Way_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankVowels !&#94; **Subroutine Interface**: QuickRankVowels <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm based on the *QuickSort Version 3* !       (the professional version) by R.A. Vowels. <br> !  **Usage**: <br> !   --->    CALL QuickRankVowels(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortvowels.html\">QuickSortVowels</a> !   interface for the technical information of the *Vowels' QuickSort* !   algorithm. <br> MODULE SUBROUTINE QuickVowels_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickVowels_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankStable !&#94; **Subroutine Interface**: QuickRankStable <br> !  **Purpose**:  To rank an array in an ascending order using the !       *QuickSort* algorithm with the *stable* partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRankStable(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortstable.html\">QuickSortStable</a> !   interface for the technical information of the *QuickSort* algorithm !   with the stable partitioning scheme. <br> MODULE SUBROUTINE QuickStable_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickStable_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankIterative !&#94; **Subroutine Interface**: QuickRankIterative <br> !  **Purpose**:  To rank an array in an ascending order using an *iterative !       Quicksort* algorithm with median-of-three (Mo3) partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickRankIterative(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortiterative.html\">QuickSortIterative</a> !   interface for the technical information of the *iterative Quicksort* !   algorithm with median-of-three partitioning scheme. <br> MODULE SUBROUTINE QuickIterative_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickIterative_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE QuickRankJava !&#94; **Subroutine Interface**: QuickRankJava <br> !  **Purpose**:  To rank an array in an ascending order using a *dual-pivot !       Quicksort* algorithm based on Java's sorting algorithm. <br> !  **Usage**: <br> !   --->    CALL QuickRankJava(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/quicksortjava.html\">QuickSortJava</a> !   interface for the technical information of the Java's *dual-pivot !   QuickSort* algorithm. <br> MODULE SUBROUTINE QuickJava_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE QuickJava_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE ! merge INTERFACE MergeRankTopDown !&#94; **Subroutine Interface**: MergeRankTopDown <br> !  **Purpose**:  To rank an array in an ascending order using a *top-down !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeRankTopDown(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/mergesorttopdown.html\">MergeSortTopDown</a> !   interface for the technical information of the *top-down merge sort* !   algorithm. <br> MODULE SUBROUTINE MergeTopDown_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE MergeRankBottomUp !&#94; **Subroutine Interface**: MergeRankBottomUp <br> !  **Purpose**:  To rank an array in an ascending order using a *bottom-up !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeRankBottomUp(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/mergesortbottomup.html\">MergeSortBottomUp</a> !   interface for the technical information of the *bottom-up merge sort* !   algorithm. <br> MODULE SUBROUTINE MergeBottomUp_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE MergeRankQuadSplit !&#94; **Subroutine Interface**: MergeRankQuadSplit <br> !  **Purpose**:  To rank an array in an ascending order using a *top-down !       merge sort* algorithm where the given array is split into four !       sub-arrays instead of two sub-arrays. <br> !  **Usage**: <br> !   --->    CALL MergeRankQuadSplit(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/mergesortquadsplit.html\">MergeSortRealQPSplit</a> !   interface for the technical information of the *top-down merge sort* !   algorithm with quad split. <br> MODULE SUBROUTINE MergeQuadSplit_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE MergeRankHalfCopy !&#94; **Subroutine Interface**: MergeRankHalfCopy <br> !  **Purpose**:  To rank an array in an ascending order using a *top-down !       merge sort* algorithm with *half-copying merge* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeRankHalfCopy(AVal, AInd) <br> !  **Technical Information**: <br> !   See the <a href=\"../interface/mergesorthalfcopy.html\">MergeSortHalfCopy</a> !   interface for the technical information of the *top-down merge sort* !   algorithm with *half-copying merge* algorithm. <br> MODULE SUBROUTINE MergeHalfCopy_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE INTERFACE MergeRankOrderPack !&#94; **Subroutine Interface**: MergeRankOrderPack <br> !  **Purpose**:  To rank an array in an ascending order using a *merge sort* !       algorithm based on the '*MrgRnk*' routine in the *OrderPack* 2.0 !       library by Olagnon [1]. <br> !  **Usage**: <br> !   --->    CALL MergeRankOrderPack(AVal, AInd) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small arrays and the !   Orderpack's merge sort algorithm [1] is employed for large arrays. <br> !  **References**: <br> !   [1] <a href=\"http://www.fortran-2000.com/rank/\">ORDERPACK 2.0: Unconditional, !       Unique, and Partial Ranking, Sorting, and Permutation Downloadable Fortran90 !       source code. </a> <br> MODULE SUBROUTINE MergeOrderPack_RankChar ( AVal , AInd ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankI8 ( AVal , AInd ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankI16 ( AVal , AInd ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankI32 ( AVal , AInd ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankI64 ( AVal , AInd ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankR32 ( AVal , AInd ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankR64 ( AVal , AInd ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankR128 ( AVal , AInd ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE MODULE SUBROUTINE MergeOrderPack_RankComp ( AVal , AInd ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( INOUT ) :: AInd ( SIZE ( AVal )) END SUBROUTINE END INTERFACE ! auxiliary INTERFACE IsRanked !&#94; **Function Interface**: IsRanked <br> !  **Purpose**:  To check whether the specified array is ranked in !       the ascending order. <br> !  **Usage**: <br> !   --->    Flag = IsRanked(AVal, AInd) <br> !   --->    IF (.NOT.IsRanked(AVal, AInd)) DoSomething <br> MODULE FUNCTION IsRanked_Char ( AVal , AInd ) RESULT ( Flag ) tCharStar , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_I8 ( AVal , AInd ) RESULT ( Flag ) tSInt8 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_I16 ( AVal , AInd ) RESULT ( Flag ) tSInt16 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_I32 ( AVal , AInd ) RESULT ( Flag ) tSInt32 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_I64 ( AVal , AInd ) RESULT ( Flag ) tSInt64 , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_R32 ( AVal , AInd ) RESULT ( Flag ) tRealSP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_R64 ( AVal , AInd ) RESULT ( Flag ) tRealDP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_R128 ( AVal , AInd ) RESULT ( Flag ) tRealQP , INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION MODULE FUNCTION IsRanked_Comp ( AVal , AInd ) RESULT ( Flag ) CLASS ( Comparable ), INTENT ( IN ) :: AVal (:) tIndex , INTENT ( IN ) :: AInd ( SIZE ( AVal )) tLogical :: Flag END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na END MODULE MBase_Ranking !******************************************************************************","tags":"","loc":"sourcefile\\mbase_ranking.f90.html"},{"title":"MBase_SortAscend.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_SortAscend !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains routines that can be used to sort an array in an *ascending* !   order.  The specified array can be of any type that is comparable.  For *Fortran !   intrinsic* types, *CHARACTER*, *INTEGER* and *REAL* types are considered valid !   comparable types.  For derived types, any types that extend from the *Comparable* !   type are valid comparable types. <br> !   Various sorting algorithms are available and are summarized as follows. <br> !   1.  *WiseSort* and *WiseSort-Stable* algorithms are hybrid sorting algorithms that !       employ multiple sorting algorithms.  As the names suggested, the *WiseSort-Stable* !       algorithm can be used for stable sorting whereas the *WiseSort* algorithm cannot. !       Both algorithms are originated in this library (XpfLib) and they sort the given !       array using a variety of sorting algorithms based on the pattern of the data. !       First, they carefully and *wisely* inspect the specified array by checking if there !       is any pattern in the given array.  Next, they decide which sorting algorithm is !       most suitable for the array.  They then sort the array using the chosen algorithm. !       For more information regarding the selection of a preferred algorithm and the various !       algorithms employed by either the *WiseSort* or the *WiseSort-Stable* algorithm, see !       the *Technical Information* section of each algorithm. <br> !   2.  *Hybrid* sorting algorithms include the *IntroSort*, *JavaSort*, *PDQSort*, *TimSort*, !       and *RustSort* algorithms.  These hybrid algorithms commonly employ multiple algorithms !       and can be classified into two groups: stable and unstable sorting algorithms.  The !       *stable* algorithms include the *TimSort* and *RustSort* algorithms whereas the other !       three algorithms are unstable.  For more information, see the *Technical Information* !       section of each algorithm. <br> !   3.  *Quicksort-based* sorting algorithms are actually hybrid algorithms that utilize a !       quicksort algorithm as its main algorithm and employ an insertion sort algorithm !       (mostly the pair-insertion sort) to deal with small (sub)array(s).  All of these !       algorithms, with the exception of the *QuickSortStable* algorithm, are unstable. !       For more information, see the *Technical Information* section of each algorithm. <br> !   4.  *Mergesort-based* sorting algorithms are actually hybrid algorithms that employ a !       mergesort algorithm as its main algorithm and use an insertion sort algorithm to !       deal with small (sub)array(s).  All of these algorithms are considered stable. !       For more information, see the *Technical Information* section of each algorithm. <br> !   See the <a href=\"../module/mbase_sortdescend.html\">MBase_SortDescend</a> module !   for routines that perform sorting of an array in a *descending* order.  Also, see !   the <a href=\"../module/mbase_ranking.html\">MBase_Ranking</a> module for routines !   that perform ranking of an array in an *ascending* order. !** USE STATEMENTS: USE MBase_Common USE MClass_Comparable IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! hybrid PUBLIC :: WiseSort PUBLIC :: WiseSortStable PUBLIC :: IntroSort PUBLIC :: JavaSort PUBLIC :: PDQSort PUBLIC :: TimSort PUBLIC :: RustSort ! quick PUBLIC :: QuickSortHoare PUBLIC :: QuickSortLomuto PUBLIC :: QuickSortMo3 PUBLIC :: QuickSort3Way PUBLIC :: QuickSortVowels PUBLIC :: QuickSortStable PUBLIC :: QuickSortIterative PUBLIC :: QuickSortJava ! merge PUBLIC :: MergeSortTopDown PUBLIC :: MergeSortBottomUp PUBLIC :: MergeSortRealQPSplit PUBLIC :: MergeSortHalfCopy ! auxiliary PUBLIC :: IsSortedAscend PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharParam :: ModName = 'MBase_SortAscend' !** DERIVED TYPE DEFINITIONS ! na !** INTERFACE DEFINITIONS: ! hybrid INTERFACE WiseSort !&#94; **Subroutine Interface**: WiseSort <br> !  **Purpose**:  To sort an array in a desired order using the *WiseSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *mergesort* and *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseSort(A) <br> !  **Technical Information**: <br> !   The *WiseSort* algorithm is a hybrid algorithm originated in this library !   (*XpfLib*).  The algorithm sorts the given array using a variety of sorting !   algorithms based on the pattern of the data.  First, it carefully and wisely !   inspects the specified array by checking if there is any pattern in the given !   array.  Next, it decides which sorting algorithm is most suitable for the array. !   It then sorts the array using the chosen algorithm. <br> !   The selection of a sorting algorithm is based on the following facts. <br> !   - An *Insertion sort* algorithm usually performs well for an array with !     small size. <br> !   - If the data is already sorted, no sorting algorithm is needed. <br> !   - If the data is already sorted but in an order opposite to the desired one, !     a reversion of the array is the most optimal sorting algorithm. <br> !   - A quicksort algorithm typically performs well for a totally randomized array. <br> !   - A mergesort algorithm generally performs well for a mostly ordered array. <br> !   Based on the aforementioned facts, the *WiseSort* algorithm utilizes various !   sorting algorithms including: <br> !   1. *Pair-insertion-sort-based* algorithms consisting of <br> !     - guarded version for a left-most sub-array or the whole array with small size, <br> !     - unguarded version for a non-left-most sub-array with small size. <br> !   2. *Merge-sort-based* algorithms consisting of <br> !     - Java's merging runs for a highly structured array (an array with a certain !       recognized pattern, e.g. saw- or wave-like pattern), <br> !     - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered !       array (i.e. an array having a very long ordered run, either in ascending or !       descending order). <br> !       For this particular implementation, it is found that Rust's mergesort performs !       very well for an array when more than 50% of the first or last elements of the !       array are already sorted. <br> !   3. *Quick-sort-based* algorithms where various partitioning schemes are employed !       including: <br> !     - Hoare's partitioning scheme for a NOT highly structured array, i.e. a !       partly-ordered and partly-randomized array (an array having not very long !       and not very short ordered runs), <br> !     - Median-of-three partitioning scheme for a totally-randomized array !       (an array having VERY SHORT ordered runs, e.g. an ordered run with less than !       4 elements), <br> !     - Ninther (median of medians or pseudo-median of nine) partitioning scheme for !       worst-case situations (when the quicksort algorithm converges too slowly, it !       switches from Hoare's or median-of-three partitioning scheme to the ninther !       partitioning scheme), <br> !     - Three-way (or Dutch's national flag) partitioning scheme for an array with !       many equal elements (when the quick sort algorithm detects that many elements !       are equal, it switches from Hoare's or median-of-three partitioning scheme to !       the three-way partitioning scheme). <br> !   As previously mentioned, the selection of an appropriate algorithm is based on !   a careful and wise inspection of the given array.  The routine responsible for !   this task will try to predict a suitable algorithm for any given array according !   to its pattern found.  The following list provides an overview of the routine. <br> !     - The routine will mostly try to scan just a very few runs and quit very quickly. !       Only, the highly structured array (the one sorted by Java's merge runs) is !       entirely scanned since all the runs are needed by the selected algorithm. <br> !     - If the routine detects that the current run is in an order opposite to the !       desired one, it will only reverse the run if necessary (i.e. the chosen !       algorithm will benefit from the reversion of the run). <br> !     - The prediction of a proper algorithm is quite accurate for most known cases. !       However, there are certain known cases that the routine may not choose !       the *BEST* algorithm.  For example, if highly-order parts of the given array !       are in the middle while randomized parts are in the beginning and in the end, !       the routine will typically select a quick sort algorithm.  However, if the !       highly-ordered parts are long enough (e.g. more than 50% of the array size), !       Rust/TimSort algorithms might be better algorithms.  For these certain cases, !       nonetheless, it is not worth scanning the whole array just so we can choose !       the *BEST* algorithm because the overhead will surely be very expensive. <br> MODULE SUBROUTINE Wise_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Wise_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE WiseSortStable !&#94; **Subroutine Interface**: WiseSortStable <br> !  **Purpose**:  To sort an array in a desired order using the *WiseSort-Stable* !       algorithm, which is a hybrid *stable* algorithm that employs various !       sorting algorithms including the *insertion sort*, *mergesort* and !       *quicksort* algorithms. <br> !  **Usage**: <br> !   --->    CALL WiseSortStable(A) <br> !  **Technical Information**: <br> !   Similar to the *WiseSort* algorithm, the *WiseSort-Stable* algorithm is !   a hybrid algorithm originated in this library(*XpfLib*).  Unlike the !   *WiseSort* algorithm, which is an unstable algorithm, the *WiseSort-Stable* !   algorithm (as the name implied) is a stable algorithm that sorts the given !   array using a variety of *stable* sorting algorithms.  Similar to the *WiseSort* !   algorithm, the *WiseSort-Stable* algorithm first inspects the specified !   array by checking if there is any pattern in the given array and then decides !   which stable sorting algorithm is most suitable for the array.  It then sorts !   the array using the chosen algorithm. <br> !   The selection of a stable sorting algorithm is based on the same facts given !   in the *WiseSort* section; hence, the *WiseSort-Stable* algorithm employs !   various stable sorting algorithms including: <br> !   1. *Insertion sort* algorithm (guarded version only) for a small-size (sub)array. <br> !   2. *Merge-sort-based* algorithms consisting of <br> !     - Java's merging runs for a highly structured array (an array with a certain !       recognized pattern, e.g. saw- or wave-like pattern), <br> !     - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered !       array (an array having a very long ordered run, either in ascending or !       descending order), <br> !     - Merge sort with half-copying for a small-size array or a partially randomized !       array (an array with one not-too-short and not-too-long run and many very-very !       short runs). <br> !   3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array !       (an array having VERY SHORT ordered runs, e.g. an ordered run with less than !       4 elements). <br> !   4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array !       with many not-too-short and not-too-long runs). <br> !   Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm !       that switches to the mergesort with half-copying algorithm for the smaller !       sub-array after the stable partitioning process while it recurs on the larger !       sub-array. <br> MODULE SUBROUTINE WiseStable_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE WiseStable_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE IntroSort !&#94; **Subroutine Interface**: IntroSort <br> !  **Purpose**:  To sort an array in a desired order using the *IntroSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *pair-insertion sort*, !       *quicksort* and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL IntroSort(A) <br> !  **Technical Information**: <br> !   The *IntroSort* algorithm is a hybrid algorithm developed by David Musser [1]. !   The algorithm starts sorting the given array using the quicksort algorithm !   with the median-of-three partitioning scheme.  It then switches to the heapsort !   algorithm when the recursion depth exceeds its limit (which is dependent on the !   array size).  It also switches to the pair-insertion sort algorithm if the !   (sub)array size falls below a certain threshold (called insertion cutoff). <br> !  **References**: <br> !   [1] <a href=\"https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps\"> !       Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms. !       Software: Practice and Experience. 27(8):983-993. </a> <br> MODULE SUBROUTINE Intro_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Intro_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE JavaSort !&#94; **Subroutine Interface**: JavaSort <br> !  **Purpose**:  To sort an array in a desired order using the *JavaSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *mixed-insertion sort*, !       *quicksort*, *heapsort*, and *merging* algorithms. <br> !  **Usage**: <br> !   --->    CALL JavaSort(A) <br> !  **Technical Information**: <br> !   The *JavaSort* algorithm is a hybrid algorithm based on Java's sorting !   algorithm [1].  The algorithm employs the dual-pivot quicksort as the !   main algorithm.  The algorithm is a variant of the *IntroSort* algorithm !   where the heapsort algorithm is used when the recursion depth exceeds its !   limit and the mixed insertion sort algorithm is utilized when the number !   of elements of the (sub)array(s) is below the insertion cutoff.  In addition, !   the *JavaSort* algorithm (with a routine that inspects the pattern of the !   specified array) employs a variant of the mergesort algorithm (a merging of !   runs) if the given array is found to be highly structured. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java\"> !       Java's DualPivotQuicksort class. </a> <br> MODULE SUBROUTINE Java_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Java_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE PDQSort !&#94; **Subroutine Interface**: PDQSort <br> !  **Purpose**:  To sort an array in a desired order using the *PDQSort* !       algorithm, which is a hybrid (unstable) algorithm that employs !       various sorting algorithms including the *insertion sort*, !       *quicksort*, and *heapsort* algorithms. <br> !  **Usage**: <br> !   --->    CALL PDQSort(A) <br> !  **Technical Information**: <br> !   The *PDQSort* (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm !   developed by Orson Peters [1].  The algorithm is a variant of the *IntroSort* !   algorithm with various improvements including median-of-three pivoting scheme, !   *BlockQuickSort* partitioning scheme to lesson the branch mis-prediction penalties, !   an adaptive sort to deals with an array with certain patterns, and a shuffling !   of array elements to help the heapsort works better. <br> !  **References**: <br> !   [1] <a href=\"https://arxiv.org/abs/2106.05123\">Peters, O.R.L. 2021. !       Pattern-defeating Quicksort. </a> <br> MODULE SUBROUTINE PDQ_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE PDQ_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE TimSort !&#94; **Subroutine Interface**: TimSort <br> !  **Purpose**:  To sort an array in a desired order using the *TimSort* !       algorithm, which is a hybrid *stable* algorithm that employs an !       *insertion sort* and an *adaptive mergesort* algorithms. <br> !  **Usage**: <br> !   --->    CALL TimSort(A) <br> !  **Technical Information**: <br> !   The *TimSort* algorithm is a hybrid stable algorithm developed by Tim !   Peters [1].  The algorithm is an adaptive, natural mergesort that works !   well for many kinds of partially ordered arrays.  As implemented here, !   the *Timsort* algorithm employs the insertion sort for small arrays and !   the adaptive mergesort for large arrays. <br> !  **References**: <br> !   [1] <a href=\"https://bugs.python.org/file4451/timsort.txt\">Timsort by !       Tim Peters. </a> <br> MODULE SUBROUTINE Tim_SortChar ( A ) tCharStar , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI8 ( A ) tSInt8 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI16 ( A ) tSInt16 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI32 ( A ) tSInt32 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortI64 ( A ) tSInt64 , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR32 ( A ) tRealSP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR64 ( A ) tRealDP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortR128 ( A ) tRealQP , INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE MODULE SUBROUTINE Tim_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ), TARGET :: A (:) END SUBROUTINE END INTERFACE INTERFACE RustSort !&#94; **Subroutine Interface**: RustSort <br> !  **Purpose**:  To sort an array in a desired order using the *RustSort* !       algorithm, which is a hybrid *stable* algorithm that employs an !       *insertion sort* and an *adaptive mergesort* algorithms. <br> !  **Usage**: <br> !   --->    CALL RustSort(A) <br> !  **Technical Information**: <br> !   The *RustSort* algorithm is a hybrid stable algorithm based on the Rust's !   mergesort algorithm [1].  The algorithm can be considered as a simplified !   *TimSort* algorithm where the galloping mode is not utilized.  Similar to !   the *Timsort* algorithm, the *RustSort* algorithm employs the insertion sort !   for small arrays and the adaptive mergesort for large arrays. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\"> !       Rust's mergesort. </a> <br> MODULE SUBROUTINE Rust_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Rust_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! quick INTERFACE QuickSortHoare !&#94; **Subroutine Interface**: QuickSortHoare <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with Hoare's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortHoare(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Hoare's partitioning scheme [1] is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead !   of a pure recursion) to minimize the recursive depth and make sure at most !   O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickHoare_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickHoare_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortLomuto !&#94; **Subroutine Interface**: QuickSortLomuto <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with Lomuto's partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortLomuto(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Lomuto's partitioning scheme [1] is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead !   of a pure recursion) to minimize the recursive depth and make sure at most !   O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickLomuto_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickLomuto_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortMo3 !&#94; **Subroutine Interface**: QuickSortMo3 <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with the median-of-three (Mo3) partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortMo3(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with median-of-three partitioning scheme [1] is !   employed for large (sub)array(s).  Unlike other *QuickSort* procedures, !   the algorithm for *QuickSortMo3* procedures uses a pure recursion instead !   of a tail recursion since it appears experimentally that the pure recursion !   provides a better performance for this particular implementation of the !   median-of-three partitioning scheme. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> MODULE SUBROUTINE QuickMo3_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickMo3_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSort3Way !&#94; **Subroutine Interface**: QuickSort3Way <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with the three-way partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSort3Way(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with Bentley and McIlroy's three-way partitioning !   scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses !   a tail recursion (instead of a pure recursion) to minimize the recursive !   depth and make sure at most O(log(n)) space is used [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Quicksort\">Quicksort. </a> <br> !   [2] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE Quick3Way_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE Quick3Way_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortVowels !&#94; **Subroutine Interface**: QuickSortVowels <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm based on the *QuickSort Version 3* (the professional version) !       by R.A. Vowels [1]. <br> !  **Usage**: <br> !   --->    CALL QuickSortVowels(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm based on the *QuickSort Version 3* (the professional !   version) by R.A. Vowels [1] is employed for large (sub)array(s). <br> !  **References**: <br> !   [1] <a href=\"http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html\"> !       Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran, !       Unicomp. </a> <br> MODULE SUBROUTINE QuickVowels_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickVowels_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortStable !&#94; **Subroutine Interface**: QuickSortStable <br> !  **Purpose**:  To sort an array in a desired order using the *QuickSort* !       algorithm with a stable partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortStable(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid *stable* algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the quicksort algorithm with a stable partitioning scheme is employed !   for large (sub)array(s).  Also, the algorithm uses a tail recursion !   (instead of a pure recursion) to minimize the recursive depth and make !   sure at most O(log(n)) space is used [1]. <br> !   It is important to note that although the pair-insertion sort algorithm !   should conceptually be a stable algorithm, its implementation in this !   library seems to be *unstable*.  Therefore, for all *hybrid stable* !   algorithms, the insertion sort is used in place of the pair-insertion !   sort although the pair-insertion sort typically provides better overall !   performance. <br> !  **References**: <br> !   [1] <a href=\"https://www.techiedelight.com/boost-quicksort-performance/\"> !       How to Boost QuickSort Performance? </a> <br> MODULE SUBROUTINE QuickStable_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickStable_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortIterative !&#94; **Subroutine Interface**: QuickSortIterative <br> !  **Purpose**:  To sort an array in a desired order using an *iterative !       Quicksort* algorithm with median-of-three (Mo3) partitioning scheme. <br> !  **Usage**: <br> !   --->    CALL QuickSortIterative(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the *iterative* quicksort algorithm with median-of-three partitioning !   scheme is employed for large (sub)array(s).  The implementation of the !   iterative quicksort algorithm is based mainly on the *Sort* subroutine !   of Numerical Recipes in Fortran 90 [1]. <br> !  **References**: <br> !   [1] <a href=\"http://numerical.recipes/oldverswitcher.html\">Numerical !       Recipes Books Online. </a> <br> MODULE SUBROUTINE QuickIterative_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickIterative_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE QuickSortJava !&#94; **Subroutine Interface**: QuickSortJava <br> !  **Purpose**:  To sort an array in a desired order using a *dual-pivot !       Quicksort* algorithm based on Java's sorting algorithm [1]. <br> !  **Usage**: <br> !   --->    CALL QuickSortJava(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid (unstable) algorithm where !   the pair-insertion sort algorithm is utilized for small (sub)array(s) and !   the *dual-pivot* quicksort algorithm is employed for large (sub)array(s). !   The implementation of the dual-pivot quicksort algorithm is based mainly !   on Java's sorting algorithm [1]. <br> !  **References**: <br> !   [1] <a href=\"https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java\"> !       Java's DualPivotQuicksort class. </a> <br> MODULE SUBROUTINE QuickJava_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE QuickJava_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! merge INTERFACE MergeSortTopDown !&#94; **Subroutine Interface**: MergeSortTopDown <br> !  **Purpose**:  To sort an array in a desired order using a *top-down !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeSortTopDown(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm [1] is employed for large (sub)array(s). !   The algorithm also considers other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeTopDown_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeTopDown_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortBottomUp !&#94; **Subroutine Interface**: MergeSortBottomUp <br> !  **Purpose**:  To sort an array in a desired order using a *bottom-up !       merge sort* algorithm. <br> !  **Usage**: <br> !   --->    CALL MergeSortBottomUp(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> MODULE SUBROUTINE MergeBottomUp_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeBottomUp_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortRealQPSplit !&#94; **Subroutine Interface**: MergeSortRealQPSplit <br> !  **Purpose**:  To sort an array in a desired order using a *top-down !       merge sort* algorithm where the given array is split into four !       sub-arrays instead of two sub-arrays. <br> !  **Usage**: <br> !   --->    CALL MergeSortRealQPSplit(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm [1] with quad split.  The algorithm !   also considers other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"https://en.wikipedia.org/wiki/Merge_sort\">Merge sort. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeQuadSplit_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeQuadSplit_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE INTERFACE MergeSortHalfCopy !&#94; **Subroutine Interface**: MergeSortHalfCopy <br> !  **Purpose**:  To sort an array in a desired order using a fast !       *mergesort* algorithm based on *half-copying merge* algorithm !       by C. Juszczak [1]. <br> !  **Usage**: <br> !   --->    CALL MergeSortHalfCopy(A) <br> !  **Technical Information**: <br> !   The algorithm used here is actually a hybrid stable algorithm where !   the insertion sort algorithm is utilized for small (sub)array(s) and !   the top-down merge sort algorithm with a *half-copying* merging [1] !   is employed for large (sub)array(s).  The algorithm also considers !   other improvements as suggested in [2]. <br> !  **References**: <br> !   [1] <a href=\"http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf\"> !       Juszczak, C. 2007.  Fast mergesort implementation based on half-copying !       merge algorithm. </a> <br> !   [2] <a href=\"https://algs4.cs.princeton.edu/22mergesort/\">Section 2.2 Merge sort !       of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br> MODULE SUBROUTINE MergeHalfCopy_SortChar ( A ) tCharStar , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI8 ( A ) tSInt8 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI16 ( A ) tSInt16 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI32 ( A ) tSInt32 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortI64 ( A ) tSInt64 , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR32 ( A ) tRealSP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR64 ( A ) tRealDP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortR128 ( A ) tRealQP , INTENT ( INOUT ) :: A (:) END SUBROUTINE MODULE SUBROUTINE MergeHalfCopy_SortComp ( A ) CLASS ( Comparable ), INTENT ( INOUT ) :: A (:) END SUBROUTINE END INTERFACE ! auxiliary INTERFACE IsSortedAscend !&#94; **Function Interface**: IsSortedAscend <br> !  **Purpose**:  To check whether the specified array is sorted in !       the desired order. <br> !  **Usage**: <br> !   --->    Flag = IsSortedAscend(A) <br> !   --->    IF (.NOT.IsSortedAscend(A)) DoSomething <br> MODULE FUNCTION IsSortedAscend_Char ( A ) RESULT ( Flag ) tCharStar , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_I8 ( A ) RESULT ( Flag ) tSInt8 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_I16 ( A ) RESULT ( Flag ) tSInt16 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_I32 ( A ) RESULT ( Flag ) tSInt32 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_I64 ( A ) RESULT ( Flag ) tSInt64 , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_R32 ( A ) RESULT ( Flag ) tRealSP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_R64 ( A ) RESULT ( Flag ) tRealDP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_R128 ( A ) RESULT ( Flag ) tRealQP , INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION MODULE FUNCTION IsSortedAscend_Comp ( A ) RESULT ( Flag ) CLASS ( Comparable ), INTENT ( IN ) :: A (:) tLogical :: Flag END FUNCTION END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na END MODULE MBase_SortAscend !******************************************************************************","tags":"","loc":"sourcefile\\mbase_sortascend.f90.html"}]}
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Experimental Fortran Package - Ranking and Sorting">
    <meta name="author" content="Niranama" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; eXPerimental Fortran Library (XpfLib) Documentation
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha256-tG5mcZUtJsZvyKAxYLVXrmjKBVLd6VpVccqz/r4ypFE=" crossorigin="anonymous"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">eXPerimental Fortran Library (XpfLib) Documentation </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr><td><a href='../interface/introrank.html'>IntroRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/introsort.html">IntroSort</a> interface
  for the technical information of the <em>IntroSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/introsort.html'>IntroSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>IntroSort</em> algorithm is a hybrid algorithm developed by David Musser [1].
  The algorithm starts sorting the given array using the quicksort algorithm
  with the median-of-three partitioning scheme.  It then switches to the heapsort
  algorithm when the recursion depth exceeds its limit (which is dependent on the
  array size).  It also switches to the pair-insertion sort algorithm if the
  (sub)array size falls below a certain threshold (called insertion cutoff). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps">
      Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.
      Software: Practice and Experience. 27(8):983-993. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/introsort~2.html'>IntroSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: IntroSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>IntroSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>quicksort</em> and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL IntroSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>IntroSort</em> algorithm is a hybrid algorithm developed by David Musser [1].
  The algorithm starts sorting the given array using the quicksort algorithm
  with the median-of-three partitioning scheme.  It then switches to the heapsort
  algorithm when the recursion depth exceeds its limit (which is dependent on the
  array size).  It also switches to the pair-insertion sort algorithm if the
  (sub)array size falls below a certain threshold (called insertion cutoff). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://web.archive.org/web/20230307185457/http://www.cs.rpi.edu/~musser/gp/introsort.ps">
      Musser, D.R. 1997.  Introspective Sorting and Selection Algorithms.
      Software: Practice and Experience. 27(8):983-993. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/isranked.html'>IsRanked</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsRanked <br>
 <strong>Purpose</strong>:  To check whether the specified array is ranked in
      the ascending order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsRanked(AVal, AInd) <br>
  ---&gt;    IF (.NOT.IsRanked(AVal, AInd)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/issortedascend.html'>IsSortedAscend</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsSortedAscend <br>
 <strong>Purpose</strong>:  To check whether the specified array is sorted in
      the desired order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsSortedAscend(A) <br>
  ---&gt;    IF (.NOT.IsSortedAscend(A)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/issorteddescend.html'>IsSortedDescend</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Function Interface</strong>: IsSortedDescend <br>
 <strong>Purpose</strong>:  To check whether the specified array is sorted in
      the desired order. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    Flag = IsSortedDescend(A) <br>
  ---&gt;    IF (.NOT.IsSortedDescend(A)) DoSomething <br></p></td></tr>
			   <tr><td><a href='../interface/javarank.html'>JavaRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/javasort.html">JavaSort</a> interface
  for the technical information of the <em>JavaSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/javasort.html'>JavaSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>JavaSort</em> algorithm is a hybrid algorithm based on Java's sorting
  algorithm [1].  The algorithm employs the dual-pivot quicksort as the
  main algorithm.  The algorithm is a variant of the <em>IntroSort</em> algorithm
  where the heapsort algorithm is used when the recursion depth exceeds its
  limit and the mixed insertion sort algorithm is utilized when the number
  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,
  the <em>JavaSort</em> algorithm (with a routine that inspects the pattern of the
  specified array) employs a variant of the mergesort algorithm (a merging of
  runs) if the given array is found to be highly structured. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/javasort~2.html'>JavaSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: JavaSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>JavaSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL JavaSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>JavaSort</em> algorithm is a hybrid algorithm based on Java's sorting
  algorithm [1].  The algorithm employs the dual-pivot quicksort as the
  main algorithm.  The algorithm is a variant of the <em>IntroSort</em> algorithm
  where the heapsort algorithm is used when the recursion depth exceeds its
  limit and the mixed insertion sort algorithm is utilized when the number
  of elements of the (sub)array(s) is below the insertion cutoff.  In addition,
  the <em>JavaSort</em> algorithm (with a routine that inspects the pattern of the
  specified array) employs a variant of the mergesort algorithm (a merging of
  runs) if the given array is found to be highly structured. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankbottomup.html'>MergeRankBottomUp</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankBottomUp <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankBottomUp(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesortbottomup.html">MergeSortBottomUp</a>
  interface for the technical information of the <em>bottom-up merge sort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankhalfcopy.html'>MergeRankHalfCopy</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankHalfCopy <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm with <em>half-copying merge</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankHalfCopy(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesorthalfcopy.html">MergeSortHalfCopy</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm with <em>half-copying merge</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankorderpack.html'>MergeRankOrderPack</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankOrderPack <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>merge sort</em>
      algorithm based on the '<em>MrgRnk</em>' routine in the <em>OrderPack</em> 2.0
      library by Olagnon [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankOrderPack(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small arrays and the
  Orderpack's merge sort algorithm [1] is employed for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://www.fortran-2000.com/rank/">ORDERPACK 2.0: Unconditional,
      Unique, and Partial Ranking, Sorting, and Permutation Downloadable Fortran90
      source code. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergerankquadsplit.html'>MergeRankQuadSplit</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankQuadSplit <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankQuadSplit(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesortquadsplit.html">MergeSortRealQPSplit</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm with quad split. <br></p></td></tr>
			   <tr><td><a href='../interface/mergeranktopdown.html'>MergeRankTopDown</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeRankTopDown <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeRankTopDown(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/mergesorttopdown.html">MergeSortTopDown</a>
  interface for the technical information of the <em>top-down merge sort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortbottomup.html'>MergeSortBottomUp</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortBottomUp <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortBottomUp(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortbottomup~2.html'>MergeSortBottomUp</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortBottomUp <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>bottom-up
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortBottomUp(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the bottom-up merge sort algorithm [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorthalfcopy.html'>MergeSortHalfCopy</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortHalfCopy <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a fast
      <em>mergesort</em> algorithm based on <em>half-copying merge</em> algorithm
      by C. Juszczak [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortHalfCopy(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm with a <em>half-copying</em> merging [1]
  is employed for large (sub)array(s).  The algorithm also considers
  other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf">
      Juszczak, C. 2007.  Fast mergesort implementation based on half-copying
      merge algorithm. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorthalfcopy~2.html'>MergeSortHalfCopy</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortHalfCopy <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a fast
      <em>mergesort</em> algorithm based on <em>half-copying merge</em> algorithm
      by C. Juszczak [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortHalfCopy(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm with a <em>half-copying</em> merging [1]
  is employed for large (sub)array(s).  The algorithm also considers
  other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://kicia.ift.uni.wroc.pl/algorytmy/mergesortpaper.pdf">
      Juszczak, C. 2007.  Fast mergesort implementation based on half-copying
      merge algorithm. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortrealqpsplit.html'>MergeSortRealQPSplit</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortRealQPSplit <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortRealQPSplit(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] with quad split.  The algorithm
  also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesortrealqpsplit~2.html'>MergeSortRealQPSplit</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortRealQPSplit <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm where the given array is split into four
      sub-arrays instead of two sub-arrays. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortRealQPSplit(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] with quad split.  The algorithm
  also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorttopdown.html'>MergeSortTopDown</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortTopDown <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortTopDown(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] is employed for large (sub)array(s).
  The algorithm also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/mergesorttopdown~2.html'>MergeSortTopDown</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: MergeSortTopDown <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>top-down
      merge sort</em> algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL MergeSortTopDown(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid stable algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the top-down merge sort algorithm [1] is employed for large (sub)array(s).
  The algorithm also considers other improvements as suggested in [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge sort. </a> <br>
  [2] <a href="https://algs4.cs.princeton.edu/22mergesort/">Section 2.2 Merge sort
      of Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/pdqrank.html'>PDQRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/pdqsort.html">PDQSort</a> interface
  for the technical information of the <em>PDQSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/pdqsort.html'>PDQSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>PDQSort</em> (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm
  developed by Orson Peters [1].  The algorithm is a variant of the <em>IntroSort</em>
  algorithm with various improvements including median-of-three pivoting scheme,
  <em>BlockQuickSort</em> partitioning scheme to lesson the branch mis-prediction penalties,
  an adaptive sort to deals with an array with certain patterns, and a shuffling
  of array elements to help the heapsort works better. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://arxiv.org/abs/2106.05123">Peters, O.R.L. 2021.
      Pattern-defeating Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/pdqsort~2.html'>PDQSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: PDQSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>PDQSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>insertion sort</em>,
      <em>quicksort</em>, and <em>heapsort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL PDQSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>PDQSort</em> (Pattern-Defeating Quicksort) algorithm is a hybrid algorithm
  developed by Orson Peters [1].  The algorithm is a variant of the <em>IntroSort</em>
  algorithm with various improvements including median-of-three pivoting scheme,
  <em>BlockQuickSort</em> partitioning scheme to lesson the branch mis-prediction penalties,
  an adaptive sort to deals with an array with certain patterns, and a shuffling
  of array elements to help the heapsort works better. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://arxiv.org/abs/2106.05123">Peters, O.R.L. 2021.
      Pattern-defeating Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quickrank3way.html'>QuickRank3Way</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRank3Way <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRank3Way(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksort3way.html">QuickSort3Way</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the three-way partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankhoare.html'>QuickRankHoare</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankHoare <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankHoare(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksorthoare.html">QuickSortHoare</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with Hoare's partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankiterative.html'>QuickRankIterative</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankIterative <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankIterative(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortiterative.html">QuickSortIterative</a>
  interface for the technical information of the <em>iterative Quicksort</em>
  algorithm with median-of-three partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankjava.html'>QuickRankJava</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankJava <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankJava(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortjava.html">QuickSortJava</a>
  interface for the technical information of the Java's <em>dual-pivot
  QuickSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/quickranklomuto.html'>QuickRankLomuto</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankLomuto <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankLomuto(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortlomuto.html">QuickSortLomuto</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with Lomuto's partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankmo3.html'>QuickRankMo3</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankMo3 <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the median-of-three (Mo3)
      partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankMo3(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortmo3.html">QuickSortMo3</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the median-of-three partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankstable.html'>QuickRankStable</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankStable <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm with the <em>stable</em> partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankStable(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortstable.html">QuickSortStable</a>
  interface for the technical information of the <em>QuickSort</em> algorithm
  with the stable partitioning scheme. <br></p></td></tr>
			   <tr><td><a href='../interface/quickrankvowels.html'>QuickRankVowels</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickRankVowels <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the
      <em>QuickSort</em> algorithm based on the <em>QuickSort Version 3</em>
      (the professional version) by R.A. Vowels. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickRankVowels(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/quicksortvowels.html">QuickSortVowels</a>
  interface for the technical information of the <em>Vowels' QuickSort</em>
  algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/quicksort3way.html'>QuickSort3Way</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSort3Way <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSort3Way(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Bentley and McIlroy's three-way partitioning
  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses
  a tail recursion (instead of a pure recursion) to minimize the recursive
  depth and make sure at most O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksort3way~2.html'>QuickSort3Way</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSort3Way <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the three-way partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSort3Way(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Bentley and McIlroy's three-way partitioning
  scheme [1] is employed for large (sub)array(s).  Also, the algorithm uses
  a tail recursion (instead of a pure recursion) to minimize the recursive
  depth and make sure at most O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksorthoare.html'>QuickSortHoare</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortHoare <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortHoare(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Hoare's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksorthoare~2.html'>QuickSortHoare</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortHoare <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Hoare's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortHoare(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Hoare's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortiterative.html'>QuickSortIterative</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortIterative <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortIterative(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>iterative</em> quicksort algorithm with median-of-three partitioning
  scheme is employed for large (sub)array(s).  The implementation of the
  iterative quicksort algorithm is based mainly on the <em>Sort</em> subroutine
  of Numerical Recipes in Fortran 90 [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://numerical.recipes/oldverswitcher.html">Numerical
      Recipes Books Online. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortiterative~2.html'>QuickSortIterative</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortIterative <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using an <em>iterative
      Quicksort</em> algorithm with median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortIterative(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>iterative</em> quicksort algorithm with median-of-three partitioning
  scheme is employed for large (sub)array(s).  The implementation of the
  iterative quicksort algorithm is based mainly on the <em>Sort</em> subroutine
  of Numerical Recipes in Fortran 90 [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="http://numerical.recipes/oldverswitcher.html">Numerical
      Recipes Books Online. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortjava.html'>QuickSortJava</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortJava <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortJava(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>dual-pivot</em> quicksort algorithm is employed for large (sub)array(s).
  The implementation of the dual-pivot quicksort algorithm is based mainly
  on Java's sorting algorithm [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortjava~2.html'>QuickSortJava</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortJava <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using a <em>dual-pivot
      Quicksort</em> algorithm based on Java's sorting algorithm [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortJava(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the <em>dual-pivot</em> quicksort algorithm is employed for large (sub)array(s).
  The implementation of the dual-pivot quicksort algorithm is based mainly
  on Java's sorting algorithm [1]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/DualPivotQuicksort.java">
      Java's DualPivotQuicksort class. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortlomuto.html'>QuickSortLomuto</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortLomuto <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortLomuto(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortlomuto~2.html'>QuickSortLomuto</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortLomuto <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with Lomuto's partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortLomuto(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with Lomuto's partitioning scheme [1] is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion (instead
  of a pure recursion) to minimize the recursive depth and make sure at most
  O(log(n)) space is used [2]. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br>
  [2] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortmo3.html'>QuickSortMo3</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortMo3 <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortMo3(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with median-of-three partitioning scheme [1] is
  employed for large (sub)array(s).  Unlike other <em>QuickSort</em> procedures,
  the algorithm for <em>QuickSortMo3</em> procedures uses a pure recursion instead
  of a tail recursion since it appears experimentally that the pure recursion
  provides a better performance for this particular implementation of the
  median-of-three partitioning scheme. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortmo3~2.html'>QuickSortMo3</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortMo3 <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with the median-of-three (Mo3) partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortMo3(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with median-of-three partitioning scheme [1] is
  employed for large (sub)array(s).  Unlike other <em>QuickSort</em> procedures,
  the algorithm for <em>QuickSortMo3</em> procedures uses a pure recursion instead
  of a tail recursion since it appears experimentally that the pure recursion
  provides a better performance for this particular implementation of the
  median-of-three partitioning scheme. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://en.wikipedia.org/wiki/Quicksort">Quicksort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortstable.html'>QuickSortStable</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with a stable partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid <em>stable</em> algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with a stable partitioning scheme is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion
  (instead of a pure recursion) to minimize the recursive depth and make
  sure at most O(log(n)) space is used [1]. <br>
  It is important to note that although the pair-insertion sort algorithm
  should conceptually be a stable algorithm, its implementation in this
  library seems to be <em>unstable</em>.  Therefore, for all <em>hybrid stable</em>
  algorithms, the insertion sort is used in place of the pair-insertion
  sort although the pair-insertion sort typically provides better overall
  performance. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortstable~2.html'>QuickSortStable</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm with a stable partitioning scheme. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid <em>stable</em> algorithm where
  the insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm with a stable partitioning scheme is employed
  for large (sub)array(s).  Also, the algorithm uses a tail recursion
  (instead of a pure recursion) to minimize the recursive depth and make
  sure at most O(log(n)) space is used [1]. <br>
  It is important to note that although the pair-insertion sort algorithm
  should conceptually be a stable algorithm, its implementation in this
  library seems to be <em>unstable</em>.  Therefore, for all <em>hybrid stable</em>
  algorithms, the insertion sort is used in place of the pair-insertion
  sort although the pair-insertion sort typically provides better overall
  performance. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://www.techiedelight.com/boost-quicksort-performance/">
      How to Boost QuickSort Performance? </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortvowels.html'>QuickSortVowels</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortVowels <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm based on the <em>QuickSort Version 3</em> (the professional version)
      by R.A. Vowels [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortVowels(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm based on the <em>QuickSort Version 3</em> (the professional
  version) by R.A. Vowels [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html">
      Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,
      Unicomp. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/quicksortvowels~2.html'>QuickSortVowels</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: QuickSortVowels <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>QuickSort</em>
      algorithm based on the <em>QuickSort Version 3</em> (the professional version)
      by R.A. Vowels [1]. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL QuickSortVowels(A) <br>
 <strong>Technical Information</strong>: <br>
  The algorithm used here is actually a hybrid (unstable) algorithm where
  the pair-insertion sort algorithm is utilized for small (sub)array(s) and
  the quicksort algorithm based on the <em>QuickSort Version 3</em> (the professional
  version) by R.A. Vowels [1] is employed for large (sub)array(s). <br>
 <strong>References</strong>: <br>
  [1] <a href="http://pages.swcp.com/~walt/fortran_store/Html/Info/books/adsff.html">
      Robin A. Vowels. 1998. Algorithms and Data Structures in F and Fortran,
      Unicomp. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/rustrank.html'>RustRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>RustSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>mixed-insertion sort</em>,
      <em>quicksort</em>, <em>heapsort</em>, and <em>merging</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/rustsort.html">RustSort</a> interface
  for the technical information of the <em>RustSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/rustsort.html'>RustSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>RustSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>RustSort</em> algorithm is a hybrid stable algorithm based on the Rust's
  mergesort algorithm [1].  The algorithm can be considered as a simplified
  <em>TimSort</em> algorithm where the galloping mode is not utilized.  Similar to
  the <em>Timsort</em> algorithm, the <em>RustSort</em> algorithm employs the insertion sort
  for small arrays and the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159">
      Rust's mergesort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/rustsort~2.html'>RustSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: RustSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>RustSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL RustSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>RustSort</em> algorithm is a hybrid stable algorithm based on the Rust's
  mergesort algorithm [1].  The algorithm can be considered as a simplified
  <em>TimSort</em> algorithm where the galloping mode is not utilized.  Similar to
  the <em>Timsort</em> algorithm, the <em>RustSort</em> algorithm employs the insertion sort
  for small arrays and the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159">
      Rust's mergesort. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/timrank.html'>TimRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/timsort.html">TimSort</a> interface
  for the technical information of the <em>TimSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/timsort.html'>TimSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>TimSort</em> algorithm is a hybrid stable algorithm developed by Tim
  Peters [1].  The algorithm is an adaptive, natural mergesort that works
  well for many kinds of partially ordered arrays.  As implemented here,
  the <em>Timsort</em> algorithm employs the insertion sort for small arrays and
  the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://bugs.python.org/file4451/timsort.txt">Timsort by
      Tim Peters. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/timsort~2.html'>TimSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: TimSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>TimSort</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs an
      <em>insertion sort</em> and an <em>adaptive mergesort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL TimSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>TimSort</em> algorithm is a hybrid stable algorithm developed by Tim
  Peters [1].  The algorithm is an adaptive, natural mergesort that works
  well for many kinds of partially ordered arrays.  As implemented here,
  the <em>Timsort</em> algorithm employs the insertion sort for small arrays and
  the adaptive mergesort for large arrays. <br>
 <strong>References</strong>: <br>
  [1] <a href="https://bugs.python.org/file4451/timsort.txt">Timsort by
      Tim Peters. </a> <br></p></td></tr>
			   <tr><td><a href='../interface/wiserank.html'>WiseRank</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseRank <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseRank(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/wisesort.html">WiseSort</a> interface
  for the technical information of the <em>WiseSort</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/wiserankstable.html'>WiseRankStable</a></td><td><a href='../module/mbase_ranking.html'>MBase_Ranking</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseRankStable <br>
 <strong>Purpose</strong>:  To rank an array in an ascending order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseRankStable(AVal, AInd) <br>
 <strong>Technical Information</strong>: <br>
  See the <a href="../interface/wisesortstable.html">WiseSortStable</a> interface
  for the technical information of the <em>WiseSort-Stable</em> algorithm. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesort.html'>WiseSort</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>WiseSort</em> algorithm is a hybrid algorithm originated in this library
  (<em>XpfLib</em>).  The algorithm sorts the given array using a variety of sorting
  algorithms based on the pattern of the data.  First, it carefully and wisely
  inspects the specified array by checking if there is any pattern in the given
  array.  Next, it decides which sorting algorithm is most suitable for the array.
  It then sorts the array using the chosen algorithm. <br>
  The selection of a sorting algorithm is based on the following facts. <br>
  - An <em>Insertion sort</em> algorithm usually performs well for an array with
    small size. <br>
  - If the data is already sorted, no sorting algorithm is needed. <br>
  - If the data is already sorted but in an order opposite to the desired one,
    a reversion of the array is the most optimal sorting algorithm. <br>
  - A quicksort algorithm typically performs well for a totally randomized array. <br>
  - A mergesort algorithm generally performs well for a mostly ordered array. <br>
  Based on the aforementioned facts, the <em>WiseSort</em> algorithm utilizes various
  sorting algorithms including: <br>
  1. <em>Pair-insertion-sort-based</em> algorithms consisting of <br>
    - guarded version for a left-most sub-array or the whole array with small size, <br>
    - unguarded version for a non-left-most sub-array with small size. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered
      array (i.e. an array having a very long ordered run, either in ascending or
      descending order). <br>
      For this particular implementation, it is found that Rust's mergesort performs
      very well for an array when more than 50% of the first or last elements of the
      array are already sorted. <br>
  3. <em>Quick-sort-based</em> algorithms where various partitioning schemes are employed
      including: <br>
    - Hoare's partitioning scheme for a NOT highly structured array, i.e. a
      partly-ordered and partly-randomized array (an array having not very long
      and not very short ordered runs), <br>
    - Median-of-three partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements), <br>
    - Ninther (median of medians or pseudo-median of nine) partitioning scheme for
      worst-case situations (when the quicksort algorithm converges too slowly, it
      switches from Hoare's or median-of-three partitioning scheme to the ninther
      partitioning scheme), <br>
    - Three-way (or Dutch's national flag) partitioning scheme for an array with
      many equal elements (when the quick sort algorithm detects that many elements
      are equal, it switches from Hoare's or median-of-three partitioning scheme to
      the three-way partitioning scheme). <br>
  As previously mentioned, the selection of an appropriate algorithm is based on
  a careful and wise inspection of the given array.  The routine responsible for
  this task will try to predict a suitable algorithm for any given array according
  to its pattern found.  The following list provides an overview of the routine. <br>
    - The routine will mostly try to scan just a very few runs and quit very quickly.
      Only, the highly structured array (the one sorted by Java's merge runs) is
      entirely scanned since all the runs are needed by the selected algorithm. <br>
    - If the routine detects that the current run is in an order opposite to the
      desired one, it will only reverse the run if necessary (i.e. the chosen
      algorithm will benefit from the reversion of the run). <br>
    - The prediction of a proper algorithm is quite accurate for most known cases.
      However, there are certain known cases that the routine may not choose
      the <em>BEST</em> algorithm.  For example, if highly-order parts of the given array
      are in the middle while randomized parts are in the beginning and in the end,
      the routine will typically select a quick sort algorithm.  However, if the
      highly-ordered parts are long enough (e.g. more than 50% of the array size),
      Rust/TimSort algorithms might be better algorithms.  For these certain cases,
      nonetheless, it is not worth scanning the whole array just so we can choose
      the <em>BEST</em> algorithm because the overhead will surely be very expensive. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesort~2.html'>WiseSort</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSort <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort</em>
      algorithm, which is a hybrid (unstable) algorithm that employs
      various sorting algorithms including the <em>pair-insertion sort</em>,
      <em>mergesort</em> and <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSort(A) <br>
 <strong>Technical Information</strong>: <br>
  The <em>WiseSort</em> algorithm is a hybrid algorithm originated in this library
  (<em>XpfLib</em>).  The algorithm sorts the given array using a variety of sorting
  algorithms based on the pattern of the data.  First, it carefully and wisely
  inspects the specified array by checking if there is any pattern in the given
  array.  Next, it decides which sorting algorithm is most suitable for the array.
  It then sorts the array using the chosen algorithm. <br>
  The selection of a sorting algorithm is based on the following facts. <br>
  - An <em>Insertion sort</em> algorithm usually performs well for an array with
    small size. <br>
  - If the data is already sorted, no sorting algorithm is needed. <br>
  - If the data is already sorted but in an order opposite to the desired one,
    a reversion of the array is the most optimal sorting algorithm. <br>
  - A quicksort algorithm typically performs well for a totally randomized array. <br>
  - A mergesort algorithm generally performs well for a mostly ordered array. <br>
  Based on the aforementioned facts, the <em>WiseSort</em> algorithm utilizes various
  sorting algorithms including: <br>
  1. <em>Pair-insertion-sort-based</em> algorithms consisting of <br>
    - guarded version for a left-most sub-array or the whole array with small size, <br>
    - unguarded version for a non-left-most sub-array with small size. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's mergesort (or the so-called simplified TimSort) for a mostly ordered
      array (i.e. an array having a very long ordered run, either in ascending or
      descending order). <br>
      For this particular implementation, it is found that Rust's mergesort performs
      very well for an array when more than 50% of the first or last elements of the
      array are already sorted. <br>
  3. <em>Quick-sort-based</em> algorithms where various partitioning schemes are employed
      including: <br>
    - Hoare's partitioning scheme for a NOT highly structured array, i.e. a
      partly-ordered and partly-randomized array (an array having not very long
      and not very short ordered runs), <br>
    - Median-of-three partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements), <br>
    - Ninther (median of medians or pseudo-median of nine) partitioning scheme for
      worst-case situations (when the quicksort algorithm converges too slowly, it
      switches from Hoare's or median-of-three partitioning scheme to the ninther
      partitioning scheme), <br>
    - Three-way (or Dutch's national flag) partitioning scheme for an array with
      many equal elements (when the quick sort algorithm detects that many elements
      are equal, it switches from Hoare's or median-of-three partitioning scheme to
      the three-way partitioning scheme). <br>
  As previously mentioned, the selection of an appropriate algorithm is based on
  a careful and wise inspection of the given array.  The routine responsible for
  this task will try to predict a suitable algorithm for any given array according
  to its pattern found.  The following list provides an overview of the routine. <br>
    - The routine will mostly try to scan just a very few runs and quit very quickly.
      Only, the highly structured array (the one sorted by Java's merge runs) is
      entirely scanned since all the runs are needed by the selected algorithm. <br>
    - If the routine detects that the current run is in an order opposite to the
      desired one, it will only reverse the run if necessary (i.e. the chosen
      algorithm will benefit from the reversion of the run). <br>
    - The prediction of a proper algorithm is quite accurate for most known cases.
      However, there are certain known cases that the routine may not choose
      the <em>BEST</em> algorithm.  For example, if highly-order parts of the given array
      are in the middle while randomized parts are in the beginning and in the end,
      the routine will typically select a quick sort algorithm.  However, if the
      highly-ordered parts are long enough (e.g. more than 50% of the array size),
      Rust/TimSort algorithms might be better algorithms.  For these certain cases,
      nonetheless, it is not worth scanning the whole array just so we can choose
      the <em>BEST</em> algorithm because the overhead will surely be very expensive. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesortstable.html'>WiseSortStable</a></td><td><a href='../module/mbase_sortdescend.html'>MBase_SortDescend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  Similar to the <em>WiseSort</em> algorithm, the <em>WiseSort-Stable</em> algorithm is
  a hybrid algorithm originated in this library(<em>XpfLib</em>).  Unlike the
  <em>WiseSort</em> algorithm, which is an unstable algorithm, the <em>WiseSort-Stable</em>
  algorithm (as the name implied) is a stable algorithm that sorts the given
  array using a variety of <em>stable</em> sorting algorithms.  Similar to the <em>WiseSort</em>
  algorithm, the <em>WiseSort-Stable</em> algorithm first inspects the specified
  array by checking if there is any pattern in the given array and then decides
  which stable sorting algorithm is most suitable for the array.  It then sorts
  the array using the chosen algorithm. <br>
  The selection of a stable sorting algorithm is based on the same facts given
  in the <em>WiseSort</em> section; hence, the <em>WiseSort-Stable</em> algorithm employs
  various stable sorting algorithms including: <br>
  1. <em>Insertion sort</em> algorithm (guarded version only) for a small-size (sub)array. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered
      array (an array having a very long ordered run, either in ascending or
      descending order), <br>
    - Merge sort with half-copying for a small-size array or a partially randomized
      array (an array with one not-too-short and not-too-long run and many very-very
      short runs). <br>
  3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements). <br>
  4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array
      with many not-too-short and not-too-long runs). <br>
  Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm
      that switches to the mergesort with half-copying algorithm for the smaller
      sub-array after the stable partitioning process while it recurs on the larger
      sub-array. <br></p></td></tr>
			   <tr><td><a href='../interface/wisesortstable~2.html'>WiseSortStable</a></td><td><a href='../module/mbase_sortascend.html'>MBase_SortAscend</a></td><td>Interface</td><td><p><strong>Subroutine Interface</strong>: WiseSortStable <br>
 <strong>Purpose</strong>:  To sort an array in a desired order using the <em>WiseSort-Stable</em>
      algorithm, which is a hybrid <em>stable</em> algorithm that employs various
      sorting algorithms including the <em>insertion sort</em>, <em>mergesort</em> and
      <em>quicksort</em> algorithms. <br>
 <strong>Usage</strong>: <br>
  ---&gt;    CALL WiseSortStable(A) <br>
 <strong>Technical Information</strong>: <br>
  Similar to the <em>WiseSort</em> algorithm, the <em>WiseSort-Stable</em> algorithm is
  a hybrid algorithm originated in this library(<em>XpfLib</em>).  Unlike the
  <em>WiseSort</em> algorithm, which is an unstable algorithm, the <em>WiseSort-Stable</em>
  algorithm (as the name implied) is a stable algorithm that sorts the given
  array using a variety of <em>stable</em> sorting algorithms.  Similar to the <em>WiseSort</em>
  algorithm, the <em>WiseSort-Stable</em> algorithm first inspects the specified
  array by checking if there is any pattern in the given array and then decides
  which stable sorting algorithm is most suitable for the array.  It then sorts
  the array using the chosen algorithm. <br>
  The selection of a stable sorting algorithm is based on the same facts given
  in the <em>WiseSort</em> section; hence, the <em>WiseSort-Stable</em> algorithm employs
  various stable sorting algorithms including: <br>
  1. <em>Insertion sort</em> algorithm (guarded version only) for a small-size (sub)array. <br>
  2. <em>Merge-sort-based</em> algorithms consisting of <br>
    - Java's merging runs for a highly structured array (an array with a certain
      recognized pattern, e.g. saw- or wave-like pattern), <br>
    - Rust's merge sort (or the so-called simplified TimSort) for a mostly ordered
      array (an array having a very long ordered run, either in ascending or
      descending order), <br>
    - Merge sort with half-copying for a small-size array or a partially randomized
      array (an array with one not-too-short and not-too-long run and many very-very
      short runs). <br>
  3. Quicksort algorithm with stable partitioning scheme for a totally-randomized array
      (an array having VERY SHORT ordered runs, e.g. an ordered run with less than
      4 elements). <br>
  4. Hybrid quick-merge sorting algorithm for a partially randomized array (an array
      with many not-too-short and not-too-long runs). <br>
  Note: the hybrid quick-merge sorting algorithm is a quick-sort-based algorithm
      that switches to the mergesort with half-copying algorithm for the smaller
      sub-array after the stable partitioning process while it recurs on the larger
      sub-array. <br></p></td></tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>eXPerimental Fortran Library (XpfLib) Documentation was developed by Niranama<br>&copy; 2024 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>
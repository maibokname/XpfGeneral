var tipuesearch = {"pages":[{"title":" eXPerimental Fortran Library (XpfLib) Documentation ","text":"eXPerimental Fortran Library (XpfLib) Documentation XpfHighPrec: eXPerimental Fortran HighPrec Package XpfHighPrec is an experimenal package written in Fortran.   It is a sub-package of the XpfGeneral package (a larger package within the XpfLib library), which contains a large collection of general-purpose modules.  The XpfHighPrec package consists of three modules (and a number of submodules) that provides three data types representing numbers with precision higher than those numbers of Fortran intrinsic types. The source code of the XpfHighPrec package is organized into 3 module files and 3 subfolders of the XpfHighPrec folder.   A brief overview of the source code is given below. The MBase_Float128 module contains the Float128 type, which represents a quadruple-precision floating point number.  Internally, the Float128 type consists of a logical value representing its sign, two 64-bit integers representing its 128-bit significand and a 32-bit integer representing its exponent.  Therefore, it is slightly more precise and has a wider range than the standard IEEE-754 quadruple- precision floating point number (i.e. 128-bit Fortran intrinsic real number).  The Float128 subfolder contains a number of submodules that provide implementations of the various operations of the Float128 type. The MClass_ApInt32 module contains the ApInt32 type, which represents a mutable, arbitrary-precision signed integer.  The ApInt32 subfolder contains several submodules that provide implementations of the various operations of the ApInt32 type. The MClass_ApInt64 module contains the ApInt64 type, which represents a mutable, arbitrary-precision signed integer. The ApInt64 subfolder contains a number of submodules that provide implementations of the various operations of the ApInt64 type.  It should be noted that the main difference between the ApInt32 and ApInt64 types is that the ApInt32 type uses an array of 32-bit integers to represent its magnitude whereas the ApInt64 type uses an array of 64-bit integers instead.  Therefore, the base of the ApInt32 type is 2 32 whereas the base of the ApInt64 type is 2 64 .  The uses of difference bases make their actual implementation somewhat different although the various theories behind their provided operations are the same. Dependencies The XpfHighPrec pacakge is primarily dependent on the XpfBase and XpfRandom packages. Documentation The FORD program can be used to automatically generate the documentation of the XpfHighPrec package via ford XpfHighPrecDoc.md . Developer Info Niranama","tags":"home","loc":"index.html"},{"title":"ApInt64 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ApInt64 ApInt64 is a mutable arbitrary-precision signed integer type where\n  its representations are as follows. - Base is 2 64 . - Magnitude is represented by the 'Digit' array in little-endian order. - The 'Length' first 'Digit' count as the ApInt64 number (i.e. it is always\n  less than or equal to the size/capacity of the 'Digit' array). - Sign is represented by a sign integer (-1 or 1). - Internally zero is allowed to have either sign.\n  (Otherwise one would have to remember to check for sign-swap for division,\n  multiplication etc...) - Zero can have many forms: -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through\n     ZeroApInt64()). -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number\n     is considered to be zero. Constructor public        interface ApInt64 Constructor Interface : ApInt64 Purpose :  To construct an ApInt64 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt64(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt64(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt64(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt64(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt64('-123456789098765432101122334455667788990012345') private module function Construct_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 64-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt64), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 64-bit integer array where\n the first element gives the least significant 64 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function Bytes_To_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function DecString_To_ApInt64(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt64 number based on the specified decimal string. Usage : ---> ApNum = ApInt64('1234567890987654321011223344') ---> ApNum = ApInt64('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt64(NumStr, ErrMsg=Message) ---> ApNum = ApInt64(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt64 ) number private module function U32_To_ApInt64(Sign, U32) result(Big) To construct the ApInt64 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U64_To_ApInt64(Sign, U64) result(Big) To construct the ApInt64 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U128_To_ApInt64(Sign, U128) result(Big) To construct the ApInt64 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function I32_To_ApInt64(I32) result(Big) To construct the ApInt64 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt64(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt64 ) private module function I64_To_ApInt64(I64) result(Big) To construct the ApInt64 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt64(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt64 ) private module function I128_To_ApInt64(I128) result(Big) To construct the ApInt64 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt64(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt64 ) private module function R32_To_ApInt64(R32) result(Big) To construct the ApInt64 number based on the specified 32-bit real number. Usage : ApNum = ApInt64(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt64 ) private module function R64_To_ApInt64(R64) result(Big) To construct the ApInt64 number based on the specified 64-bit real number. Usage : ApNum = ApInt64(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt64 ) private module function R128_To_ApInt64(R128) result(Big) To construct the ApInt64 number based on the specified 128-bit real number. Usage : ApNum = ApInt64(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt64 ) Type-Bound Procedures procedure, public :: Increment => ApInt64_Increment Type-Bound Subroutine : Increment Purpose :  To increase value of the ApInt64 number by one. Usage : --->    CALL ApNum%Increment() interface private module subroutine ApInt64_Increment(Val) To perform addition: Val = Val + 1. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: Val procedure, public :: Decrement => ApInt64_Decrement Type-Bound Subroutine : Decrement Purpose :  To decrease value of the ApInt64 number by one. Usage : --->    CALL ApNum%Decrement() interface private module subroutine ApInt64_Decrement(Val) To perform subtraction: Val = Val - 1. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: Val procedure, public :: Square => ApInt64_SquareSub Type-Bound Subroutine : Square Purpose :  To return the ApInt64 number (ApInt64) where its value is\n               computed by: ApNum = ApNum * ApNum. Usage : --->    CALL ApNum%Square() interface private module subroutine ApInt64_SquareSub(This) To perform self-multiplication: This = This * This. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: This procedure, public :: Compare => ApInt64_Compare Type-Bound Function : Compare Purpose :  To compare two ApInt64 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = LHS%Compare(RHS) --->    IF (LHS%Compare(RHS) /= 0) DoSomething interface private module function ApInt64_Compare(LHS, RHS) result(Flag) To compare two ApInt64 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value integer(kind=kInt32) procedure, public :: LShift => ApInt64_LeftShift Type-Bound Subroutine : LShift Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%LShift(112) interface private module subroutine ApInt64_LeftShift(Val, ShiftPos) To perform logical left shift with 0 <= ShiftPos <= 128. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: Val integer(kind=kInt32), intent(in) :: ShiftPos procedure, public :: RShift => ApInt64_RightShift Type-Bound Subroutine : RShift Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%RShift(112) interface private module subroutine ApInt64_RightShift(Val, ShiftPos) To perform logical right shift with 0 <= ShiftPos <= 128. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: Val integer(kind=kInt32), intent(in) :: ShiftPos procedure, public :: IsZero => ApInt64_Is_Zero_II Type-Bound Function : IsZero Purpose :  To check whether the ApInt64 number has value of zero or not. Usage : --->    Flag = ApNum%IsZero() --->    IF (.NOT.ApNum%IsZero()) DoSomething interface private module function ApInt64_Is_Zero_II(Big) result(Flag) To check whether the ApInt64 number has value of zero or not. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: Big Return Value logical procedure, public :: IsOne => ApInt64_Is_One Type-Bound Function : IsOne Purpose :  To check whether the ApInt64 number has value of one or not. Usage : --->    Flag = ApNum%IsOne() --->    IF (.NOT.ApNum%IsOne()) DoSomething interface private module function ApInt64_Is_One(Big) result(Flag) To check whether the ApInt64 number has value of one or not. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Big Return Value logical procedure, public :: IsPositive => ApInt64_Is_Positive Type-Bound Function : IsPositive Purpose :  To check whether the ApInt64 number has positive value or not. Usage : --->    Flag = ApNum%IsPositive() --->    IF (.NOT.ApNum%IsPositive()) DoSomething interface private module function ApInt64_Is_Positive(Big) result(Flag) To check whether the ApInt64 number has positive value or not. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Big Return Value logical procedure, public :: IsNegative => ApInt64_Is_Negative Type-Bound Function : IsNegative Purpose :  To check whether the ApInt64 number has negative value or not. Usage : --->    Flag = ApNum%IsNegative() --->    IF (.NOT.ApNum%IsNegative()) DoSomething interface private module function ApInt64_Is_Negative(Big) result(Flag) To check whether the ApInt64 number has negative value or not. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Big Return Value logical procedure, public :: RandNum => ApInt64_RandNumSub Type-Bound Subroutine : RandNum Purpose :  To generate the ApIn64 number with random value. Usage : ! generate random number with default settings --->    CALL ApNum%RandNum() ! generate random number with specified PRNG --->    CALL ApNum%RandNum(PRNG) ! generate random number with negative value --->    CALL ApNum%RandNum(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    CALL ApNum%RandNum(Length=MagLen) interface private module subroutine ApInt64_RandNumSub(BigRnd, Prng, Positive, Length) To generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(out) :: BigRnd the ApInt64 number with random value class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array procedure, public :: Copy => ApInt64_Copy Type-Bound Function : Copy Purpose :  To make a copy of the ApInt64 number. Usage : ! make a copy of the ApInt64 number --->    DstApNum = SrcApNum%Copy() ! make a copy of the ApInt64 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = SrcApNum%Copy(DstCap) interface private module function ApInt64_Copy(Source, Capacity) result(Destination) To make a copy of the ApInt64 number. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Source the source number integer(kind=kInt32), intent(in), optional :: Capacity capacity (size of magnitude array) of the destination number if specified, must be greater than capacity of the source number Return Value type( ApInt64 ) the destination number procedure, public :: Display => ApInt64_Write Type-Bound Subroutine : Display Purpose :  To write/display the 'ApInt64' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL ApNum%Display() ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL ApNum%Display(11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL ApNum%Display(11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL ApNum%Display(ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL ApNum%Display(Prefix='Signed value of ApNum') interface private module subroutine ApInt64_Write(Big, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write the ApInt64 number to the screen (or the specified unit). Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in), optional :: Unit output logical unit integer(kind=kInt32), intent(out), optional :: IOStat io stat character(kind=kChar, len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to write the upper and lower components. - If flag is present and true, write components of the number. - Otherwise, write the number as a decimal string. character(kind=kChar, len=*), intent(in), optional :: Prefix prefix string procedure, public :: GetLength => ApInt64_GetLength Type-Bound Function : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = ApNum%GetLength() interface private module function ApInt64_GetLength(Num) result(Length) To return the number of digits counted as the ApNum number. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Num Return Value integer(kind=kInt32) the number of digits counted generic, public :: Add => ApInt64_Add_I32, ApInt64_Add_I64, ApInt64_Add_I128, ApInt64_Add_ApInt64 Type-Bound Subroutine : Add Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%Add(Other) private  interface ApInt64_Add_I32() Arguments None private  interface ApInt64_Add_I64() Arguments None private  interface ApInt64_Add_I128() Arguments None private  interface ApInt64_Add_ApInt64() Arguments None generic, public :: Subtract => ApInt64_Subtract_I32, ApInt64_Subtract_I64, ApInt64_Subtract_I128, ApInt64_Subtract_ApInt64 Type-Bound Subroutine : Subtract Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%Subtract(Other) private  interface ApInt64_Subtract_I32() Arguments None private  interface ApInt64_Subtract_I64() Arguments None private  interface ApInt64_Subtract_I128() Arguments None private  interface ApInt64_Subtract_ApInt64() Arguments None generic, public :: Multiply => ApInt64_Times_I32, ApInt64_Times_I64, ApInt64_Times_I128, ApInt64_Times_ApInt64 Type-Bound Subroutine : Multiply Purpose :  To perform a multiplication: This = This * Other. Usage : --->    CALL This%Multiply(Other) private  interface ApInt64_Times_I32() Arguments None private  interface ApInt64_Times_I64() Arguments None private  interface ApInt64_Times_I128() Arguments None private  interface ApInt64_Times_ApInt64() Arguments None generic, public :: Divide => ApInt64_Over_I32, ApInt64_Over_I64, ApInt64_Over_I128, ApInt64_Over_ApInt64 Type-Bound Subroutine : Divide Purpose :  To perform a division: This = This / Other.  Optionally,\n               return the remainder if present. Usage : --->    CALL This%Divide(Other) --->    CALL This%Divide(Other, Remainder) private  interface ApInt64_Over_I32() Arguments None private  interface ApInt64_Over_I64() Arguments None private  interface ApInt64_Over_I128() Arguments None private  interface ApInt64_Over_ApInt64() Arguments None generic, public :: DivMod => ApInt64_DivMod_I32, ApInt64_DivMod_I64, ApInt64_DivMod_I128, ApInt64_DivMod_ApInt64 Type-Bound Subroutine : DivMod Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) private  interface ApInt64_DivMod_I32() Arguments None private  interface ApInt64_DivMod_I64() Arguments None private  interface ApInt64_DivMod_I128() Arguments None private  interface ApInt64_DivMod_ApInt64() Arguments None procedure, public :: AddXp => ApInt64_Add_Xp Type-Bound Subroutine : AddXp Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%AddXp(Other, Algorithm) Note : Algorithm must be between 1 and 3. interface private module subroutine ApInt64_Add_Xp(This, Other, Algorithm) To perform addition: This = This + Other.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: This type( ApInt64 ), intent(in) :: Other integer(kind=kInt32), intent(in) :: Algorithm procedure, public :: SubtractXp => ApInt64_Subtract_Xp Type-Bound Subroutine : SubtractXp Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%SubtractXp(Other, Algorithm) Note : Algorithm must be between 1 and 3. interface private module subroutine ApInt64_Subtract_Xp(This, Other, Algorithm) To perform subtraction: This = This - Other.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: This type( ApInt64 ), intent(in) :: Other integer(kind=kInt32), intent(in) :: Algorithm procedure, public :: DivideXp => ApInt64_Over_Xp Type-Bound Subroutine : DivideXp Purpose :  To perform a division: This = This / Other. Usage : --->    CALL This%DivideXp(Other, Algorithm) Note : Algorithm must be between 1 and 5. interface private module subroutine ApInt64_Over_Xp(This, Other, Algorithm, Remainder) To perform division: This = This / Other.  Valid value of Algorithm is between 1 and 5.  Optionally, return the\n remainder if present. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(inout) :: This type( ApInt64 ), intent(in) :: Other integer(kind=kInt32), intent(in) :: Algorithm type( ApInt64 ), intent(out), optional :: Remainder procedure, public :: DivModXp => ApInt64_DivMod_Xp Type-Bound Subroutine : DivModXp Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivModXp(Denominator, Algorithm, Quotient, Remainder) Note : Algorithm must be between 1 and 5. interface private module subroutine ApInt64_DivMod_Xp(Dividend, Divisor, Algorithm, Quotient, Remainder) To perform division (Dividend/Divisor) and return both the quotient\n and the remainder.  Valid value of Algorithm is between 1 and 5. Arguments Type Intent Optional Attributes Name class( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor integer(kind=kInt32), intent(in) :: Algorithm type( ApInt64 ), intent(out) :: Quotient type( ApInt64 ), intent(out) :: Remainder Source Code TYPE ApInt64 PRIVATE !> The sign of this number. <br> ! -> +1 for positive numbers and -1 for negative numbers. <br> ! -> Zero can have either sign. tSInt32 :: Sign = 1 !% The number of digits of the number (in base 2<sup>64</sup>). tIndex :: Length = 0_kIndex !> The digits of the number, i.e., the magnitude array. <br> !  Values are treated as unsigned integer tUInt64 , ALLOCATABLE :: Digit (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Private Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ApInt64_Add_I32 PROCEDURE , PRIVATE :: ApInt64_Add_I64 PROCEDURE , PRIVATE :: ApInt64_Add_I128 PROCEDURE , PRIVATE :: ApInt64_Add_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Subtract_I32 PROCEDURE , PRIVATE :: ApInt64_Subtract_I64 PROCEDURE , PRIVATE :: ApInt64_Subtract_I128 PROCEDURE , PRIVATE :: ApInt64_Subtract_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Times_I32 PROCEDURE , PRIVATE :: ApInt64_Times_I64 PROCEDURE , PRIVATE :: ApInt64_Times_I128 PROCEDURE , PRIVATE :: ApInt64_Times_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Over_I32 PROCEDURE , PRIVATE :: ApInt64_Over_I64 PROCEDURE , PRIVATE :: ApInt64_Over_I128 PROCEDURE , PRIVATE :: ApInt64_Over_ApInt64 PROCEDURE , PRIVATE :: ApInt64_DivMod_I32 PROCEDURE , PRIVATE :: ApInt64_DivMod_I64 PROCEDURE , PRIVATE :: ApInt64_DivMod_I128 PROCEDURE , PRIVATE :: ApInt64_DivMod_ApInt64 ! --------------------------------------------------------------------- ! -----                 Public Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Increment <br> !  **Purpose**:  To increase value of the ApInt64 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Increment() PROCEDURE :: Increment => ApInt64_Increment !> **Type-Bound Subroutine**: Decrement <br> !  **Purpose**:  To decrease value of the ApInt64 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Decrement() PROCEDURE :: Decrement => ApInt64_Decrement !> **Type-Bound Subroutine**: Square <br> !  **Purpose**:  To return the ApInt64 number (ApInt64) where its value is !                computed by: ApNum = ApNum * ApNum. <br> !  **Usage**: <br> !   --->    CALL ApNum%Square() PROCEDURE :: Square => ApInt64_SquareSub !> **Type-Bound Function**: Compare <br> !  **Purpose**:  To compare two ApInt64 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = LHS%Compare(RHS) <br> !   --->    IF (LHS%Compare(RHS) /= 0) DoSomething PROCEDURE :: Compare => ApInt64_Compare !> **Type-Bound Subroutine**: LShift <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%LShift(112) PROCEDURE :: LShift => ApInt64_LeftShift !> **Type-Bound Subroutine**: RShift <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%RShift(112) PROCEDURE :: RShift => ApInt64_RightShift !> **Type-Bound Function**: IsZero <br> !  **Purpose**:  To check whether the ApInt64 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsZero() <br> !   --->    IF (.NOT.ApNum%IsZero()) DoSomething PROCEDURE :: IsZero => ApInt64_Is_Zero_II !> **Type-Bound Function**: IsOne <br> !  **Purpose**:  To check whether the ApInt64 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsOne() <br> !   --->    IF (.NOT.ApNum%IsOne()) DoSomething PROCEDURE :: IsOne => ApInt64_Is_One !> **Type-Bound Function**: IsPositive <br> !  **Purpose**:  To check whether the ApInt64 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsPositive() <br> !   --->    IF (.NOT.ApNum%IsPositive()) DoSomething PROCEDURE :: IsPositive => ApInt64_Is_Positive !> **Type-Bound Function**: IsNegative <br> !  **Purpose**:  To check whether the ApInt64 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsNegative() <br> !   --->    IF (.NOT.ApNum%IsNegative()) DoSomething PROCEDURE :: IsNegative => ApInt64_Is_Negative !> **Type-Bound Subroutine**: RandNum <br> !  **Purpose**:  To generate the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    CALL ApNum%RandNum() <br> !   ! generate random number with specified PRNG <br> !   --->    CALL ApNum%RandNum(PRNG) <br> !   ! generate random number with negative value <br> !   --->    CALL ApNum%RandNum(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    CALL ApNum%RandNum(Length=MagLen) PROCEDURE :: RandNum => ApInt64_RandNumSub !> **Type-Bound Function**: Copy <br> !  **Purpose**:  To make a copy of the ApInt64 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt64 number <br> !   --->    DstApNum = SrcApNum%Copy() <br> !   ! make a copy of the ApInt64 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = SrcApNum%Copy(DstCap) PROCEDURE :: Copy => ApInt64_Copy !> **Type-Bound Subroutine**: Display <br> !  **Purpose**:  To write/display the 'ApInt64' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display() <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL ApNum%Display(11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL ApNum%Display(11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display(ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL ApNum%Display(Prefix='Signed value of ApNum') PROCEDURE :: Display => ApInt64_Write !> **Type-Bound Function**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = ApNum%GetLength() PROCEDURE :: GetLength => ApInt64_GetLength ! --------------------------------------------------------------------- ! -----                 Generic Interfaces                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Add <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%Add(Other) GENERIC :: Add => ApInt64_Add_I32 , ApInt64_Add_I64 , & ApInt64_Add_I128 , ApInt64_Add_ApInt64 !> **Type-Bound Subroutine**: Subtract <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%Subtract(Other) GENERIC :: Subtract => ApInt64_Subtract_I32 , ApInt64_Subtract_I64 , & ApInt64_Subtract_I128 , ApInt64_Subtract_ApInt64 !> **Type-Bound Subroutine**: Multiply <br> !  **Purpose**:  To perform a multiplication: This = This * Other. <br> !  **Usage**: <br> !   --->    CALL This%Multiply(Other) GENERIC :: Multiply => ApInt64_Times_I32 , ApInt64_Times_I64 , & ApInt64_Times_I128 , ApInt64_Times_ApInt64 !> **Type-Bound Subroutine**: Divide <br> !  **Purpose**:  To perform a division: This = This / Other.  Optionally, !                return the remainder if present. <br> !  **Usage**: <br> !   --->    CALL This%Divide(Other) <br> !   --->    CALL This%Divide(Other, Remainder) GENERIC :: Divide => ApInt64_Over_I32 , ApInt64_Over_I64 , & ApInt64_Over_I128 , ApInt64_Over_ApInt64 !> **Type-Bound Subroutine**: DivMod <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) GENERIC :: DivMod => ApInt64_DivMod_I32 , ApInt64_DivMod_I64 , & ApInt64_DivMod_I128 , ApInt64_DivMod_ApInt64 ! --------------------------------------------------------------------- ! -----                 Experimental Procedures                   ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddXp <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%AddXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. PROCEDURE :: AddXp => ApInt64_Add_Xp !> **Type-Bound Subroutine**: SubtractXp <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%SubtractXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. PROCEDURE :: SubtractXp => ApInt64_Subtract_Xp !> **Type-Bound Subroutine**: DivideXp <br> !  **Purpose**:  To perform a division: This = This / Other. <br> !  **Usage**: <br> !   --->    CALL This%DivideXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 5. PROCEDURE :: DivideXp => ApInt64_Over_Xp !> **Type-Bound Subroutine**: DivModXp <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivModXp(Denominator, Algorithm, Quotient, Remainder) <br> !  **Note**: Algorithm must be between 1 and 5. PROCEDURE :: DivModXp => ApInt64_DivMod_Xp ! --------------------------------------------------------------------- END TYPE ApInt64","tags":"","loc":"type\\apint64.html"},{"title":"Float128 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: Float128 Float128 is a derived type representing a signed quadruple-precision floating-point\n  number.  Internally, it consists of a logical variable representing its sign, two\n  64-bit integers representing its 128-bit significand, and a 32-bit integer representing\n  its (biased) exponent.  Its value ranges from approximately 6.67283E-646457032 to\n  1.76161E+646456993. Constructor public        interface Float128 Constructor Interface : Float128 Purpose :  To construct a Float128 number. Usage : ! construct from 32-bit intrinsic integer number --->    F128 = Float128(I32) ! construct from 64-bit intrinsic real number --->    F128 = Float128(R64) ! construct from a decimal string --->    I128 = Float128('1234567.890987654321011223344E-23132', ErrFlag, ErrMsg) private  interface Construct_Positive_Float128() Arguments None private  interface I32_To_Float128() Arguments None private  interface I64_To_Float128() Arguments None private  interface R32_To_Float128() Arguments None private  interface R64_To_Float128() Arguments None private  interface R128_To_Float128() Arguments None private  interface DecString_To_Float128() Arguments None Source Code TYPE Float128 PRIVATE tLogical :: Negative !! flag indicating whether the number is negative or not tSInt32 :: Exponent !! number representing the biased exponent tSInt64 :: MantHi !! number representing upper 64 bits of the significand tSInt64 :: MantLo !! number representing lower 64 bits of the significand END TYPE Float128","tags":"","loc":"type\\float128.html"},{"title":"ApInt32 – eXPerimental Fortran Library (XpfLib) Documentation ","text":"type, public :: ApInt32 ApInt32 is a mutable arbitrary-precision signed integer type where\n  its representations are as follows. - Base is 2 32 . - Magnitude is represented by the 'Digit' array in little-endian order. - The 'Length' first 'Digit' count as the ApInt32 number (i.e. it is always\n  less than or equal to the size/capacity of the 'Digit' array). - Sign is represented by a sign integer (-1 or 1). - Internally zero is allowed to have either sign.\n  (Otherwise one would have to remember to check for sign-swap for division,\n  multiplication etc...) - Zero can have many forms: -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through\n     ZeroApInt32()). -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number\n     is considered to be zero. Constructor public        interface ApInt32 Constructor Interface : ApInt32 Purpose :  To construct an ApInt32 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt32(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt32(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt32(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt32(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt32('-123456789098765432101122334455667788990012345') private module function Construct_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 32-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt32), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 32-bit integer array where\n the first element gives the least significant 32 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function Bytes_To_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function DecString_To_ApInt32(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt32 number based on the specified decimal string. Usage : ---> ApNum = ApInt32('1234567890987654321011223344') ---> ApNum = ApInt32('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt32(NumStr, ErrMsg=Message) ---> ApNum = ApInt32(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt32 ) number private module function U32_To_ApInt32(Sign, U32) result(Big) To construct the ApInt32 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U64_To_ApInt32(Sign, U64) result(Big) To construct the ApInt32 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U128_To_ApInt32(Sign, U128) result(Big) To construct the ApInt32 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function I32_To_ApInt32(I32) result(Big) To construct the ApInt32 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt32(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt32 ) private module function I64_To_ApInt32(I64) result(Big) To construct the ApInt32 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt32(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt32 ) private module function I128_To_ApInt32(I128) result(Big) To construct the ApInt32 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt32(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt32 ) private module function R32_To_ApInt32(R32) result(Big) To construct the ApInt32 number based on the specified 32-bit real number. Usage : ApNum = ApInt32(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt32 ) private module function R64_To_ApInt32(R64) result(Big) To construct the ApInt32 number based on the specified 64-bit real number. Usage : ApNum = ApInt32(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt32 ) private module function R128_To_ApInt32(R128) result(Big) To construct the ApInt32 number based on the specified 128-bit real number. Usage : ApNum = ApInt32(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt32 ) Type-Bound Procedures procedure, public :: Increment => ApInt32_Increment Type-Bound Subroutine : Increment Purpose :  To increase value of the ApInt32 number by one. Usage : --->    CALL ApNum%Increment() interface private module subroutine ApInt32_Increment(Val) To perform addition: Val = Val + 1. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: Val procedure, public :: Decrement => ApInt32_Decrement Type-Bound Subroutine : Decrement Purpose :  To decrease value of the ApInt32 number by one. Usage : --->    CALL ApNum%Decrement() interface private module subroutine ApInt32_Decrement(Val) To perform subtraction: Val = Val - 1. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: Val procedure, public :: Square => ApInt32_SquareSub Type-Bound Subroutine : Square Purpose :  To return the ApInt32 number (ApInt32) where its value is\n               computed by: ApNum = ApNum * ApNum. Usage : --->    CALL ApNum%Square() interface private module subroutine ApInt32_SquareSub(This) To perform self-multiplication: This = This * This. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: This procedure, public :: Compare => ApInt32_Compare Type-Bound Function : Compare Purpose :  To compare two ApInt32 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = LHS%Compare(RHS) --->    IF (LHS%Compare(RHS) /= 0) DoSomething interface private module function ApInt32_Compare(LHS, RHS) result(Flag) To compare two ApInt32 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value integer(kind=kInt32) procedure, public :: LShift => ApInt32_LeftShift Type-Bound Subroutine : LShift Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%LShift(112) interface private module subroutine ApInt32_LeftShift(Val, ShiftPos) To perform logical left shift with 0 <= ShiftPos <= 128. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: Val integer(kind=kInt32), intent(in) :: ShiftPos procedure, public :: RShift => ApInt32_RightShift Type-Bound Subroutine : RShift Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%RShift(112) interface private module subroutine ApInt32_RightShift(Val, ShiftPos) To perform logical right shift with 0 <= ShiftPos <= 128. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: Val integer(kind=kInt32), intent(in) :: ShiftPos procedure, public :: IsZero => ApInt32_Is_Zero_II Type-Bound Function : IsZero Purpose :  To check whether the ApInt32 number has value of zero or not. Usage : --->    Flag = ApNum%IsZero() --->    IF (.NOT.ApNum%IsZero()) DoSomething interface private module function ApInt32_Is_Zero_II(Big) result(Flag) To check whether the ApInt32 number has value of zero or not. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(inout) :: Big Return Value logical procedure, public :: IsOne => ApInt32_Is_One Type-Bound Function : IsOne Purpose :  To check whether the ApInt32 number has value of one or not. Usage : --->    Flag = ApNum%IsOne() --->    IF (.NOT.ApNum%IsOne()) DoSomething interface private module function ApInt32_Is_One(Big) result(Flag) To check whether the ApInt32 number has value of one or not. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Big Return Value logical procedure, public :: IsPositive => ApInt32_Is_Positive Type-Bound Function : IsPositive Purpose :  To check whether the ApInt32 number has positive value or not. Usage : --->    Flag = ApNum%IsPositive() --->    IF (.NOT.ApNum%IsPositive()) DoSomething interface private module function ApInt32_Is_Positive(Big) result(Flag) To check whether the ApInt32 number has positive value or not. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Big Return Value logical procedure, public :: IsNegative => ApInt32_Is_Negative Type-Bound Function : IsNegative Purpose :  To check whether the ApInt32 number has negative value or not. Usage : --->    Flag = ApNum%IsNegative() --->    IF (.NOT.ApNum%IsNegative()) DoSomething interface private module function ApInt32_Is_Negative(Big) result(Flag) To check whether the ApInt32 number has negative value or not. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Big Return Value logical procedure, public :: RandNum => ApInt32_RandNumSub Type-Bound Subroutine : RandNum Purpose :  To generate the ApIn64 number with random value. Usage : ! generate random number with default settings --->    CALL ApNum%RandNum() ! generate random number with specified PRNG --->    CALL ApNum%RandNum(PRNG) ! generate random number with negative value --->    CALL ApNum%RandNum(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    CALL ApNum%RandNum(Length=MagLen) interface private module subroutine ApInt32_RandNumSub(BigRnd, Prng, Positive, Length) To generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(out) :: BigRnd the ApInt32 number with random value class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array procedure, public :: Copy => ApInt32_Copy Type-Bound Function : Copy Purpose :  To make a copy of the ApInt32 number. Usage : ! make a copy of the ApInt32 number --->    DstApNum = SrcApNum%Copy() ! make a copy of the ApInt32 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = SrcApNum%Copy(DstCap) interface private module function ApInt32_Copy(Source, Capacity) result(Destination) To make a copy of the ApInt32 number. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Source the source number integer(kind=kInt32), intent(in), optional :: Capacity capacity (size of magnitude array) of the destination number if specified, must be greater than capacity of the source number Return Value type( ApInt32 ) the destination number procedure, public :: Display => ApInt32_Write Type-Bound Subroutine : Display Purpose :  To write/display the 'ApInt32' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL ApNum%Display() ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL ApNum%Display(11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL ApNum%Display(11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL ApNum%Display(ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL ApNum%Display(Prefix='Signed value of ApNum') interface private module subroutine ApInt32_Write(Big, Unit, IOStat, IOMsg, ShowComponent, Prefix) To write the ApInt32 number to the screen (or the specified unit). Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in), optional :: Unit output logical unit integer(kind=kInt32), intent(out), optional :: IOStat io stat character(kind=kChar, len=*), intent(out), optional :: IOMsg io message logical, intent(in), optional :: ShowComponent flag indicating whether to write the upper and lower components. - If flag is present and true, write components of the object. - Otherwise, write the object as a decimal string. character(kind=kChar, len=*), intent(in), optional :: Prefix prefix string procedure, public :: GetLength => ApInt32_GetLength Type-Bound Function : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = ApNum%GetLength() interface private module function ApInt32_GetLength(Num) result(Length) To return the number of digits counted as the ApNum number. Arguments Type Intent Optional Attributes Name class( ApInt32 ), intent(in) :: Num Return Value integer(kind=kInt32) the number of digits counted generic, public :: Add => ApInt32_Add_I32, ApInt32_Add_I64, ApInt32_Add_I128, ApInt32_Add_ApInt32 Type-Bound Subroutine : Add Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%Add(Other) private  interface ApInt32_Add_I32() Arguments None private  interface ApInt32_Add_I64() Arguments None private  interface ApInt32_Add_I128() Arguments None private  interface ApInt32_Add_ApInt32() Arguments None generic, public :: Subtract => ApInt32_Subtract_I32, ApInt32_Subtract_I64, ApInt32_Subtract_I128, ApInt32_Subtract_ApInt32 Type-Bound Subroutine : Subtract Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%Subtract(Other) private  interface ApInt32_Subtract_I32() Arguments None private  interface ApInt32_Subtract_I64() Arguments None private  interface ApInt32_Subtract_I128() Arguments None private  interface ApInt32_Subtract_ApInt32() Arguments None generic, public :: Multiply => ApInt32_Times_I32, ApInt32_Times_I64, ApInt32_Times_I128, ApInt32_Times_ApInt32 Type-Bound Subroutine : Multiply Purpose :  To perform a multiplication: This = This * Other. Usage : --->    CALL This%Multiply(Other) private  interface ApInt32_Times_I32() Arguments None private  interface ApInt32_Times_I64() Arguments None private  interface ApInt32_Times_I128() Arguments None private  interface ApInt32_Times_ApInt32() Arguments None generic, public :: Divide => ApInt32_Over_I32, ApInt32_Over_I64, ApInt32_Over_I128, ApInt32_Over_ApInt32 Type-Bound Subroutine : Divide Purpose :  To perform a division: This = This / Other.  Optionally,\n               return the remainder if present. Usage : --->    CALL This%Divide(Other) --->    CALL This%Divide(Other, Remainder) private  interface ApInt32_Over_I32() Arguments None private  interface ApInt32_Over_I64() Arguments None private  interface ApInt32_Over_I128() Arguments None private  interface ApInt32_Over_ApInt32() Arguments None generic, public :: DivMod => ApInt32_DivMod_I32, ApInt32_DivMod_I64, ApInt32_DivMod_I128, ApInt32_DivMod_ApInt32 Type-Bound Subroutine : DivMod Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) private  interface ApInt32_DivMod_I32() Arguments None private  interface ApInt32_DivMod_I64() Arguments None private  interface ApInt32_DivMod_I128() Arguments None private  interface ApInt32_DivMod_ApInt32() Arguments None Source Code TYPE ApInt32 PRIVATE !> The sign of this number. <br> ! -> +1 for positive numbers and -1 for negative numbers. <br> ! -> Zero can have either sign. tSInt32 :: Sign = 1 !% The number of digits of the number (in base 2<sup>64</sup>). tIndex :: Length = 0_kIndex !> The digits of the number, i.e., the magnitude array. <br> !  Values are treated as unsigned integer tUInt32 , ALLOCATABLE :: Digit (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Private Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ApInt32_Add_I32 PROCEDURE , PRIVATE :: ApInt32_Add_I64 PROCEDURE , PRIVATE :: ApInt32_Add_I128 PROCEDURE , PRIVATE :: ApInt32_Add_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Subtract_I32 PROCEDURE , PRIVATE :: ApInt32_Subtract_I64 PROCEDURE , PRIVATE :: ApInt32_Subtract_I128 PROCEDURE , PRIVATE :: ApInt32_Subtract_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Times_I32 PROCEDURE , PRIVATE :: ApInt32_Times_I64 PROCEDURE , PRIVATE :: ApInt32_Times_I128 PROCEDURE , PRIVATE :: ApInt32_Times_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Over_I32 PROCEDURE , PRIVATE :: ApInt32_Over_I64 PROCEDURE , PRIVATE :: ApInt32_Over_I128 PROCEDURE , PRIVATE :: ApInt32_Over_ApInt32 PROCEDURE , PRIVATE :: ApInt32_DivMod_I32 PROCEDURE , PRIVATE :: ApInt32_DivMod_I64 PROCEDURE , PRIVATE :: ApInt32_DivMod_I128 PROCEDURE , PRIVATE :: ApInt32_DivMod_ApInt32 ! --------------------------------------------------------------------- ! -----                 Public Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Increment <br> !  **Purpose**:  To increase value of the ApInt32 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Increment() PROCEDURE :: Increment => ApInt32_Increment !> **Type-Bound Subroutine**: Decrement <br> !  **Purpose**:  To decrease value of the ApInt32 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Decrement() PROCEDURE :: Decrement => ApInt32_Decrement !> **Type-Bound Subroutine**: Square <br> !  **Purpose**:  To return the ApInt32 number (ApInt32) where its value is !                computed by: ApNum = ApNum * ApNum. <br> !  **Usage**: <br> !   --->    CALL ApNum%Square() PROCEDURE :: Square => ApInt32_SquareSub !> **Type-Bound Function**: Compare <br> !  **Purpose**:  To compare two ApInt32 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = LHS%Compare(RHS) <br> !   --->    IF (LHS%Compare(RHS) /= 0) DoSomething PROCEDURE :: Compare => ApInt32_Compare !> **Type-Bound Subroutine**: LShift <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%LShift(112) PROCEDURE :: LShift => ApInt32_LeftShift !> **Type-Bound Subroutine**: RShift <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%RShift(112) PROCEDURE :: RShift => ApInt32_RightShift !> **Type-Bound Function**: IsZero <br> !  **Purpose**:  To check whether the ApInt32 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsZero() <br> !   --->    IF (.NOT.ApNum%IsZero()) DoSomething PROCEDURE :: IsZero => ApInt32_Is_Zero_II !> **Type-Bound Function**: IsOne <br> !  **Purpose**:  To check whether the ApInt32 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsOne() <br> !   --->    IF (.NOT.ApNum%IsOne()) DoSomething PROCEDURE :: IsOne => ApInt32_Is_One !> **Type-Bound Function**: IsPositive <br> !  **Purpose**:  To check whether the ApInt32 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsPositive() <br> !   --->    IF (.NOT.ApNum%IsPositive()) DoSomething PROCEDURE :: IsPositive => ApInt32_Is_Positive !> **Type-Bound Function**: IsNegative <br> !  **Purpose**:  To check whether the ApInt32 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsNegative() <br> !   --->    IF (.NOT.ApNum%IsNegative()) DoSomething PROCEDURE :: IsNegative => ApInt32_Is_Negative !> **Type-Bound Subroutine**: RandNum <br> !  **Purpose**:  To generate the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    CALL ApNum%RandNum() <br> !   ! generate random number with specified PRNG <br> !   --->    CALL ApNum%RandNum(PRNG) <br> !   ! generate random number with negative value <br> !   --->    CALL ApNum%RandNum(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    CALL ApNum%RandNum(Length=MagLen) PROCEDURE :: RandNum => ApInt32_RandNumSub !> **Type-Bound Function**: Copy <br> !  **Purpose**:  To make a copy of the ApInt32 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt32 number <br> !   --->    DstApNum = SrcApNum%Copy() <br> !   ! make a copy of the ApInt32 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = SrcApNum%Copy(DstCap) PROCEDURE :: Copy => ApInt32_Copy !> **Type-Bound Subroutine**: Display <br> !  **Purpose**:  To write/display the 'ApInt32' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display() <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL ApNum%Display(11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL ApNum%Display(11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display(ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL ApNum%Display(Prefix='Signed value of ApNum') PROCEDURE :: Display => ApInt32_Write !> **Type-Bound Function**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = ApNum%GetLength() PROCEDURE :: GetLength => ApInt32_GetLength ! --------------------------------------------------------------------- ! -----                 Generic Interfaces                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Add <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%Add(Other) GENERIC :: Add => ApInt32_Add_I32 , ApInt32_Add_I64 , & ApInt32_Add_I128 , ApInt32_Add_ApInt32 !> **Type-Bound Subroutine**: Subtract <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%Subtract(Other) GENERIC :: Subtract => ApInt32_Subtract_I32 , ApInt32_Subtract_I64 , & ApInt32_Subtract_I128 , ApInt32_Subtract_ApInt32 !> **Type-Bound Subroutine**: Multiply <br> !  **Purpose**:  To perform a multiplication: This = This * Other. <br> !  **Usage**: <br> !   --->    CALL This%Multiply(Other) GENERIC :: Multiply => ApInt32_Times_I32 , ApInt32_Times_I64 , & ApInt32_Times_I128 , ApInt32_Times_ApInt32 !> **Type-Bound Subroutine**: Divide <br> !  **Purpose**:  To perform a division: This = This / Other.  Optionally, !                return the remainder if present. <br> !  **Usage**: <br> !   --->    CALL This%Divide(Other) <br> !   --->    CALL This%Divide(Other, Remainder) GENERIC :: Divide => ApInt32_Over_I32 , ApInt32_Over_I64 , & ApInt32_Over_I128 , ApInt32_Over_ApInt32 !> **Type-Bound Subroutine**: DivMod <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) GENERIC :: DivMod => ApInt32_DivMod_I32 , ApInt32_DivMod_I64 , & ApInt32_DivMod_I128 , ApInt32_DivMod_ApInt32 ! --------------------------------------------------------------------- END TYPE ApInt32","tags":"","loc":"type\\apint32.html"},{"title":"ZeroApInt64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function ZeroApInt64() result(Big) Arguments None Return Value type( ApInt64 ) Description To return the ApInt64 number with value of zero.","tags":"","loc":"interface\\zeroapint64.html"},{"title":"OneApInt64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function OneApInt64() result(Big) Arguments None Return Value type( ApInt64 ) Description To return the ApInt64 number with value of one.","tags":"","loc":"interface\\oneapint64.html"},{"title":"ASSIGNMENT(=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between the ApInt64 type and a signed integer\n      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). Usage : ! convert 64-bit signed integer to the ApInt64 type --->    ApNum = I64 ! convert the ApInt64 type to 128-bit signed integer --->    I128 = ApNum Subroutines private module subroutine ApInt64_Assign(This, Other) To make a copy of the ApInt64 number via an assignment expression. Usage : This = Other Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: This type( ApInt64 ), intent(in) :: Other private module subroutine ApInt64_From_I32(Big, I32) To convert from a 32-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big integer(kind=kInt32), intent(in) :: I32 private module subroutine ApInt64_From_I64(Big, I64) To convert from a 64-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big integer(kind=kInt64), intent(in) :: I64 private module subroutine ApInt64_From_I128(Big, I128) To convert from a 128-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big type(SInt128), intent(in) :: I128 private module subroutine ApInt64_To_I32(I32, Big) To convert from an ApInt64 number to a 32-bit signed integer\n via an assignment expression. Usage : I32 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: I32 type( ApInt64 ), intent(in) :: Big private module subroutine ApInt64_To_I64(I64, Big) To convert from an ApInt64 number to a 64-bit signed integer\n via an assignment expression. Usage : I64 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: I64 type( ApInt64 ), intent(in) :: Big private module subroutine ApInt64_To_I128(I128, Big) To convert from an ApInt64 number to a 128-bit signed integer\n via an assignment expression. Usage : I128 = Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(out) :: I128 type( ApInt64 ), intent(in) :: Big","tags":"","loc":"interface\\assignment(=).html"},{"title":"ApInt64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ApInt64 Constructor Interface : ApInt64 Purpose :  To construct an ApInt64 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt64(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt64(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt64(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt64(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt64('-123456789098765432101122334455667788990012345') Functions private module function Construct_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 64-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt64), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 64-bit integer array where\n the first element gives the least significant 64 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function Bytes_To_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function DecString_To_ApInt64(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt64 number based on the specified decimal string. Usage : ---> ApNum = ApInt64('1234567890987654321011223344') ---> ApNum = ApInt64('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt64(NumStr, ErrMsg=Message) ---> ApNum = ApInt64(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt64 ) number private module function U32_To_ApInt64(Sign, U32) result(Big) To construct the ApInt64 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U64_To_ApInt64(Sign, U64) result(Big) To construct the ApInt64 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U128_To_ApInt64(Sign, U128) result(Big) To construct the ApInt64 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function I32_To_ApInt64(I32) result(Big) To construct the ApInt64 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt64(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt64 ) private module function I64_To_ApInt64(I64) result(Big) To construct the ApInt64 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt64(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt64 ) private module function I128_To_ApInt64(I128) result(Big) To construct the ApInt64 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt64(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt64 ) private module function R32_To_ApInt64(R32) result(Big) To construct the ApInt64 number based on the specified 32-bit real number. Usage : ApNum = ApInt64(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt64 ) private module function R64_To_ApInt64(R64) result(Big) To construct the ApInt64 number based on the specified 64-bit real number. Usage : ApNum = ApInt64(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt64 ) private module function R128_To_ApInt64(R128) result(Big) To construct the ApInt64 number based on the specified 128-bit real number. Usage : ApNum = ApInt64(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt64 )","tags":"","loc":"interface\\apint64.html"},{"title":"ToBytes – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToBytes Subroutine Interface : ToBytes Purpose :  To convert an ApInt64 number to a 8-bit integer magnitude\n  array and its sign. Usage : ---> CALL ToBytes(ApNum, MagArray, Sign) Subroutines private module subroutine Bytes_From_ApInt64(Big, Digit, Sign) To convert an ApInt64 number to a 8-bit integer magnitude array and its sign. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt8), intent(out), ALLOCATABLE :: Digit (:) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) integer(kind=kInt32), intent(out), optional :: Sign sign of the number","tags":"","loc":"interface\\tobytes.html"},{"title":"ToU32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU32 Function Interface : ToU32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit unsigned integer. Usage : --->    U32 = ToU32(ApNum) Functions private module function U32_From_ApInt64(Big) result(U32) To convert the ApInt64 number to a 32-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as unsigned","tags":"","loc":"interface\\tou32.html"},{"title":"ToU64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU64 Function Interface : ToU64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit unsigned integer. Usage : --->    U64 = ToU64(ApNum) Functions private module function U64_From_ApInt64(Big) result(U64) To convert the ApInt64 number to a 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as unsigned","tags":"","loc":"interface\\tou64.html"},{"title":"ToU128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU128 Function Interface : ToU128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit unsigned integer. Usage : --->    U128 = ToU128(ApNum) Functions private module function U128_From_ApInt64(Big) result(U128) To convert the ApInt64 number to a 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value type(UInt128) a 128-bit unsigned integer","tags":"","loc":"interface\\tou128.html"},{"title":"ToI32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI32 Function Interface : ToI32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit signed integer. Usage : --->    I32 = ToI32(ApNum) Functions private module function I32_From_ApInt64(Big) result(I32) To convert the ApInt64 number to a 32-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as signed","tags":"","loc":"interface\\toi32.html"},{"title":"ToI64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI64 Function Interface : ToI64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit signed integer. Usage : --->    I64 = ToI64(ApNum) Functions private module function I64_From_ApInt64(Big) result(I64) To convert the ApInt64 number to a 64-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as signed","tags":"","loc":"interface\\toi64.html"},{"title":"ToI128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI128 Function Interface : ToI128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit signed integer. Usage : --->    I128 = ToI128(ApNum) Functions private module function I128_From_ApInt64(Big) result(I128) To convert the ApInt64 number to a 128-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value type(SInt128) a 128-bit signed integer","tags":"","loc":"interface\\toi128.html"},{"title":"ToR32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR32 Function Interface : ToR32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit real number. Usage : --->    R32 = ToR32(ApNum) Functions private module function R32_From_ApInt64(Big) result(R32) To convert the ApInt64 number to a 32-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kSingle)","tags":"","loc":"interface\\tor32.html"},{"title":"ToR64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR64 Function Interface : ToR64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit real number. Usage : --->    R64 = ToR64(ApNum) Functions private module function R64_From_ApInt64(Big) result(R64) To convert the ApInt64 number to a 64-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kDouble)","tags":"","loc":"interface\\tor64.html"},{"title":"ToR128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR128 Function Interface : ToR128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit real number. Usage : --->    R128 = ToR128(ApNum) Functions private module function R128_From_ApInt64(Big) result(R128) To convert the ApInt64 number to a 128-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kQuad)","tags":"","loc":"interface\\tor128.html"},{"title":"ToDecString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToDecString Function Interface : ToDecString Purpose :  To convert an arbitrary-precision signed integer to\n  a decimal string. Usage : --->    Str = ToDecString(ApNum) Functions private module function DecString_From_ApInt64(Big) result(Str) To convert an arbitrary-precision signed integer to a decimal string. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value character(kind=kChar, len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstring.html"},{"title":"OPERATOR(==) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two ApInt64 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Functions private module function ApInt64_Equal(LHS, RHS) result(Flag) To check whether two ApInt64 numbers are equal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(==).html"},{"title":"OPERATOR(/=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two ApInt64 numbers are NOT equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Functions private module function ApInt64_NotEqual(LHS, RHS) result(Flag) To check whether two ApInt64 numbers NOT are equal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(SLASH=).html"},{"title":"OPERATOR(<) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething Functions private module function ApInt64_LessThan(LHS, RHS) result(Flag) To check whether the LHS number is less than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt).html"},{"title":"OPERATOR(<=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething Functions private module function ApInt64_LessEqual(LHS, RHS) result(Flag) To check whether the LHS number is less than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt=).html"},{"title":"OPERATOR(>) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething Functions private module function ApInt64_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS number is greater than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt).html"},{"title":"OPERATOR(>=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething Functions private module function ApInt64_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS number is greater than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt=).html"},{"title":"Compare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Compare Function Interface : Compare Purpose :  To compare two ApInt64 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething Module Procedures private  interface ApInt64_Compare() Arguments None","tags":"","loc":"interface\\compare.html"},{"title":"OPERATOR(+) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers (at least one\n               of which is a ApInt64 number) or to add a unary plus sign\n               to a ApInt64 number. Usage : --->    OutNum = +InNum --->    OutNum = InNum1 + InNum2 Functions private module function ApInt64_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 ) private module function ApInt64_Plus_ApInt64(LhsVal, RhsVal) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Plus_I32(Big, I32) result(OutVal) To perform addition: OutVal = Big + I32. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Plus_ApInt64(I32, Big) result(OutVal) To perform addition: OutVal = I32 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Plus_I64(Big, I64) result(OutVal) To perform addition: OutVal = Big + I64. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Plus_ApInt64(I64, Big) result(OutVal) To perform addition: OutVal = I64 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Plus_I128(Big, I128) result(OutVal) To perform addition: OutVal = Big + I128. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Plus_ApInt64(I128, Big) result(OutVal) To perform addition: OutVal = I128 + Big. Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 )","tags":"","loc":"interface\\operator(+).html"},{"title":"OPERATOR(-) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers (at least one\n               of which is a ApInt64 number) or to negate a ApInt64 number. Usage : --->    OutNum = -InNum --->    OutNum = InNum1 - InNum2 Functions private module function ApInt64_Negate(InVal) result(OutVal) To negate a ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 ) private module function ApInt64_Minus_ApInt64(LhsVal, RhsVal) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Minus_I32(Big, I32) result(OutVal) To perform subtraction: OutVal = Big - I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Minus_ApInt64(I32, Big) result(OutVal) To perform subtraction: OutVal = I32 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Minus_I64(Big, I64) result(OutVal) To perform subtraction: OutVal = Big - I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Minus_ApInt64(I64, Big) result(OutVal) To perform subtraction: OutVal = I64 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Minus_I128(Big, I128) result(OutVal) To perform subtraction: OutVal = Big - I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Minus_ApInt64(I128, Big) result(OutVal) To perform subtraction: OutVal = I128 - Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 )","tags":"","loc":"interface\\operator(-).html"},{"title":"OPERATOR(*) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one\n               of which is a ApInt64 number). Usage : --->    OutNum = InNum1 * InNum2 Functions private module function ApInt64_Multiply_ApInt64(LhsVal, RhsVal) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Multiply_I32(Big, I32) result(OutVal) To perform multiplication: OutVal = Big * I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Multiply_ApInt64(I32, Big) result(OutVal) To perform multiplication: OutVal = I32 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Multiply_I64(Big, I64) result(OutVal) To perform multiplication: OutVal = Big * I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Multiply_ApInt64(I64, Big) result(OutVal) To perform multiplication: OutVal = I64 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Multiply_I128(Big, I128) result(OutVal) To perform multiplication: OutVal = Big * I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Multiply_ApInt64(I128, Big) result(OutVal) To perform multiplication: OutVal = I128 * Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 )","tags":"","loc":"interface\\operator(ASTERISK).html"},{"title":"OPERATOR(/) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n               where the dividend (numerator) is a ApInt64 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Quotient = Dividend / Divisor Functions private module function ApInt64_Divide_ApInt64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I128(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt64 )","tags":"","loc":"interface\\operator(SLASH).html"},{"title":"MOD – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n               where the dividend (numerator) is a ApInt64 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Remainder = MOD(Dividend, Divisor) Functions private module function ApInt64_Mod_ApInt64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt64 )","tags":"","loc":"interface\\mod.html"},{"title":"MODULO – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MODULO Function Interface : MODULO Purpose :  To compute the modulo of two ApInt64 numbers. Usage : --->    Modulo = MODULO(Dividend, Divisor) Functions private module function ApInt64_Modulo(Dividend, Divisor) result(Modulo) To compute the modulo of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 )","tags":"","loc":"interface\\modulo.html"},{"title":"OPERATOR(**) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(**) Operator Overload : OPERATOR( ** ) Purpose :  To perform an exponentiation of the ApInt64 number. Usage : --->    NumOut = NumIn**Exp Functions private module function ApInt64_Power(BigIn, Exp) result(BigOut) To perform an exponentiation: BigOut = BigIn**Exp Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: BigIn integer(kind=kInt32), intent(in) :: Exp Return Value type( ApInt64 )","tags":"","loc":"interface\\operator(ASTERISKASTERISK).html"},{"title":"SQR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SQR Function Interface : SQR Purpose :  To compute the square of the ApInt64 number. Usage : --->    NumSqr = SQR(ApNum) Functions private module function ApInt64_Square(BigIn) result(BigOut) To perform squaring: BigOut = BigIn * BigIn. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: BigIn Return Value type( ApInt64 )","tags":"","loc":"interface\\sqr.html"},{"title":"SHIFTL – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTL(NumIn, 157) Functions private module function ApInt64_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 )","tags":"","loc":"interface\\shiftl.html"},{"title":"SHIFTR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTR(NumIn, 141) Functions private module function ApInt64_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 )","tags":"","loc":"interface\\shiftr.html"},{"title":"ISHFT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift of an ApInt64 number. Usage : --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 Functions private module function ApInt64_LogicalShift(InVal, ShiftPos) result(OutVal) To perform logical shift of an ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 )","tags":"","loc":"interface\\ishft.html"},{"title":"NOT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement an ApInt64 number. Usage : --->    NumOut = NOT(NumIn) Functions private module function ApInt64_Not(InVal) result(OutVal) To return the bitwise logical complement an ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 )","tags":"","loc":"interface\\not.html"},{"title":"IOR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IOR(NumIn1, NumIn2) Functions private module function ApInt64_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 )","tags":"","loc":"interface\\ior.html"},{"title":"IEOR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IEOR(NumIn1, NumIn2) Functions private module function ApInt64_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 )","tags":"","loc":"interface\\ieor.html"},{"title":"IAND – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IAND(NumIn1, NumIn2) Functions private module function ApInt64_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 )","tags":"","loc":"interface\\iand.html"},{"title":"IAND_NOT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IAND_NOT Function Interface : IAND_NOT Purpose :  To perform a bitwise AND and NOT on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IAND_NOT(NumIn1, NumIn2) Note : IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). Functions private module function ApInt64_IandNot(LhsVal, RhsVal) result(OutVal) To perform a bitwise AND and NOT on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 )","tags":"","loc":"interface\\iand_not.html"},{"title":"LEADZ – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the ApInt64 number. Usage : --->    NumLZ = LEADZ(ApNum) Functions private module function ApInt64_LeadingZeros(Big) result(NumLZ) To count the number of leading zero bits of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\leadz.html"},{"title":"TRAILZ – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the ApInt64 number. Usage : --->    NumTZ = TRAILZ(ApNum) Functions private module function ApInt64_TrailingZeros(Big) result(NumTZ) To count the number of trailing zero bits of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\trailz.html"},{"title":"POPCNT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the ApInt64 number. Usage : --->    NumBits = POPCNT(ApNum) Functions private module function ApInt64_Count1Bits(Big) result(NumBits) To count the number of 1 bits in the ApInt64 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\popcnt.html"},{"title":"POPPAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the ApInt64 number. Usage : --->    NumPar = POPPAR(ApNum) Functions private module function ApInt64_Parity(Big) result(ParNum) To determine the parity of the ApInt64 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\poppar.html"},{"title":"IBSET – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1. Usage : --->    NumOut = IBSET(NumIn, Pos) Functions private module function ApInt64_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 )","tags":"","loc":"interface\\ibset.html"},{"title":"IBCLR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0. Usage : --->    NumOut = IBCLR(NumIn, Pos) Functions private module function ApInt64_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 )","tags":"","loc":"interface\\ibclr.html"},{"title":"IBCHNG – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position. Usage : --->    NumOut = IBCHNG(NumIn, Pos) Functions private module function ApInt64_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 )","tags":"","loc":"interface\\ibchng.html"},{"title":"BTEST – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position\n               is 0 (False) or 1 (True). Usage : --->    Flag = BTEST(ApNum, Pos) Functions private module function ApInt64_TestBit(Big, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True).\n (For more information, see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Pos Return Value logical","tags":"","loc":"interface\\btest.html"},{"title":"ABS – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ABS Function Interface : ABS Purpose :  To return the absolute value of the ApInt64 number. Usage : --->    AbsNum = ABS(ApNum) Module Procedures private  function ApInt64_Absolute(Num) result(Abs) To get the absolute value of the specified number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Num Return Value type( ApInt64 )","tags":"","loc":"interface\\abs.html"},{"title":"IsZero – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsZero Function Interface : IsZero Purpose :  To check whether the ApInt64 number has value of zero or not. Usage : --->    Flag = IsZero(ApNum) --->    IF (IsZero(ApNum)) DoSomeThing Module Procedures private  function ApInt64_Is_Zero(Big) result(Flag) To check whether the number is zero or not. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value logical true if value is zero.","tags":"","loc":"interface\\iszero.html"},{"title":"IsOne – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsOne Function Interface : IsOne Purpose :  To check whether the ApInt64 number has value of one or not. Usage : --->    Flag = IsOne(ApNum) --->    IF (IsOne(ApNum)) DoSomeThing Module Procedures private  interface ApInt64_Is_One() Arguments None","tags":"","loc":"interface\\isone.html"},{"title":"IsPositive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsPositive Function Interface : IsPositive Purpose :  To check whether the ApInt64 number has positive value or not. Usage : --->    Flag = IsPositive(ApNum) --->    IF (IsPositive(ApNum)) DoSomeThing Module Procedures private  interface ApInt64_Is_Positive() Arguments None","tags":"","loc":"interface\\ispositive.html"},{"title":"IsNegative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsNegative Function Interface : IsNegative Purpose :  To check whether the ApInt64 number has negative value or not. Usage : --->    Flag = IsNegative(ApNum) --->    IF (IsNegative(ApNum)) DoSomeThing Module Procedures private  interface ApInt64_Is_Negative() Arguments None","tags":"","loc":"interface\\isnegative.html"},{"title":"RandNumApInt64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RandNumApInt64 Functions private module function ApInt64_Random_Number(Prng, Positive, Length) result(BigRnd) Function Interface : RandNumApInt64 Purpose :  To generate and return the ApIn64 number with random value. Usage : ! generate random number with default settings --->    ApNum = RandNumApInt64() ! generate random number with specified PRNG --->    ApNum = RandNumApInt64(PRNG) ! generate random number with negative value --->    ApNum = RandNumApInt64(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    ApNum = RandNumApInt64(Length=MagLen)\nTo generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array Return Value type( ApInt64 ) the ApInt64 number with random value","tags":"","loc":"interface\\randnumapint64.html"},{"title":"Display – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Display Subroutine Interface : Display Purpose :  To write/display the 'ApInt64' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL Display(ApNum) ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL Display(ApNum, 11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL Display(ApNum, 11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL Display(ApNum, ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL Display(ApNum, Prefix='Signed value of ApNum') Module Procedures private  interface ApInt64_Write() Arguments None","tags":"","loc":"interface\\display.html"},{"title":"MakeCopy – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MakeCopy Function Interface : Copy Purpose :  To make a copy of the ApInt64 number. Usage : ! make a copy of the ApInt64 number --->    DstApNum = MakeCopy(SrcApNum) ! make a copy of the ApInt64 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = MakeCopy(SrcApNum, DstCap) Module Procedures private  interface ApInt64_Copy() Arguments None","tags":"","loc":"interface\\makecopy.html"},{"title":"GetLength – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface GetLength Function Interface : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = GetLength(ApNum) Module Procedures private  interface ApInt64_GetLength() Arguments None","tags":"","loc":"interface\\getlength.html"},{"title":"AddXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface AddXp Function Interface : AddXp Purpose :  To perform an addition: OutVal = LhsVal + RhsVal. Usage : --->    OutVal = AddXp(LhsVal, RhsVal, Algorithm) Note : Algorithm must be between 1 and 3. Functions private module function ApInt64_Plus_Xp(LhsVal, RhsVal, Algorithm) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 )","tags":"","loc":"interface\\addxp.html"},{"title":"SubtractXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SubtractXp Function Interface : SubtractXp Purpose :  To perform a subtraction: OutVal = LhsVal - RhsVal. Usage : --->    OutVal = SubtractXp(LhsVal, RhsVal, Algorithm) Note : Algorithm must be between 1 and 3. Functions private module function ApInt64_Minus_Xp(LhsVal, RhsVal, Algorithm) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 )","tags":"","loc":"interface\\subtractxp.html"},{"title":"MultiplyXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MultiplyXp Function Interface : MultiplyXp Purpose :  To perform a multiplication: OutVal = LhsVal * RhsVal. Usage : --->    OutVal = MultiplyXp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) Note : Algorithm must be between 1 and 6. Functions private module function ApInt64_Multiply_Xp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal.  Valid value of Algorithm is between 1 and 6. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: KThreshold Threshold to perform Karatsuba algorithm.  If the 'Length' components of\n  both LhsVal and RhsVal are greater than the threshold, use Karatsuba algorithm.  Otherwise, use basic (grade-school) algorithm. integer(kind=kInt32), intent(in) :: BaseCut Threshold to perform basic algorithm when using the Karatsuba algorithm. BaseCut must be less than KThreshold . integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 )","tags":"","loc":"interface\\multiplyxp.html"},{"title":"DivideXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface DivideXp Function Interface : DivideXp Purpose :  To perform a division: Quotient = Dividend / Divisor. Usage : --->    Quotient = DivideXp(Dividend, Divisor, Algorithm) Note : Algorithm must be between 1 and 5. Functions private module function ApInt64_Divide_Xp(Dividend, Divisor, Algorithm) result(Quotient) To perform division: Quotient = Dividend / Divisor.  Valid value of Algorithm is between 1 and 5. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 )","tags":"","loc":"interface\\dividexp.html"},{"title":"ModXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ModXp Function Interface : ModXp Purpose :  To perform modulation: Remainder = Dividend Mod Divisor. Usage : --->    Remainder = ModXp(Dividend, Divisor, Algorithm) Note : Algorithm must be between 1 and 5. Functions private module function ApInt64_Mod_Xp(Dividend, Divisor, Algorithm) result(Remainder) To perform modulation: Remainder = Dividend Mod Divisor.  Valid value of Algorithm is between 1 and 5. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 )","tags":"","loc":"interface\\modxp.html"},{"title":"FromStringXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface FromStringXp Function Interface : FromStringXp Purpose :  To construct the ApInt64 number based on the specified decimal\n               string.  Valid value of Algorithm is between 1 and 4. Usage : ---> ApNum = FromStringXp('1234567890987654321011223344', Algorithm) ---> ApNum = FromStringXp('-987654321012345678900123123', Algorithm, ErrFlag) ---> ApNum = FromStringXp(NumStr, 1, ErrMsg=Message) ---> ApNum = FromStringXp(NumStr, 4, ErrFlag, ErrMsg) Functions private module function FromString_Xp(cStr, Algorithm, ErrFlag, ErrMsg) result(Big) To construct the ApInt64 number based on the specified decimal string.\n Valid value of Algorithm is between 1 and 4. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string integer(kind=kInt32), intent(in) :: Algorithm logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt64 ) number","tags":"","loc":"interface\\fromstringxp.html"},{"title":"ToStringXp – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToStringXp Function Interface : ToStringXp Purpose :  To convert an arbitrary-precision signed integer to a decimal\n               string.  Valid value of Algorithm is between 1 and 7. Usage : --->    Str = ToStringXp(ApNum, Algorithm) Functions private module function ToString_Xp(Big, Algorithm) result(Str) To convert an arbitrary-precision signed integer to a decimal string.\n Valid value of Algorithm is between 1 and 7. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Algorithm Return Value character(kind=kChar, len=:), ALLOCATABLE","tags":"","loc":"interface\\tostringxp.html"},{"title":"ASSIGNMENT(=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a Float128 number and an other real number. Usage : ! convert 32-bit real number (Fortran intrinsic type) to the Float128 number --->    F128 = R32 ! convert the Float128 number to 128-bit real number (Fortran intrinsic type) --->    R128 = F128 Module Procedures private  interface Float128_Assign() Arguments None private  interface Float128_From_R32() Arguments None private  interface Float128_From_R64() Arguments None private  interface Float128_From_R128() Arguments None private  interface Float128_To_R32() Arguments None private  interface Float128_To_R64() Arguments None private  interface Float128_To_R128() Arguments None","tags":"","loc":"interface\\assignment(=)~2.html"},{"title":"Float128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Float128 Constructor Interface : Float128 Purpose :  To construct a Float128 number. Usage : ! construct from 32-bit intrinsic integer number --->    F128 = Float128(I32) ! construct from 64-bit intrinsic real number --->    F128 = Float128(R64) ! construct from a decimal string --->    I128 = Float128('1234567.890987654321011223344E-23132', ErrFlag, ErrMsg) Module Procedures private  interface Construct_Positive_Float128() Arguments None private  interface I32_To_Float128() Arguments None private  interface I64_To_Float128() Arguments None private  interface R32_To_Float128() Arguments None private  interface R64_To_Float128() Arguments None private  interface R128_To_Float128() Arguments None private  interface DecString_To_Float128() Arguments None","tags":"","loc":"interface\\float128.html"},{"title":"ToI32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI32 Function Interface : ToI32 Purpose :  To convert a Float128 number to a 32-bit integer number. Usage : --->    I32 = ToI32(F128) Module Procedures private  interface I32_From_Float128() Arguments None","tags":"","loc":"interface\\toi32~2.html"},{"title":"ToI64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI64 Function Interface : ToI64 Purpose :  To convert a Float128 number to a 64-bit integer number. Usage : --->    I64 = ToI64(F128) Module Procedures private  interface I64_From_Float128() Arguments None","tags":"","loc":"interface\\toi64~2.html"},{"title":"ToR32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR32 Function Interface : ToR32 Purpose :  To convert a Float128 number to a 32-bit real number. Usage : --->    R32 = ToR32(F128) Module Procedures private  interface R32_From_Float128() Arguments None","tags":"","loc":"interface\\tor32~2.html"},{"title":"ToR64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR64 Function Interface : ToR64 Purpose :  To convert a Float128 number to a 64-bit real number. Usage : --->    R64 = ToR64(F128) Module Procedures private  interface R64_From_Float128() Arguments None","tags":"","loc":"interface\\tor64~2.html"},{"title":"ToR128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR128 Function Interface : ToR128 Purpose :  To convert a Float128 number to a 128-bit real number. Usage : --->    R128 = ToR128(F128) Module Procedures private  interface R128_From_Float128() Arguments None","tags":"","loc":"interface\\tor128~2.html"},{"title":"ToDecString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToDecString Function Interface : ToDecString Purpose :  To convert a Float128 number to a decimal string. Usage : --->    Str = ToDecString(F128) Module Procedures private  interface DecString_From_Float128() Arguments None","tags":"","loc":"interface\\todecstring~2.html"},{"title":"OPERATOR(==) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two Float128 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Module Procedures private  interface Float128_Equal() Arguments None","tags":"","loc":"interface\\operator(==)~2.html"},{"title":"OPERATOR(/=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two Float128 numbers are not equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Module Procedures private  interface Float128_NotEqual() Arguments None","tags":"","loc":"interface\\operator(SLASH=)~2.html"},{"title":"OPERATOR(<) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething Module Procedures private  interface Float128_LessThan() Arguments None","tags":"","loc":"interface\\operator(lt)~2.html"},{"title":"OPERATOR(<=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething Module Procedures private  interface Float128_LessEqual() Arguments None","tags":"","loc":"interface\\operator(lt=)~2.html"},{"title":"OPERATOR(>) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething Module Procedures private  interface Float128_GreaterThan() Arguments None","tags":"","loc":"interface\\operator(gt)~2.html"},{"title":"OPERATOR(>=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething Module Procedures private  interface Float128_GreaterEqual() Arguments None","tags":"","loc":"interface\\operator(gt=)~2.html"},{"title":"Compare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Compare Function Interface : Compare Purpose :  To compare Float128 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething Module Procedures private  interface Float128_Compare() Arguments None","tags":"","loc":"interface\\compare~2.html"},{"title":"OPERATOR(+) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two real numbers (at least one of which is\n      a Float128 number) or to add a unary plus sign to a Float128 number. Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN Module Procedures private  interface Float128_UnaryPlus() Arguments None private  interface Float128_Plus_Float128() Arguments None private  interface Float128_Plus_R32() Arguments None private  interface R32_Plus_Float128() Arguments None private  interface Float128_Plus_R64() Arguments None private  interface R64_Plus_Float128() Arguments None","tags":"","loc":"interface\\operator(+)~2.html"},{"title":"OPERATOR(-) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two real numbers (at least one of which is\n      a Float128 number) or to perform a negation of a Float128 number. Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN Module Procedures private  interface Float128_Negate() Arguments None private  interface Float128_Minus_Float128() Arguments None private  interface Float128_Minus_R32() Arguments None private  interface R32_Minus_Float128() Arguments None private  interface Float128_Minus_R64() Arguments None private  interface R64_Minus_Float128() Arguments None","tags":"","loc":"interface\\operator(-)~2.html"},{"title":"OPERATOR(*) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two real numbers (at least one of which is\n      a Float128 number). Usage : --->    OUTPUT = FIRST_IN * SECOND_IN Module Procedures private  interface Float128_Multiply_Float128() Arguments None private  interface Float128_Multiply_R32() Arguments None private  interface R32_Multiply_Float128() Arguments None private  interface Float128_Multiply_R64() Arguments None private  interface R64_Multiply_Float128() Arguments None","tags":"","loc":"interface\\operator(ASTERISK)~2.html"},{"title":"OPERATOR(/) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To perform a division of two real numbers where the dividend (numerator)\n      must be a Float128 number. Usage : --->    OUTPUT = FIRST_IN * SECOND_IN Module Procedures private  interface Float128_Divide_R32() Arguments None private  interface Float128_Divide_R64() Arguments None private  interface Float128_Divide_Float128() Arguments None","tags":"","loc":"interface\\operator(SLASH)~2.html"},{"title":"MOD – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two real numbers, where the\n      dividend (numerator) must be a Float128 number. Usage : --->    REM = MOD(NUMER, DENOM) Module Procedures private  interface Float128_Mod_R32() Arguments None private  interface Float128_Mod_R64() Arguments None private  interface Float128_Mod_Float128() Arguments None","tags":"","loc":"interface\\mod~2.html"},{"title":"DivMod – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface DivMod Subroutine Interface : DivMod Purpose :  To perform a division of two real numbers where the dividend (numerator)\n       must be a Float128 number and to return both the quotient and the remainder. Usage : --->    CALL DivMod(NUMER, DENOM, QUOT, REM) Module Procedures private  interface Float128_DivMod_R32() Arguments None private  interface Float128_DivMod_R64() Arguments None private  interface Float128_DivMod_Float128() Arguments None","tags":"","loc":"interface\\divmod.html"},{"title":"Increment – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Increment Subroutine Interface : Increment Purpose :  To increase value of a Float128 number by one. Usage : --->    CALL Increment(F128) Module Procedures private  interface Float128_Increment() Arguments None","tags":"","loc":"interface\\increment.html"},{"title":"Decrement – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a Float128 by one. Usage : --->    CALL Decrement(F128) Module Procedures private  interface Float128_Decrement() Arguments None","tags":"","loc":"interface\\decrement.html"},{"title":"Add – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Add Subroutine Interface : Add Purpose :  To perform addition: This = This + Other. Usage : --->    CALL Add(This, Other) Module Procedures private  interface Float128_Add_R32() Arguments None private  interface Float128_Add_R64() Arguments None private  interface Float128_Add_Float128() Arguments None","tags":"","loc":"interface\\add.html"},{"title":"Subtract – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Subtract Subroutine Interface : Subtract Purpose :  To perform subtraction: This = This - Other. Usage : --->    CALL Subtract(This, Other) Module Procedures private  interface Float128_Subtract_R32() Arguments None private  interface Float128_Subtract_R64() Arguments None private  interface Float128_Subtract_Float128() Arguments None","tags":"","loc":"interface\\subtract.html"},{"title":"Multiply – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Multiply Subroutine Interface : Multiply Purpose :  To perform multiplication: This = This * Other. Usage : --->    CALL Multiply(This, Other) Module Procedures private  interface Float128_Times_R32() Arguments None private  interface Float128_Times_R64() Arguments None private  interface Float128_Times_Float128() Arguments None","tags":"","loc":"interface\\multiply.html"},{"title":"Divide – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Divide Subroutine Interface : Divide Purpose :  To perform a division: This = This / Other. Usage : --->    CALL Divide(This, Other) Module Procedures private  interface Float128_Over_R32() Arguments None private  interface Float128_Over_R64() Arguments None private  interface Float128_Over_Float128() Arguments None","tags":"","loc":"interface\\divide.html"},{"title":"Is_NaN – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Is_NaN Function Interface : Is_NaN Purpose :  To check whether the input value is a NAN (not a number) or not. Usage : --->    Flag = Is_NaN(INPUT) --->    IF (.NOT.Is_NaN(INPUT)) DoSomeThing Module Procedures private  function Float128_Is_NaN(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical","tags":"","loc":"interface\\is_nan.html"},{"title":"Is_Infinite – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Is_Infinite Function Interface : Is_Infinite Purpose :  To check whether the input value is an infinity or not. Usage : --->    Flag = Is_Infinite(INPUT) --->    IF (.NOT.Is_Infinite(INPUT)) DoSomeThing Module Procedures private  function Float128_Is_Infinite(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical","tags":"","loc":"interface\\is_infinite.html"},{"title":"Is_Zero – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Is_Zero Function Interface : IsZero Purpose :  To check whether the input value is zero or not. Usage : --->    Flag = IsZero(INPUT) --->    IF (.NOT.IsZero(INPUT)) DoSomeThing Module Procedures private  function Float128_Is_Zero(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical","tags":"","loc":"interface\\is_zero.html"},{"title":"Is_Negative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Is_Negative Function Interface : IsNegative Purpose :  To check whether the input value is negative or not. Usage : --->    Flag = IsNegative(INPUT) --->    IF (.NOT.IsNegative(INPUT)) DoSomeThing Module Procedures private  function Float128_Is_Negative(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical","tags":"","loc":"interface\\is_negative.html"},{"title":"ZeroApInt32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function ZeroApInt32() result(Big) Arguments None Return Value type( ApInt32 ) Description To return the ApInt32 number with value of zero.","tags":"","loc":"interface\\zeroapint32.html"},{"title":"OneApInt32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"interface public module function OneApInt32() result(Big) Arguments None Return Value type( ApInt32 ) Description To return the ApInt32 number with value of one.","tags":"","loc":"interface\\oneapint32.html"},{"title":"ASSIGNMENT(=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between the ApInt32 type and a signed integer\n      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). Usage : ! convert 64-bit signed integer to the ApInt32 type --->    ApNum = I64 ! convert the ApInt32 type to 128-bit signed integer --->    I128 = ApNum Subroutines private module subroutine ApInt32_Assign(This, Other) To make a copy of the ApInt32 number via an assignment expression. Usage : This = Other Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: This type( ApInt32 ), intent(in) :: Other private module subroutine ApInt32_From_I32(Big, I32) To convert from a 32-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big integer(kind=kInt32), intent(in) :: I32 private module subroutine ApInt32_From_I64(Big, I64) To convert from a 64-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big integer(kind=kInt64), intent(in) :: I64 private module subroutine ApInt32_From_I128(Big, I128) To convert from a 128-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big type(SInt128), intent(in) :: I128 private module subroutine ApInt32_To_I32(I32, Big) To convert from an ApInt32 number to a 32-bit signed integer\n via an assignment expression. Usage : I32 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: I32 type( ApInt32 ), intent(in) :: Big private module subroutine ApInt32_To_I64(I64, Big) To convert from an ApInt32 number to a 64-bit signed integer\n via an assignment expression. Usage : I64 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: I64 type( ApInt32 ), intent(in) :: Big private module subroutine ApInt32_To_I128(I128, Big) To convert from an ApInt32 number to a 128-bit signed integer\n via an assignment expression. Usage : I128 = Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(out) :: I128 type( ApInt32 ), intent(in) :: Big","tags":"","loc":"interface\\assignment(=)~3.html"},{"title":"ApInt32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ApInt32 Constructor Interface : ApInt32 Purpose :  To construct an ApInt32 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt32(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt32(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt32(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt32(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt32('-123456789098765432101122334455667788990012345') Functions private module function Construct_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 32-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt32), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 32-bit integer array where\n the first element gives the least significant 32 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function Bytes_To_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function DecString_To_ApInt32(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt32 number based on the specified decimal string. Usage : ---> ApNum = ApInt32('1234567890987654321011223344') ---> ApNum = ApInt32('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt32(NumStr, ErrMsg=Message) ---> ApNum = ApInt32(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt32 ) number private module function U32_To_ApInt32(Sign, U32) result(Big) To construct the ApInt32 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U64_To_ApInt32(Sign, U64) result(Big) To construct the ApInt32 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U128_To_ApInt32(Sign, U128) result(Big) To construct the ApInt32 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function I32_To_ApInt32(I32) result(Big) To construct the ApInt32 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt32(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt32 ) private module function I64_To_ApInt32(I64) result(Big) To construct the ApInt32 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt32(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt32 ) private module function I128_To_ApInt32(I128) result(Big) To construct the ApInt32 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt32(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt32 ) private module function R32_To_ApInt32(R32) result(Big) To construct the ApInt32 number based on the specified 32-bit real number. Usage : ApNum = ApInt32(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt32 ) private module function R64_To_ApInt32(R64) result(Big) To construct the ApInt32 number based on the specified 64-bit real number. Usage : ApNum = ApInt32(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt32 ) private module function R128_To_ApInt32(R128) result(Big) To construct the ApInt32 number based on the specified 128-bit real number. Usage : ApNum = ApInt32(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt32 )","tags":"","loc":"interface\\apint32.html"},{"title":"ToBytes – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToBytes Subroutine Interface : ToBytes Purpose :  To convert an ApInt32 number to a 8-bit integer magnitude\n  array and its sign. Usage : ---> CALL ToBytes(ApNum, MagArray, Sign) Subroutines private module subroutine Bytes_From_ApInt32(Big, Digit, Sign) To convert an ApInt32 number to a 8-bit integer magnitude array and its sign. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt8), intent(out), ALLOCATABLE :: Digit (:) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) integer(kind=kInt32), intent(out), optional :: Sign sign of the number","tags":"","loc":"interface\\tobytes~2.html"},{"title":"ToU32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU32 Function Interface : ToU32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit unsigned integer. Usage : --->    U32 = ToU32(ApNum) Functions private module function U32_From_ApInt32(Big) result(U32) To convert the ApInt32 number to a 32-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as unsigned","tags":"","loc":"interface\\tou32~2.html"},{"title":"ToU64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU64 Function Interface : ToU64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit unsigned integer. Usage : --->    U64 = ToU64(ApNum) Functions private module function U64_From_ApInt32(Big) result(U64) To convert the ApInt32 number to a 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as unsigned","tags":"","loc":"interface\\tou64~2.html"},{"title":"ToU128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToU128 Function Interface : ToU128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit unsigned integer. Usage : --->    U128 = ToU128(ApNum) Functions private module function U128_From_ApInt32(Big) result(U128) To convert the ApInt32 number to a 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value type(UInt128) a 128-bit unsigned integer","tags":"","loc":"interface\\tou128~2.html"},{"title":"ToI32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI32 Function Interface : ToI32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit signed integer. Usage : --->    I32 = ToI32(ApNum) Functions private module function I32_From_ApInt32(Big) result(I32) To convert the ApInt32 number to a 32-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as signed","tags":"","loc":"interface\\toi32~3.html"},{"title":"ToI64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI64 Function Interface : ToI64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit signed integer. Usage : --->    I64 = ToI64(ApNum) Functions private module function I64_From_ApInt32(Big) result(I64) To convert the ApInt32 number to a 64-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as signed","tags":"","loc":"interface\\toi64~3.html"},{"title":"ToI128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToI128 Function Interface : ToI128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit signed integer. Usage : --->    I128 = ToI128(ApNum) Functions private module function I128_From_ApInt32(Big) result(I128) To convert the ApInt32 number to a 128-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value type(SInt128) a 128-bit signed integer","tags":"","loc":"interface\\toi128~2.html"},{"title":"ToR32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR32 Function Interface : ToR32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit real number. Usage : --->    R32 = ToR32(ApNum) Functions private module function R32_From_ApInt32(Big) result(R32) To convert the ApInt32 number to a 32-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kSingle)","tags":"","loc":"interface\\tor32~3.html"},{"title":"ToR64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR64 Function Interface : ToR64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit real number. Usage : --->    R64 = ToR64(ApNum) Functions private module function R64_From_ApInt32(Big) result(R64) To convert the ApInt32 number to a 64-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kDouble)","tags":"","loc":"interface\\tor64~3.html"},{"title":"ToR128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToR128 Function Interface : ToR128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit real number. Usage : --->    R128 = ToR128(ApNum) Functions private module function R128_From_ApInt32(Big) result(R128) To convert the ApInt32 number to a 128-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kQuad)","tags":"","loc":"interface\\tor128~3.html"},{"title":"ToDecString – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ToDecString Function Interface : ToDecString Purpose :  To convert an arbitrary-precision signed integer to\n  a decimal string. Usage : --->    Str = ToDecString(ApNum) Functions private module function DecString_From_ApInt32(Big) result(Str) To convert an arbitrary-precision signed integer to a decimal string. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value character(kind=kChar, len=:), ALLOCATABLE","tags":"","loc":"interface\\todecstring~3.html"},{"title":"OPERATOR(==) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two ApInt32 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething Functions private module function ApInt32_Equal(LHS, RHS) result(Flag) To check whether two ApInt32 numbers are equal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(==)~3.html"},{"title":"OPERATOR(/=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two ApInt32 numbers are NOT equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething Functions private module function ApInt32_NotEqual(LHS, RHS) result(Flag) To check whether two ApInt32 numbers NOT are equal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(SLASH=)~3.html"},{"title":"OPERATOR(<) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething Functions private module function ApInt32_LessThan(LHS, RHS) result(Flag) To check whether the LHS number is less than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt)~3.html"},{"title":"OPERATOR(<=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething Functions private module function ApInt32_LessEqual(LHS, RHS) result(Flag) To check whether the LHS number is less than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(lt=)~3.html"},{"title":"OPERATOR(>) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething Functions private module function ApInt32_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS number is greater than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt)~3.html"},{"title":"OPERATOR(>=) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething Functions private module function ApInt32_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS number is greater than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical","tags":"","loc":"interface\\operator(gt=)~3.html"},{"title":"Compare – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Compare Function Interface : Compare Purpose :  To compare two ApInt32 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething Module Procedures private  interface ApInt32_Compare() Arguments None","tags":"","loc":"interface\\compare~3.html"},{"title":"OPERATOR(+) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers (at least one\n               of which is a ApInt32 number) or to add a unary plus sign\n               to a ApInt32 number. Usage : --->    OutNum = +InNum --->    OutNum = InNum1 + InNum2 Functions private module function ApInt32_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 ) private module function ApInt32_Plus_ApInt32(LhsVal, RhsVal) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Plus_I32(Big, I32) result(OutVal) To perform addition: OutVal = Big + I32. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Plus_ApInt32(I32, Big) result(OutVal) To perform addition: OutVal = I32 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Plus_I64(Big, I64) result(OutVal) To perform addition: OutVal = Big + I64. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Plus_ApInt32(I64, Big) result(OutVal) To perform addition: OutVal = I64 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Plus_I128(Big, I128) result(OutVal) To perform addition: OutVal = Big + I128. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Plus_ApInt32(I128, Big) result(OutVal) To perform addition: OutVal = I128 + Big. Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 )","tags":"","loc":"interface\\operator(+)~3.html"},{"title":"OPERATOR(-) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers (at least one\n               of which is a ApInt32 number) or to negate a ApInt32 number. Usage : --->    OutNum = -InNum --->    OutNum = InNum1 - InNum2 Functions private module function ApInt32_Negate(InVal) result(OutVal) To negate a ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 ) private module function ApInt32_Minus_ApInt32(LhsVal, RhsVal) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Minus_I32(Big, I32) result(OutVal) To perform subtraction: OutVal = Big - I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Minus_ApInt32(I32, Big) result(OutVal) To perform subtraction: OutVal = I32 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Minus_I64(Big, I64) result(OutVal) To perform subtraction: OutVal = Big - I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Minus_ApInt32(I64, Big) result(OutVal) To perform subtraction: OutVal = I64 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Minus_I128(Big, I128) result(OutVal) To perform subtraction: OutVal = Big - I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Minus_ApInt32(I128, Big) result(OutVal) To perform subtraction: OutVal = I128 - Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 )","tags":"","loc":"interface\\operator(-)~3.html"},{"title":"OPERATOR(*) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one\n               of which is a ApInt32 number). Usage : --->    OutNum = InNum1 * InNum2 Functions private module function ApInt32_Multiply_ApInt32(LhsVal, RhsVal) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Multiply_I32(Big, I32) result(OutVal) To perform multiplication: OutVal = Big * I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Multiply_ApInt32(I32, Big) result(OutVal) To perform multiplication: OutVal = I32 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Multiply_I64(Big, I64) result(OutVal) To perform multiplication: OutVal = Big * I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Multiply_ApInt32(I64, Big) result(OutVal) To perform multiplication: OutVal = I64 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Multiply_I128(Big, I128) result(OutVal) To perform multiplication: OutVal = Big * I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Multiply_ApInt32(I128, Big) result(OutVal) To perform multiplication: OutVal = I128 * Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 )","tags":"","loc":"interface\\operator(ASTERISK)~3.html"},{"title":"OPERATOR(/) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n               where the dividend (numerator) is a ApInt32 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Quotient = Dividend / Divisor Functions private module function ApInt32_Divide_ApInt32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I128(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt32 )","tags":"","loc":"interface\\operator(SLASH)~3.html"},{"title":"MOD – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n               where the dividend (numerator) is a ApInt32 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Remainder = MOD(Dividend, Divisor) Functions private module function ApInt32_Mod_ApInt32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt32 )","tags":"","loc":"interface\\mod~3.html"},{"title":"MODULO – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MODULO Function Interface : MODULO Purpose :  To compute the modulo of two ApInt32 numbers. Usage : --->    Modulo = MODULO(Dividend, Divisor) Functions private module function ApInt32_Modulo(Dividend, Divisor) result(Modulo) To compute the modulo of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 )","tags":"","loc":"interface\\modulo~2.html"},{"title":"OPERATOR(**) – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface OPERATOR(**) Operator Overload : OPERATOR( ** ) Purpose :  To perform an exponentiation of the ApInt32 number. Usage : --->    NumOut = NumIn**Exp Functions private module function ApInt32_Power(BigIn, Exp) result(BigOut) To perform an exponentiation: BigOut = BigIn**Exp Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: BigIn integer(kind=kInt32), intent(in) :: Exp Return Value type( ApInt32 )","tags":"","loc":"interface\\operator(ASTERISKASTERISK)~2.html"},{"title":"SQR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SQR Function Interface : SQR Purpose :  To compute the square of the ApInt32 number. Usage : --->    NumSqr = SQR(ApNum) Functions private module function ApInt32_Square(BigIn) result(BigOut) To perform squaring: BigOut = BigIn * BigIn. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: BigIn Return Value type( ApInt32 )","tags":"","loc":"interface\\sqr~2.html"},{"title":"SHIFTL – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTL(NumIn, 157) Functions private module function ApInt32_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 )","tags":"","loc":"interface\\shiftl~2.html"},{"title":"SHIFTR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTR(NumIn, 141) Functions private module function ApInt32_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 )","tags":"","loc":"interface\\shiftr~2.html"},{"title":"ISHFT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift of an ApInt32 number. Usage : --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 Functions private module function ApInt32_LogicalShift(InVal, ShiftPos) result(OutVal) To perform logical shift of an ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 )","tags":"","loc":"interface\\ishft~2.html"},{"title":"NOT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement an ApInt32 number. Usage : --->    NumOut = NOT(NumIn) Functions private module function ApInt32_Not(InVal) result(OutVal) To return the bitwise logical complement an ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 )","tags":"","loc":"interface\\not~2.html"},{"title":"IOR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IOR(NumIn1, NumIn2) Functions private module function ApInt32_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 )","tags":"","loc":"interface\\ior~2.html"},{"title":"IEOR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IEOR(NumIn1, NumIn2) Functions private module function ApInt32_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 )","tags":"","loc":"interface\\ieor~2.html"},{"title":"IAND – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IAND(NumIn1, NumIn2) Functions private module function ApInt32_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 )","tags":"","loc":"interface\\iand~2.html"},{"title":"IAND_NOT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IAND_NOT Function Interface : IAND_NOT Purpose :  To perform a bitwise AND and NOT on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IAND_NOT(NumIn1, NumIn2) Note : IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). Functions private module function ApInt32_IandNot(LhsVal, RhsVal) result(OutVal) To perform a bitwise AND and NOT on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 )","tags":"","loc":"interface\\iand_not~2.html"},{"title":"LEADZ – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the ApInt32 number. Usage : --->    NumLZ = LEADZ(ApNum) Functions private module function ApInt32_LeadingZeros(Big) result(NumLZ) To count the number of leading zero bits of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\leadz~2.html"},{"title":"TRAILZ – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the ApInt32 number. Usage : --->    NumTZ = TRAILZ(ApNum) Functions private module function ApInt32_TrailingZeros(Big) result(NumTZ) To count the number of trailing zero bits of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\trailz~2.html"},{"title":"POPCNT – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the ApInt32 number. Usage : --->    NumBits = POPCNT(ApNum) Functions private module function ApInt32_Count1Bits(Big) result(NumBits) To count the number of 1 bits in the ApInt32 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\popcnt~2.html"},{"title":"POPPAR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the ApInt32 number. Usage : --->    NumPar = POPPAR(ApNum) Functions private module function ApInt32_Parity(Big) result(ParNum) To determine the parity of the ApInt32 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32)","tags":"","loc":"interface\\poppar~2.html"},{"title":"IBSET – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1. Usage : --->    NumOut = IBSET(NumIn, Pos) Functions private module function ApInt32_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 )","tags":"","loc":"interface\\ibset~2.html"},{"title":"IBCLR – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0. Usage : --->    NumOut = IBCLR(NumIn, Pos) Functions private module function ApInt32_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 )","tags":"","loc":"interface\\ibclr~2.html"},{"title":"IBCHNG – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position. Usage : --->    NumOut = IBCHNG(NumIn, Pos) Functions private module function ApInt32_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 )","tags":"","loc":"interface\\ibchng~2.html"},{"title":"BTEST – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position\n               is 0 (False) or 1 (True). Usage : --->    Flag = BTEST(ApNum, Pos) Functions private module function ApInt32_TestBit(Big, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True).\n (For more information, see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Pos Return Value logical","tags":"","loc":"interface\\btest~2.html"},{"title":"ABS – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface ABS Function Interface : ABS Purpose :  To return the absolute value of the ApInt32 number. Usage : --->    AbsNum = ABS(ApNum) Module Procedures private  function ApInt32_Absolute(Num) result(Abs) To get the absolute value of the specified number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Num Return Value type( ApInt32 )","tags":"","loc":"interface\\abs~2.html"},{"title":"IsZero – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsZero Function Interface : IsZero Purpose :  To check whether the ApInt32 number has value of zero or not. Usage : --->    Flag = IsZero(ApNum) --->    IF (IsZero(ApNum)) DoSomeThing Module Procedures private  function ApInt32_Is_Zero(Big) result(Flag) To check whether the number is zero or not. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value logical true if value is zero.","tags":"","loc":"interface\\iszero~2.html"},{"title":"IsOne – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsOne Function Interface : IsOne Purpose :  To check whether the ApInt32 number has value of one or not. Usage : --->    Flag = IsOne(ApNum) --->    IF (IsOne(ApNum)) DoSomeThing Module Procedures private  interface ApInt32_Is_One() Arguments None","tags":"","loc":"interface\\isone~2.html"},{"title":"IsPositive – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsPositive Function Interface : IsPositive Purpose :  To check whether the ApInt32 number has positive value or not. Usage : --->    Flag = IsPositive(ApNum) --->    IF (IsPositive(ApNum)) DoSomeThing Module Procedures private  interface ApInt32_Is_Positive() Arguments None","tags":"","loc":"interface\\ispositive~2.html"},{"title":"IsNegative – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface IsNegative Function Interface : IsNegative Purpose :  To check whether the ApInt32 number has negative value or not. Usage : --->    Flag = IsNegative(ApNum) --->    IF (IsNegative(ApNum)) DoSomeThing Module Procedures private  interface ApInt32_Is_Negative() Arguments None","tags":"","loc":"interface\\isnegative~2.html"},{"title":"RandNumApInt32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface RandNumApInt32 Functions private module function ApInt32_Random_Number(Prng, Positive, Length) result(BigRnd) Function Interface : RandNumApInt32 Purpose :  To generate and return the ApIn64 number with random value. Usage : ! generate random number with default settings --->    ApNum = RandNumApInt32() ! generate random number with specified PRNG --->    ApNum = RandNumApInt32(PRNG) ! generate random number with negative value --->    ApNum = RandNumApInt32(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    ApNum = RandNumApInt32(Length=MagLen)\nTo generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array Return Value type( ApInt32 ) the ApInt32 number with random value","tags":"","loc":"interface\\randnumapint32.html"},{"title":"Display – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface Display Subroutine Interface : Display Purpose :  To write/display the 'ApInt32' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL Display(ApNum) ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL Display(ApNum, 11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL Display(ApNum, 11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL Display(ApNum, ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL Display(ApNum, Prefix='Signed value of ApNum') Module Procedures private  interface ApInt32_Write() Arguments None","tags":"","loc":"interface\\display~2.html"},{"title":"MakeCopy – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface MakeCopy Function Interface : Copy Purpose :  To make a copy of the ApInt32 number. Usage : ! make a copy of the ApInt32 number --->    DstApNum = MakeCopy(SrcApNum) ! make a copy of the ApInt32 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = MakeCopy(SrcApNum, DstCap) Module Procedures private  interface ApInt32_Copy() Arguments None","tags":"","loc":"interface\\makecopy~2.html"},{"title":"GetLength – eXPerimental Fortran Library (XpfLib) Documentation","text":"public interface GetLength Function Interface : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = GetLength(ApNum) Module Procedures private  interface ApInt32_GetLength() Arguments None","tags":"","loc":"interface\\getlength~2.html"},{"title":"MClass_ApInt64 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ApInt64 type, its related routines and some useful\n  parameter-like functions.  The ApInt64 type is a derived type representing\n  a mutable, arbitrary-precision signed integer.  Various common operations\n  usually available for integer types are provided including arithmetic, bitwise,\n  comparison, and conversion/construction operations.  The application programming\n  interface (API) follows Fortran intrinsic integer types with additional functions/\n  methods provided. Due to the fact that the ApInt64 type has an allocatable component, unlike\n  other integer types available, the ApInt64 type normally requires an explicit\n  construction either via a constructor method or an assignment expression before\n  being used as an input argument in other operations.  Otherwise, the number\n  would be interpreted as having zero value. If a number is always in a range provided by a 128-bit signed integer, a user can\n  use the SInt128 type instead for efficiency reason.  Likewise, if a number is always in a range\n  provided by a 128-bit unsigned integer, the UInt128 type can be used with better performance. Similar to the SInt128 type, mixed types of signed integer types (32-bit, 64-bit,\n  128-bit or arbitrary-precision) are allowed in arithmetic operations.  Likewise,\n  arguments with Fortran intrinsic integer types in all public methods are considered\n  to be signed, except those in some of conversion methods.  Also, for comparison and\n  bitwise operations that require two input arguments, both arguments must only be the ApInt64 type.  The operations on mixed types are not provided.  Therefore, all other\n  types must be explicitly converted to the ApInt64 type before using in the comparison\n  and bitwise operations. It should be noted that unlike both the SInt128 and UInt128 types where a conventional\n  API (procedural programming) following Fortran integer types is used, the ApInt64 type\n  uses a mixed programming style.  For basic integer operations, a conventional API is used.\n  For additional functionalities provided, both a conventional API and an object-oriented\n  API (via type-bound procedures) are used.  Therefore, for additional functions/methods,\n  the usage of the ApInt64 type may differ from the usage of the SInt128 and UInt128 types. See the ApInt32 type for a mutable,\n  arbitrary-precision signed integer that has mostly identical functionalities.\n  The ApInt32 type is similar to the ApInt64 type, but employs the base of\n  2 32 instead of 2 64 .  Therefore, the ApInt32 type uses\n  many similar algorithms but requires different implementations.  Also, the ApInt64 type provides experimental routines for various operations while\n  the ApInt64 type does not. REFERENCES : [1] The Huldra Project: BigInt [2] Java's Class BigInteger [3] IntX: Extended precision integer C++\n      library Uses MBase_Common MClass_BaseRng MBase_SInt128 MBase_UInt128 MBase_UIntUtil Interfaces interface public module function ZeroApInt64() result(Big) To return the ApInt64 number with value of zero. Arguments None Return Value type( ApInt64 ) interface public module function OneApInt64() result(Big) To return the ApInt64 number with value of one. Arguments None Return Value type( ApInt64 ) public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between the ApInt64 type and a signed integer\n      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). Usage : ! convert 64-bit signed integer to the ApInt64 type --->    ApNum = I64 ! convert the ApInt64 type to 128-bit signed integer --->    I128 = ApNum private module subroutine ApInt64_Assign(This, Other) To make a copy of the ApInt64 number via an assignment expression. Usage : This = Other Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: This type( ApInt64 ), intent(in) :: Other private module subroutine ApInt64_From_I32(Big, I32) To convert from a 32-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big integer(kind=kInt32), intent(in) :: I32 private module subroutine ApInt64_From_I64(Big, I64) To convert from a 64-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big integer(kind=kInt64), intent(in) :: I64 private module subroutine ApInt64_From_I128(Big, I128) To convert from a 128-bit signed integer to an ApInt64 number\n via an assignment expression. Usage : Big = I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(out) :: Big type(SInt128), intent(in) :: I128 private module subroutine ApInt64_To_I32(I32, Big) To convert from an ApInt64 number to a 32-bit signed integer\n via an assignment expression. Usage : I32 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: I32 type( ApInt64 ), intent(in) :: Big private module subroutine ApInt64_To_I64(I64, Big) To convert from an ApInt64 number to a 64-bit signed integer\n via an assignment expression. Usage : I64 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: I64 type( ApInt64 ), intent(in) :: Big private module subroutine ApInt64_To_I128(I128, Big) To convert from an ApInt64 number to a 128-bit signed integer\n via an assignment expression. Usage : I128 = Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(out) :: I128 type( ApInt64 ), intent(in) :: Big public        interface ApInt64 Constructor Interface : ApInt64 Purpose :  To construct an ApInt64 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt64(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt64(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt64(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt64(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt64('-123456789098765432101122334455667788990012345') private module function Construct_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 64-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt64), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 64-bit integer array where\n the first element gives the least significant 64 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function Bytes_To_ApInt64(Sign, Length, Digit) result(Big) To construct the ApInt64 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt64 ) the arbitrary-precision integer number private module function DecString_To_ApInt64(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt64 number based on the specified decimal string. Usage : ---> ApNum = ApInt64('1234567890987654321011223344') ---> ApNum = ApInt64('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt64(NumStr, ErrMsg=Message) ---> ApNum = ApInt64(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt64 ) number private module function U32_To_ApInt64(Sign, U32) result(Big) To construct the ApInt64 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U64_To_ApInt64(Sign, U64) result(Big) To construct the ApInt64 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function U128_To_ApInt64(Sign, U128) result(Big) To construct the ApInt64 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt64 ) private module function I32_To_ApInt64(I32) result(Big) To construct the ApInt64 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt64(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt64 ) private module function I64_To_ApInt64(I64) result(Big) To construct the ApInt64 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt64(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt64 ) private module function I128_To_ApInt64(I128) result(Big) To construct the ApInt64 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt64(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt64 ) private module function R32_To_ApInt64(R32) result(Big) To construct the ApInt64 number based on the specified 32-bit real number. Usage : ApNum = ApInt64(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt64 ) private module function R64_To_ApInt64(R64) result(Big) To construct the ApInt64 number based on the specified 64-bit real number. Usage : ApNum = ApInt64(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt64 ) private module function R128_To_ApInt64(R128) result(Big) To construct the ApInt64 number based on the specified 128-bit real number. Usage : ApNum = ApInt64(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt64 ) public        interface ToBytes Subroutine Interface : ToBytes Purpose :  To convert an ApInt64 number to a 8-bit integer magnitude\n  array and its sign. Usage : ---> CALL ToBytes(ApNum, MagArray, Sign) private module subroutine Bytes_From_ApInt64(Big, Digit, Sign) To convert an ApInt64 number to a 8-bit integer magnitude array and its sign. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt8), intent(out), ALLOCATABLE :: Digit (:) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) integer(kind=kInt32), intent(out), optional :: Sign sign of the number public        interface ToU32 Function Interface : ToU32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit unsigned integer. Usage : --->    U32 = ToU32(ApNum) private module function U32_From_ApInt64(Big) result(U32) To convert the ApInt64 number to a 32-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as unsigned public        interface ToU64 Function Interface : ToU64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit unsigned integer. Usage : --->    U64 = ToU64(ApNum) private module function U64_From_ApInt64(Big) result(U64) To convert the ApInt64 number to a 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as unsigned public        interface ToU128 Function Interface : ToU128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit unsigned integer. Usage : --->    U128 = ToU128(ApNum) private module function U128_From_ApInt64(Big) result(U128) To convert the ApInt64 number to a 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value type(UInt128) a 128-bit unsigned integer public        interface ToI32 Function Interface : ToI32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit signed integer. Usage : --->    I32 = ToI32(ApNum) private module function I32_From_ApInt64(Big) result(I32) To convert the ApInt64 number to a 32-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as signed public        interface ToI64 Function Interface : ToI64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit signed integer. Usage : --->    I64 = ToI64(ApNum) private module function I64_From_ApInt64(Big) result(I64) To convert the ApInt64 number to a 64-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as signed public        interface ToI128 Function Interface : ToI128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit signed integer. Usage : --->    I128 = ToI128(ApNum) private module function I128_From_ApInt64(Big) result(I128) To convert the ApInt64 number to a 128-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value type(SInt128) a 128-bit signed integer public        interface ToR32 Function Interface : ToR32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit real number. Usage : --->    R32 = ToR32(ApNum) private module function R32_From_ApInt64(Big) result(R32) To convert the ApInt64 number to a 32-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kSingle) public        interface ToR64 Function Interface : ToR64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit real number. Usage : --->    R64 = ToR64(ApNum) private module function R64_From_ApInt64(Big) result(R64) To convert the ApInt64 number to a 64-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kDouble) public        interface ToR128 Function Interface : ToR128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit real number. Usage : --->    R128 = ToR128(ApNum) private module function R128_From_ApInt64(Big) result(R128) To convert the ApInt64 number to a 128-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value real(kind=kQuad) public        interface ToDecString Function Interface : ToDecString Purpose :  To convert an arbitrary-precision signed integer to\n  a decimal string. Usage : --->    Str = ToDecString(ApNum) private module function DecString_From_ApInt64(Big) result(Str) To convert an arbitrary-precision signed integer to a decimal string. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value character(kind=kChar, len=:), ALLOCATABLE public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two ApInt64 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private module function ApInt64_Equal(LHS, RHS) result(Flag) To check whether two ApInt64 numbers are equal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two ApInt64 numbers are NOT equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private module function ApInt64_NotEqual(LHS, RHS) result(Flag) To check whether two ApInt64 numbers NOT are equal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething private module function ApInt64_LessThan(LHS, RHS) result(Flag) To check whether the LHS number is less than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething private module function ApInt64_LessEqual(LHS, RHS) result(Flag) To check whether the LHS number is less than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething private module function ApInt64_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS number is greater than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething private module function ApInt64_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS number is greater than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LHS type( ApInt64 ), intent(in) :: RHS Return Value logical public        interface Compare Function Interface : Compare Purpose :  To compare two ApInt64 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething private  interface ApInt64_Compare() Arguments None public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers (at least one\n               of which is a ApInt64 number) or to add a unary plus sign\n               to a ApInt64 number. Usage : --->    OutNum = +InNum --->    OutNum = InNum1 + InNum2 private module function ApInt64_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 ) private module function ApInt64_Plus_ApInt64(LhsVal, RhsVal) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Plus_I32(Big, I32) result(OutVal) To perform addition: OutVal = Big + I32. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Plus_ApInt64(I32, Big) result(OutVal) To perform addition: OutVal = I32 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Plus_I64(Big, I64) result(OutVal) To perform addition: OutVal = Big + I64. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Plus_ApInt64(I64, Big) result(OutVal) To perform addition: OutVal = I64 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Plus_I128(Big, I128) result(OutVal) To perform addition: OutVal = Big + I128. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Plus_ApInt64(I128, Big) result(OutVal) To perform addition: OutVal = I128 + Big. Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) public        interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers (at least one\n               of which is a ApInt64 number) or to negate a ApInt64 number. Usage : --->    OutNum = -InNum --->    OutNum = InNum1 - InNum2 private module function ApInt64_Negate(InVal) result(OutVal) To negate a ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 ) private module function ApInt64_Minus_ApInt64(LhsVal, RhsVal) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Minus_I32(Big, I32) result(OutVal) To perform subtraction: OutVal = Big - I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Minus_ApInt64(I32, Big) result(OutVal) To perform subtraction: OutVal = I32 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Minus_I64(Big, I64) result(OutVal) To perform subtraction: OutVal = Big - I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Minus_ApInt64(I64, Big) result(OutVal) To perform subtraction: OutVal = I64 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Minus_I128(Big, I128) result(OutVal) To perform subtraction: OutVal = Big - I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Minus_ApInt64(I128, Big) result(OutVal) To perform subtraction: OutVal = I128 - Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) public        interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one\n               of which is a ApInt64 number). Usage : --->    OutNum = InNum1 * InNum2 private module function ApInt64_Multiply_ApInt64(LhsVal, RhsVal) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) private module function ApInt64_Multiply_I32(Big, I32) result(OutVal) To perform multiplication: OutVal = Big * I32 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt64 ) private module function I32_Multiply_ApInt64(I32, Big) result(OutVal) To perform multiplication: OutVal = I32 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Multiply_I64(Big, I64) result(OutVal) To perform multiplication: OutVal = Big * I64 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt64 ) private module function I64_Multiply_ApInt64(I64, Big) result(OutVal) To perform multiplication: OutVal = I64 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) private module function ApInt64_Multiply_I128(Big, I128) result(OutVal) To perform multiplication: OutVal = Big * I128 Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt64 ) private module function I128_Multiply_ApInt64(I128, Big) result(OutVal) To perform multiplication: OutVal = I128 * Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt64 ), intent(in) :: Big Return Value type( ApInt64 ) public        interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n               where the dividend (numerator) is a ApInt64 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Quotient = Dividend / Divisor private module function ApInt64_Divide_ApInt64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Divide_I128(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt64 ) public        interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n               where the dividend (numerator) is a ApInt64 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Remainder = MOD(Dividend, Divisor) private module function ApInt64_Mod_ApInt64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt64 ) private module function ApInt64_Mod_I128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt64 ) public        interface MODULO Function Interface : MODULO Purpose :  To compute the modulo of two ApInt64 numbers. Usage : --->    Modulo = MODULO(Dividend, Divisor) private module function ApInt64_Modulo(Dividend, Divisor) result(Modulo) To compute the modulo of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor Return Value type( ApInt64 ) public        interface OPERATOR(**) Operator Overload : OPERATOR( ** ) Purpose :  To perform an exponentiation of the ApInt64 number. Usage : --->    NumOut = NumIn**Exp private module function ApInt64_Power(BigIn, Exp) result(BigOut) To perform an exponentiation: BigOut = BigIn**Exp Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: BigIn integer(kind=kInt32), intent(in) :: Exp Return Value type( ApInt64 ) public        interface SQR Function Interface : SQR Purpose :  To compute the square of the ApInt64 number. Usage : --->    NumSqr = SQR(ApNum) private module function ApInt64_Square(BigIn) result(BigOut) To perform squaring: BigOut = BigIn * BigIn. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: BigIn Return Value type( ApInt64 ) public        interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTL(NumIn, 157) private module function ApInt64_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 ) public        interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTR(NumIn, 141) private module function ApInt64_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 ) public        interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift of an ApInt64 number. Usage : --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 private module function ApInt64_LogicalShift(InVal, ShiftPos) result(OutVal) To perform logical shift of an ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt64 ) public        interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement an ApInt64 number. Usage : --->    NumOut = NOT(NumIn) private module function ApInt64_Not(InVal) result(OutVal) To return the bitwise logical complement an ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal Return Value type( ApInt64 ) public        interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IOR(NumIn1, NumIn2) private module function ApInt64_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) public        interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IEOR(NumIn1, NumIn2) private module function ApInt64_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) public        interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IAND(NumIn1, NumIn2) private module function ApInt64_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) public        interface IAND_NOT Function Interface : IAND_NOT Purpose :  To perform a bitwise AND and NOT on corresponding bits of two\n               ApInt64 numbers. Usage : --->    NumOut = IAND_NOT(NumIn1, NumIn2) Note : IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). private module function ApInt64_IandNot(LhsVal, RhsVal) result(OutVal) To perform a bitwise AND and NOT on corresponding bits of two ApInt64 numbers. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal Return Value type( ApInt64 ) public        interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the ApInt64 number. Usage : --->    NumLZ = LEADZ(ApNum) private module function ApInt64_LeadingZeros(Big) result(NumLZ) To count the number of leading zero bits of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the ApInt64 number. Usage : --->    NumTZ = TRAILZ(ApNum) private module function ApInt64_TrailingZeros(Big) result(NumTZ) To count the number of trailing zero bits of the ApInt64 number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the ApInt64 number. Usage : --->    NumBits = POPCNT(ApNum) private module function ApInt64_Count1Bits(Big) result(NumBits) To count the number of 1 bits in the ApInt64 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the ApInt64 number. Usage : --->    NumPar = POPPAR(ApNum) private module function ApInt64_Parity(Big) result(ParNum) To determine the parity of the ApInt64 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1. Usage : --->    NumOut = IBSET(NumIn, Pos) private module function ApInt64_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 ) public        interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0. Usage : --->    NumOut = IBCLR(NumIn, Pos) private module function ApInt64_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 ) public        interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position. Usage : --->    NumOut = IBCHNG(NumIn, Pos) private module function ApInt64_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt64 ) public        interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position\n               is 0 (False) or 1 (True). Usage : --->    Flag = BTEST(ApNum, Pos) private module function ApInt64_TestBit(Big, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True).\n (For more information, see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Pos Return Value logical public        interface ABS Function Interface : ABS Purpose :  To return the absolute value of the ApInt64 number. Usage : --->    AbsNum = ABS(ApNum) private  function ApInt64_Absolute(Num) result(Abs) To get the absolute value of the specified number. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Num Return Value type( ApInt64 ) public        interface IsZero Function Interface : IsZero Purpose :  To check whether the ApInt64 number has value of zero or not. Usage : --->    Flag = IsZero(ApNum) --->    IF (IsZero(ApNum)) DoSomeThing private  function ApInt64_Is_Zero(Big) result(Flag) To check whether the number is zero or not. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big Return Value logical true if value is zero. public        interface IsOne Function Interface : IsOne Purpose :  To check whether the ApInt64 number has value of one or not. Usage : --->    Flag = IsOne(ApNum) --->    IF (IsOne(ApNum)) DoSomeThing private  interface ApInt64_Is_One() Arguments None public        interface IsPositive Function Interface : IsPositive Purpose :  To check whether the ApInt64 number has positive value or not. Usage : --->    Flag = IsPositive(ApNum) --->    IF (IsPositive(ApNum)) DoSomeThing private  interface ApInt64_Is_Positive() Arguments None public        interface IsNegative Function Interface : IsNegative Purpose :  To check whether the ApInt64 number has negative value or not. Usage : --->    Flag = IsNegative(ApNum) --->    IF (IsNegative(ApNum)) DoSomeThing private  interface ApInt64_Is_Negative() Arguments None public        interface RandNumApInt64 private module function ApInt64_Random_Number(Prng, Positive, Length) result(BigRnd) Function Interface : RandNumApInt64 Purpose :  To generate and return the ApIn64 number with random value. Usage : ! generate random number with default settings --->    ApNum = RandNumApInt64() ! generate random number with specified PRNG --->    ApNum = RandNumApInt64(PRNG) ! generate random number with negative value --->    ApNum = RandNumApInt64(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    ApNum = RandNumApInt64(Length=MagLen)\nTo generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array Return Value type( ApInt64 ) the ApInt64 number with random value public        interface Display Subroutine Interface : Display Purpose :  To write/display the 'ApInt64' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL Display(ApNum) ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL Display(ApNum, 11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL Display(ApNum, 11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL Display(ApNum, ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL Display(ApNum, Prefix='Signed value of ApNum') private  interface ApInt64_Write() Arguments None public        interface MakeCopy Function Interface : Copy Purpose :  To make a copy of the ApInt64 number. Usage : ! make a copy of the ApInt64 number --->    DstApNum = MakeCopy(SrcApNum) ! make a copy of the ApInt64 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = MakeCopy(SrcApNum, DstCap) private  interface ApInt64_Copy() Arguments None public        interface GetLength Function Interface : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = GetLength(ApNum) private  interface ApInt64_GetLength() Arguments None public        interface AddXp Function Interface : AddXp Purpose :  To perform an addition: OutVal = LhsVal + RhsVal. Usage : --->    OutVal = AddXp(LhsVal, RhsVal, Algorithm) Note : Algorithm must be between 1 and 3. private module function ApInt64_Plus_Xp(LhsVal, RhsVal, Algorithm) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 ) public        interface SubtractXp Function Interface : SubtractXp Purpose :  To perform a subtraction: OutVal = LhsVal - RhsVal. Usage : --->    OutVal = SubtractXp(LhsVal, RhsVal, Algorithm) Note : Algorithm must be between 1 and 3. private module function ApInt64_Minus_Xp(LhsVal, RhsVal, Algorithm) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal.  Valid value of Algorithm is between 1 and 3. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 ) public        interface MultiplyXp Function Interface : MultiplyXp Purpose :  To perform a multiplication: OutVal = LhsVal * RhsVal. Usage : --->    OutVal = MultiplyXp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) Note : Algorithm must be between 1 and 6. private module function ApInt64_Multiply_Xp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal.  Valid value of Algorithm is between 1 and 6. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: LhsVal type( ApInt64 ), intent(in) :: RhsVal integer(kind=kInt32), intent(in) :: KThreshold Threshold to perform Karatsuba algorithm.  If the 'Length' components of\n  both LhsVal and RhsVal are greater than the threshold, use Karatsuba algorithm.  Otherwise, use basic (grade-school) algorithm. integer(kind=kInt32), intent(in) :: BaseCut Threshold to perform basic algorithm when using the Karatsuba algorithm. BaseCut must be less than KThreshold . integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 ) public        interface DivideXp Function Interface : DivideXp Purpose :  To perform a division: Quotient = Dividend / Divisor. Usage : --->    Quotient = DivideXp(Dividend, Divisor, Algorithm) Note : Algorithm must be between 1 and 5. private module function ApInt64_Divide_Xp(Dividend, Divisor, Algorithm) result(Quotient) To perform division: Quotient = Dividend / Divisor.  Valid value of Algorithm is between 1 and 5. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 ) public        interface ModXp Function Interface : ModXp Purpose :  To perform modulation: Remainder = Dividend Mod Divisor. Usage : --->    Remainder = ModXp(Dividend, Divisor, Algorithm) Note : Algorithm must be between 1 and 5. private module function ApInt64_Mod_Xp(Dividend, Divisor, Algorithm) result(Remainder) To perform modulation: Remainder = Dividend Mod Divisor.  Valid value of Algorithm is between 1 and 5. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Dividend type( ApInt64 ), intent(in) :: Divisor integer(kind=kInt32), intent(in) :: Algorithm Return Value type( ApInt64 ) public        interface FromStringXp Function Interface : FromStringXp Purpose :  To construct the ApInt64 number based on the specified decimal\n               string.  Valid value of Algorithm is between 1 and 4. Usage : ---> ApNum = FromStringXp('1234567890987654321011223344', Algorithm) ---> ApNum = FromStringXp('-987654321012345678900123123', Algorithm, ErrFlag) ---> ApNum = FromStringXp(NumStr, 1, ErrMsg=Message) ---> ApNum = FromStringXp(NumStr, 4, ErrFlag, ErrMsg) private module function FromString_Xp(cStr, Algorithm, ErrFlag, ErrMsg) result(Big) To construct the ApInt64 number based on the specified decimal string.\n Valid value of Algorithm is between 1 and 4. Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string integer(kind=kInt32), intent(in) :: Algorithm logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt64 ) number public        interface ToStringXp Function Interface : ToStringXp Purpose :  To convert an arbitrary-precision signed integer to a decimal\n               string.  Valid value of Algorithm is between 1 and 7. Usage : --->    Str = ToStringXp(ApNum, Algorithm) private module function ToString_Xp(Big, Algorithm) result(Str) To convert an arbitrary-precision signed integer to a decimal string.\n Valid value of Algorithm is between 1 and 7. Arguments Type Intent Optional Attributes Name type( ApInt64 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Algorithm Return Value character(kind=kChar, len=:), ALLOCATABLE Derived Types type, public :: ApInt64 ApInt64 is a mutable arbitrary-precision signed integer type where\n  its representations are as follows. - Base is 2 64 . - Magnitude is represented by the 'Digit' array in little-endian order. - The 'Length' first 'Digit' count as the ApInt64 number (i.e. it is always\n  less than or equal to the size/capacity of the 'Digit' array). - Sign is represented by a sign integer (-1 or 1). - Internally zero is allowed to have either sign.\n  (Otherwise one would have to remember to check for sign-swap for division,\n  multiplication etc...) - Zero can have many forms: -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through\n     ZeroApInt64()). -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number\n     is considered to be zero. Constructor Constructor Interface : ApInt64 Purpose :  To construct an ApInt64 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt64(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt64(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt64(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt64(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt64('-123456789098765432101122334455667788990012345') private\n\n                    module\n                    function Construct_ApInt64 (Sign, Length, Digit) To construct the ApInt64 number based on the specified 64-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) private\n\n                    module\n                    function Bytes_To_ApInt64 (Sign, Length, Digit) To construct the ApInt64 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt64(Sign, MagLen, MagArray) private\n\n                    module\n                    function DecString_To_ApInt64 (cStr, ErrFlag, ErrMsg) To construct the ApInt64 number based on the specified decimal string. Usage : ---> ApNum = ApInt64('1234567890987654321011223344') ---> ApNum = ApInt64('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt64(NumStr, ErrMsg=Message) ---> ApNum = ApInt64(NumStr, ErrFlag, ErrMsg) private\n\n                    module\n                    function U32_To_ApInt64 (Sign, U32) To construct the ApInt64 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U32) private\n\n                    module\n                    function U64_To_ApInt64 (Sign, U64) To construct the ApInt64 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U64) private\n\n                    module\n                    function U128_To_ApInt64 (Sign, U128) To construct the ApInt64 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt64(Sign, U128) private\n\n                    module\n                    function I32_To_ApInt64 (I32) To construct the ApInt64 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt64(I32) private\n\n                    module\n                    function I64_To_ApInt64 (I64) To construct the ApInt64 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt64(I64) private\n\n                    module\n                    function I128_To_ApInt64 (I128) To construct the ApInt64 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt64(I128) private\n\n                    module\n                    function R32_To_ApInt64 (R32) To construct the ApInt64 number based on the specified 32-bit real number. Usage : ApNum = ApInt64(R32) private\n\n                    module\n                    function R64_To_ApInt64 (R64) To construct the ApInt64 number based on the specified 64-bit real number. Usage : ApNum = ApInt64(R64) private\n\n                    module\n                    function R128_To_ApInt64 (R128) To construct the ApInt64 number based on the specified 128-bit real number. Usage : ApNum = ApInt64(R128) Type-Bound Procedures procedure, public :: Increment => ApInt64_Increment Type-Bound Subroutine : Increment Purpose :  To increase value of the ApInt64 number by one. Usage : --->    CALL ApNum%Increment() procedure, public :: Decrement => ApInt64_Decrement Type-Bound Subroutine : Decrement Purpose :  To decrease value of the ApInt64 number by one. Usage : --->    CALL ApNum%Decrement() procedure, public :: Square => ApInt64_SquareSub Type-Bound Subroutine : Square Purpose :  To return the ApInt64 number (ApInt64) where its value is\n               computed by: ApNum = ApNum * ApNum. Usage : --->    CALL ApNum%Square() procedure, public :: Compare => ApInt64_Compare Type-Bound Function : Compare Purpose :  To compare two ApInt64 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = LHS%Compare(RHS) --->    IF (LHS%Compare(RHS) /= 0) DoSomething procedure, public :: LShift => ApInt64_LeftShift Type-Bound Subroutine : LShift Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%LShift(112) procedure, public :: RShift => ApInt64_RightShift Type-Bound Subroutine : RShift Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%RShift(112) procedure, public :: IsZero => ApInt64_Is_Zero_II Type-Bound Function : IsZero Purpose :  To check whether the ApInt64 number has value of zero or not. Usage : --->    Flag = ApNum%IsZero() --->    IF (.NOT.ApNum%IsZero()) DoSomething procedure, public :: IsOne => ApInt64_Is_One Type-Bound Function : IsOne Purpose :  To check whether the ApInt64 number has value of one or not. Usage : --->    Flag = ApNum%IsOne() --->    IF (.NOT.ApNum%IsOne()) DoSomething procedure, public :: IsPositive => ApInt64_Is_Positive Type-Bound Function : IsPositive Purpose :  To check whether the ApInt64 number has positive value or not. Usage : --->    Flag = ApNum%IsPositive() --->    IF (.NOT.ApNum%IsPositive()) DoSomething procedure, public :: IsNegative => ApInt64_Is_Negative Type-Bound Function : IsNegative Purpose :  To check whether the ApInt64 number has negative value or not. Usage : --->    Flag = ApNum%IsNegative() --->    IF (.NOT.ApNum%IsNegative()) DoSomething procedure, public :: RandNum => ApInt64_RandNumSub Type-Bound Subroutine : RandNum Purpose :  To generate the ApIn64 number with random value. Usage : ! generate random number with default settings --->    CALL ApNum%RandNum() ! generate random number with specified PRNG --->    CALL ApNum%RandNum(PRNG) ! generate random number with negative value --->    CALL ApNum%RandNum(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    CALL ApNum%RandNum(Length=MagLen) procedure, public :: Copy => ApInt64_Copy Type-Bound Function : Copy Purpose :  To make a copy of the ApInt64 number. Usage : ! make a copy of the ApInt64 number --->    DstApNum = SrcApNum%Copy() ! make a copy of the ApInt64 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = SrcApNum%Copy(DstCap) procedure, public :: Display => ApInt64_Write Type-Bound Subroutine : Display Purpose :  To write/display the 'ApInt64' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL ApNum%Display() ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL ApNum%Display(11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL ApNum%Display(11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL ApNum%Display(ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL ApNum%Display(Prefix='Signed value of ApNum') procedure, public :: GetLength => ApInt64_GetLength Type-Bound Function : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = ApNum%GetLength() generic, public :: Add => ApInt64_Add_I32, ApInt64_Add_I64, ApInt64_Add_I128, ApInt64_Add_ApInt64 Type-Bound Subroutine : Add Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%Add(Other) generic, public :: Subtract => ApInt64_Subtract_I32, ApInt64_Subtract_I64, ApInt64_Subtract_I128, ApInt64_Subtract_ApInt64 Type-Bound Subroutine : Subtract Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%Subtract(Other) generic, public :: Multiply => ApInt64_Times_I32, ApInt64_Times_I64, ApInt64_Times_I128, ApInt64_Times_ApInt64 Type-Bound Subroutine : Multiply Purpose :  To perform a multiplication: This = This * Other. Usage : --->    CALL This%Multiply(Other) generic, public :: Divide => ApInt64_Over_I32, ApInt64_Over_I64, ApInt64_Over_I128, ApInt64_Over_ApInt64 Type-Bound Subroutine : Divide Purpose :  To perform a division: This = This / Other.  Optionally,\n               return the remainder if present. Usage : --->    CALL This%Divide(Other) --->    CALL This%Divide(Other, Remainder) generic, public :: DivMod => ApInt64_DivMod_I32, ApInt64_DivMod_I64, ApInt64_DivMod_I128, ApInt64_DivMod_ApInt64 Type-Bound Subroutine : DivMod Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) procedure, public :: AddXp => ApInt64_Add_Xp Type-Bound Subroutine : AddXp Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%AddXp(Other, Algorithm) Note : Algorithm must be between 1 and 3. procedure, public :: SubtractXp => ApInt64_Subtract_Xp Type-Bound Subroutine : SubtractXp Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%SubtractXp(Other, Algorithm) Note : Algorithm must be between 1 and 3. procedure, public :: DivideXp => ApInt64_Over_Xp Type-Bound Subroutine : DivideXp Purpose :  To perform a division: This = This / Other. Usage : --->    CALL This%DivideXp(Other, Algorithm) Note : Algorithm must be between 1 and 5. procedure, public :: DivModXp => ApInt64_DivMod_Xp Type-Bound Subroutine : DivModXp Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivModXp(Denominator, Algorithm, Quotient, Remainder) Note : Algorithm must be between 1 and 5.","tags":"","loc":"module\\mclass_apint64.html"},{"title":"MBase_Float128 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the Float128 type, its related routines and useful Float128 parameters.\n  The Float128 type is a derived type representing a quadruple-precision floating point number.\n  Internally, it consists of a logical value representing a sign component, two 64-bit integers\n  representing a significand component and a 32-bit integer representing an exponent component.\n  Therefore, it is slightly more precise and has a wider range than the standard IEEE-754 quadruple-\n  precision floating point number. Various common operations typically available for real types are provided including arithmetic,\n  comparison and conversion/construction operations.  Currently, only basic arithmetic operations\n  including addition, subtraction, multiplication and division are implemented. REFERENCES : [1] Quadruple: A 128-bit floating-point arithmetic\n      for Java Uses MBase_Common Variables Type Visibility Attributes Name Initial type( Float128 ), public, parameter :: MIN_VALUE = Float128(FalseVal, 0, 0_kInt64, 1_kInt64) Minimum possible positive value, 6.672829482607474308148353774991346115977e-646457032 type( Float128 ), public, parameter :: MAX_VALUE = Float128(FalseVal, INT(EXPONENT_OF_MAX_VALUE, KIND=kInt32), -1_kInt64, -1_kInt64) Maximum possible value, 1.761613051683963353207493149791840285665e+646456993 type( Float128 ), public, parameter :: MIN_NORMAL = Float128(FalseVal, 1, 0_kInt64, 0_kInt64) Minimum possible positive normal value, 2.270646210401492537526567265179587581247e-646456993 type( Float128 ), public, parameter :: ZERO_F128 = Float128(FalseVal, 0, 0_kInt64, 0_kInt64) Float128 with value of 0.0 type( Float128 ), public, parameter :: ONE_F128 = Float128(FalseVal, EXPONENT_OF_ONE, 0_kInt64, 0_kInt64) Float128 with value of 1.0 type( Float128 ), public, parameter :: TWO_F128 = Float128(FalseVal, -2147483648, 0_kInt64, 0_kInt64) Float128 with value of 2.0 type( Float128 ), public, parameter :: TEN_F128 = Float128(FalseVal, -2147483646, 4611686018427387904_kInt64, 0_kInt64) Float128 with value of 2.0 type( Float128 ), public, parameter :: MINUS_ONE = Float128(TrueVal, EXPONENT_OF_ONE, 0_kInt64, 0_kInt64) Float128 with value of -1.0 type( Float128 ), public, parameter :: NOT_A_NUMBER = Float128(FalseVal, EXPONENT_OF_INFINITY, HIGH_BIT, 0_kInt64) Not a number type( Float128 ), public, parameter :: NEGATIVE_INFINITY = Float128(TrueVal, EXPONENT_OF_INFINITY, 0_kInt64, 0_kInt64) Negative infinity type( Float128 ), public, parameter :: POSITIVE_INFINITY = Float128(FalseVal, EXPONENT_OF_INFINITY, 0_kInt64, 0_kInt64) Positive infinity type( Float128 ), public, parameter :: PI_F128 = Float128(FalseVal, INT(Z'80000000', KIND=kInt32), INT(Z'921FB54442D18469', KIND=kInt64), INT(Z'898CC51701B839A2', KIND=kInt64)) Float128 with value of Pi Interfaces public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between a Float128 number and an other real number. Usage : ! convert 32-bit real number (Fortran intrinsic type) to the Float128 number --->    F128 = R32 ! convert the Float128 number to 128-bit real number (Fortran intrinsic type) --->    R128 = F128 private  interface Float128_Assign() Arguments None private  interface Float128_From_R32() Arguments None private  interface Float128_From_R64() Arguments None private  interface Float128_From_R128() Arguments None private  interface Float128_To_R32() Arguments None private  interface Float128_To_R64() Arguments None private  interface Float128_To_R128() Arguments None public        interface Float128 Constructor Interface : Float128 Purpose :  To construct a Float128 number. Usage : ! construct from 32-bit intrinsic integer number --->    F128 = Float128(I32) ! construct from 64-bit intrinsic real number --->    F128 = Float128(R64) ! construct from a decimal string --->    I128 = Float128('1234567.890987654321011223344E-23132', ErrFlag, ErrMsg) private  interface Construct_Positive_Float128() Arguments None private  interface I32_To_Float128() Arguments None private  interface I64_To_Float128() Arguments None private  interface R32_To_Float128() Arguments None private  interface R64_To_Float128() Arguments None private  interface R128_To_Float128() Arguments None private  interface DecString_To_Float128() Arguments None public        interface ToI32 Function Interface : ToI32 Purpose :  To convert a Float128 number to a 32-bit integer number. Usage : --->    I32 = ToI32(F128) private  interface I32_From_Float128() Arguments None public        interface ToI64 Function Interface : ToI64 Purpose :  To convert a Float128 number to a 64-bit integer number. Usage : --->    I64 = ToI64(F128) private  interface I64_From_Float128() Arguments None public        interface ToR32 Function Interface : ToR32 Purpose :  To convert a Float128 number to a 32-bit real number. Usage : --->    R32 = ToR32(F128) private  interface R32_From_Float128() Arguments None public        interface ToR64 Function Interface : ToR64 Purpose :  To convert a Float128 number to a 64-bit real number. Usage : --->    R64 = ToR64(F128) private  interface R64_From_Float128() Arguments None public        interface ToR128 Function Interface : ToR128 Purpose :  To convert a Float128 number to a 128-bit real number. Usage : --->    R128 = ToR128(F128) private  interface R128_From_Float128() Arguments None public        interface ToDecString Function Interface : ToDecString Purpose :  To convert a Float128 number to a decimal string. Usage : --->    Str = ToDecString(F128) private  interface DecString_From_Float128() Arguments None public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two Float128 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private  interface Float128_Equal() Arguments None public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two Float128 numbers are not equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private  interface Float128_NotEqual() Arguments None public        interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething private  interface Float128_LessThan() Arguments None public        interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething private  interface Float128_LessEqual() Arguments None public        interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething private  interface Float128_GreaterThan() Arguments None public        interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething private  interface Float128_GreaterEqual() Arguments None public        interface Compare Function Interface : Compare Purpose :  To compare Float128 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething private  interface Float128_Compare() Arguments None public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two real numbers (at least one of which is\n      a Float128 number) or to add a unary plus sign to a Float128 number. Usage : --->    OUTPUT = +INPUT --->    OUTPUT = FIRST_IN + SECOND_IN private  interface Float128_UnaryPlus() Arguments None private  interface Float128_Plus_Float128() Arguments None private  interface Float128_Plus_R32() Arguments None private  interface R32_Plus_Float128() Arguments None private  interface Float128_Plus_R64() Arguments None private  interface R64_Plus_Float128() Arguments None public        interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two real numbers (at least one of which is\n      a Float128 number) or to perform a negation of a Float128 number. Usage : --->    OUTPUT = -INPUT --->    OUTPUT = FIRST_IN - SECOND_IN private  interface Float128_Negate() Arguments None private  interface Float128_Minus_Float128() Arguments None private  interface Float128_Minus_R32() Arguments None private  interface R32_Minus_Float128() Arguments None private  interface Float128_Minus_R64() Arguments None private  interface R64_Minus_Float128() Arguments None public        interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two real numbers (at least one of which is\n      a Float128 number). Usage : --->    OUTPUT = FIRST_IN * SECOND_IN private  interface Float128_Multiply_Float128() Arguments None private  interface Float128_Multiply_R32() Arguments None private  interface R32_Multiply_Float128() Arguments None private  interface Float128_Multiply_R64() Arguments None private  interface R64_Multiply_Float128() Arguments None public        interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To perform a division of two real numbers where the dividend (numerator)\n      must be a Float128 number. Usage : --->    OUTPUT = FIRST_IN * SECOND_IN private  interface Float128_Divide_R32() Arguments None private  interface Float128_Divide_R64() Arguments None private  interface Float128_Divide_Float128() Arguments None public        interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two real numbers, where the\n      dividend (numerator) must be a Float128 number. Usage : --->    REM = MOD(NUMER, DENOM) private  interface Float128_Mod_R32() Arguments None private  interface Float128_Mod_R64() Arguments None private  interface Float128_Mod_Float128() Arguments None public        interface DivMod Subroutine Interface : DivMod Purpose :  To perform a division of two real numbers where the dividend (numerator)\n       must be a Float128 number and to return both the quotient and the remainder. Usage : --->    CALL DivMod(NUMER, DENOM, QUOT, REM) private  interface Float128_DivMod_R32() Arguments None private  interface Float128_DivMod_R64() Arguments None private  interface Float128_DivMod_Float128() Arguments None public        interface Increment Subroutine Interface : Increment Purpose :  To increase value of a Float128 number by one. Usage : --->    CALL Increment(F128) private  interface Float128_Increment() Arguments None public        interface Decrement Subroutine Interface : Decrement Purpose :  To decrease value of a Float128 by one. Usage : --->    CALL Decrement(F128) private  interface Float128_Decrement() Arguments None public        interface Add Subroutine Interface : Add Purpose :  To perform addition: This = This + Other. Usage : --->    CALL Add(This, Other) private  interface Float128_Add_R32() Arguments None private  interface Float128_Add_R64() Arguments None private  interface Float128_Add_Float128() Arguments None public        interface Subtract Subroutine Interface : Subtract Purpose :  To perform subtraction: This = This - Other. Usage : --->    CALL Subtract(This, Other) private  interface Float128_Subtract_R32() Arguments None private  interface Float128_Subtract_R64() Arguments None private  interface Float128_Subtract_Float128() Arguments None public        interface Multiply Subroutine Interface : Multiply Purpose :  To perform multiplication: This = This * Other. Usage : --->    CALL Multiply(This, Other) private  interface Float128_Times_R32() Arguments None private  interface Float128_Times_R64() Arguments None private  interface Float128_Times_Float128() Arguments None public        interface Divide Subroutine Interface : Divide Purpose :  To perform a division: This = This / Other. Usage : --->    CALL Divide(This, Other) private  interface Float128_Over_R32() Arguments None private  interface Float128_Over_R64() Arguments None private  interface Float128_Over_Float128() Arguments None public        interface Is_NaN Function Interface : Is_NaN Purpose :  To check whether the input value is a NAN (not a number) or not. Usage : --->    Flag = Is_NaN(INPUT) --->    IF (.NOT.Is_NaN(INPUT)) DoSomeThing private  function Float128_Is_NaN(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical public        interface Is_Infinite Function Interface : Is_Infinite Purpose :  To check whether the input value is an infinity or not. Usage : --->    Flag = Is_Infinite(INPUT) --->    IF (.NOT.Is_Infinite(INPUT)) DoSomeThing private  function Float128_Is_Infinite(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical public        interface Is_Zero Function Interface : IsZero Purpose :  To check whether the input value is zero or not. Usage : --->    Flag = IsZero(INPUT) --->    IF (.NOT.IsZero(INPUT)) DoSomeThing private  function Float128_Is_Zero(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical public        interface Is_Negative Function Interface : IsNegative Purpose :  To check whether the input value is negative or not. Usage : --->    Flag = IsNegative(INPUT) --->    IF (.NOT.IsNegative(INPUT)) DoSomeThing private  function Float128_Is_Negative(F128) result(Flag) Arguments Type Intent Optional Attributes Name type( Float128 ), intent(in) :: F128 Return Value logical Derived Types type, public :: Float128 Float128 is a derived type representing a signed quadruple-precision floating-point\n  number.  Internally, it consists of a logical variable representing its sign, two\n  64-bit integers representing its 128-bit significand, and a 32-bit integer representing\n  its (biased) exponent.  Its value ranges from approximately 6.67283E-646457032 to\n  1.76161E+646456993. Constructor Constructor Interface : Float128 Purpose :  To construct a Float128 number. Usage : ! construct from 32-bit intrinsic integer number --->    F128 = Float128(I32) ! construct from 64-bit intrinsic real number --->    F128 = Float128(R64) ! construct from a decimal string --->    I128 = Float128('1234567.890987654321011223344E-23132', ErrFlag, ErrMsg) private\n\n                    \n                    interface Construct_Positive_Float128 () private\n\n                    \n                    interface I32_To_Float128 () private\n\n                    \n                    interface I64_To_Float128 () private\n\n                    \n                    interface R32_To_Float128 () private\n\n                    \n                    interface R64_To_Float128 () private\n\n                    \n                    interface R128_To_Float128 () private\n\n                    \n                    interface DecString_To_Float128 ()","tags":"","loc":"module\\mbase_float128.html"},{"title":"MClass_ApInt32 – eXPerimental Fortran Library (XpfLib) Documentation","text":"PURPOSE OF THIS MODULE : This module contains the ApInt32 type, its related routines and some useful\n  parameter-like functions.  The ApInt32 type is a derived type representing\n  a mutable, arbitrary-precision signed integer.  Various common operations\n  usually available for integer types are provided including arithmetic, bitwise,\n  comparison, and conversion/construction operations.  The application programming\n  interface (API) follows Fortran intrinsic integer types with additional functions/\n  methods provided. Due to the fact that the ApInt32 type has an allocatable component, unlike\n  other integer types available, the ApInt32 type normally requires an explicit\n  construction either via a constructor method or an assignment expression before\n  being used as an input argument in other operations.  Otherwise, the number\n  would be interpreted as having zero value. If a number is always in a range provided by a 128-bit signed integer, a user can\n  use the SInt128 type instead for efficiency reason.  Likewise, if a number is always in a range\n  provided by a 128-bit unsigned integer, the UInt128 type\n  can be used with better performance. Similar to the SInt128 type, mixed types of signed integer types (32-bit, 64-bit,\n  128-bit or arbitrary-precision) are allowed in arithmetic operations.  Likewise,\n  arguments with Fortran intrinsic integer types in all public methods are considered\n  to be signed, except those in some of conversion methods.  Also, for comparison and\n  bitwise operations that require two input arguments, both arguments must only be the ApInt32 type.  The operations on mixed types are not provided.  Therefore, all other\n  types must be explicitly converted to the ApInt32 type before using in the comparison\n  and bitwise operations. It should be noted that unlike both the SInt128 and UInt128 types where a conventional\n  API (procedural programming) following Fortran integer types is used, the ApInt32 type\n  uses a mixed programming style.  For basic integer operations, a conventional API is used.\n  For additional functionalities provided, both a conventional API and an object-oriented\n  API (via type-bound procedures) are used.  Therefore, for additional functions/methods,\n  the usage of the ApInt32 type may differ from the usage of the SInt128 and UInt128 types. See the ApInt64 type for a mutable,\n  arbitrary-precision signed integer that has mostly identical functionalities.\n  The ApInt64 type is similar to the ApInt32 type, but employs the base of\n  2 64 instead of 2 32 .  Therefore, the ApInt64 type uses\n  many similar algorithms but requires different implementations.  Also, the ApInt64 type provides experimental routines for various operations while\n  the ApInt32 type does not. REFERENCES : [1] The Huldra Project: BigInt [2] Java's Class BigInteger Uses MBase_Common MClass_BaseRng MBase_SInt128 MBase_UInt128 MBase_UIntUtil Interfaces interface public module function ZeroApInt32() result(Big) To return the ApInt32 number with value of zero. Arguments None Return Value type( ApInt32 ) interface public module function OneApInt32() result(Big) To return the ApInt32 number with value of one. Arguments None Return Value type( ApInt32 ) public        interface ASSIGNMENT(=) Operator Overload : ASSIGNMENT(=) Purpose :  To convert between the ApInt32 type and a signed integer\n      (32-bit, 64-bit, 128-bit or arbitrary-precision integer). Usage : ! convert 64-bit signed integer to the ApInt32 type --->    ApNum = I64 ! convert the ApInt32 type to 128-bit signed integer --->    I128 = ApNum private module subroutine ApInt32_Assign(This, Other) To make a copy of the ApInt32 number via an assignment expression. Usage : This = Other Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: This type( ApInt32 ), intent(in) :: Other private module subroutine ApInt32_From_I32(Big, I32) To convert from a 32-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big integer(kind=kInt32), intent(in) :: I32 private module subroutine ApInt32_From_I64(Big, I64) To convert from a 64-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big integer(kind=kInt64), intent(in) :: I64 private module subroutine ApInt32_From_I128(Big, I128) To convert from a 128-bit signed integer to an ApInt32 number\n via an assignment expression. Usage : Big = I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(out) :: Big type(SInt128), intent(in) :: I128 private module subroutine ApInt32_To_I32(I32, Big) To convert from an ApInt32 number to a 32-bit signed integer\n via an assignment expression. Usage : I32 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(out) :: I32 type( ApInt32 ), intent(in) :: Big private module subroutine ApInt32_To_I64(I64, Big) To convert from an ApInt32 number to a 64-bit signed integer\n via an assignment expression. Usage : I64 = Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(out) :: I64 type( ApInt32 ), intent(in) :: Big private module subroutine ApInt32_To_I128(I128, Big) To convert from an ApInt32 number to a 128-bit signed integer\n via an assignment expression. Usage : I128 = Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(out) :: I128 type( ApInt32 ), intent(in) :: Big public        interface ApInt32 Constructor Interface : ApInt32 Purpose :  To construct an ApInt32 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt32(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt32(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt32(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt32(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt32('-123456789098765432101122334455667788990012345') private module function Construct_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 32-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt32), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 32-bit integer array where\n the first element gives the least significant 32 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function Bytes_To_ApInt32(Sign, Length, Digit) result(Big) To construct the ApInt32 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign sign of the number integer(kind=kInt32), intent(in) :: Length length of the magnitude array integer(kind=kInt8), intent(in) :: Digit (0:Length-1) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) Return Value type( ApInt32 ) the arbitrary-precision integer number private module function DecString_To_ApInt32(cStr, ErrFlag, ErrMsg) result(Big) To construct the ApInt32 number based on the specified decimal string. Usage : ---> ApNum = ApInt32('1234567890987654321011223344') ---> ApNum = ApInt32('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt32(NumStr, ErrMsg=Message) ---> ApNum = ApInt32(NumStr, ErrFlag, ErrMsg) Arguments Type Intent Optional Attributes Name character(kind=kChar, len=*), intent(in), TARGET :: cStr character string logical, intent(out), optional :: ErrFlag true if input is not invalid character(kind=kChar, len=:), intent(out), optional, ALLOCATABLE :: ErrMsg message if input is not invalid Return Value type( ApInt32 ) number private module function U32_To_ApInt32(Sign, U32) result(Big) To construct the ApInt32 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt32), intent(in) :: U32 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U64_To_ApInt32(Sign, U64) result(Big) To construct the ApInt32 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U64) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number integer(kind=kInt64), intent(in) :: U64 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function U128_To_ApInt32(Sign, U128) result(Big) To construct the ApInt32 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U128) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: Sign the sign of the number type(UInt128), intent(in) :: U128 the magnitude of the number treated as unsigned Return Value type( ApInt32 ) private module function I32_To_ApInt32(I32) result(Big) To construct the ApInt32 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt32(I32) Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 the 32-bit signed integer Return Value type( ApInt32 ) private module function I64_To_ApInt32(I64) result(Big) To construct the ApInt32 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt32(I64) Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 the 64-bit signed integer Return Value type( ApInt32 ) private module function I128_To_ApInt32(I128) result(Big) To construct the ApInt32 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt32(I128) Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 the 128-bit signed integer Return Value type( ApInt32 ) private module function R32_To_ApInt32(R32) result(Big) To construct the ApInt32 number based on the specified 32-bit real number. Usage : ApNum = ApInt32(R32) Arguments Type Intent Optional Attributes Name real(kind=kSingle), intent(in) :: R32 the 32-bit real number Return Value type( ApInt32 ) private module function R64_To_ApInt32(R64) result(Big) To construct the ApInt32 number based on the specified 64-bit real number. Usage : ApNum = ApInt32(R64) Arguments Type Intent Optional Attributes Name real(kind=kDouble), intent(in) :: R64 the 64-bit real number Return Value type( ApInt32 ) private module function R128_To_ApInt32(R128) result(Big) To construct the ApInt32 number based on the specified 128-bit real number. Usage : ApNum = ApInt32(R128) Arguments Type Intent Optional Attributes Name real(kind=kQuad), intent(in) :: R128 the 128-bit real number Return Value type( ApInt32 ) public        interface ToBytes Subroutine Interface : ToBytes Purpose :  To convert an ApInt32 number to a 8-bit integer magnitude\n  array and its sign. Usage : ---> CALL ToBytes(ApNum, MagArray, Sign) private module subroutine Bytes_From_ApInt32(Big, Digit, Sign) To convert an ApInt32 number to a 8-bit integer magnitude array and its sign. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt8), intent(out), ALLOCATABLE :: Digit (:) the magnitude of the number given as a 8-bit integer array where\n the first element gives the least significant 8 bits (i.e. little\n endian order) integer(kind=kInt32), intent(out), optional :: Sign sign of the number public        interface ToU32 Function Interface : ToU32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit unsigned integer. Usage : --->    U32 = ToU32(ApNum) private module function U32_From_ApInt32(Big) result(U32) To convert the ApInt32 number to a 32-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as unsigned public        interface ToU64 Function Interface : ToU64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit unsigned integer. Usage : --->    U64 = ToU64(ApNum) private module function U64_From_ApInt32(Big) result(U64) To convert the ApInt32 number to a 64-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as unsigned public        interface ToU128 Function Interface : ToU128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit unsigned integer. Usage : --->    U128 = ToU128(ApNum) private module function U128_From_ApInt32(Big) result(U128) To convert the ApInt32 number to a 128-bit unsigned integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value type(UInt128) a 128-bit unsigned integer public        interface ToI32 Function Interface : ToI32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit signed integer. Usage : --->    I32 = ToI32(ApNum) private module function I32_From_ApInt32(Big) result(I32) To convert the ApInt32 number to a 32-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) a 32-bit integer treated as signed public        interface ToI64 Function Interface : ToI64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit signed integer. Usage : --->    I64 = ToI64(ApNum) private module function I64_From_ApInt32(Big) result(I64) To convert the ApInt32 number to a 64-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt64) a 64-bit integer treated as signed public        interface ToI128 Function Interface : ToI128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit signed integer. Usage : --->    I128 = ToI128(ApNum) private module function I128_From_ApInt32(Big) result(I128) To convert the ApInt32 number to a 128-bit signed integer. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value type(SInt128) a 128-bit signed integer public        interface ToR32 Function Interface : ToR32 Purpose :  To convert an arbitrary-precision signed integer to a\n  32-bit real number. Usage : --->    R32 = ToR32(ApNum) private module function R32_From_ApInt32(Big) result(R32) To convert the ApInt32 number to a 32-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kSingle) public        interface ToR64 Function Interface : ToR64 Purpose :  To convert an arbitrary-precision signed integer to a\n  64-bit real number. Usage : --->    R64 = ToR64(ApNum) private module function R64_From_ApInt32(Big) result(R64) To convert the ApInt32 number to a 64-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kDouble) public        interface ToR128 Function Interface : ToR128 Purpose :  To convert an arbitrary-precision signed integer to a\n  128-bit real number. Usage : --->    R128 = ToR128(ApNum) private module function R128_From_ApInt32(Big) result(R128) To convert the ApInt32 number to a 128-bit real number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value real(kind=kQuad) public        interface ToDecString Function Interface : ToDecString Purpose :  To convert an arbitrary-precision signed integer to\n  a decimal string. Usage : --->    Str = ToDecString(ApNum) private module function DecString_From_ApInt32(Big) result(Str) To convert an arbitrary-precision signed integer to a decimal string. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value character(kind=kChar, len=:), ALLOCATABLE public        interface OPERATOR(==) Operator Overload : OPERATOR(==) Purpose :  To check if values of two ApInt32 numbers are equal.\n  Return .TRUE. if both values are equal; otherwise return .FALSE.. Usage : --->    Flag = LHS == RHS --->    IF (LHS .EQ. RHS) DoSomething private module function ApInt32_Equal(LHS, RHS) result(Flag) To check whether two ApInt32 numbers are equal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(/=) Operator Overload : OPERATOR(/=) Purpose :  To check if values of two ApInt32 numbers are NOT equal.\n  Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. Usage : --->    Flag = LHS /= RHS --->    IF (LHS .NE. RHS) DoSomething private module function ApInt32_NotEqual(LHS, RHS) result(Flag) To check whether two ApInt32 numbers NOT are equal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<) Operator Overload : OPERATOR(<) Purpose :  To check if the LHS value is less than the RHS value.\n  Return .TRUE. if LHS < RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS < RHS --->    IF (LHS .LT. RHS) DoSomething private module function ApInt32_LessThan(LHS, RHS) result(Flag) To check whether the LHS number is less than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(<=) Operator Overload : OPERATOR(<=) Purpose :  To check if the LHS value is less than or equal to the RHS value.\n  Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS <= RHS --->    IF (LHS .LE. RHS) DoSomething private module function ApInt32_LessEqual(LHS, RHS) result(Flag) To check whether the LHS number is less than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>) Operator Overload : OPERATOR(>) Purpose :  To check if the LHS value is greater than the RHS value.\n  Return .TRUE. if LHS > RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS > RHS --->    IF (LHS .GT. RHS) DoSomething private module function ApInt32_GreaterThan(LHS, RHS) result(Flag) To check whether the LHS number is greater than the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface OPERATOR(>=) Operator Overload : OPERATOR(>=) Purpose :  To check if the LHS value is greater than or equal to the RHS value.\n  Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. Usage : --->    Flag = LHS >= RHS --->    IF (LHS .GE. RHS) DoSomething private module function ApInt32_GreaterEqual(LHS, RHS) result(Flag) To check whether the LHS number is greater than or equal to the RHS number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LHS type( ApInt32 ), intent(in) :: RHS Return Value logical public        interface Compare Function Interface : Compare Purpose :  To compare two ApInt32 numbers and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = Compare(LHS, RHS) --->    IF (Compare(LHS, RHS) /= 0) DoSomething private  interface ApInt32_Compare() Arguments None public        interface OPERATOR(+) Operator Overload : OPERATOR(+) Purpose :  To perform a summation of two signed integers (at least one\n               of which is a ApInt32 number) or to add a unary plus sign\n               to a ApInt32 number. Usage : --->    OutNum = +InNum --->    OutNum = InNum1 + InNum2 private module function ApInt32_UnaryPlus(InVal) result(OutVal) To return result of the unary plus sign of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 ) private module function ApInt32_Plus_ApInt32(LhsVal, RhsVal) result(OutVal) To perform addition: OutVal = LhsVal + RhsVal. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Plus_I32(Big, I32) result(OutVal) To perform addition: OutVal = Big + I32. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Plus_ApInt32(I32, Big) result(OutVal) To perform addition: OutVal = I32 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Plus_I64(Big, I64) result(OutVal) To perform addition: OutVal = Big + I64. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Plus_ApInt32(I64, Big) result(OutVal) To perform addition: OutVal = I64 + Big. Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Plus_I128(Big, I128) result(OutVal) To perform addition: OutVal = Big + I128. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Plus_ApInt32(I128, Big) result(OutVal) To perform addition: OutVal = I128 + Big. Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) public        interface OPERATOR(-) Operator Overload : OPERATOR(-) Purpose :  To perform a subtraction of two signed integers (at least one\n               of which is a ApInt32 number) or to negate a ApInt32 number. Usage : --->    OutNum = -InNum --->    OutNum = InNum1 - InNum2 private module function ApInt32_Negate(InVal) result(OutVal) To negate a ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 ) private module function ApInt32_Minus_ApInt32(LhsVal, RhsVal) result(OutVal) To perform subtraction: OutVal = LhsVal - RhsVal Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Minus_I32(Big, I32) result(OutVal) To perform subtraction: OutVal = Big - I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Minus_ApInt32(I32, Big) result(OutVal) To perform subtraction: OutVal = I32 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Minus_I64(Big, I64) result(OutVal) To perform subtraction: OutVal = Big - I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Minus_ApInt32(I64, Big) result(OutVal) To perform subtraction: OutVal = I64 - Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Minus_I128(Big, I128) result(OutVal) To perform subtraction: OutVal = Big - I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Minus_ApInt32(I128, Big) result(OutVal) To perform subtraction: OutVal = I128 - Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) public        interface OPERATOR(*) Operator Overload : OPERATOR( * ) Purpose :  To perform a multiplication of two signed integers (at least one\n               of which is a ApInt32 number). Usage : --->    OutNum = InNum1 * InNum2 private module function ApInt32_Multiply_ApInt32(LhsVal, RhsVal) result(OutVal) To perform multiplication: OutVal = LhsVal * RhsVal Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) private module function ApInt32_Multiply_I32(Big, I32) result(OutVal) To perform multiplication: OutVal = Big * I32 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: I32 Return Value type( ApInt32 ) private module function I32_Multiply_ApInt32(I32, Big) result(OutVal) To perform multiplication: OutVal = I32 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt32), intent(in) :: I32 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Multiply_I64(Big, I64) result(OutVal) To perform multiplication: OutVal = Big * I64 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt64), intent(in) :: I64 Return Value type( ApInt32 ) private module function I64_Multiply_ApInt32(I64, Big) result(OutVal) To perform multiplication: OutVal = I64 * Big Arguments Type Intent Optional Attributes Name integer(kind=kInt64), intent(in) :: I64 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) private module function ApInt32_Multiply_I128(Big, I128) result(OutVal) To perform multiplication: OutVal = Big * I128 Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big type(SInt128), intent(in) :: I128 Return Value type( ApInt32 ) private module function I128_Multiply_ApInt32(I128, Big) result(OutVal) To perform multiplication: OutVal = I128 * Big Arguments Type Intent Optional Attributes Name type(SInt128), intent(in) :: I128 type( ApInt32 ), intent(in) :: Big Return Value type( ApInt32 ) public        interface OPERATOR(/) Operator Overload : OPERATOR(/) Purpose :  To return the quotient of a division of two signed integers,\n               where the dividend (numerator) is a ApInt32 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Quotient = Dividend / Divisor private module function ApInt32_Divide_ApInt32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I32(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I64(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Divide_I128(Dividend, Divisor) result(Quotient) To perform division: Quotient = Dividend / Divisor. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt32 ) public        interface MOD Function Interface : MOD Purpose :  To return the remainder of a division of two signed integers,\n               where the dividend (numerator) is a ApInt32 number and the\n               divisor (denominator) can be any signed integer. Usage : --->    Remainder = MOD(Dividend, Divisor) private module function ApInt32_Mod_ApInt32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I32(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt32), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I64(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend integer(kind=kInt64), intent(in) :: Divisor Return Value type( ApInt32 ) private module function ApInt32_Mod_I128(Dividend, Divisor) result(Remainder) To perform modulation:  Remainder = Dividend Mod Divisor Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type(SInt128), intent(in) :: Divisor Return Value type( ApInt32 ) public        interface MODULO Function Interface : MODULO Purpose :  To compute the modulo of two ApInt32 numbers. Usage : --->    Modulo = MODULO(Dividend, Divisor) private module function ApInt32_Modulo(Dividend, Divisor) result(Modulo) To compute the modulo of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Dividend type( ApInt32 ), intent(in) :: Divisor Return Value type( ApInt32 ) public        interface OPERATOR(**) Operator Overload : OPERATOR( ** ) Purpose :  To perform an exponentiation of the ApInt32 number. Usage : --->    NumOut = NumIn**Exp private module function ApInt32_Power(BigIn, Exp) result(BigOut) To perform an exponentiation: BigOut = BigIn**Exp Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: BigIn integer(kind=kInt32), intent(in) :: Exp Return Value type( ApInt32 ) public        interface SQR Function Interface : SQR Purpose :  To compute the square of the ApInt32 number. Usage : --->    NumSqr = SQR(ApNum) private module function ApInt32_Square(BigIn) result(BigOut) To perform squaring: BigOut = BigIn * BigIn. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: BigIn Return Value type( ApInt32 ) public        interface SHIFTL Function Interface : SHIFTL Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTL(NumIn, 157) private module function ApInt32_ShiftLeft(InVal, ShiftPos) result(OutVal) To perform logical left shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 ) public        interface SHIFTR Function Interface : SHIFTR Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    NumOut = SHIFTR(NumIn, 141) private module function ApInt32_ShiftRight(InVal, ShiftPos) result(OutVal) To perform logical right shift where ShiftPos is non-negative. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 ) public        interface ISHFT Function Interface : ISHFT Purpose :  To perform logical shift of an ApInt32 number. Usage : --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 private module function ApInt32_LogicalShift(InVal, ShiftPos) result(OutVal) To perform logical shift of an ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: ShiftPos Return Value type( ApInt32 ) public        interface NOT Function Interface : NOT Purpose :  To return the bitwise logical complement an ApInt32 number. Usage : --->    NumOut = NOT(NumIn) private module function ApInt32_Not(InVal) result(OutVal) To return the bitwise logical complement an ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal Return Value type( ApInt32 ) public        interface IOR Function Interface : IOR Purpose :  To perform an inclusive OR on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IOR(NumIn1, NumIn2) private module function ApInt32_Ior(LhsVal, RhsVal) result(OutVal) To perform an inclusive OR on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) public        interface IEOR Function Interface : IEOR Purpose :  To perform an exclusive OR on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IEOR(NumIn1, NumIn2) private module function ApInt32_Ieor(LhsVal, RhsVal) result(OutVal) To perform an exclusive OR on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) public        interface IAND Function Interface : IAND Purpose :  To perform a logical AND on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IAND(NumIn1, NumIn2) private module function ApInt32_Iand(LhsVal, RhsVal) result(OutVal) To perform a logical AND on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) public        interface IAND_NOT Function Interface : IAND_NOT Purpose :  To perform a bitwise AND and NOT on corresponding bits of two\n               ApInt32 numbers. Usage : --->    NumOut = IAND_NOT(NumIn1, NumIn2) Note : IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). private module function ApInt32_IandNot(LhsVal, RhsVal) result(OutVal) To perform a bitwise AND and NOT on corresponding bits of two ApInt32 numbers. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: LhsVal type( ApInt32 ), intent(in) :: RhsVal Return Value type( ApInt32 ) public        interface LEADZ Function Interface : LEADZ Purpose :  To count the number of leading zero bits of the ApInt32 number. Usage : --->    NumLZ = LEADZ(ApNum) private module function ApInt32_LeadingZeros(Big) result(NumLZ) To count the number of leading zero bits of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface TRAILZ Function Interface : TRAILZ Purpose :  To count the number of trailing zero bits of the ApInt32 number. Usage : --->    NumTZ = TRAILZ(ApNum) private module function ApInt32_TrailingZeros(Big) result(NumTZ) To count the number of trailing zero bits of the ApInt32 number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface POPCNT Function Interface : POPCNT Purpose :  To count the number of 1 bits in the ApInt32 number. Usage : --->    NumBits = POPCNT(ApNum) private module function ApInt32_Count1Bits(Big) result(NumBits) To count the number of 1 bits in the ApInt32 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface POPPAR Function Interface : POPPAR Purpose :  To determine the parity of the ApInt32 number. Usage : --->    NumPar = POPPAR(ApNum) private module function ApInt32_Parity(Big) result(ParNum) To determine the parity of the ApInt32 number.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value integer(kind=kInt32) public        interface IBSET Function Interface : IBSET Purpose :  To set the bit at the specified position to 1. Usage : --->    NumOut = IBSET(NumIn, Pos) private module function ApInt32_SetBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 1.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 ) public        interface IBCLR Function Interface : IBCLR Purpose :  To set the bit at the specified position to 0. Usage : --->    NumOut = IBCLR(NumIn, Pos) private module function ApInt32_ClearBit(InVal, Pos) result(OutVal) To set the bit at the specified position to 0.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 ) public        interface IBCHNG Function Interface : IBCHNG Purpose :  To reverse the bit at the specified position. Usage : --->    NumOut = IBCHNG(NumIn, Pos) private module function ApInt32_FlipBit(InVal, Pos) result(OutVal) To reverse the bit at the specified position.  (For more information,\n see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: InVal integer(kind=kInt32), intent(in) :: Pos Return Value type( ApInt32 ) public        interface BTEST Function Interface : BTEST Purpose :  To check whether the bit at the specified position\n               is 0 (False) or 1 (True). Usage : --->    Flag = BTEST(ApNum, Pos) private module function ApInt32_TestBit(Big, Pos) result(Flag) To check whether the bit at the specified position is 0 (False) or 1 (True).\n (For more information, see detailed explanation of the intrinsic function.) Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big integer(kind=kInt32), intent(in) :: Pos Return Value logical public        interface ABS Function Interface : ABS Purpose :  To return the absolute value of the ApInt32 number. Usage : --->    AbsNum = ABS(ApNum) private  function ApInt32_Absolute(Num) result(Abs) To get the absolute value of the specified number. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Num Return Value type( ApInt32 ) public        interface IsZero Function Interface : IsZero Purpose :  To check whether the ApInt32 number has value of zero or not. Usage : --->    Flag = IsZero(ApNum) --->    IF (IsZero(ApNum)) DoSomeThing private  function ApInt32_Is_Zero(Big) result(Flag) To check whether the number is zero or not. Arguments Type Intent Optional Attributes Name type( ApInt32 ), intent(in) :: Big Return Value logical true if value is zero. public        interface IsOne Function Interface : IsOne Purpose :  To check whether the ApInt32 number has value of one or not. Usage : --->    Flag = IsOne(ApNum) --->    IF (IsOne(ApNum)) DoSomeThing private  interface ApInt32_Is_One() Arguments None public        interface IsPositive Function Interface : IsPositive Purpose :  To check whether the ApInt32 number has positive value or not. Usage : --->    Flag = IsPositive(ApNum) --->    IF (IsPositive(ApNum)) DoSomeThing private  interface ApInt32_Is_Positive() Arguments None public        interface IsNegative Function Interface : IsNegative Purpose :  To check whether the ApInt32 number has negative value or not. Usage : --->    Flag = IsNegative(ApNum) --->    IF (IsNegative(ApNum)) DoSomeThing private  interface ApInt32_Is_Negative() Arguments None public        interface RandNumApInt32 private module function ApInt32_Random_Number(Prng, Positive, Length) result(BigRnd) Function Interface : RandNumApInt32 Purpose :  To generate and return the ApIn64 number with random value. Usage : ! generate random number with default settings --->    ApNum = RandNumApInt32() ! generate random number with specified PRNG --->    ApNum = RandNumApInt32(PRNG) ! generate random number with negative value --->    ApNum = RandNumApInt32(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    ApNum = RandNumApInt32(Length=MagLen)\nTo generate the ApIn64 number with random value. Arguments Type Intent Optional Attributes Name class(BaseRNG), intent(inout), optional, TARGET :: Prng pseudo-random number generator logical, intent(in), optional :: Positive flag indicating whether the number has positive value or not integer(kind=kInt32), intent(in), optional :: Length number indicating the length of magnitude array Return Value type( ApInt32 ) the ApInt32 number with random value public        interface Display Subroutine Interface : Display Purpose :  To write/display the 'ApInt32' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL Display(ApNum) ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL Display(ApNum, 11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL Display(ApNum, 11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL Display(ApNum, ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL Display(ApNum, Prefix='Signed value of ApNum') private  interface ApInt32_Write() Arguments None public        interface MakeCopy Function Interface : Copy Purpose :  To make a copy of the ApInt32 number. Usage : ! make a copy of the ApInt32 number --->    DstApNum = MakeCopy(SrcApNum) ! make a copy of the ApInt32 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = MakeCopy(SrcApNum, DstCap) private  interface ApInt32_Copy() Arguments None public        interface GetLength Function Interface : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = GetLength(ApNum) private  interface ApInt32_GetLength() Arguments None Derived Types type, public :: ApInt32 ApInt32 is a mutable arbitrary-precision signed integer type where\n  its representations are as follows. - Base is 2 32 . - Magnitude is represented by the 'Digit' array in little-endian order. - The 'Length' first 'Digit' count as the ApInt32 number (i.e. it is always\n  less than or equal to the size/capacity of the 'Digit' array). - Sign is represented by a sign integer (-1 or 1). - Internally zero is allowed to have either sign.\n  (Otherwise one would have to remember to check for sign-swap for division,\n  multiplication etc...) - Zero can have many forms: -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through\n     ZeroApInt32()). -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number\n     is considered to be zero. Constructor Constructor Interface : ApInt32 Purpose :  To construct an ApInt32 number. Usage : ! construct ApNum from a magnitude array --->    ApNum = ApInt32(Sign, MagLen, MagArray) ! construct ApNum from 64-bit intrinsic integer treated as signed --->    ApNum = ApInt32(I64) ! construct ApNum from 32-bit intrinsic integer treated as unsigned --->    ApNum = ApInt32(Sign, U32) ! construct ApNum from 128-bit real number --->    ApNum = ApInt32(R128) ! construct ApNum from a decimal string --->    ApNum = ApInt32('-123456789098765432101122334455667788990012345') private\n\n                    module\n                    function Construct_ApInt32 (Sign, Length, Digit) To construct the ApInt32 number based on the specified 32-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) private\n\n                    module\n                    function Bytes_To_ApInt32 (Sign, Length, Digit) To construct the ApInt32 number based on the specified 8-bit integer\n magnitude array and related data. Usage : ApNum = ApInt32(Sign, MagLen, MagArray) private\n\n                    module\n                    function DecString_To_ApInt32 (cStr, ErrFlag, ErrMsg) To construct the ApInt32 number based on the specified decimal string. Usage : ---> ApNum = ApInt32('1234567890987654321011223344') ---> ApNum = ApInt32('-987654321012345678900123123', ErrFlag) ---> ApNum = ApInt32(NumStr, ErrMsg=Message) ---> ApNum = ApInt32(NumStr, ErrFlag, ErrMsg) private\n\n                    module\n                    function U32_To_ApInt32 (Sign, U32) To construct the ApInt32 number based on the specified 32-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U32) private\n\n                    module\n                    function U64_To_ApInt32 (Sign, U64) To construct the ApInt32 number based on the specified 64-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U64) private\n\n                    module\n                    function U128_To_ApInt32 (Sign, U128) To construct the ApInt32 number based on the specified 128-bit unsigned integer. Usage : ApNum = ApInt32(Sign, U128) private\n\n                    module\n                    function I32_To_ApInt32 (I32) To construct the ApInt32 number based on the specified 32-bit signed integer. Usage : ApNum = ApInt32(I32) private\n\n                    module\n                    function I64_To_ApInt32 (I64) To construct the ApInt32 number based on the specified 64-bit signed integer. Usage : ApNum = ApInt32(I64) private\n\n                    module\n                    function I128_To_ApInt32 (I128) To construct the ApInt32 number based on the specified 128-bit signed integer. Usage : ApNum = ApInt32(I128) private\n\n                    module\n                    function R32_To_ApInt32 (R32) To construct the ApInt32 number based on the specified 32-bit real number. Usage : ApNum = ApInt32(R32) private\n\n                    module\n                    function R64_To_ApInt32 (R64) To construct the ApInt32 number based on the specified 64-bit real number. Usage : ApNum = ApInt32(R64) private\n\n                    module\n                    function R128_To_ApInt32 (R128) To construct the ApInt32 number based on the specified 128-bit real number. Usage : ApNum = ApInt32(R128) Type-Bound Procedures procedure, public :: Increment => ApInt32_Increment Type-Bound Subroutine : Increment Purpose :  To increase value of the ApInt32 number by one. Usage : --->    CALL ApNum%Increment() procedure, public :: Decrement => ApInt32_Decrement Type-Bound Subroutine : Decrement Purpose :  To decrease value of the ApInt32 number by one. Usage : --->    CALL ApNum%Decrement() procedure, public :: Square => ApInt32_SquareSub Type-Bound Subroutine : Square Purpose :  To return the ApInt32 number (ApInt32) where its value is\n               computed by: ApNum = ApNum * ApNum. Usage : --->    CALL ApNum%Square() procedure, public :: Compare => ApInt32_Compare Type-Bound Function : Compare Purpose :  To compare two ApInt32 numbers (LHS and RHS) and return -1 if LHS < RHS, 0 if LHS == RHS, or 1 if LHS > RHS. Usage : --->    Flag = LHS%Compare(RHS) --->    IF (LHS%Compare(RHS) /= 0) DoSomething procedure, public :: LShift => ApInt32_LeftShift Type-Bound Subroutine : LShift Purpose :  To perform logical left shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%LShift(112) procedure, public :: RShift => ApInt32_RightShift Type-Bound Subroutine : RShift Purpose :  To perform logical right shift where ShiftPos is non-negative. Usage : --->    CALL ApNum%RShift(112) procedure, public :: IsZero => ApInt32_Is_Zero_II Type-Bound Function : IsZero Purpose :  To check whether the ApInt32 number has value of zero or not. Usage : --->    Flag = ApNum%IsZero() --->    IF (.NOT.ApNum%IsZero()) DoSomething procedure, public :: IsOne => ApInt32_Is_One Type-Bound Function : IsOne Purpose :  To check whether the ApInt32 number has value of one or not. Usage : --->    Flag = ApNum%IsOne() --->    IF (.NOT.ApNum%IsOne()) DoSomething procedure, public :: IsPositive => ApInt32_Is_Positive Type-Bound Function : IsPositive Purpose :  To check whether the ApInt32 number has positive value or not. Usage : --->    Flag = ApNum%IsPositive() --->    IF (.NOT.ApNum%IsPositive()) DoSomething procedure, public :: IsNegative => ApInt32_Is_Negative Type-Bound Function : IsNegative Purpose :  To check whether the ApInt32 number has negative value or not. Usage : --->    Flag = ApNum%IsNegative() --->    IF (.NOT.ApNum%IsNegative()) DoSomething procedure, public :: RandNum => ApInt32_RandNumSub Type-Bound Subroutine : RandNum Purpose :  To generate the ApIn64 number with random value. Usage : ! generate random number with default settings --->    CALL ApNum%RandNum() ! generate random number with specified PRNG --->    CALL ApNum%RandNum(PRNG) ! generate random number with negative value --->    CALL ApNum%RandNum(Positive=.FALSE.) ! generate random number with specified length of magnitude array --->    CALL ApNum%RandNum(Length=MagLen) procedure, public :: Copy => ApInt32_Copy Type-Bound Function : Copy Purpose :  To make a copy of the ApInt32 number. Usage : ! make a copy of the ApInt32 number --->    DstApNum = SrcApNum%Copy() ! make a copy of the ApInt32 number with the specified capacity\n  (size of magnitude array) of the destination number --->    DstApNum = SrcApNum%Copy(DstCap) procedure, public :: Display => ApInt32_Write Type-Bound Subroutine : Display Purpose :  To write/display the 'ApInt32' number to the screen (or the specified unit). Usage : ! To display (signed) value of ApNum as a decimal string to the screen --->    CALL ApNum%Display() ! To display (signed) value of ApNum as a decimal string to the output logical unit --->    CALL ApNum%Display(11) ! To display (signed) value of ApNum as a decimal string to the output logical unit with input/output status and message --->    CALL ApNum%Display(11, IOStat, IOMsg) ! To display (signed) values of components of ApNum as a decimal string to the screen --->    CALL ApNum%Display(ShowComponent=.TRUE.) ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string --->    CALL ApNum%Display(Prefix='Signed value of ApNum') procedure, public :: GetLength => ApInt32_GetLength Type-Bound Function : GetLength Purpose :  To return the length of the magnitude array (the number of\n               digits counted as the ApNum number). Usage : --->    MagLen = ApNum%GetLength() generic, public :: Add => ApInt32_Add_I32, ApInt32_Add_I64, ApInt32_Add_I128, ApInt32_Add_ApInt32 Type-Bound Subroutine : Add Purpose :  To perform an addition: This = This + Other. Usage : --->    CALL This%Add(Other) generic, public :: Subtract => ApInt32_Subtract_I32, ApInt32_Subtract_I64, ApInt32_Subtract_I128, ApInt32_Subtract_ApInt32 Type-Bound Subroutine : Subtract Purpose :  To perform a subtraction: This = This - Other. Usage : --->    CALL This%Subtract(Other) generic, public :: Multiply => ApInt32_Times_I32, ApInt32_Times_I64, ApInt32_Times_I128, ApInt32_Times_ApInt32 Type-Bound Subroutine : Multiply Purpose :  To perform a multiplication: This = This * Other. Usage : --->    CALL This%Multiply(Other) generic, public :: Divide => ApInt32_Over_I32, ApInt32_Over_I64, ApInt32_Over_I128, ApInt32_Over_ApInt32 Type-Bound Subroutine : Divide Purpose :  To perform a division: This = This / Other.  Optionally,\n               return the remainder if present. Usage : --->    CALL This%Divide(Other) --->    CALL This%Divide(Other, Remainder) generic, public :: DivMod => ApInt32_DivMod_I32, ApInt32_DivMod_I64, ApInt32_DivMod_I128, ApInt32_DivMod_ApInt32 Type-Bound Subroutine : DivMod Purpose :  To perform a division and return both quotient and remainder. Usage : --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder)","tags":"","loc":"module\\mclass_apint32.html"},{"title":"MClass_ApInt64.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ApInt64 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ApInt64* type, its related routines and some useful !   parameter-like functions.  The *ApInt64* type is a derived type representing !   a **mutable, arbitrary-precision signed** integer.  Various common operations !   usually available for integer types are provided including arithmetic, bitwise, !   comparison, and conversion/construction operations.  The application programming !   interface (API) follows Fortran intrinsic integer types with additional functions/ !   methods provided. <br> !   Due to the fact that the *ApInt64* type has an allocatable component, unlike !   other integer types available, the *ApInt64* type normally requires an explicit !   construction either via a constructor method or an assignment expression before !   being used as an input argument in other operations.  Otherwise, the number !   would be interpreted as having zero value. <br> !   If a number is always in a range provided by a 128-bit signed integer, a user can !   use the <a href=\"../../xpfbase/module/mbase_sint128.html#type-sint128\">SInt128</a> !   type instead for efficiency reason.  Likewise, if a number is always in a range !   provided by a 128-bit unsigned integer, the !   <a href=\"../../xpfbase/module/mbase_uint128.html#type-uint128\"> UInt128</a> !   type can be used with better performance. <br> !   Similar to the *SInt128* type, mixed types of signed integer types (32-bit, 64-bit, !   128-bit or arbitrary-precision) are allowed in arithmetic operations.  Likewise, !   arguments with Fortran intrinsic integer types in all public methods are considered !   to be signed, except those in some of conversion methods.  Also, for comparison and !   bitwise operations that require two input arguments, both arguments must only be the !   *ApInt64* type.  The operations on mixed types are not provided.  Therefore, all other !   types must be explicitly converted to the *ApInt64* type before using in the comparison !   and bitwise operations. <br> !   It should be noted that unlike both the *SInt128* and *UInt128* types where a conventional !   API (procedural programming) following Fortran integer types is used, the *ApInt64* type !   uses a mixed programming style.  For basic integer operations, a conventional API is used. !   For additional functionalities provided, both a conventional API and an object-oriented !   API (via type-bound procedures) are used.  Therefore, for additional functions/methods, !   the usage of the *ApInt64* type may differ from the usage of the *SInt128* and *UInt128* !   types. <br> !   See the <a href=\"../module/mclass_ApInt32.html\">ApInt32</a> type for a **mutable, !   arbitrary-precision signed** integer that has mostly identical functionalities. !   The *ApInt32* type is similar to the *ApInt64* type, but employs the base of !   2<sup>32</sup> instead of 2<sup>64</sup>.  Therefore, the *ApInt32* type uses !   many similar algorithms but requires different implementations.  Also, the !   *ApInt64* type provides experimental routines for various operations while !   the *ApInt64* type does not. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/bwakell/Huldra/blob/master/src/main/java/org/huldra/math/BigInt.java\"> !       The Huldra Project: BigInt</a> <br> !   [2] <a href=\"https://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html\"> !       Java's Class BigInteger</a> <br> !   [3] <a href=\"https://github.com/chfast/intx\">IntX: Extended precision integer C++ !       library</a> !** USE STATEMENTS: USE MBase_Common USE MBase_UIntUtil USE MBase_SInt128 USE MBase_UInt128 USE MClass_BaseRNG IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type & constructor PUBLIC :: ApInt64 ! assignment & conversion PUBLIC :: ASSIGNMENT ( = ) PUBLIC :: ToU32 , ToU64 , ToU128 PUBLIC :: ToI32 , ToI64 , ToI128 PUBLIC :: ToR32 , ToR64 , ToR128 PUBLIC :: ToBytes , ToDecString ! comparison PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ) PUBLIC :: OPERATOR ( < ), OPERATOR ( <= ) PUBLIC :: OPERATOR ( > ), OPERATOR ( >= ) PUBLIC :: Compare ! arithmetic PUBLIC :: OPERATOR ( + ), OPERATOR ( - ) PUBLIC :: OPERATOR ( * ), OPERATOR ( / ) PUBLIC :: OPERATOR ( ** ) PUBLIC :: MOD , MODULO , SQR ! bitwise PUBLIC :: SHIFTL , SHIFTR , ISHFT PUBLIC :: NOT , IOR , IAND , IAND_NOT PUBLIC :: IEOR , LEADZ , TRAILZ PUBLIC :: POPCNT , POPPAR , IBSET , IBCLR PUBLIC :: IBCHNG , BTEST ! parameter-like PUBLIC :: ZeroApInt64 , OneApInt64 ! inquiry PUBLIC :: IsPositive , IsNegative , IsZero , IsOne ! miscellaneous PUBLIC :: ABS , RandNumApInt64 ! auxiliary PUBLIC :: MakeCopy , GetLength , Display ! experimental PUBLIC :: AddXp , SubtractXp , MultiplyXp PUBLIC :: DivideXp , ModXp PUBLIC :: FromStringXp , ToStringXp PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of the module tCharStar , PARAMETER :: ModName = 'MClass_ApInt64' !** DERIVED TYPE DEFINITIONS !> *ApInt64* is a mutable arbitrary-precision signed integer type where !   its representations are as follows. <br> ! - Base is 2<sup>64</sup>. <br> ! - Magnitude is represented by the 'Digit' array in little-endian order. <br> ! - The 'Length' first 'Digit' count as the *ApInt64* number (i.e. it is always !   less than or equal to the size/capacity of the 'Digit' array). <br> ! - Sign is represented by a sign integer (-1 or 1). <br> ! - Internally zero is allowed to have either sign. !   (Otherwise one would have to remember to check for sign-swap for division, !   multiplication etc...) <br> ! - Zero can have many forms: <br> !   -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through !      ZeroApInt64()). <br> !   -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number !      is considered to be zero. <br> TYPE ApInt64 PRIVATE !> The sign of this number. <br> ! -> +1 for positive numbers and -1 for negative numbers. <br> ! -> Zero can have either sign. tSInt32 :: Sign = 1 !% The number of digits of the number (in base 2<sup>64</sup>). tIndex :: Length = 0_kIndex !> The digits of the number, i.e., the magnitude array. <br> !  Values are treated as unsigned integer tUInt64 , ALLOCATABLE :: Digit (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Private Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ApInt64_Add_I32 PROCEDURE , PRIVATE :: ApInt64_Add_I64 PROCEDURE , PRIVATE :: ApInt64_Add_I128 PROCEDURE , PRIVATE :: ApInt64_Add_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Subtract_I32 PROCEDURE , PRIVATE :: ApInt64_Subtract_I64 PROCEDURE , PRIVATE :: ApInt64_Subtract_I128 PROCEDURE , PRIVATE :: ApInt64_Subtract_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Times_I32 PROCEDURE , PRIVATE :: ApInt64_Times_I64 PROCEDURE , PRIVATE :: ApInt64_Times_I128 PROCEDURE , PRIVATE :: ApInt64_Times_ApInt64 PROCEDURE , PRIVATE :: ApInt64_Over_I32 PROCEDURE , PRIVATE :: ApInt64_Over_I64 PROCEDURE , PRIVATE :: ApInt64_Over_I128 PROCEDURE , PRIVATE :: ApInt64_Over_ApInt64 PROCEDURE , PRIVATE :: ApInt64_DivMod_I32 PROCEDURE , PRIVATE :: ApInt64_DivMod_I64 PROCEDURE , PRIVATE :: ApInt64_DivMod_I128 PROCEDURE , PRIVATE :: ApInt64_DivMod_ApInt64 ! --------------------------------------------------------------------- ! -----                 Public Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Increment <br> !  **Purpose**:  To increase value of the ApInt64 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Increment() PROCEDURE :: Increment => ApInt64_Increment !> **Type-Bound Subroutine**: Decrement <br> !  **Purpose**:  To decrease value of the ApInt64 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Decrement() PROCEDURE :: Decrement => ApInt64_Decrement !> **Type-Bound Subroutine**: Square <br> !  **Purpose**:  To return the ApInt64 number (ApInt64) where its value is !                computed by: ApNum = ApNum * ApNum. <br> !  **Usage**: <br> !   --->    CALL ApNum%Square() PROCEDURE :: Square => ApInt64_SquareSub !> **Type-Bound Function**: Compare <br> !  **Purpose**:  To compare two ApInt64 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = LHS%Compare(RHS) <br> !   --->    IF (LHS%Compare(RHS) /= 0) DoSomething PROCEDURE :: Compare => ApInt64_Compare !> **Type-Bound Subroutine**: LShift <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%LShift(112) PROCEDURE :: LShift => ApInt64_LeftShift !> **Type-Bound Subroutine**: RShift <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%RShift(112) PROCEDURE :: RShift => ApInt64_RightShift !> **Type-Bound Function**: IsZero <br> !  **Purpose**:  To check whether the ApInt64 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsZero() <br> !   --->    IF (.NOT.ApNum%IsZero()) DoSomething PROCEDURE :: IsZero => ApInt64_Is_Zero_II !> **Type-Bound Function**: IsOne <br> !  **Purpose**:  To check whether the ApInt64 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsOne() <br> !   --->    IF (.NOT.ApNum%IsOne()) DoSomething PROCEDURE :: IsOne => ApInt64_Is_One !> **Type-Bound Function**: IsPositive <br> !  **Purpose**:  To check whether the ApInt64 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsPositive() <br> !   --->    IF (.NOT.ApNum%IsPositive()) DoSomething PROCEDURE :: IsPositive => ApInt64_Is_Positive !> **Type-Bound Function**: IsNegative <br> !  **Purpose**:  To check whether the ApInt64 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsNegative() <br> !   --->    IF (.NOT.ApNum%IsNegative()) DoSomething PROCEDURE :: IsNegative => ApInt64_Is_Negative !> **Type-Bound Subroutine**: RandNum <br> !  **Purpose**:  To generate the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    CALL ApNum%RandNum() <br> !   ! generate random number with specified PRNG <br> !   --->    CALL ApNum%RandNum(PRNG) <br> !   ! generate random number with negative value <br> !   --->    CALL ApNum%RandNum(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    CALL ApNum%RandNum(Length=MagLen) PROCEDURE :: RandNum => ApInt64_RandNumSub !> **Type-Bound Function**: Copy <br> !  **Purpose**:  To make a copy of the ApInt64 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt64 number <br> !   --->    DstApNum = SrcApNum%Copy() <br> !   ! make a copy of the ApInt64 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = SrcApNum%Copy(DstCap) PROCEDURE :: Copy => ApInt64_Copy !> **Type-Bound Subroutine**: Display <br> !  **Purpose**:  To write/display the 'ApInt64' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display() <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL ApNum%Display(11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL ApNum%Display(11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display(ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL ApNum%Display(Prefix='Signed value of ApNum') PROCEDURE :: Display => ApInt64_Write !> **Type-Bound Function**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = ApNum%GetLength() PROCEDURE :: GetLength => ApInt64_GetLength ! --------------------------------------------------------------------- ! -----                 Generic Interfaces                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Add <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%Add(Other) GENERIC :: Add => ApInt64_Add_I32 , ApInt64_Add_I64 , & ApInt64_Add_I128 , ApInt64_Add_ApInt64 !> **Type-Bound Subroutine**: Subtract <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%Subtract(Other) GENERIC :: Subtract => ApInt64_Subtract_I32 , ApInt64_Subtract_I64 , & ApInt64_Subtract_I128 , ApInt64_Subtract_ApInt64 !> **Type-Bound Subroutine**: Multiply <br> !  **Purpose**:  To perform a multiplication: This = This * Other. <br> !  **Usage**: <br> !   --->    CALL This%Multiply(Other) GENERIC :: Multiply => ApInt64_Times_I32 , ApInt64_Times_I64 , & ApInt64_Times_I128 , ApInt64_Times_ApInt64 !> **Type-Bound Subroutine**: Divide <br> !  **Purpose**:  To perform a division: This = This / Other.  Optionally, !                return the remainder if present. <br> !  **Usage**: <br> !   --->    CALL This%Divide(Other) <br> !   --->    CALL This%Divide(Other, Remainder) GENERIC :: Divide => ApInt64_Over_I32 , ApInt64_Over_I64 , & ApInt64_Over_I128 , ApInt64_Over_ApInt64 !> **Type-Bound Subroutine**: DivMod <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) GENERIC :: DivMod => ApInt64_DivMod_I32 , ApInt64_DivMod_I64 , & ApInt64_DivMod_I128 , ApInt64_DivMod_ApInt64 ! --------------------------------------------------------------------- ! -----                 Experimental Procedures                   ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: AddXp <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%AddXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. PROCEDURE :: AddXp => ApInt64_Add_Xp !> **Type-Bound Subroutine**: SubtractXp <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%SubtractXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. PROCEDURE :: SubtractXp => ApInt64_Subtract_Xp !> **Type-Bound Subroutine**: DivideXp <br> !  **Purpose**:  To perform a division: This = This / Other. <br> !  **Usage**: <br> !   --->    CALL This%DivideXp(Other, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 5. PROCEDURE :: DivideXp => ApInt64_Over_Xp !> **Type-Bound Subroutine**: DivModXp <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivModXp(Denominator, Algorithm, Quotient, Remainder) <br> !  **Note**: Algorithm must be between 1 and 5. PROCEDURE :: DivModXp => ApInt64_DivMod_Xp ! --------------------------------------------------------------------- END TYPE ApInt64 !** INTERFACE DEFINITIONS: !------------------------------------------------------------ ! type-bound procedure interfaces !------------------------------------------------------------ INTERFACE !------------------------------------------------------------ ! comparison !------------------------------------------------------------ MODULE FUNCTION ApInt64_Compare ( LHS , RHS ) RESULT ( Flag ) !&#94; To compare two ApInt64 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. CLASS ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tSInt32 :: Flag END FUNCTION ApInt64_Compare !------------------------------------------------------------ ! bitwise !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_LeftShift ( Val , ShiftPos ) !&#94; To perform logical left shift with 0 <= ShiftPos <= 128. CLASS ( ApInt64 ), INTENT ( INOUT ) :: Val tSInt32 , INTENT ( IN ) :: ShiftPos END SUBROUTINE ApInt64_LeftShift !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_RightShift ( Val , ShiftPos ) !&#94; To perform logical right shift with 0 <= ShiftPos <= 128. CLASS ( ApInt64 ), INTENT ( INOUT ) :: Val tSInt32 , INTENT ( IN ) :: ShiftPos END SUBROUTINE ApInt64_RightShift !------------------------------------------------------------ ! arithmetic !------------------------------------------------------------ !------------------------------------------------------------ ! 'Plus' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Increment ( Val ) !&#94; To perform addition: Val = Val + 1. CLASS ( ApInt64 ), INTENT ( INOUT ) :: Val END SUBROUTINE ApInt64_Increment !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Add_ApInt64 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Add_ApInt64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Add_I32 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Add_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Add_I64 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Add_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Add_I128 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Add_I128 !------------------------------------------------------------ ! 'Minus' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Decrement ( Val ) !&#94; To perform subtraction: Val = Val - 1. CLASS ( ApInt64 ), INTENT ( INOUT ) :: Val END SUBROUTINE ApInt64_Decrement !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Subtract_ApInt64 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Subtract_ApInt64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Subtract_I32 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Subtract_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Subtract_I64 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Subtract_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Subtract_I128 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Subtract_I128 !------------------------------------------------------------ ! 'Multiply' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Times_ApInt64 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Times_ApInt64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Times_I32 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Times_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Times_I64 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Times_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Times_I128 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Times_I128 !------------------------------------------------------------ ! 'Divide' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_DivMod_ApInt64 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt64 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_DivMod_ApInt64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_DivMod_I32 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt64 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_DivMod_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_DivMod_I64 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt64 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_DivMod_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_DivMod_I128 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt64 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_DivMod_I128 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Over_ApInt64 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other TYPE ( ApInt64 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_Over_ApInt64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Over_I32 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other tSInt32 , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_Over_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Over_I64 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other tSInt64 , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_Over_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Over_I128 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other TYPE ( SInt128 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_Over_I128 !------------------------------------------------------------ ! 'Other' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_SquareSub ( This ) !&#94; To perform self-multiplication: This = This * This. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This END SUBROUTINE ApInt64_SquareSub !------------------------------------------------------------ ! auxiliary !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_Copy ( Source , Capacity ) RESULT ( Destination ) !&#94; To make a copy of the ApInt64 number. CLASS ( ApInt64 ), INTENT ( IN ) :: Source !! the source number !> capacity (size of magnitude array) of the destination number <br> !  if specified, must be greater than capacity of the source number tIndex , OPTIONAL , INTENT ( IN ) :: Capacity TYPE ( ApInt64 ) :: Destination !! the destination number END FUNCTION ApInt64_Copy !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Write ( Big , Unit , IOStat , IOMsg , ShowComponent , Prefix ) !&#94; To write the ApInt64 number to the screen (or the specified unit). CLASS ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , OPTIONAL , INTENT ( IN ) :: Unit !! output logical unit tSInt32 , OPTIONAL , INTENT ( OUT ) :: IOStat !! io stat tCharStar , OPTIONAL , INTENT ( OUT ) :: IOMsg !! io message tLogical , OPTIONAL , INTENT ( IN ) :: ShowComponent !&#94; flag indicating whether to write the upper and lower components. <br> ! - If flag is present and true, write components of the number. <br> ! - Otherwise, write the number as a decimal string. tCharStar , OPTIONAL , INTENT ( IN ) :: Prefix !! prefix string END SUBROUTINE ApInt64_Write !------------------------------------------------------------------------------ MODULE FUNCTION ZeroApInt64 () RESULT ( Big ) !&#94; To return the ApInt64 number with value of zero. TYPE ( ApInt64 ) :: Big END FUNCTION ZeroApInt64 !------------------------------------------------------------------------------ MODULE FUNCTION OneApInt64 () RESULT ( Big ) !&#94; To return the ApInt64 number with value of one. TYPE ( ApInt64 ) :: Big END FUNCTION OneApInt64 !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_Is_Zero_II ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt64 number has value of zero or not. CLASS ( ApInt64 ), INTENT ( INOUT ) :: Big tLogical :: Flag END FUNCTION ApInt64_Is_Zero_II !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_Is_One ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt64 number has value of one or not. CLASS ( ApInt64 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt64_Is_One !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_Is_Positive ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt64 number has positive value or not. CLASS ( ApInt64 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt64_Is_Positive !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_Is_Negative ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt64 number has negative value or not. CLASS ( ApInt64 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt64_Is_Negative !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt64_RandNumSub ( BigRnd , Prng , Positive , Length ) !&#94; To generate the ApIn64 number with random value. CLASS ( ApInt64 ), INTENT ( OUT ) :: BigRnd !! the ApInt64 number with random value CLASS ( BaseRNG ), OPTIONAL , TARGET , INTENT ( INOUT ) :: Prng !! pseudo-random number generator tLogical , OPTIONAL , INTENT ( IN ) :: Positive !! flag indicating whether the number has positive value or not tIndex , OPTIONAL , INTENT ( IN ) :: Length !! number indicating the length of magnitude array END SUBROUTINE ApInt64_RandNumSub !------------------------------------------------------------------------------ MODULE FUNCTION ApInt64_GetLength ( Num ) RESULT ( Length ) !&#94; To return the number of digits counted as the ApNum number. CLASS ( ApInt64 ), INTENT ( IN ) :: Num tIndex :: Length !! the number of digits counted END FUNCTION ApInt64_GetLength !------------------------------------------------------------ ! experimental !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Add_Xp ( This , Other , Algorithm ) !&#94; To perform addition: This = This + Other.  Valid value of !  *Algorithm* is between 1 and 3. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other tSInt32 , INTENT ( IN ) :: Algorithm END SUBROUTINE ApInt64_Add_Xp !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Subtract_Xp ( This , Other , Algorithm ) !&#94; To perform subtraction: This = This - Other.  Valid value of !  *Algorithm* is between 1 and 3. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other tSInt32 , INTENT ( IN ) :: Algorithm END SUBROUTINE ApInt64_Subtract_Xp !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt64_Over_Xp ( This , Other , Algorithm , Remainder ) !&#94; To perform division: This = This / Other.  Valid value of !  *Algorithm* is between 1 and 5.  Optionally, return the !  remainder if present. CLASS ( ApInt64 ), INTENT ( INOUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other tSInt32 , INTENT ( IN ) :: Algorithm TYPE ( ApInt64 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_Over_Xp !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt64_DivMod_Xp ( Dividend , Divisor , Algorithm , Quotient , Remainder ) !&#94; To perform division (Dividend/Divisor) and return both the quotient !  and the remainder.  Valid value of *Algorithm* is between 1 and 5. CLASS ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor tSInt32 , INTENT ( IN ) :: Algorithm TYPE ( ApInt64 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt64 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt64_DivMod_Xp !------------------------------------------------------------------------------ END INTERFACE !** GENERIC DEFINITIONS: !-------------------------------------------------------------------------- !   assignment !-------------------------------------------------------------------------- INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) <br> !  **Purpose**:  To convert between the ApInt64 type and a signed integer !       (32-bit, 64-bit, 128-bit or arbitrary-precision integer). <br> !  **Usage**: <br> !   ! convert 64-bit signed integer to the ApInt64 type <br> !   --->    ApNum = I64 <br> !   ! convert the ApInt64 type to 128-bit signed integer <br> !   --->    I128 = ApNum MODULE SUBROUTINE ApInt64_Assign ( This , Other ) !&#94; To make a copy of the *ApInt64* number via an assignment expression. <br> !  *Usage*: This = Other TYPE ( ApInt64 ), INTENT ( OUT ) :: This TYPE ( ApInt64 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt64_Assign !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_From_I32 ( Big , I32 ) !&#94; To convert from a 32-bit signed integer to an ApInt64 number !  via an assignment expression. <br> !  *Usage*: Big = I32 TYPE ( ApInt64 ), INTENT ( OUT ) :: Big tSInt32 , INTENT ( IN ) :: I32 END SUBROUTINE ApInt64_From_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_From_I64 ( Big , I64 ) !&#94; To convert from a 64-bit signed integer to an ApInt64 number !  via an assignment expression. <br> !  *Usage*: Big = I64 TYPE ( ApInt64 ), INTENT ( OUT ) :: Big tSInt64 , INTENT ( IN ) :: I64 END SUBROUTINE ApInt64_From_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_From_I128 ( Big , I128 ) !&#94; To convert from a 128-bit signed integer to an ApInt64 number !  via an assignment expression. <br> !  *Usage*: Big = I128 TYPE ( ApInt64 ), INTENT ( OUT ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 END SUBROUTINE ApInt64_From_I128 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_To_I32 ( I32 , Big ) !&#94; To convert from an ApInt64 number to a 32-bit signed integer !  via an assignment expression. <br> !  *Usage*: I32 = Big tSInt32 , INTENT ( OUT ) :: I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt64_To_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_To_I64 ( I64 , Big ) !&#94; To convert from an ApInt64 number to a 64-bit signed integer !  via an assignment expression. <br> !  *Usage*: I64 = Big tSInt64 , INTENT ( OUT ) :: I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt64_To_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt64_To_I128 ( I128 , Big ) !&#94; To convert from an ApInt64 number to a 128-bit signed integer !  via an assignment expression. <br> !  *Usage*: I128 = Big TYPE ( SInt128 ), INTENT ( OUT ) :: I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt64_To_I128 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   constructor !-------------------------------------------------------------------------- INTERFACE ApInt64 !&#94; **Constructor Interface**: ApInt64 <br> !  **Purpose**:  To construct an ApInt64 number. <br> !  **Usage**: <br> !   ! construct ApNum from a magnitude array <br> !   --->    ApNum = ApInt64(Sign, MagLen, MagArray) <br> !   ! construct ApNum from 64-bit intrinsic integer treated as signed <br> !   --->    ApNum = ApInt64(I64) <br> !   ! construct ApNum from 32-bit intrinsic integer treated as unsigned <br> !   --->    ApNum = ApInt64(Sign, U32) <br> !   ! construct ApNum from 128-bit real number <br> !   --->    ApNum = ApInt64(R128) <br> !   ! construct ApNum from a decimal string <br> !   --->    ApNum = ApInt64('-123456789098765432101122334455667788990012345') MODULE FUNCTION Construct_ApInt64 ( Sign , Length , Digit ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 64-bit integer !  magnitude array and related data. <br> !  *Usage*: ApNum = ApInt64(Sign, MagLen, MagArray) tSInt32 , INTENT ( IN ) :: Sign !! sign of the number tIndex , INTENT ( IN ) :: Length !! length of the magnitude array !> the magnitude of the number given as a 64-bit integer array where !  the first element gives the least significant 64 bits (i.e. little !  endian order) tUInt64 , INTENT ( IN ) :: Digit ( 0 : Length - 1 ) TYPE ( ApInt64 ) :: Big !! the arbitrary-precision integer number END FUNCTION Construct_ApInt64 !------------------------------------------------------------ MODULE FUNCTION Bytes_To_ApInt64 ( Sign , Length , Digit ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 8-bit integer !  magnitude array and related data. <br> !  *Usage*: ApNum = ApInt64(Sign, MagLen, MagArray) tSInt32 , INTENT ( IN ) :: Sign !! sign of the number tIndex , INTENT ( IN ) :: Length !! length of the magnitude array !> the magnitude of the number given as a 8-bit integer array where !  the first element gives the least significant 8 bits (i.e. little !  endian order) tSInt8 , INTENT ( IN ) :: Digit ( 0 : Length - 1 ) TYPE ( ApInt64 ) :: Big !! the arbitrary-precision integer number END FUNCTION Bytes_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION DecString_To_ApInt64 ( cStr , ErrFlag , ErrMsg ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified decimal string. <br> !  *Usage*:  <br> !  ---> ApNum = ApInt64('1234567890987654321011223344') <br> !  ---> ApNum = ApInt64('-987654321012345678900123123', ErrFlag) <br> !  ---> ApNum = ApInt64(NumStr, ErrMsg=Message) <br> !  ---> ApNum = ApInt64(NumStr, ErrFlag, ErrMsg) tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid TYPE ( ApInt64 ) :: Big !! number END FUNCTION DecString_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION U32_To_ApInt64 ( Sign , U32 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 32-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt64(Sign, U32) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number tUInt32 , INTENT ( IN ) :: U32 !! the magnitude of the number treated as unsigned TYPE ( ApInt64 ) :: Big END FUNCTION U32_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION U64_To_ApInt64 ( Sign , U64 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 64-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt64(Sign, U64) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number tUInt64 , INTENT ( IN ) :: U64 !! the magnitude of the number treated as unsigned TYPE ( ApInt64 ) :: Big END FUNCTION U64_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION U128_To_ApInt64 ( Sign , U128 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 128-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt64(Sign, U128) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number TYPE ( UInt128 ), INTENT ( IN ) :: U128 !! the magnitude of the number treated as unsigned TYPE ( ApInt64 ) :: Big END FUNCTION U128_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION I32_To_ApInt64 ( I32 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 32-bit signed integer. <br> !  *Usage*: ApNum = ApInt64(I32) tSInt32 , INTENT ( IN ) :: I32 !! the 32-bit signed integer TYPE ( ApInt64 ) :: Big END FUNCTION I32_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION I64_To_ApInt64 ( I64 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 64-bit signed integer. <br> !  *Usage*: ApNum = ApInt64(I64) tSInt64 , INTENT ( IN ) :: I64 !! the 64-bit signed integer TYPE ( ApInt64 ) :: Big END FUNCTION I64_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION I128_To_ApInt64 ( I128 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 128-bit signed integer. <br> !  *Usage*: ApNum = ApInt64(I128) TYPE ( SInt128 ), INTENT ( IN ) :: I128 !! the 128-bit signed integer TYPE ( ApInt64 ) :: Big END FUNCTION I128_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION R32_To_ApInt64 ( R32 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 32-bit real number. <br> !  *Usage*: ApNum = ApInt64(R32) tRealSP , INTENT ( IN ) :: R32 !! the 32-bit real number TYPE ( ApInt64 ) :: Big END FUNCTION R32_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION R64_To_ApInt64 ( R64 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 64-bit real number. <br> !  *Usage*: ApNum = ApInt64(R64) tRealDP , INTENT ( IN ) :: R64 !! the 64-bit real number TYPE ( ApInt64 ) :: Big END FUNCTION R64_To_ApInt64 !------------------------------------------------------------ MODULE FUNCTION R128_To_ApInt64 ( R128 ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified 128-bit real number. <br> !  *Usage*: ApNum = ApInt64(R128) tRealQP , INTENT ( IN ) :: R128 !! the 128-bit real number TYPE ( ApInt64 ) :: Big END FUNCTION R128_To_ApInt64 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   conversion !-------------------------------------------------------------------------- INTERFACE ToBytes !&#94; **Subroutine Interface**: ToBytes <br> !  **Purpose**:  To convert an ApInt64 number to a 8-bit integer magnitude !   array and its sign. <br> !  **Usage**: <br> !   ---> CALL ToBytes(ApNum, MagArray, Sign) MODULE SUBROUTINE Bytes_From_ApInt64 ( Big , Digit , Sign ) !&#94; To convert an ApInt64 number to a 8-bit integer magnitude array and its sign. TYPE ( ApInt64 ), INTENT ( IN ) :: Big !> the magnitude of the number given as a 8-bit integer array where !  the first element gives the least significant 8 bits (i.e. little !  endian order) tSInt8 , ALLOCATABLE , INTENT ( OUT ) :: Digit (:) tSInt32 , OPTIONAL , INTENT ( OUT ) :: Sign !! sign of the number END SUBROUTINE Bytes_From_ApInt64 END INTERFACE INTERFACE ToU32 !&#94; **Function Interface**: ToU32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U32 = ToU32(ApNum) MODULE FUNCTION U32_From_ApInt64 ( Big ) RESULT ( U32 ) !&#94; To convert the ApInt64 number to a 32-bit unsigned integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tUInt32 :: U32 !! a 32-bit integer treated as unsigned END FUNCTION U32_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToU64 !&#94; **Function Interface**: ToU64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U64 = ToU64(ApNum) MODULE FUNCTION U64_From_ApInt64 ( Big ) RESULT ( U64 ) !&#94; To convert the ApInt64 number to a 64-bit unsigned integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tUInt64 :: U64 !! a 64-bit integer treated as unsigned END FUNCTION U64_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToU128 !&#94; **Function Interface**: ToU128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U128 = ToU128(ApNum) MODULE FUNCTION U128_From_ApInt64 ( Big ) RESULT ( U128 ) !&#94; To convert the ApInt64 number to a 128-bit unsigned integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( UInt128 ) :: U128 !! a 128-bit unsigned integer END FUNCTION U128_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToI32 !&#94; **Function Interface**: ToI32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit signed integer. <br> !  **Usage**: <br> !   --->    I32 = ToI32(ApNum) MODULE FUNCTION I32_From_ApInt64 ( Big ) RESULT ( I32 ) !&#94; To convert the ApInt64 number to a 32-bit signed integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 :: I32 !! a 32-bit integer treated as signed END FUNCTION I32_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToI64 !&#94; **Function Interface**: ToI64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit signed integer. <br> !  **Usage**: <br> !   --->    I64 = ToI64(ApNum) MODULE FUNCTION I64_From_ApInt64 ( Big ) RESULT ( I64 ) !&#94; To convert the ApInt64 number to a 64-bit signed integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt64 :: I64 !! a 64-bit integer treated as signed END FUNCTION I64_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToI128 !&#94; **Function Interface**: ToI128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit signed integer. <br> !  **Usage**: <br> !   --->    I128 = ToI128(ApNum) MODULE FUNCTION I128_From_ApInt64 ( Big ) RESULT ( I128 ) !&#94; To convert the ApInt64 number to a 128-bit signed integer. TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( SInt128 ) :: I128 !! a 128-bit signed integer END FUNCTION I128_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToR32 !&#94; **Function Interface**: ToR32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit real number. <br> !  **Usage**: <br> !   --->    R32 = ToR32(ApNum) MODULE FUNCTION R32_From_ApInt64 ( Big ) RESULT ( R32 ) !&#94; To convert the ApInt64 number to a 32-bit real number. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tRealSP :: R32 END FUNCTION R32_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToR64 !&#94; **Function Interface**: ToR64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit real number. <br> !  **Usage**: <br> !   --->    R64 = ToR64(ApNum) MODULE FUNCTION R64_From_ApInt64 ( Big ) RESULT ( R64 ) !&#94; To convert the ApInt64 number to a 64-bit real number. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tRealDP :: R64 END FUNCTION R64_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToR128 !&#94; **Function Interface**: ToR128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit real number. <br> !  **Usage**: <br> !   --->    R128 = ToR128(ApNum) MODULE FUNCTION R128_From_ApInt64 ( Big ) RESULT ( R128 ) !&#94; To convert the ApInt64 number to a 128-bit real number. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tRealQP :: R128 END FUNCTION R128_From_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE ToDecString !&#94; **Function Interface**: ToDecString <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to !   a decimal string. <br> !  **Usage**: <br> !   --->    Str = ToDecString(ApNum) MODULE FUNCTION DecString_From_ApInt64 ( Big ) RESULT ( Str ) !&#94; To convert an arbitrary-precision signed integer to a decimal string. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tCharAlloc :: Str END FUNCTION DecString_From_ApInt64 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   comparison !-------------------------------------------------------------------------- INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) <br> !  **Purpose**:  To check if values of two ApInt64 numbers are equal. !   Return .TRUE. if both values are equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS == RHS <br> !   --->    IF (LHS .EQ. RHS) DoSomething MODULE FUNCTION ApInt64_Equal ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether two ApInt64 numbers are equal. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_Equal !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) <br> !  **Purpose**:  To check if values of two ApInt64 numbers are NOT equal. !   Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS /= RHS <br> !   --->    IF (LHS .NE. RHS) DoSomething MODULE FUNCTION ApInt64_NotEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether two ApInt64 numbers NOT are equal. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_NotEqual !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( < ) !&#94; **Operator Overload**: OPERATOR(<) <br> !  **Purpose**:  To check if the LHS value is less than the RHS value. !   Return .TRUE. if LHS < RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS < RHS <br> !   --->    IF (LHS .LT. RHS) DoSomething MODULE FUNCTION ApInt64_LessThan ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is less than the RHS number. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_LessThan !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( <= ) !&#94; **Operator Overload**: OPERATOR(<=) <br> !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value. !   Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS <= RHS <br> !   --->    IF (LHS .LE. RHS) DoSomething MODULE FUNCTION ApInt64_LessEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is less than or equal to the RHS number. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_LessEqual !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( > ) !&#94; **Operator Overload**: OPERATOR(>) <br> !  **Purpose**:  To check if the LHS value is greater than the RHS value. !   Return .TRUE. if LHS > RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS > RHS <br> !   --->    IF (LHS .GT. RHS) DoSomething MODULE FUNCTION ApInt64_GreaterThan ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is greater than the RHS number. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_GreaterThan !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( >= ) !&#94; **Operator Overload**: OPERATOR(>=) <br> !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value. !   Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS >= RHS <br> !   --->    IF (LHS .GE. RHS) DoSomething MODULE FUNCTION ApInt64_GreaterEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is greater than or equal to the RHS number. TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt64_GreaterEqual !------------------------------------------------------------ END INTERFACE INTERFACE Compare !&#94; **Function Interface**: Compare <br> !  **Purpose**:  To compare two ApInt64 numbers and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = Compare(LHS, RHS) <br> !   --->    IF (Compare(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE ApInt64_Compare !------------------------------------------------------------ END INTERFACE INTERFACE CompareAbs !&#94; **Function Interface**: CompareAbs <br> !  **Purpose**:  To compare the absolute values of two ApInt64 numbers and return <br> !   -1 if ABS(LHS) <  ABS(RHS), <br> !    0 if ABS(LHS) == ABS(RHS), or <br> !    1 if ABS(LHS) >  ABS(RHS). <br> !  **Usage**: <br> !   --->    Flag = CompareAbs(LHS, RHS) <br> !   --->    IF (CompareAbs(LHS, RHS) /= 0) DoSomething MODULE FUNCTION ApInt64_CompareAbs ( LHS , RHS ) RESULT ( Flag ) !&#94; To compare the absolute value of LHS and RHS. <br> ! - Return -1 if ABS(LHS) <  ABS(RHS). <br> ! - Return  0 if ABS(LHS) == ABS(RHS). <br> ! - Return +1 if ABS(LHS) >  ABS(RHS). TYPE ( ApInt64 ), INTENT ( IN ) :: LHS TYPE ( ApInt64 ), INTENT ( IN ) :: RHS tSInt32 :: Flag END FUNCTION ApInt64_CompareAbs !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   arithmetic !-------------------------------------------------------------------------- INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) <br> !  **Purpose**:  To perform a summation of two signed integers (at least one !                of which is a ApInt64 number) or to add a unary plus sign !                to a ApInt64 number. <br> !  **Usage**: <br> !   --->    OutNum = +InNum <br> !   --->    OutNum = InNum1 + InNum2 MODULE FUNCTION ApInt64_UnaryPlus ( InVal ) RESULT ( OutVal ) !&#94; To return result of the unary plus sign of the ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_UnaryPlus !------------------------------------------------------------ MODULE FUNCTION ApInt64_Plus_ApInt64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = LhsVal + RhsVal. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Plus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Plus_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I32. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Plus_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Plus_ApInt64 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I32 + Big. tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I32_Plus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Plus_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I64. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Plus_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Plus_ApInt64 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I64 + Big. tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I64_Plus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Plus_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I128. TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Plus_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Plus_ApInt64 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I128 + Big. TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I128_Plus_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( - ) !&#94; **Operator Overload**: OPERATOR(-) <br> !  **Purpose**:  To perform a subtraction of two signed integers (at least one !                of which is a ApInt64 number) or to negate a ApInt64 number. <br> !  **Usage**: <br> !   --->    OutNum = -InNum <br> !   --->    OutNum = InNum1 - InNum2 MODULE FUNCTION ApInt64_Negate ( InVal ) RESULT ( OutVal ) !&#94; To negate a ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Negate !------------------------------------------------------------ MODULE FUNCTION ApInt64_Minus_ApInt64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = LhsVal - RhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Minus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Minus_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Minus_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Minus_ApInt64 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I32 - Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I32_Minus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Minus_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Minus_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Minus_ApInt64 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I64 - Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I64_Minus_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Minus_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Minus_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Minus_ApInt64 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I128 - Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I128_Minus_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( * ) !&#94; **Operator Overload**: OPERATOR( * ) <br> !  **Purpose**:  To perform a multiplication of two signed integers (at least one !                of which is a ApInt64 number). <br> !  **Usage**: <br> !   --->    OutNum = InNum1 * InNum2 MODULE FUNCTION ApInt64_Multiply_ApInt64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = LhsVal * RhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Multiply_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Multiply_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Multiply_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Multiply_ApInt64 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I32 * Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I32_Multiply_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Multiply_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Multiply_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Multiply_ApInt64 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I64 * Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I64_Multiply_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Multiply_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Multiply_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Multiply_ApInt64 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I128 * Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt64 ), INTENT ( IN ) :: Big TYPE ( ApInt64 ) :: OutVal END FUNCTION I128_Multiply_ApInt64 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( / ) !&#94; **Operator Overload**: OPERATOR(/) <br> !  **Purpose**:  To return the quotient of a division of two signed integers, !                where the dividend (numerator) is a ApInt64 number and the !                divisor (denominator) can be any signed integer. <br> !  **Usage**: <br> !   --->    Quotient = Dividend / Divisor MODULE FUNCTION ApInt64_Divide_ApInt64 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Quotient END FUNCTION ApInt64_Divide_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Divide_I32 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Quotient END FUNCTION ApInt64_Divide_I32 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Divide_I64 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Quotient END FUNCTION ApInt64_Divide_I64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Divide_I128 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Quotient END FUNCTION ApInt64_Divide_I128 !------------------------------------------------------------ END INTERFACE INTERFACE MOD !&#94; **Function Interface**: MOD <br> !  **Purpose**:  To return the remainder of a division of two signed integers, !                where the dividend (numerator) is a ApInt64 number and the !                divisor (denominator) can be any signed integer. <br> !  **Usage**: <br> !   --->    Remainder = MOD(Dividend, Divisor) MODULE FUNCTION ApInt64_Mod_ApInt64 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Remainder END FUNCTION ApInt64_Mod_ApInt64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Mod_I32 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Remainder END FUNCTION ApInt64_Mod_I32 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Mod_I64 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Remainder END FUNCTION ApInt64_Mod_I64 !------------------------------------------------------------ MODULE FUNCTION ApInt64_Mod_I128 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Remainder END FUNCTION ApInt64_Mod_I128 !------------------------------------------------------------ END INTERFACE INTERFACE MODULO !&#94; **Function Interface**: MODULO <br> !  **Purpose**:  To compute the modulo of two ApInt64 numbers. <br> !  **Usage**: <br> !   --->    Modulo = MODULO(Dividend, Divisor) MODULE FUNCTION ApInt64_Modulo ( Dividend , Divisor ) RESULT ( Modulo ) !&#94; To compute the modulo of two ApInt64 numbers. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor TYPE ( ApInt64 ) :: Modulo END FUNCTION ApInt64_Modulo !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( ** ) !&#94; **Operator Overload**: OPERATOR( ** ) <br> !  **Purpose**:  To perform an exponentiation of the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumOut = NumIn**Exp MODULE FUNCTION ApInt64_Power ( BigIn , Exp ) RESULT ( BigOut ) !&#94; To perform an exponentiation: BigOut = BigIn**Exp TYPE ( ApInt64 ), INTENT ( IN ) :: BigIn tSInt32 , INTENT ( IN ) :: Exp TYPE ( ApInt64 ) :: BigOut END FUNCTION ApInt64_Power !------------------------------------------------------------ END INTERFACE INTERFACE SQR !&#94; **Function Interface**: SQR <br> !  **Purpose**:  To compute the square of the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumSqr = SQR(ApNum) MODULE FUNCTION ApInt64_Square ( BigIn ) RESULT ( BigOut ) !&#94; To perform squaring: BigOut = BigIn * BigIn. TYPE ( ApInt64 ), INTENT ( IN ) :: BigIn TYPE ( ApInt64 ) :: BigOut END FUNCTION ApInt64_Square !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   bitwise !-------------------------------------------------------------------------- INTERFACE SHIFTL !&#94; **Function Interface**: SHIFTL <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    NumOut = SHIFTL(NumIn, 157) MODULE FUNCTION ApInt64_ShiftLeft ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical left shift where ShiftPos is non-negative. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_ShiftLeft !------------------------------------------------------------ END INTERFACE INTERFACE SHIFTR !&#94; **Function Interface**: SHIFTR <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    NumOut = SHIFTR(NumIn, 141) MODULE FUNCTION ApInt64_ShiftRight ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical right shift where ShiftPos is non-negative. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_ShiftRight !------------------------------------------------------------ END INTERFACE INTERFACE ISHFT !&#94; **Function Interface**: ISHFT <br> !  **Purpose**:  To perform logical shift of an ApInt64 number. <br> !  **Usage**: <br> !   --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 <br> !   --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 MODULE FUNCTION ApInt64_LogicalShift ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical shift of an ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_LogicalShift !------------------------------------------------------------ END INTERFACE INTERFACE NOT !&#94; **Function Interface**: NOT <br> !  **Purpose**:  To return the bitwise logical complement an ApInt64 number. <br> !  **Usage**: <br> !   --->    NumOut = NOT(NumIn) MODULE FUNCTION ApInt64_Not ( InVal ) RESULT ( OutVal ) !&#94; To return the bitwise logical complement an ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: InVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Not !------------------------------------------------------------ END INTERFACE INTERFACE IOR !&#94; **Function Interface**: IOR <br> !  **Purpose**:  To perform an inclusive OR on corresponding bits of two !                ApInt64 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IOR(NumIn1, NumIn2) MODULE FUNCTION ApInt64_Ior ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform an inclusive OR on corresponding bits of two ApInt64 numbers. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Ior !------------------------------------------------------------ END INTERFACE INTERFACE IEOR !&#94; **Function Interface**: IEOR <br> !  **Purpose**:  To perform an exclusive OR on corresponding bits of two !                ApInt64 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IEOR(NumIn1, NumIn2) MODULE FUNCTION ApInt64_Ieor ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform an exclusive OR on corresponding bits of two ApInt64 numbers. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Ieor !------------------------------------------------------------ END INTERFACE INTERFACE IAND !&#94; **Function Interface**: IAND <br> !  **Purpose**:  To perform a logical AND on corresponding bits of two !                ApInt64 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IAND(NumIn1, NumIn2) MODULE FUNCTION ApInt64_Iand ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform a logical AND on corresponding bits of two ApInt64 numbers. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_Iand !------------------------------------------------------------ END INTERFACE INTERFACE IAND_NOT !&#94; **Function Interface**: IAND_NOT <br> !  **Purpose**:  To perform a bitwise AND and NOT on corresponding bits of two !                ApInt64 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IAND_NOT(NumIn1, NumIn2) <br> !  **Note**: IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). MODULE FUNCTION ApInt64_IandNot ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform a bitwise AND and NOT on corresponding bits of two ApInt64 numbers. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_IandNot !------------------------------------------------------------ END INTERFACE INTERFACE LEADZ !&#94; **Function Interface**: LEADZ <br> !  **Purpose**:  To count the number of leading zero bits of the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumLZ = LEADZ(ApNum) MODULE FUNCTION ApInt64_LeadingZeros ( Big ) RESULT ( NumLZ ) !&#94; To count the number of leading zero bits of the ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 :: NumLZ END FUNCTION ApInt64_LeadingZeros !------------------------------------------------------------ END INTERFACE INTERFACE TRAILZ !&#94; **Function Interface**: TRAILZ <br> !  **Purpose**:  To count the number of trailing zero bits of the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumTZ = TRAILZ(ApNum) MODULE FUNCTION ApInt64_TrailingZeros ( Big ) RESULT ( NumTZ ) !&#94; To count the number of trailing zero bits of the ApInt64 number. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 :: NumTZ END FUNCTION ApInt64_TrailingZeros !------------------------------------------------------------ END INTERFACE INTERFACE POPCNT !&#94; **Function Interface**: POPCNT <br> !  **Purpose**:  To count the number of 1 bits in the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumBits = POPCNT(ApNum) MODULE FUNCTION ApInt64_Count1Bits ( Big ) RESULT ( NumBits ) !&#94; To count the number of 1 bits in the ApInt64 number.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 :: NumBits END FUNCTION ApInt64_Count1Bits !------------------------------------------------------------ END INTERFACE INTERFACE POPPAR !&#94; **Function Interface**: POPPAR <br> !  **Purpose**:  To determine the parity of the ApInt64 number. <br> !  **Usage**: <br> !   --->    NumPar = POPPAR(ApNum) MODULE FUNCTION ApInt64_Parity ( Big ) RESULT ( ParNum ) !&#94; To determine the parity of the ApInt64 number.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 :: ParNum END FUNCTION ApInt64_Parity !------------------------------------------------------------ END INTERFACE INTERFACE IBSET !&#94; **Function Interface**: IBSET <br> !  **Purpose**:  To set the bit at the specified position to 1. <br> !  **Usage**: <br> !   --->    NumOut = IBSET(NumIn, Pos) MODULE FUNCTION ApInt64_SetBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To set the bit at the specified position to 1.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_SetBit !------------------------------------------------------------ END INTERFACE INTERFACE IBCLR !&#94; **Function Interface**: IBCLR <br> !  **Purpose**:  To set the bit at the specified position to 0. <br> !  **Usage**: <br> !   --->    NumOut = IBCLR(NumIn, Pos) MODULE FUNCTION ApInt64_ClearBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To set the bit at the specified position to 0.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_ClearBit !------------------------------------------------------------ END INTERFACE INTERFACE IBCHNG !&#94; **Function Interface**: IBCHNG <br> !  **Purpose**:  To reverse the bit at the specified position. <br> !  **Usage**: <br> !   --->    NumOut = IBCHNG(NumIn, Pos) MODULE FUNCTION ApInt64_FlipBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To reverse the bit at the specified position.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt64 ) :: OutVal END FUNCTION ApInt64_FlipBit !------------------------------------------------------------ END INTERFACE INTERFACE BTEST !&#94; **Function Interface**: BTEST <br> !  **Purpose**:  To check whether the bit at the specified position !                is 0 (False) or 1 (True). <br> !  **Usage**: <br> !   --->    Flag = BTEST(ApNum, Pos) MODULE FUNCTION ApInt64_TestBit ( Big , Pos ) RESULT ( Flag ) !&#94; To check whether the bit at the specified position is 0 (False) or 1 (True). !  (For more information, see detailed explanation of the intrinsic function.) TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: Pos tLogical :: Flag END FUNCTION ApInt64_TestBit !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   miscellaneous !-------------------------------------------------------------------------- INTERFACE ABS !&#94; **Function Interface**: ABS <br> !  **Purpose**:  To return the absolute value of the ApInt64 number. <br> !  **Usage**: <br> !   --->    AbsNum = ABS(ApNum) MODULE PROCEDURE ApInt64_Absolute END INTERFACE INTERFACE IsZero !&#94; **Function Interface**: IsZero <br> !  **Purpose**:  To check whether the ApInt64 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = IsZero(ApNum) <br> !   --->    IF (IsZero(ApNum)) DoSomeThing MODULE PROCEDURE ApInt64_Is_Zero END INTERFACE INTERFACE IsOne !&#94; **Function Interface**: IsOne <br> !  **Purpose**:  To check whether the ApInt64 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = IsOne(ApNum) <br> !   --->    IF (IsOne(ApNum)) DoSomeThing MODULE PROCEDURE ApInt64_Is_One END INTERFACE INTERFACE IsPositive !&#94; **Function Interface**: IsPositive <br> !  **Purpose**:  To check whether the ApInt64 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = IsPositive(ApNum) <br> !   --->    IF (IsPositive(ApNum)) DoSomeThing MODULE PROCEDURE ApInt64_Is_Positive END INTERFACE INTERFACE IsNegative !&#94; **Function Interface**: IsNegative <br> !  **Purpose**:  To check whether the ApInt64 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = IsNegative(ApNum) <br> !   --->    IF (IsNegative(ApNum)) DoSomeThing MODULE PROCEDURE ApInt64_Is_Negative END INTERFACE INTERFACE RandNumApInt64 !> **Function Interface**: RandNumApInt64 <br> !  **Purpose**:  To generate and return the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    ApNum = RandNumApInt64() <br> !   ! generate random number with specified PRNG <br> !   --->    ApNum = RandNumApInt64(PRNG) <br> !   ! generate random number with negative value <br> !   --->    ApNum = RandNumApInt64(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    ApNum = RandNumApInt64(Length=MagLen) MODULE FUNCTION ApInt64_Random_Number ( Prng , Positive , Length ) RESULT ( BigRnd ) !&#94; To generate the ApIn64 number with random value. CLASS ( BaseRNG ), OPTIONAL , TARGET , INTENT ( INOUT ) :: Prng !! pseudo-random number generator tLogical , OPTIONAL , INTENT ( IN ) :: Positive !! flag indicating whether the number has positive value or not tIndex , OPTIONAL , INTENT ( IN ) :: Length !! number indicating the length of magnitude array TYPE ( ApInt64 ) :: BigRnd !! the ApInt64 number with random value END FUNCTION ApInt64_Random_Number !------------------------------------------------------------------------------ END INTERFACE INTERFACE Display !&#94; **Subroutine Interface**: Display <br> !  **Purpose**:  To write/display the 'ApInt64' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL Display(ApNum) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL Display(ApNum, 11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL Display(ApNum, 11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL Display(ApNum, ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL Display(ApNum, Prefix='Signed value of ApNum') MODULE PROCEDURE ApInt64_Write END INTERFACE INTERFACE MakeCopy !&#94; **Function Interface**: Copy <br> !  **Purpose**:  To make a copy of the ApInt64 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt64 number <br> !   --->    DstApNum = MakeCopy(SrcApNum) <br> !   ! make a copy of the ApInt64 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = MakeCopy(SrcApNum, DstCap) MODULE PROCEDURE ApInt64_Copy END INTERFACE INTERFACE GetLength !&#94; **Function Interface**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = GetLength(ApNum) MODULE PROCEDURE ApInt64_GetLength END INTERFACE !-------------------------------------------------------------------------- !   experimental !-------------------------------------------------------------------------- INTERFACE AddXp !&#94; **Function Interface**: AddXp <br> !  **Purpose**:  To perform an addition: OutVal = LhsVal + RhsVal. <br> !  **Usage**: <br> !   --->    OutVal = AddXp(LhsVal, RhsVal, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. MODULE FUNCTION ApInt64_Plus_Xp ( LhsVal , RhsVal , Algorithm ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = LhsVal + RhsVal.  Valid value of !  *Algorithm* is between 1 and 3. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal tSInt32 , INTENT ( IN ) :: Algorithm END FUNCTION ApInt64_Plus_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE SubtractXp !&#94; **Function Interface**: SubtractXp <br> !  **Purpose**:  To perform a subtraction: OutVal = LhsVal - RhsVal. <br> !  **Usage**: <br> !   --->    OutVal = SubtractXp(LhsVal, RhsVal, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 3. MODULE FUNCTION ApInt64_Minus_Xp ( LhsVal , RhsVal , Algorithm ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = LhsVal - RhsVal.  Valid value of !  *Algorithm* is between 1 and 3. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal tSInt32 , INTENT ( IN ) :: Algorithm END FUNCTION ApInt64_Minus_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE MultiplyXp !&#94; **Function Interface**: MultiplyXp <br> !  **Purpose**:  To perform a multiplication: OutVal = LhsVal * RhsVal. <br> !  **Usage**: <br> !   --->    OutVal = MultiplyXp(LhsVal, RhsVal, KThreshold, BaseCut, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 6. MODULE FUNCTION ApInt64_Multiply_Xp ( LhsVal , RhsVal , KThreshold , BaseCut , Algorithm ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = LhsVal * RhsVal.  Valid value of !  *Algorithm* is between 1 and 6. TYPE ( ApInt64 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt64 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt64 ) :: OutVal !> Threshold to perform Karatsuba algorithm.  If the 'Length' components of !   both LhsVal and RhsVal are greater than the threshold, use *Karatsuba* !   algorithm.  Otherwise, use basic (grade-school) algorithm. tIndex , INTENT ( IN ) :: KThreshold !> Threshold to perform basic algorithm when using the Karatsuba algorithm. !  *BaseCut* must be less than *KThreshold*. tIndex , INTENT ( IN ) :: BaseCut tSInt32 , INTENT ( IN ) :: Algorithm END FUNCTION ApInt64_Multiply_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE DivideXp !&#94; **Function Interface**: DivideXp <br> !  **Purpose**:  To perform a division: Quotient = Dividend / Divisor. <br> !  **Usage**: <br> !   --->    Quotient = DivideXp(Dividend, Divisor, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 5. MODULE FUNCTION ApInt64_Divide_Xp ( Dividend , Divisor , Algorithm ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor.  Valid value of !  *Algorithm* is between 1 and 5. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor tSInt32 , INTENT ( IN ) :: Algorithm TYPE ( ApInt64 ) :: Quotient END FUNCTION ApInt64_Divide_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE ModXp !&#94; **Function Interface**: ModXp <br> !  **Purpose**:  To perform modulation: Remainder = Dividend Mod Divisor. <br> !  **Usage**: <br> !   --->    Remainder = ModXp(Dividend, Divisor, Algorithm) <br> !  **Note**: Algorithm must be between 1 and 5. MODULE FUNCTION ApInt64_Mod_Xp ( Dividend , Divisor , Algorithm ) RESULT ( Remainder ) !&#94; To perform modulation: Remainder = Dividend Mod Divisor.  Valid value of !  *Algorithm* is between 1 and 5. TYPE ( ApInt64 ), INTENT ( IN ) :: Dividend TYPE ( ApInt64 ), INTENT ( IN ) :: Divisor tSInt32 , INTENT ( IN ) :: Algorithm TYPE ( ApInt64 ) :: Remainder END FUNCTION ApInt64_Mod_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE FromStringXp !&#94; **Function Interface**: FromStringXp <br> !  **Purpose**:  To construct the *ApInt64* number based on the specified decimal !                string.  Valid value of *Algorithm* is between 1 and 4. <br> !  **Usage**: <br> !  ---> ApNum = FromStringXp('1234567890987654321011223344', Algorithm) <br> !  ---> ApNum = FromStringXp('-987654321012345678900123123', Algorithm, ErrFlag) <br> !  ---> ApNum = FromStringXp(NumStr, 1, ErrMsg=Message) <br> !  ---> ApNum = FromStringXp(NumStr, 4, ErrFlag, ErrMsg) MODULE FUNCTION FromString_Xp ( cStr , Algorithm , ErrFlag , ErrMsg ) RESULT ( Big ) !&#94; To construct the *ApInt64* number based on the specified decimal string. !  Valid value of *Algorithm* is between 1 and 4. tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tSInt32 , INTENT ( IN ) :: Algorithm tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid TYPE ( ApInt64 ) :: Big !! number END FUNCTION FromString_Xp !------------------------------------------------------------------------------ END INTERFACE INTERFACE ToStringXp !&#94; **Function Interface**: ToStringXp <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a decimal !                string.  Valid value of *Algorithm* is between 1 and 7. <br> !  **Usage**: <br> !   --->    Str = ToStringXp(ApNum, Algorithm) MODULE FUNCTION ToString_Xp ( Big , Algorithm ) RESULT ( Str ) !&#94; To convert an arbitrary-precision signed integer to a decimal string. !  Valid value of *Algorithm* is between 1 and 7. TYPE ( ApInt64 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: Algorithm tCharAlloc :: Str END FUNCTION ToString_Xp !------------------------------------------------------------------------------ END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** FUNCTION ApInt64_Is_Zero ( Big ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the number is zero or not. ! ** Technical notes**: !   Zero can have many forms: !   - The most common form is set through ZeroApInt64() where Digit(0) = 0 and Length = 1. !   - If Digit has not yet been allocated or Length is less than 1, the number is also !     considered to be zero. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ApInt64 ), INTENT ( IN ) :: Big tLogical :: Flag !! true if value is zero. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( Big % Digit )) THEN IF ( Big % Length >= 1_kIndex ) THEN Flag = ( Big % Length == 1_kIndex ). AND .( Big % Digit ( 0 ) == 0_kInt64 ) ELSE ! length is less than 1 Flag = TrueVal END IF ELSE ! digit not yet allocated Flag = TrueVal END IF RETURN END FUNCTION ApInt64_Is_Zero !****************************************************************************** FUNCTION ApInt64_Absolute ( Num ) RESULT ( Abs ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the absolute value of the specified number. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ApInt64 ), INTENT ( IN ) :: Num TYPE ( ApInt64 ) :: Abs !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Abs = MakeCopy ( Num ) IF ( Abs % Sign < 0 ) Abs % Sign = - Abs % Sign RETURN END FUNCTION ApInt64_Absolute !****************************************************************************** END MODULE MClass_ApInt64 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_apint64.f90.html"},{"title":"MBase_Float128.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MBase_Float128 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *Float128* type, its related routines and useful *Float128* parameters. !   The *Float128* type is a derived type representing a quadruple-precision floating point number. !   Internally, it consists of a logical value representing a sign component, two 64-bit integers !   representing a significand component and a 32-bit integer representing an exponent component. !   Therefore, it is slightly more precise and has a wider range than the standard IEEE-754 quadruple- !   precision floating point number. <br> !   Various common operations typically available for real types are provided including arithmetic, !   comparison and conversion/construction operations.  Currently, only basic arithmetic operations !   including addition, subtraction, multiplication and division are implemented. <br> !  <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/m-vokhm/Quadruple\">Quadruple: A 128-bit floating-point arithmetic !       for Java</a> <br> !** USE STATEMENTS: USE MBase_Common IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type + constructor PUBLIC :: Float128 ! assignment + conversion PUBLIC :: ASSIGNMENT ( = ) PUBLIC :: ToI32 , ToI64 , ToR32 , ToR64 , ToR128 PUBLIC :: ToDecString !, ToHexString !    PUBLIC :: ToF128 ! comparison PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ) PUBLIC :: OPERATOR ( < ), OPERATOR ( <= ) PUBLIC :: OPERATOR ( > ), OPERATOR ( >= ) PUBLIC :: Compare ! arithmetic PUBLIC :: OPERATOR ( + ), OPERATOR ( - ) PUBLIC :: OPERATOR ( * ), OPERATOR ( / ) PUBLIC :: Increment , Decrement , Add , Subtract PUBLIC :: Multiply , Divide , MOD , DivMod ! inquiry / getter PUBLIC :: Is_NaN , Is_Infinite , Is_Negative , Is_Zero !    PUBLIC :: GetExponent, GetExpUnbiased, GetMantHi, GetMantLo !    PUBLIC :: FloorNCeiling ! auxiliary !    PUBLIC :: ABS !    PUBLIC :: Display PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: tCharStar , PARAMETER :: ModName = 'MBase_Float128' ! The value of the exponent (biased) corresponding to subnormal values tSInt32 , PARAMETER :: EXPONENT_OF_SUBNORMAL = 0 ! The value of the exponent (biased) corresponding to MIN_NORMAL tSInt32 , PARAMETER :: EXPONENT_OF_MIN_NORMAL = 1 ! The value of the exponent (biased) corresponding to 1.0 (== 2**0) ! equals to 2147483647(Z'7FFFFFFF'). ! The same as EXPONENT_BIAS tSInt32 , PARAMETER :: EXPONENT_OF_ONE = ToInt32 ( Z '7FFFFFFF' ) ! The value of the exponent (biased) corresponding to 1.0 (== 2**0) ! equals to 2147483647(Z'7FFFFFFF'). ! The same as EXPONENT_OF_ONE tSInt32 , PARAMETER :: EXPONENT_BIAS = ToInt32 ( Z '7FFFFFFF' ) ! The value of the exponent (biased), corresponding to MAX_VALUE ! equals to 4294967294 (Z'FFFFFFFE) tSInt64 , PARAMETER :: EXPONENT_OF_MAX_VALUE = ToInt64 ( Z '00000000FFFFFFFE' ) ! The value of the exponent (biased), corresponding to Infinity and NaN ! equals to -1 (Z'FFFFFFFF') !    tSInt32,   PARAMETER    :: EXPONENT_OF_INFINITY  = ToInt32(Z'FFFFFFFF') tSInt32 , PARAMETER :: EXPONENT_OF_INFINITY = - 1 ! character parameter used in string conversion tCharStar , PARAMETER :: ZEROS = '0000000000000000000000000000000000000000' ! Just for convenience: Z'8000_0000_0000_0000' (== Long.MIN_VALUE) tSInt64 , PARAMETER :: HIGH_BIT = ToInt64 ( Z '8000000000000000' ) ! Just for convenience: Z'8000_0000_0000_0000' tSInt64 , PARAMETER :: BIT_63 = HIGH_BIT ! Just for convenience: Z'0000_0000_0000_7FFF' tSInt64 , PARAMETER :: LOWER_15_BITS = ToInt64 ( Z '0000000000007FFF' ) ! Just for convenience: Z'0000_0000_FFFF_FFFF' tSInt64 , PARAMETER :: LOWER_32_BITS = ToInt64 ( Z '00000000FFFFFFFF' ) ! Just for convenience: Z'0000_FFFF_FFFF_FFFF' tSInt64 , PARAMETER :: LOWER_48_BITS = ToInt64 ( Z '0000FFFFFFFFFFFF' ) ! Just for convenience: Z'FFFF_FFFF_0000_0000' tSInt64 , PARAMETER :: HIGHER_32_BITS = ToInt64 ( Z 'FFFFFFFF00000000' ) ! Just for convenience: Z'8000_0000' // 2&#94;31 tSInt64 , PARAMETER :: POW_2_31_L = ToInt64 ( Z '0000000080000000' ) ! 2&#94;31 ! Inner structure of double: where it holds its sign tSInt64 , PARAMETER :: DOUBLE_SIGN_MASK = HIGH_BIT ! Inner structure of double: where it holds its exponent tSInt64 , PARAMETER :: DOUBLE_EXP_MASK = ToInt64 ( Z '7FF0000000000000' ) ! Inner structure of double: where it holds its mantissa tSInt64 , PARAMETER :: DOUBLE_MANT_MASK = ToInt64 ( Z '000FFFFFFFFFFFFF' ) ! double's exponent value corresponding to 2&#94;0 = 1, shifted to lower bits tSInt32 , PARAMETER :: EXP_0D = ToInt32 ( Z '000003FF' ) ! The highest bit of Quad's mantissa that doesn't fit in double's mantissa (is lower than the lowest) tSInt64 , PARAMETER :: HALF_DOUBLES_LSB = ToInt64 ( Z '0000000000000800' ) ! The implied position of the implied unity in double tSInt64 , PARAMETER :: DOUBLE_IMPLIED_MSB = ToInt64 ( Z '0010000000000000' ) ! Max value of the decimal exponent, corresponds to EXPONENT_OF_MAX_VALUE tSInt32 , PARAMETER :: MAX_EXP10 = 646456993 ! Min value of the decimal exponent, corresponds to EXPONENT_OF_MIN_NORMAL tSInt32 , PARAMETER :: MIN_EXP10 = - 646457032 ! corresponds tSInt32 , PARAMETER :: IEEE754_EXPONENT_BIAS = 16383 ! Z'3FFF' tSInt32 , PARAMETER :: IEEE754_MAX_EXPONENT = IEEE754_EXPONENT_BIAS tSInt32 , PARAMETER :: IEEE754_MIN_NORMAL_EXPONENT = - 16382 ! Z'FFFF_C002' tSInt32 , PARAMETER :: IEEE754_MIN_EXPONENT = IEEE754_MIN_NORMAL_EXPONENT - 112 tSInt64 , PARAMETER :: IEEE754_MINUS_ZERO_LEAD = ToInt64 ( Z '8000000000000000' ) tSInt64 , PARAMETER :: IEEE754_NAN_LEAD = ToInt64 ( Z '7FFF800000000000' ) tSInt64 , PARAMETER :: IEEE754_MINUS_INFINITY_LEAD = ToInt64 ( Z 'FFFF000000000000' ) tSInt64 , PARAMETER :: IEEE754_INFINITY_LEAD = ToInt64 ( Z '7FFF000000000000' ) tSInt64 , PARAMETER :: IEEE754_EXPONENT_MASK = ToInt64 ( Z '7FFF000000000000' ) ! Approximate value of log2(10) tRealDP , PARAMETER :: LOG2_10 = LOG ( 1 0.0_kDouble ) / LOG ( 2.0_kDouble ) ! Approximate value of log2(e) tRealDP , PARAMETER :: LOG2_E = 1.0_kDouble / LOG ( 2.0_kDouble ) ! The maximum number of digits in the mantissa that are taken into account ! 2&#94;192 = 6.277e57, so the 58-th digit after point may affect the result tSInt32 , PARAMETER :: MAX_MANTISSA_LENGTH = 59 !** DERIVED TYPE DEFINITIONS !> *Float128* is a derived type representing a signed quadruple-precision floating-point !   number.  Internally, it consists of a logical variable representing its sign, two !   64-bit integers representing its 128-bit significand, and a 32-bit integer representing !   its (biased) exponent.  Its value ranges from approximately 6.67283E-646457032 to !   1.76161E+646456993. TYPE Float128 PRIVATE tLogical :: Negative !! flag indicating whether the number is negative or not tSInt32 :: Exponent !! number representing the biased exponent tSInt64 :: MantHi !! number representing upper 64 bits of the significand tSInt64 :: MantLo !! number representing lower 64 bits of the significand END TYPE Float128 !** MODULE PARAMETERS (PART 2): !% Minimum possible positive value, 6.672829482607474308148353774991346115977e-646457032 TYPE ( Float128 ), PUBLIC , PARAMETER :: MIN_VALUE = Float128 ( FalseVal , 0 , 0_kInt64 , 1_kInt64 ) !% Maximum possible value, 1.761613051683963353207493149791840285665e+646456993 TYPE ( Float128 ), PUBLIC , PARAMETER :: MAX_VALUE = Float128 ( FalseVal , ToInt32 ( EXPONENT_OF_MAX_VALUE ), & - 1_kInt64 , - 1_kInt64 ) !% Minimum possible positive normal value, 2.270646210401492537526567265179587581247e-646456993 TYPE ( Float128 ), PUBLIC , PARAMETER :: MIN_NORMAL = Float128 ( FalseVal , 1 , 0_kInt64 , 0_kInt64 ) !% Float128 with value of 0.0 TYPE ( Float128 ), PUBLIC , PARAMETER :: ZERO_F128 = Float128 ( FalseVal , 0 , 0_kInt64 , 0_kInt64 ) !% Float128 with value of 1.0 TYPE ( Float128 ), PUBLIC , PARAMETER :: ONE_F128 = Float128 ( FalseVal , EXPONENT_OF_ONE , 0_kInt64 , 0_kInt64 ) !% Float128 with value of 2.0 TYPE ( Float128 ), PUBLIC , PARAMETER :: TWO_F128 = Float128 ( FalseVal , - 2147483648 , 0_kInt64 , 0_kInt64 ) !% Float128 with value of 2.0 TYPE ( Float128 ), PUBLIC , PARAMETER :: TEN_F128 = Float128 ( FalseVal , - 2147483646 , 4611686018427387904_kInt64 , 0_kInt64 ) !% Float128 with value of -1.0 TYPE ( Float128 ), PUBLIC , PARAMETER :: MINUS_ONE = Float128 ( TrueVal , EXPONENT_OF_ONE , 0_kInt64 , 0_kInt64 ) !% Not a number TYPE ( Float128 ), PUBLIC , PARAMETER :: NOT_A_NUMBER = Float128 ( FalseVal , EXPONENT_OF_INFINITY , & HIGH_BIT , 0_kInt64 ) !% Negative infinity TYPE ( Float128 ), PUBLIC , PARAMETER :: NEGATIVE_INFINITY = Float128 ( TrueVal , EXPONENT_OF_INFINITY , & 0_kInt64 , 0_kInt64 ) !% Positive infinity TYPE ( Float128 ), PUBLIC , PARAMETER :: POSITIVE_INFINITY = Float128 ( FalseVal , EXPONENT_OF_INFINITY , & 0_kInt64 , 0_kInt64 ) !% Float128 with value of Pi TYPE ( Float128 ), PUBLIC , PARAMETER :: PI_F128 = Float128 ( FalseVal , ToInt32 ( Z '80000000' ), & ToInt64 ( Z '921FB54442D18469' ), & ToInt64 ( Z '898CC51701B839A2' )) !** INTERFACE DEFINITIONS: ! procedures from SBase_F128_Conversion INTERFACE ! assignment routines MODULE SUBROUTINE Float128_Assign ( This , Other ) TYPE ( Float128 ), INTENT ( OUT ) :: This TYPE ( Float128 ), INTENT ( IN ) :: Other END SUBROUTINE Float128_Assign !------------------------------------------------------------ MODULE SUBROUTINE Float128_From_R32 ( F128 , R32 ) TYPE ( Float128 ), INTENT ( OUT ) :: F128 tRealSP , INTENT ( IN ) :: R32 END SUBROUTINE Float128_From_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_From_R64 ( F128 , R64 ) TYPE ( Float128 ), INTENT ( OUT ) :: F128 tRealDP , INTENT ( IN ) :: R64 END SUBROUTINE Float128_From_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_From_R128 ( F128 , R128 ) TYPE ( Float128 ), INTENT ( OUT ) :: F128 tRealQP , INTENT ( IN ) :: R128 END SUBROUTINE Float128_From_R128 !------------------------------------------------------------ MODULE SUBROUTINE Float128_To_R32 ( R32 , F128 ) tRealSP , INTENT ( OUT ) :: R32 TYPE ( Float128 ), INTENT ( IN ) :: F128 END SUBROUTINE Float128_To_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_To_R64 ( R64 , F128 ) tRealDP , INTENT ( OUT ) :: R64 TYPE ( Float128 ), INTENT ( IN ) :: F128 END SUBROUTINE Float128_To_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_To_R128 ( R128 , F128 ) tRealQP , INTENT ( OUT ) :: R128 TYPE ( Float128 ), INTENT ( IN ) :: F128 END SUBROUTINE Float128_To_R128 !------------------------------------------------------------ ! constructor routines MODULE FUNCTION Construct_Float128 ( Negative , Exponent , MantHi , MantLo ) RESULT ( F128 ) tLogical , INTENT ( IN ) :: Negative tSInt32 , INTENT ( IN ) :: Exponent tSInt64 , INTENT ( IN ) :: MantHi tSInt64 , INTENT ( IN ) :: MantLo TYPE ( Float128 ) :: F128 END FUNCTION Construct_Float128 !------------------------------------------------------------ MODULE FUNCTION Construct_Positive_Float128 ( Exponent , MantHi , MantLo ) RESULT ( F128 ) tSInt32 , INTENT ( IN ) :: Exponent tSInt64 , INTENT ( IN ) :: MantHi tSInt64 , INTENT ( IN ) :: MantLo TYPE ( Float128 ) :: F128 END FUNCTION Construct_Positive_Float128 !------------------------------------------------------------ MODULE FUNCTION DecString_To_Float128 ( cStr , ErrFlag , ErrMsg ) RESULT ( F128 ) tCharStar , TARGET , INTENT ( IN ) :: cStr tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg TYPE ( Float128 ) :: F128 END FUNCTION DecString_To_Float128 !------------------------------------------------------------ MODULE FUNCTION I32_To_Float128 ( I32 ) RESULT ( F128 ) tSInt32 , INTENT ( IN ) :: I32 TYPE ( Float128 ) :: F128 END FUNCTION I32_To_Float128 !------------------------------------------------------------ MODULE FUNCTION I64_To_Float128 ( I64 ) RESULT ( F128 ) tSInt64 , INTENT ( IN ) :: I64 TYPE ( Float128 ) :: F128 END FUNCTION I64_To_Float128 !------------------------------------------------------------ MODULE FUNCTION R32_To_Float128 ( R32 ) RESULT ( F128 ) tRealSP , INTENT ( IN ) :: R32 TYPE ( Float128 ) :: F128 END FUNCTION R32_To_Float128 !------------------------------------------------------------ MODULE FUNCTION R64_To_Float128 ( R64 ) RESULT ( F128 ) tRealDP , INTENT ( IN ) :: R64 TYPE ( Float128 ) :: F128 END FUNCTION R64_To_Float128 !------------------------------------------------------------ MODULE FUNCTION R128_To_Float128 ( R128 ) RESULT ( F128 ) tRealQP , INTENT ( IN ) :: R128 TYPE ( Float128 ) :: F128 END FUNCTION R128_To_Float128 !------------------------------------------------------------ ! conversion routines MODULE FUNCTION DecString_From_Float128 ( F128 , SigDigit ) RESULT ( Str ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tIndex , OPTIONAL , INTENT ( IN ) :: SigDigit tCharAlloc :: Str END FUNCTION DecString_From_Float128 !------------------------------------------------------------ MODULE FUNCTION I32_From_Float128 ( F128 ) RESULT ( I32 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt32 :: I32 END FUNCTION I32_From_Float128 !------------------------------------------------------------ MODULE FUNCTION I64_From_Float128 ( F128 ) RESULT ( I64 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt64 :: I64 END FUNCTION I64_From_Float128 !------------------------------------------------------------ MODULE FUNCTION R32_From_Float128 ( F128 ) RESULT ( R32 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tRealSP :: R32 END FUNCTION R32_From_Float128 !------------------------------------------------------------ MODULE FUNCTION R64_From_Float128 ( F128 ) RESULT ( R64 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tRealDP :: R64 END FUNCTION R64_From_Float128 !------------------------------------------------------------ MODULE FUNCTION R128_From_Float128 ( F128 ) RESULT ( R128 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tRealQP :: R128 END FUNCTION R128_From_Float128 !------------------------------------------------------------ ! auxiliary routines MODULE SUBROUTINE Assign_I32_To_Float128 ( F128 , I32 ) TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tSInt32 , INTENT ( IN ) :: I32 END SUBROUTINE Assign_I32_To_Float128 !------------------------------------------------------------ MODULE SUBROUTINE Assign_I64_To_Float128 ( F128 , I64 ) TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tSInt64 , INTENT ( IN ) :: I64 END SUBROUTINE Assign_I64_To_Float128 !------------------------------------------------------------ MODULE SUBROUTINE Assign_R32_To_Float128 ( F128 , R32 ) TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tRealSP , INTENT ( IN ) :: R32 END SUBROUTINE Assign_R32_To_Float128 !------------------------------------------------------------ MODULE SUBROUTINE Assign_R64_To_Float128 ( F128 , R64 ) TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tRealDP , INTENT ( IN ) :: R64 END SUBROUTINE Assign_R64_To_Float128 !------------------------------------------------------------ MODULE SUBROUTINE Assign_R128_To_Float128 ( F128 , R128 ) TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tRealQP , INTENT ( IN ) :: R128 END SUBROUTINE Assign_R128_To_Float128 !------------------------------------------------------------ END INTERFACE ! procedures from SBase_F128_ToString INTERFACE MODULE SUBROUTINE MultMantByMinNormal ( F128 , Product_4x64 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt64 , INTENT ( INOUT ) :: Product_4x64 ( 0 : 3 ) END SUBROUTINE MultMantByMinNormal !------------------------------------------------------------ MODULE SUBROUTINE MultMantByPowerOfTwo ( F128 , Pow2 , Product_4x64 ) TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt64 , INTENT ( IN ) :: Pow2 ( 0 : 3 ) tSInt64 , INTENT ( INOUT ) :: Product_4x64 ( 0 : 3 ) END SUBROUTINE MultMantByPowerOfTwo !------------------------------------------------------------ MODULE SUBROUTINE DecimalMantToString ( QDNumber , StrLen , MantStr , DigitLen ) tSInt64 , INTENT ( INOUT ) :: QDNumber ( 0 : 3 ) tIndex , INTENT ( IN ) :: StrLen tCharStar , INTENT ( OUT ) :: MantStr tIndex , INTENT ( OUT ) :: DigitLen END SUBROUTINE DecimalMantToString !------------------------------------------------------------ MODULE FUNCTION PowerOfTwo ( Exp ) RESULT ( Power ) tSInt64 , INTENT ( IN ) :: Exp tSInt64 :: Power ( 0 : 3 ) END FUNCTION PowerOfTwo !------------------------------------------------------------ MODULE SUBROUTINE Unpack_3x64_to_6x32 ( PackedVal , UnpackedVal ) tSInt64 , INTENT ( IN ) :: PackedVal ( 0 : 3 ) tSInt64 , INTENT ( INOUT ) :: UnpackedVal ( 0 : 5 ) END SUBROUTINE Unpack_3x64_to_6x32 !------------------------------------------------------------ MODULE SUBROUTINE MultBuffBy10 ( Buffer ) tSInt64 , INTENT ( INOUT ) :: Buffer ( 0 :) END SUBROUTINE MultBuffBy10 !------------------------------------------------------------ MODULE SUBROUTINE DivBuffBy10 ( Buffer ) tSInt64 , INTENT ( INOUT ) :: Buffer ( 0 :) END SUBROUTINE DivBuffBy10 !------------------------------------------------------------ MODULE FUNCTION AddCarry ( DigitBuf , DigitLen ) RESULT ( Flag ) tCharStar , INTENT ( INOUT ) :: DigitBuf tIndex , INTENT ( IN ) :: DigitLen tSInt32 :: Flag END FUNCTION AddCarry !------------------------------------------------------------ MODULE FUNCTION IsEmpty ( Buffer ) RESULT ( Flag ) tSInt64 , INTENT ( INOUT ) :: Buffer ( 0 :) tLogical :: Flag END FUNCTION IsEmpty !------------------------------------------------------------ END INTERFACE ! procedures from SBase_F128_FromString INTERFACE !------------------------------------------------------------ MODULE FUNCTION Parse_Fortran_Number ( cStr , Negative , SigStr , Exp10 , ExpCor , ErrMsg ) RESULT ( Valid ) tCharStar , TARGET , INTENT ( IN ) :: cStr tLogical , INTENT ( OUT ) :: Negative tCharAlloc , INTENT ( OUT ) :: SigStr tSInt64 , INTENT ( OUT ) :: Exp10 tSInt32 , INTENT ( OUT ) :: ExpCor tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg tLogical :: Valid END FUNCTION Parse_Fortran_Number !------------------------------------------------------------ MODULE FUNCTION BuildFloat128 ( Negative , SigStr , ExpDec , ExpCor ) RESULT ( F128 ) tLogical , INTENT ( IN ) :: Negative tCharStar , INTENT ( INOUT ) :: SigStr tSInt64 , INTENT ( IN ) :: ExpDec tSInt32 , INTENT ( IN ) :: ExpCor TYPE ( Float128 ) :: F128 END FUNCTION BuildFloat128 !------------------------------------------------------------ MODULE FUNCTION Parse_F128_Number ( cStr , Negative , SigDig , SigCount , Exp10 , ExpCor , ErrMsg ) RESULT ( Valid ) tCharStar , INTENT ( IN ) :: cStr TARGET :: cStr tLogical , INTENT ( OUT ) :: Negative tSInt8 , INTENT ( OUT ) :: SigDig ( 1 : MAX_MANTISSA_LENGTH + 1 ) tSInt32 , INTENT ( OUT ) :: SigCount tSInt64 , INTENT ( OUT ) :: Exp10 tSInt32 , INTENT ( OUT ) :: ExpCor tCharAlloc , INTENT ( OUT ) :: ErrMsg OPTIONAL :: ErrMsg tLogical :: Valid END FUNCTION Parse_F128_Number !------------------------------------------------------------ MODULE FUNCTION AssembleFloat128 ( Negative , SigDig , SigCount , ExpDec , ExpCor ) RESULT ( F128 ) tLogical , INTENT ( IN ) :: Negative tSInt8 , INTENT ( INOUT ) :: SigDig ( 1 : MAX_MANTISSA_LENGTH + 1 ) tSInt32 , INTENT ( INOUT ) :: SigCount tSInt64 , INTENT ( IN ) :: ExpDec tSInt32 , INTENT ( IN ) :: ExpCor TYPE ( Float128 ) :: F128 END FUNCTION AssembleFloat128 !------------------------------------------------------------ END INTERFACE ! procedures from SBase_F128_Comparison INTERFACE !------------------------------------------------------------ MODULE FUNCTION Float128_Equal ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_Equal !------------------------------------------------------------ MODULE FUNCTION Float128_NotEqual ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_NotEqual !------------------------------------------------------------ MODULE FUNCTION Float128_LessThan ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_LessThan !------------------------------------------------------------ MODULE FUNCTION Float128_LessEqual ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_LessEqual !------------------------------------------------------------ MODULE FUNCTION Float128_GreaterThan ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_GreaterThan !------------------------------------------------------------ MODULE FUNCTION Float128_GreaterEqual ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION Float128_GreaterEqual !------------------------------------------------------------ MODULE FUNCTION Float128_Compare ( LHS , RHS ) RESULT ( Flag ) TYPE ( Float128 ), INTENT ( IN ) :: LHS TYPE ( Float128 ), INTENT ( IN ) :: RHS tSInt32 :: Flag END FUNCTION Float128_Compare !------------------------------------------------------------ END INTERFACE ! procedures from SBase_F128_Arithmetic INTERFACE !------------------------------------------------------------ ! 'Plus' operations !------------------------------------------------------------ MODULE FUNCTION Float128_UnaryPlus ( InVal ) RESULT ( OutVal ) !&#94; OutVal = +InVal TYPE ( Float128 ), INTENT ( IN ) :: InVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_UnaryPlus !------------------------------------------------------------ MODULE SUBROUTINE Float128_Increment ( Val ) !&#94; Val = Val + 1 TYPE ( Float128 ), INTENT ( INOUT ) :: Val END SUBROUTINE Float128_Increment !------------------------------------------------------------ MODULE SUBROUTINE Float128_Add_R32 ( This , Other ) !&#94; This = This + Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealSP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Add_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Add_R64 ( This , Other ) !&#94; This = This + Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealDP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Add_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Add_Float128 ( This , Other ) !&#94; This = This + Other TYPE ( Float128 ), INTENT ( INOUT ) :: This TYPE ( Float128 ), INTENT ( IN ) :: Other END SUBROUTINE Float128_Add_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Plus_R32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal + RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealSP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Plus_R32 !------------------------------------------------------------ MODULE FUNCTION R32_Plus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal + RhsVal tRealSP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R32_Plus_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Plus_R64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal + RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealDP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Plus_R64 !------------------------------------------------------------ MODULE FUNCTION R64_Plus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal + RhsVal tRealDP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R64_Plus_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Plus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal + RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Plus_Float128 !------------------------------------------------------------ ! 'Minus' operations !------------------------------------------------------------ MODULE FUNCTION Float128_Negate ( InVal ) RESULT ( OutVal ) !&#94; OutVal = -InVal TYPE ( Float128 ), INTENT ( IN ) :: InVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Negate !------------------------------------------------------------ MODULE SUBROUTINE Float128_Decrement ( Val ) !&#94; Val = Val - 1 TYPE ( Float128 ), INTENT ( INOUT ) :: Val END SUBROUTINE Float128_Decrement !------------------------------------------------------------ MODULE SUBROUTINE Float128_Subtract_R32 ( This , Other ) !&#94; This = This - Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealSP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Subtract_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Subtract_R64 ( This , Other ) !&#94; This = This - Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealDP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Subtract_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Subtract_Float128 ( This , Other ) !&#94; This = This - Other TYPE ( Float128 ), INTENT ( INOUT ) :: This TYPE ( Float128 ), INTENT ( IN ) :: Other END SUBROUTINE Float128_Subtract_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Minus_R32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal - RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealSP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Minus_R32 !------------------------------------------------------------ MODULE FUNCTION R32_Minus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal - RhsVal tRealSP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R32_Minus_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Minus_R64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal - RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealDP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Minus_R64 !------------------------------------------------------------ MODULE FUNCTION R64_Minus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal - RhsVal tRealDP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R64_Minus_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Minus_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal - RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Minus_Float128 !------------------------------------------------------------ ! 'Multiply' operations !------------------------------------------------------------ MODULE SUBROUTINE Float128_Times_R32 ( This , Other ) !&#94; This = This * Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealSP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Times_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Times_R64 ( This , Other ) !&#94; This = This * Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealDP , INTENT ( IN ) :: Other END SUBROUTINE Float128_Times_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Times_Float128 ( This , Other ) !&#94; This = This * Other TYPE ( Float128 ), INTENT ( INOUT ) :: This TYPE ( Float128 ), INTENT ( IN ) :: Other END SUBROUTINE Float128_Times_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Multiply_R32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal * RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealSP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Multiply_R32 !------------------------------------------------------------ MODULE FUNCTION R32_Multiply_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal * RhsVal tRealSP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R32_Multiply_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Multiply_R64 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal * RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal tRealDP , INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Multiply_R64 !------------------------------------------------------------ MODULE FUNCTION R64_Multiply_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal * RhsVal tRealDP , INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION R64_Multiply_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Multiply_Float128 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; OutVal = LhsVal * RhsVal TYPE ( Float128 ), INTENT ( IN ) :: LhsVal TYPE ( Float128 ), INTENT ( IN ) :: RhsVal TYPE ( Float128 ) :: OutVal END FUNCTION Float128_Multiply_Float128 !------------------------------------------------------------ ! 'Divide' operations !------------------------------------------------------------ MODULE SUBROUTINE Float128_DivMod_Float128 ( Dividend , Divisor , Quotient , Remainder ) TYPE ( Float128 ), INTENT ( IN ) :: Dividend TYPE ( Float128 ), INTENT ( IN ) :: Divisor TYPE ( Float128 ), INTENT ( OUT ) :: Quotient TYPE ( Float128 ), INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_DivMod_Float128 !------------------------------------------------------------ MODULE SUBROUTINE Float128_DivMod_R32 ( Dividend , Divisor , Quotient , Remainder ) TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealSP , INTENT ( IN ) :: Divisor TYPE ( Float128 ), INTENT ( OUT ) :: Quotient TYPE ( Float128 ), INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_DivMod_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_DivMod_R64 ( Dividend , Divisor , Quotient , Remainder ) TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealDP , INTENT ( IN ) :: Divisor TYPE ( Float128 ), INTENT ( OUT ) :: Quotient TYPE ( Float128 ), INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_DivMod_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Over_R32 ( This , Other , Remainder ) !&#94; This = This / Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealSP , INTENT ( IN ) :: Other tRealSP , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_Over_R32 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Over_R64 ( This , Other , Remainder ) !&#94; This = This / Other TYPE ( Float128 ), INTENT ( INOUT ) :: This tRealDP , INTENT ( IN ) :: Other tRealDP , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_Over_R64 !------------------------------------------------------------ MODULE SUBROUTINE Float128_Over_Float128 ( This , Other , Remainder ) !&#94; This = This / Other TYPE ( Float128 ), INTENT ( INOUT ) :: This TYPE ( Float128 ), INTENT ( IN ) :: Other TYPE ( Float128 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE Float128_Over_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Divide_R32 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; Quotient = Dividend / Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealSP , INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Quotient END FUNCTION Float128_Divide_R32 !------------------------------------------------------------ MODULE FUNCTION Float128_Divide_R64 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; Quotient = Dividend / Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealDP , INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Quotient END FUNCTION Float128_Divide_R64 !------------------------------------------------------------ MODULE FUNCTION Float128_Divide_Float128 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; Quotient = Dividend / Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend TYPE ( Float128 ), INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Quotient END FUNCTION Float128_Divide_Float128 !------------------------------------------------------------ MODULE FUNCTION Float128_Mod_R32 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; Remainder = Dividend MOD Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealSP , INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Remainder END FUNCTION Float128_Mod_R32 !------------------------------------------------------------ MODULE FUNCTION Float128_Mod_R64 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; Remainder = Dividend MOD Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend tRealDP , INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Remainder END FUNCTION Float128_Mod_R64 !------------------------------------------------------------ MODULE FUNCTION Float128_Mod_Float128 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; Remainder = Dividend MOD Divisor TYPE ( Float128 ), INTENT ( IN ) :: Dividend TYPE ( Float128 ), INTENT ( IN ) :: Divisor TYPE ( Float128 ) :: Remainder END FUNCTION Float128_Mod_Float128 END INTERFACE !** GENERIC DEFINITIONS: ! assignment (for conversions between Float128 and unsigned 32/64 bit integers) INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) <br> !  **Purpose**:  To convert between a *Float128* number and an other real number. <br> !  **Usage**: <br> !   ! convert 32-bit real number (Fortran intrinsic type) to the *Float128* number <br> !   --->    F128 = R32 <br> !   ! convert the *Float128* number to 128-bit real number (Fortran intrinsic type) <br> !   --->    R128 = F128 MODULE PROCEDURE Float128_Assign , Float128_From_R32 MODULE PROCEDURE Float128_From_R64 , Float128_From_R128 MODULE PROCEDURE Float128_To_R32 , Float128_To_R64 MODULE PROCEDURE Float128_To_R128 END INTERFACE ! constructor INTERFACE Float128 !&#94; **Constructor Interface**: Float128 <br> !  **Purpose**:  To construct a *Float128* number. <br> !  **Usage**: <br> !   ! construct from 32-bit intrinsic integer number <br> !   --->    F128 = Float128(I32) <br> !   ! construct from 64-bit intrinsic real number <br> !   --->    F128 = Float128(R64) <br> !   ! construct from a decimal string <br> !   --->    I128 = Float128('1234567.890987654321011223344E-23132', ErrFlag, ErrMsg) <br> MODULE PROCEDURE Construct_Positive_Float128 MODULE PROCEDURE I32_To_Float128 , I64_To_Float128 MODULE PROCEDURE R32_To_Float128 , R64_To_Float128 MODULE PROCEDURE R128_To_Float128 , DecString_To_Float128 END INTERFACE INTERFACE ToF128 MODULE PROCEDURE String_2_Float128 END INTERFACE ! conversion INTERFACE ToI32 !&#94; **Function Interface**: ToI32 <br> !  **Purpose**:  To convert a *Float128* number to a 32-bit integer number. <br> !  **Usage**: <br> !   --->    I32 = ToI32(F128) MODULE PROCEDURE I32_From_Float128 END INTERFACE INTERFACE ToI64 !&#94; **Function Interface**: ToI64 <br> !  **Purpose**:  To convert a *Float128* number to a 64-bit integer number. <br> !  **Usage**: <br> !   --->    I64 = ToI64(F128) MODULE PROCEDURE I64_From_Float128 END INTERFACE INTERFACE ToR32 !&#94; **Function Interface**: ToR32 <br> !  **Purpose**:  To convert a *Float128* number to a 32-bit real number. <br> !  **Usage**: <br> !   --->    R32 = ToR32(F128) MODULE PROCEDURE R32_From_Float128 END INTERFACE INTERFACE ToR64 !&#94; **Function Interface**: ToR64 <br> !  **Purpose**:  To convert a *Float128* number to a 64-bit real number. <br> !  **Usage**: <br> !   --->    R64 = ToR64(F128) MODULE PROCEDURE R64_From_Float128 END INTERFACE INTERFACE ToR128 !&#94; **Function Interface**: ToR128 <br> !  **Purpose**:  To convert a *Float128* number to a 128-bit real number. <br> !  **Usage**: <br> !   --->    R128 = ToR128(F128) MODULE PROCEDURE R128_From_Float128 END INTERFACE INTERFACE ToDecString !&#94; **Function Interface**: ToDecString <br> !  **Purpose**:  To convert a *Float128* number to a decimal string. <br> !  **Usage**: <br> !   --->    Str = ToDecString(F128) MODULE PROCEDURE DecString_From_Float128 END INTERFACE ! comparison INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) <br> !  **Purpose**:  To check if values of two *Float128* numbers are equal. !   Return .TRUE. if both values are equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS == RHS <br> !   --->    IF (LHS .EQ. RHS) DoSomething MODULE PROCEDURE Float128_Equal END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) <br> !  **Purpose**:  To check if values of two *Float128* numbers are not equal. !   Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS /= RHS <br> !   --->    IF (LHS .NE. RHS) DoSomething MODULE PROCEDURE Float128_NotEqual END INTERFACE INTERFACE OPERATOR ( < ) !&#94; **Operator Overload**: OPERATOR(<) <br> !  **Purpose**:  To check if the LHS value is less than the RHS value. !   Return .TRUE. if LHS < RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS < RHS <br> !   --->    IF (LHS .LT. RHS) DoSomething MODULE PROCEDURE Float128_LessThan END INTERFACE INTERFACE OPERATOR ( <= ) !&#94; **Operator Overload**: OPERATOR(<=) <br> !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value. !   Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS <= RHS <br> !   --->    IF (LHS .LE. RHS) DoSomething MODULE PROCEDURE Float128_LessEqual END INTERFACE INTERFACE OPERATOR ( > ) !&#94; **Operator Overload**: OPERATOR(>) <br> !  **Purpose**:  To check if the LHS value is greater than the RHS value. !   Return .TRUE. if LHS > RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS > RHS <br> !   --->    IF (LHS .GT. RHS) DoSomething MODULE PROCEDURE Float128_GreaterThan END INTERFACE INTERFACE OPERATOR ( >= ) !&#94; **Operator Overload**: OPERATOR(>=) <br> !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value. !   Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS >= RHS <br> !   --->    IF (LHS .GE. RHS) DoSomething MODULE PROCEDURE Float128_GreaterEqual END INTERFACE INTERFACE Compare !&#94; **Function Interface**: Compare <br> !  **Purpose**:  To compare *Float128* numbers and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = Compare(LHS, RHS) <br> !   --->    IF (Compare(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE Float128_Compare END INTERFACE ! arithmetic INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) <br> !  **Purpose**:  To perform a summation of two real numbers (at least one of which is !       a *Float128* number) or to add a unary plus sign to a *Float128* number. <br> !  **Usage**: <br> !   --->    OUTPUT = +INPUT <br> !   --->    OUTPUT = FIRST_IN + SECOND_IN MODULE PROCEDURE Float128_UnaryPlus , Float128_Plus_Float128 MODULE PROCEDURE Float128_Plus_R32 , R32_Plus_Float128 MODULE PROCEDURE Float128_Plus_R64 , R64_Plus_Float128 END INTERFACE INTERFACE OPERATOR ( - ) !&#94; **Operator Overload**: OPERATOR(-) <br> !  **Purpose**:  To perform a subtraction of two real numbers (at least one of which is !       a *Float128* number) or to perform a negation of a *Float128* number. <br> !  **Usage**: <br> !   --->    OUTPUT = -INPUT <br> !   --->    OUTPUT = FIRST_IN - SECOND_IN <br> MODULE PROCEDURE Float128_Negate , Float128_Minus_Float128 MODULE PROCEDURE Float128_Minus_R32 , R32_Minus_Float128 MODULE PROCEDURE Float128_Minus_R64 , R64_Minus_Float128 END INTERFACE INTERFACE OPERATOR ( * ) !&#94; **Operator Overload**: OPERATOR( * ) <br> !  **Purpose**:  To perform a multiplication of two real numbers (at least one of which is !       a *Float128* number). <br> !  **Usage**: <br> !   --->    OUTPUT = FIRST_IN * SECOND_IN MODULE PROCEDURE Float128_Multiply_Float128 MODULE PROCEDURE Float128_Multiply_R32 , R32_Multiply_Float128 MODULE PROCEDURE Float128_Multiply_R64 , R64_Multiply_Float128 END INTERFACE INTERFACE OPERATOR ( / ) !&#94; **Operator Overload**: OPERATOR(/) <br> !  **Purpose**:  To perform a division of two real numbers where the dividend (numerator) !       must be a *Float128* number. <br> !  **Usage**: <br> !   --->    OUTPUT = FIRST_IN * SECOND_IN MODULE PROCEDURE Float128_Divide_R32 , Float128_Divide_R64 MODULE PROCEDURE Float128_Divide_Float128 END INTERFACE INTERFACE MOD !&#94; **Function Interface**: MOD <br> !  **Purpose**:  To return the remainder of a division of two real numbers, where the !       dividend (numerator) must be a *Float128* number. <br> !  **Usage**: <br> !   --->    REM = MOD(NUMER, DENOM) MODULE PROCEDURE Float128_Mod_R32 , Float128_Mod_R64 MODULE PROCEDURE Float128_Mod_Float128 END INTERFACE INTERFACE DivMod !&#94; **Subroutine Interface**: DivMod <br> !  **Purpose**:  To perform a division of two real numbers where the dividend (numerator) !        must be a *Float128* number and to return both the quotient and the remainder. <br> !  **Usage**: <br> !   --->    CALL DivMod(NUMER, DENOM, QUOT, REM) MODULE PROCEDURE Float128_DivMod_R32 , Float128_DivMod_R64 MODULE PROCEDURE Float128_DivMod_Float128 END INTERFACE INTERFACE Increment !&#94; **Subroutine Interface**: Increment <br> !  **Purpose**:  To increase value of a *Float128* number by one. <br> !  **Usage**: <br> !   --->    CALL Increment(F128) MODULE PROCEDURE Float128_Increment END INTERFACE INTERFACE Decrement !&#94; **Subroutine Interface**: Decrement <br> !  **Purpose**:  To decrease value of a *Float128* by one. <br> !  **Usage**: <br> !   --->    CALL Decrement(F128) MODULE PROCEDURE Float128_Decrement END INTERFACE INTERFACE Add !&#94; **Subroutine Interface**: Add <br> !  **Purpose**:  To perform addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL Add(This, Other) MODULE PROCEDURE Float128_Add_R32 , Float128_Add_R64 MODULE PROCEDURE Float128_Add_Float128 END INTERFACE INTERFACE Subtract !&#94; **Subroutine Interface**: Subtract <br> !  **Purpose**:  To perform subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL Subtract(This, Other) <br> MODULE PROCEDURE Float128_Subtract_R32 , Float128_Subtract_R64 MODULE PROCEDURE Float128_Subtract_Float128 END INTERFACE INTERFACE Multiply !&#94; **Subroutine Interface**: Multiply <br> !  **Purpose**:  To perform multiplication: This = This * Other. <br> !  **Usage**: <br> !   --->    CALL Multiply(This, Other) MODULE PROCEDURE Float128_Times_R32 , Float128_Times_R64 MODULE PROCEDURE Float128_Times_Float128 END INTERFACE INTERFACE Divide !&#94; **Subroutine Interface**: Divide <br> !  **Purpose**:  To perform a division: This = This / Other. <br> !  **Usage**: <br> !   --->    CALL Divide(This, Other) MODULE PROCEDURE Float128_Over_R32 , Float128_Over_R64 MODULE PROCEDURE Float128_Over_Float128 END INTERFACE ! auxiliary INTERFACE Assign MODULE PROCEDURE Assign_I32_To_Float128 , Assign_I64_To_Float128 MODULE PROCEDURE Assign_R32_To_Float128 , Assign_R64_To_Float128 MODULE PROCEDURE Assign_R128_To_Float128 END INTERFACE ! inquiry / getter INTERFACE Is_NaN !&#94; **Function Interface**: Is_NaN <br> !  **Purpose**:  To check whether the input value is a NAN (not a number) or not. <br> !  **Usage**: <br> !   --->    Flag = Is_NaN(INPUT) <br> !   --->    IF (.NOT.Is_NaN(INPUT)) DoSomeThing MODULE PROCEDURE Float128_Is_NaN END INTERFACE INTERFACE Is_Infinite !&#94; **Function Interface**: Is_Infinite <br> !  **Purpose**:  To check whether the input value is an infinity or not. <br> !  **Usage**: <br> !   --->    Flag = Is_Infinite(INPUT) <br> !   --->    IF (.NOT.Is_Infinite(INPUT)) DoSomeThing MODULE PROCEDURE Float128_Is_Infinite END INTERFACE INTERFACE Is_Zero !&#94; **Function Interface**: IsZero <br> !  **Purpose**:  To check whether the input value is zero or not. <br> !  **Usage**: <br> !   --->    Flag = IsZero(INPUT) <br> !   --->    IF (.NOT.IsZero(INPUT)) DoSomeThing MODULE PROCEDURE Float128_Is_Zero END INTERFACE INTERFACE Is_Negative !&#94; **Function Interface**: IsNegative <br> !  **Purpose**:  To check whether the input value is negative or not. <br> !  **Usage**: <br> !   --->    Flag = IsNegative(INPUT) <br> !   --->    IF (.NOT.IsNegative(INPUT)) DoSomeThing MODULE PROCEDURE Float128_Is_Negative END INTERFACE INTERFACE GetExponent MODULE PROCEDURE Float128_GetExponent END INTERFACE INTERFACE GetExpUnbiased MODULE PROCEDURE Float128_GetExponent_Unbiased END INTERFACE INTERFACE GetMantHi MODULE PROCEDURE Float128_GetMantissaHigh END INTERFACE INTERFACE GetMantLo MODULE PROCEDURE Float128_GetMantissaLow END INTERFACE INTERFACE FloorNCeiling MODULE PROCEDURE Float128_FloorNCeiling END INTERFACE !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE ELEMENTS SUBROUTINES OR FUNCTIONS: !------------------------------------------------------------------------------ ! !                          ASSIGN ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE AssignZero ( F128 , ChangeSign ) !** PURPOSE OF THIS SUBROUTINE: ! To assign the value of zero to the Float128 object with ! or without inverting its sign. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tLogical , INTENT ( IN ) :: ChangeSign ! if true, the sign will be changed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F128 % Negative = F128 % Negative . NEQV . ChangeSign F128 % Exponent = 0 F128 % MantHi = 0_kInt64 F128 % MantLo = 0_kInt64 RETURN END SUBROUTINE AssignZero !****************************************************************************** SUBROUTINE AssignOne ( F128 , ChangeSign ) !** PURPOSE OF THIS SUBROUTINE: ! To assign the value of one to the Float128 object with ! or without inverting its sign. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tLogical , INTENT ( IN ) :: ChangeSign ! if true, the sign will be changed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F128 % Negative = F128 % Negative . NEQV . ChangeSign F128 % Exponent = EXPONENT_OF_ONE F128 % MantHi = 0_kInt64 F128 % MantLo = 0_kInt64 RETURN END SUBROUTINE AssignOne !****************************************************************************** SUBROUTINE AssignInfinity ( F128 , ChangeSign ) !** PURPOSE OF THIS SUBROUTINE: ! To assign the value of infinity to the Float128 object with ! or without inverting its sign. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tLogical , INTENT ( IN ) :: ChangeSign ! if true, the sign will be changed !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F128 % Negative = F128 % Negative . NEQV . ChangeSign F128 % Exponent = EXPONENT_OF_INFINITY F128 % MantHi = 0_kInt64 F128 % MantLo = 0_kInt64 RETURN END SUBROUTINE AssignInfinity !****************************************************************************** FUNCTION AssignWithUnbiasedExponent ( Negative , Exponent , MantHi , MantLo ) RESULT ( F128 ) !** PURPOSE OF THIS SUBROUTINE: ! To construct Float128 object from the specified input where ! the exponent is treated as the unbiased exponent value, ! whose 0 value corresponds to the Float128 value of 1.0. !** SUBROUTINE ARGUMENT DECLARATIONS: tLogical , INTENT ( IN ) :: Negative tSInt32 , INTENT ( IN ) :: Exponent ! unbiased exponent tSInt64 , INTENT ( IN ) :: MantHi tSInt64 , INTENT ( IN ) :: MantLo TYPE ( Float128 ) :: F128 !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW F128 % Negative = Negative F128 % Exponent = Exponent + EXPONENT_BIAS F128 % MantHi = MantHi F128 % MantLo = MantLo RETURN END FUNCTION AssignWithUnbiasedExponent !------------------------------------------------------------------------------ ! !                               INQUIRY ROUTINES ! !------------------------------------------------------------------------------ FUNCTION Float128_Is_NaN ( F128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the number is NAN !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( F128 % Exponent == EXPONENT_OF_INFINITY ). AND . & ( IOR ( F128 % MantHi , F128 % MantLo ) /= 0_kInt64 ) RETURN END FUNCTION Float128_Is_NaN !****************************************************************************** FUNCTION Float128_Is_Infinite ( F128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the number is infinite (either positive or negative) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( F128 % Exponent == EXPONENT_OF_INFINITY ). AND . & ( IOR ( F128 % MantHi , F128 % MantLo ) == 0_kInt64 ) RETURN END FUNCTION Float128_Is_Infinite !****************************************************************************** FUNCTION Float128_Is_Negative ( F128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the number has negative value !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = F128 % Negative RETURN END FUNCTION Float128_Is_Negative !****************************************************************************** FUNCTION Float128_Is_Zero ( F128 ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: ! To check whether the number is zero (either positive or negative) !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tLogical :: Flag !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Flag = ( IOR ( IOR ( F128 % MantHi , F128 % MantLo ), ToInt64 ( F128 % Exponent )) == 0_kInt64 ) RETURN END FUNCTION Float128_Is_Zero !****************************************************************************** FUNCTION Float128_GetExponent ( F128 ) RESULT ( Exponent ) !** PURPOSE OF THIS SUBROUTINE: ! To get the raw (biased) binary exponent ! i.e. 0x7FFFFFFF for values falling within the interval of {[1.0 .. 2.0)}, ! 0x80000000 for {[2.0 .. 4.0)} etc. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt32 :: Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Exponent = F128 % Exponent RETURN END FUNCTION Float128_GetExponent !****************************************************************************** FUNCTION Float128_GetExponent_Unbiased ( F128 ) RESULT ( Exponent ) !** PURPOSE OF THIS SUBROUTINE: ! To get unbiased binary exponent ! i.e. 0 for values falling within the interval of {[1.0 .. 2.0)}, ! 1 for {[2.0 .. 4.0)} etc. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt32 :: Exponent !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Exponent = F128 % Exponent - EXPONENT_BIAS RETURN END FUNCTION Float128_GetExponent_Unbiased !****************************************************************************** FUNCTION Float128_GetMantissaHigh ( F128 ) RESULT ( Mantissa ) !** PURPOSE OF THIS SUBROUTINE: ! To get the most significant 64 bits of the fractional part of the mantissa !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt64 :: Mantissa !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Mantissa = F128 % MantHi RETURN END FUNCTION Float128_GetMantissaHigh !****************************************************************************** FUNCTION Float128_GetMantissaLow ( F128 ) RESULT ( Mantissa ) !** PURPOSE OF THIS SUBROUTINE: ! To get the least significant 64 bits of the fractional part of the mantissa !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: F128 tSInt64 :: Mantissa !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Mantissa = F128 % MantLo RETURN END FUNCTION Float128_GetMantissaLow !------------------------------------------------------------------------------ ! !                           MISCELLANEOUS ROUTINES ! !------------------------------------------------------------------------------ SUBROUTINE MakeSubnormal ( F128 , Exp2 ) !** PURPOSE OF THIS SUBROUTINE: ! For a Float128 with a normal mantissa (with implied unity) and non-positive ! biased exponent, converts it into the conventional subnormal form, with the ! exponent = 0 and the mantissa shifted rightwards with explicit 1 in the ! appropriate position.  Shifts mantissa rightwards by |exp2| + 1 bits, sets ! explicit 1, and rounds it up, taking into account the bits having been shifted-out !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tSInt64 , INTENT ( INOUT ) :: Exp2 ! Exp2 (IN)  : the exponent of the newly-found subnormal value (always negative) ! Exp2 (OUT) : the exponent for the new value, 0 in an ordinary case, !              and 1 if the rounding has led to overflow of the mantissa !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt64 :: ShiftedOutBit !** FLOW ! just for convenience Exp2 = - Exp2 IF ( Exp2 > 127 ) THEN ! Effectively 0 or MIN_VALUE F128 % MantHi = 0_kInt64 F128 % MantLo = 0_kInt64 IF ( Exp2 == 128 ) F128 % MantLo = F128 % MantLo + 1_kInt64 ! MIN_VALUE Exp2 = 0_kInt64 ! Exp2 >= 129 means 0 RETURN END IF ShiftedOutBit = ShiftMantissa ( F128 , Exp2 ) ! it's subnormal Exp2 = 0_kInt64 IF ( ShiftedOutBit /= 0_kInt64 ) THEN F128 % MantLo = F128 % MantLo + 1_kInt64 F128 % MantHi = F128 % MantHi + 1_kInt64 IF (( F128 % MantLo == 0_kInt64 ). AND .( F128 % MantHi == 0_kInt64 )) THEN ! Round up. carry beyond the higher word? Exp2 = Exp2 + 1_kInt64 ! it becomes MIN_NORMAL END IF END IF IF (( Exp2 == 0_kInt64 ). AND .( F128 % MantLo == 0_kInt64 ). AND .( F128 % MantHi == 0_kInt64 )) THEN ! (not really) zero -> min value F128 % MantLo = 1_kInt64 END IF RETURN END SUBROUTINE MakeSubnormal !****************************************************************************** FUNCTION ShiftMantissa ( F128 , Exp2 ) RESULT ( ShiftedOut ) !** PURPOSE OF THIS SUBROUTINE: ! To shift the mantissa by exp2 + 1 bits rightwards, to make ! a conventional subnormal value !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( INOUT ) :: F128 tSInt64 , INTENT ( IN ) :: Exp2 ! unbiased exponent of the value (negated) tSInt64 :: ShiftedOut ! the highest bit that has been shifted out beyond ! the two longs of mantissa (1L if it was 1, 0 otherwise) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW ! The highest of shifted out bits to evaluate carry ShiftedOut = IAND ( F128 % MantLo , 1_kInt64 ) F128 % MantLo = IOR ( SHIFTR ( F128 % MantLo , 1 ), SHIFTL ( F128 % MantHi , 63 )) ! move 1 bit right and set unity that was implied F128 % MantHi = IOR ( SHIFTR ( F128 % MantHi , 1 ), HIGH_BIT ) IF ( Exp2 >= 64 ) THEN ! the higher word move into the lower IF ( Exp2 == 64 ) THEN ! former lowest bit of F128%MantHi now is the highest bit of F128%MantLo ShiftedOut = SHIFTR ( F128 % MantLo , 63 ) ELSE ! one of the bits of the high word ShiftedOut = IAND ( SHIFTR ( F128 % MantHi , ( Exp2 - 65 )), 1_kInt64 ) END IF F128 % MantLo = SHIFTR ( F128 % MantHi , Exp2 - 64 ) F128 % MantHi = 0_kInt64 ELSEIF ( Exp2 > 0 ) THEN ! Shift both words ShiftedOut = IAND ( SHIFTR ( F128 % MantLo , Exp2 - 1 ), 1_kInt64 ) F128 % MantLo = IOR ( SHIFTR ( F128 % MantLo , Exp2 ), SHIFTL ( F128 % MantHi , 64 - Exp2 )) F128 % MantHi = SHIFTR ( F128 % MantHi , Exp2 ) END IF RETURN END FUNCTION ShiftMantissa !****************************************************************************** FUNCTION String_2_Float128 ( cStr , ErrFlag , ErrMsg ) RESULT ( F128 ) !** PURPOSE OF THIS SUBROUTINE: ! To convert a decimal string to a signed arbitrary-precision integer value !** SUBROUTINE ARGUMENT DECLARATIONS: tCharStar , TARGET , INTENT ( IN ) :: cStr ! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag ! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg ! message if input is not invalid TYPE ( Float128 ) :: F128 ! number !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tLogical :: Valid tLogical :: Negative tSInt8 :: SigDig ( 1 : MAX_MANTISSA_LENGTH + 1 ) tSInt32 :: SigCount tSInt64 :: ExpDec tSInt32 :: ExpCor !** FLOW ! parse the input string Valid = Parse_F128_Number ( cStr , Negative , SigDig , SigCount , ExpDec , ExpCor , ErrMsg ) ! check whether the input string is valid or not IF ( Valid ) THEN ! set flag IF ( PRESENT ( ErrFlag )) ErrFlag = FalseVal ! get value of Float128 F128 = AssembleFloat128 ( Negative , SigDig , SigCount , ExpDec , ExpCor ) ELSE ! set flag IF ( PRESENT ( ErrFlag )) ErrFlag = TrueVal ! set Float128 F128 = NOT_A_NUMBER END IF RETURN END FUNCTION String_2_Float128 !****************************************************************************** FUNCTION Float128_FloorNCeiling ( InVal , IsFloor ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: ! To determine floor or ceiling of the input value depending on 'IsFloor' flag !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: InVal ! input value to be floored or ceiled tLogical , INTENT ( IN ) :: IsFloor ! true, return floor value ! otherwise, return ceiling value TYPE ( Float128 ) :: OutVal ! floor (or ceiling) of the input value !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( IsFloor ) THEN OutVal = Float128_FloorOrCeiling ( InVal , MINUS_ONE , ZERO_F128 , MINUS_ONE ) ELSE OutVal = Float128_FloorOrCeiling ( InVal , - ZERO_F128 , ONE_F128 , ONE_F128 ) END IF RETURN END FUNCTION Float128_FloorNCeiling !****************************************************************************** FUNCTION Float128_FloorOrCeiling ( InVal , NegBound , PosBound , Sign ) RESULT ( OutVal ) !** PURPOSE OF THIS SUBROUTINE: ! To determine floor or ceiling of the input value. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( Float128 ), INTENT ( IN ) :: InVal ! input value to be floored or ceiled TYPE ( Float128 ), INTENT ( IN ) :: NegBound ! result for values in (-1, 0) TYPE ( Float128 ), INTENT ( IN ) :: PosBound ! result for values in (0, 1) TYPE ( Float128 ), INTENT ( IN ) :: Sign ! the sign of the result TYPE ( Float128 ) :: OutVal ! floor (or ceiling) of the input value !** SUBROUTINE PARAMETER DECLARATIONS: tSInt64 , PARAMETER :: SIGNIF_BIT_MASK = ToInt64 ( Z 'FFFFFFFFFFFFFFFF' ) !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: tSInt32 :: Exponent tSInt64 :: MaskHi , MaskLo !** FLOW Exponent = GetExpUnbiased ( InVal ) OutVal = InVal IF ( Exponent < 0 ) THEN ! Absolute value of argument is less than 1. ! floorOrCeil(-0.0) => -0.0 ! floorOrCeil(+0.0) => +0.0 IF ( InVal == ZERO_F128 ) THEN RETURN ELSE IF ( InVal < ZERO_F128 ) THEN OutVal = NegBound ELSE OutVal = PosBound END IF RETURN END IF ELSEIF ( Exponent >= 128 ) THEN ! Infinity, NaN, or a value so large it must be integral RETURN END IF ! Else the argument is either an integral value already XOR it ! has to be rounded to one. IF ( Exponent >= 64 ) THEN MaskHi = SHIFTR ( SIGNIF_BIT_MASK , 63 ) MaskLo = SHIFTR ( SIGNIF_BIT_MASK , Exponent - 64 ) ELSE MaskHi = SHIFTR ( SIGNIF_BIT_MASK , Exponent ) MaskLo = IOR ( SHIFTR ( SIGNIF_BIT_MASK , Exponent ), & SHIFTL ( SHIFTL ( SIGNIF_BIT_MASK , 1 ), 63 - Exponent )) END IF IF (( IAND ( MaskHi , InVal % MantHi ) /= 0_kInt64 ). OR .( IAND ( MaskLo , InVal % MantLo ) /= 0_kInt64 )) THEN OutVal % MantHi = IAND ( OutVal % MantHi , NOT ( MaskHi )) OutVal % MantLo = IAND ( OutVal % MantLo , NOT ( MaskLo )) IF ( Sign * InVal > ZERO_F128 ) OutVal = OutVal + Sign END IF RETURN END FUNCTION Float128_FloorOrCeiling !****************************************************************************** END MODULE MBase_Float128 !******************************************************************************","tags":"","loc":"sourcefile\\mbase_float128.f90.html"},{"title":"MClass_ApInt32.f90 – eXPerimental Fortran Library (XpfLib) Documentation","text":"Source Code MODULE MClass_ApInt32 !&#94; **PURPOSE OF THIS MODULE**: <br> !   This module contains the *ApInt32* type, its related routines and some useful !   parameter-like functions.  The *ApInt32* type is a derived type representing !   a **mutable, arbitrary-precision signed** integer.  Various common operations !   usually available for integer types are provided including arithmetic, bitwise, !   comparison, and conversion/construction operations.  The application programming !   interface (API) follows Fortran intrinsic integer types with additional functions/ !   methods provided. <br> !   Due to the fact that the *ApInt32* type has an allocatable component, unlike !   other integer types available, the *ApInt32* type normally requires an explicit !   construction either via a constructor method or an assignment expression before !   being used as an input argument in other operations.  Otherwise, the number !   would be interpreted as having zero value. <br> !   If a number is always in a range provided by a 128-bit signed integer, a user can !   use the <a href=\"../../xpfbase/module/mbase_sint128.html#type-sint128\">SInt128</a> !   type instead for efficiency reason.  Likewise, if a number is always in a range !   provided by a 128-bit unsigned integer, the !   <a href=\"../../xpfbase/module/mbase_uint128.html#type-uint128\">UInt128</a> type !   can be used with better performance. <br> !   Similar to the *SInt128* type, mixed types of signed integer types (32-bit, 64-bit, !   128-bit or arbitrary-precision) are allowed in arithmetic operations.  Likewise, !   arguments with Fortran intrinsic integer types in all public methods are considered !   to be signed, except those in some of conversion methods.  Also, for comparison and !   bitwise operations that require two input arguments, both arguments must only be the !   *ApInt32* type.  The operations on mixed types are not provided.  Therefore, all other !   types must be explicitly converted to the *ApInt32* type before using in the comparison !   and bitwise operations. <br> !   It should be noted that unlike both the *SInt128* and *UInt128* types where a conventional !   API (procedural programming) following Fortran integer types is used, the *ApInt32* type !   uses a mixed programming style.  For basic integer operations, a conventional API is used. !   For additional functionalities provided, both a conventional API and an object-oriented !   API (via type-bound procedures) are used.  Therefore, for additional functions/methods, !   the usage of the *ApInt32* type may differ from the usage of the *SInt128* and *UInt128* !   types. <br> !   See the <a href=\"../module/mclass_apint64.html\">ApInt64</a> type for a **mutable, !   arbitrary-precision signed** integer that has mostly identical functionalities. !   The *ApInt64* type is similar to the *ApInt32* type, but employs the base of !   2<sup>64</sup> instead of 2<sup>32</sup>.  Therefore, the *ApInt64* type uses !   many similar algorithms but requires different implementations.  Also, the !   *ApInt64* type provides experimental routines for various operations while !   the *ApInt32* type does not. <br> !   <br> !&#94; **REFERENCES**: <br> !   [1] <a href=\"https://github.com/bwakell/Huldra/blob/master/src/main/java/org/huldra/math/BigInt.java\"> !       The Huldra Project: BigInt</a> <br> !   [2] <a href=\"https://docs.oracle.com/javase/8/docs/api/?java/math/BigInteger.html\"> !       Java's Class BigInteger</a> !** USE STATEMENTS: USE MBase_Common USE MBase_UIntUtil USE MBase_SInt128 USE MBase_UInt128 USE MClass_BaseRNG IMPLICIT NONE ! Enforce explicit typing of all variables !** ACCESSIBLE SPECIFICATIONS OF MODULE DATA, SUBROUTINES OR FUNCTONS ! derived type & constructor PUBLIC :: ApInt32 ! assignment & conversion PUBLIC :: ASSIGNMENT ( = ) PUBLIC :: ToU32 , ToU64 , ToU128 PUBLIC :: ToI32 , ToI64 , ToI128 PUBLIC :: ToR32 , ToR64 , ToR128 PUBLIC :: ToBytes , ToDecString ! comparison PUBLIC :: OPERATOR ( == ), OPERATOR ( /= ) PUBLIC :: OPERATOR ( < ), OPERATOR ( <= ) PUBLIC :: OPERATOR ( > ), OPERATOR ( >= ) PUBLIC :: Compare ! arithmetic PUBLIC :: OPERATOR ( + ), OPERATOR ( - ) PUBLIC :: OPERATOR ( * ), OPERATOR ( / ) PUBLIC :: OPERATOR ( ** ) PUBLIC :: MOD , MODULO , SQR ! bitwise PUBLIC :: SHIFTL , SHIFTR , ISHFT PUBLIC :: NOT , IOR , IAND , IAND_NOT PUBLIC :: IEOR , LEADZ , TRAILZ PUBLIC :: POPCNT , POPPAR , IBSET , IBCLR PUBLIC :: IBCHNG , BTEST ! parameter-like PUBLIC :: ZeroApInt32 , OneApInt32 ! inquiry PUBLIC :: IsPositive , IsNegative , IsZero , IsOne ! miscellaneous PUBLIC :: ABS , RandNumApInt32 ! auxiliary PUBLIC :: MakeCopy , GetLength , Display PRIVATE ! by default, hide all data and routines except those declared explicitly !** MACRO DEFINITIONS: #include    \"../MacroDef/Macro - Basic Definitions.f90\" !** MODULE PARAMETERS: ! name of the module tCharStar , PARAMETER :: ModName = 'MClass_ApInt32' ! Used to cast a 32-bit integer to a 64-bit integer without getting unwanted sign extension tSInt64 , PARAMETER :: MASK = ToInt64 ( Z '00000000FFFFFFFF' ) ! SHIFTL(1_kInt64, 32) - 1_kInt64 !** DERIVED TYPE DEFINITIONS !> *ApInt32* is a mutable arbitrary-precision signed integer type where !   its representations are as follows. <br> ! - Base is 2<sup>32</sup>. <br> ! - Magnitude is represented by the 'Digit' array in little-endian order. <br> ! - The 'Length' first 'Digit' count as the *ApInt32* number (i.e. it is always !   less than or equal to the size/capacity of the 'Digit' array). <br> ! - Sign is represented by a sign integer (-1 or 1). <br> ! - Internally zero is allowed to have either sign. !   (Otherwise one would have to remember to check for sign-swap for division, !   multiplication etc...) <br> ! - Zero can have many forms: <br> !   -> The most common form of zero has 'Length' = 1 and Digit(0) = 0 (set through !      ZeroApInt32()). <br> !   -> If 'Digit' has not yet been allocated or 'Length' is less than 1, the number !      is considered to be zero. <br> TYPE ApInt32 PRIVATE !> The sign of this number. <br> ! -> +1 for positive numbers and -1 for negative numbers. <br> ! -> Zero can have either sign. tSInt32 :: Sign = 1 !% The number of digits of the number (in base 2<sup>64</sup>). tIndex :: Length = 0_kIndex !> The digits of the number, i.e., the magnitude array. <br> !  Values are treated as unsigned integer tUInt32 , ALLOCATABLE :: Digit (:) CONTAINS ! --------------------------------------------------------------------- ! -----                 Private Procedures                        ----- ! --------------------------------------------------------------------- PROCEDURE , PRIVATE :: ApInt32_Add_I32 PROCEDURE , PRIVATE :: ApInt32_Add_I64 PROCEDURE , PRIVATE :: ApInt32_Add_I128 PROCEDURE , PRIVATE :: ApInt32_Add_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Subtract_I32 PROCEDURE , PRIVATE :: ApInt32_Subtract_I64 PROCEDURE , PRIVATE :: ApInt32_Subtract_I128 PROCEDURE , PRIVATE :: ApInt32_Subtract_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Times_I32 PROCEDURE , PRIVATE :: ApInt32_Times_I64 PROCEDURE , PRIVATE :: ApInt32_Times_I128 PROCEDURE , PRIVATE :: ApInt32_Times_ApInt32 PROCEDURE , PRIVATE :: ApInt32_Over_I32 PROCEDURE , PRIVATE :: ApInt32_Over_I64 PROCEDURE , PRIVATE :: ApInt32_Over_I128 PROCEDURE , PRIVATE :: ApInt32_Over_ApInt32 PROCEDURE , PRIVATE :: ApInt32_DivMod_I32 PROCEDURE , PRIVATE :: ApInt32_DivMod_I64 PROCEDURE , PRIVATE :: ApInt32_DivMod_I128 PROCEDURE , PRIVATE :: ApInt32_DivMod_ApInt32 ! --------------------------------------------------------------------- ! -----                 Public Procedures                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Increment <br> !  **Purpose**:  To increase value of the ApInt32 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Increment() PROCEDURE :: Increment => ApInt32_Increment !> **Type-Bound Subroutine**: Decrement <br> !  **Purpose**:  To decrease value of the ApInt32 number by one. <br> !  **Usage**: <br> !   --->    CALL ApNum%Decrement() PROCEDURE :: Decrement => ApInt32_Decrement !> **Type-Bound Subroutine**: Square <br> !  **Purpose**:  To return the ApInt32 number (ApInt32) where its value is !                computed by: ApNum = ApNum * ApNum. <br> !  **Usage**: <br> !   --->    CALL ApNum%Square() PROCEDURE :: Square => ApInt32_SquareSub !> **Type-Bound Function**: Compare <br> !  **Purpose**:  To compare two ApInt32 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = LHS%Compare(RHS) <br> !   --->    IF (LHS%Compare(RHS) /= 0) DoSomething PROCEDURE :: Compare => ApInt32_Compare !> **Type-Bound Subroutine**: LShift <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%LShift(112) PROCEDURE :: LShift => ApInt32_LeftShift !> **Type-Bound Subroutine**: RShift <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    CALL ApNum%RShift(112) PROCEDURE :: RShift => ApInt32_RightShift !> **Type-Bound Function**: IsZero <br> !  **Purpose**:  To check whether the ApInt32 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsZero() <br> !   --->    IF (.NOT.ApNum%IsZero()) DoSomething PROCEDURE :: IsZero => ApInt32_Is_Zero_II !> **Type-Bound Function**: IsOne <br> !  **Purpose**:  To check whether the ApInt32 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsOne() <br> !   --->    IF (.NOT.ApNum%IsOne()) DoSomething PROCEDURE :: IsOne => ApInt32_Is_One !> **Type-Bound Function**: IsPositive <br> !  **Purpose**:  To check whether the ApInt32 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsPositive() <br> !   --->    IF (.NOT.ApNum%IsPositive()) DoSomething PROCEDURE :: IsPositive => ApInt32_Is_Positive !> **Type-Bound Function**: IsNegative <br> !  **Purpose**:  To check whether the ApInt32 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = ApNum%IsNegative() <br> !   --->    IF (.NOT.ApNum%IsNegative()) DoSomething PROCEDURE :: IsNegative => ApInt32_Is_Negative !> **Type-Bound Subroutine**: RandNum <br> !  **Purpose**:  To generate the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    CALL ApNum%RandNum() <br> !   ! generate random number with specified PRNG <br> !   --->    CALL ApNum%RandNum(PRNG) <br> !   ! generate random number with negative value <br> !   --->    CALL ApNum%RandNum(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    CALL ApNum%RandNum(Length=MagLen) PROCEDURE :: RandNum => ApInt32_RandNumSub !> **Type-Bound Function**: Copy <br> !  **Purpose**:  To make a copy of the ApInt32 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt32 number <br> !   --->    DstApNum = SrcApNum%Copy() <br> !   ! make a copy of the ApInt32 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = SrcApNum%Copy(DstCap) PROCEDURE :: Copy => ApInt32_Copy !> **Type-Bound Subroutine**: Display <br> !  **Purpose**:  To write/display the 'ApInt32' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display() <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL ApNum%Display(11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL ApNum%Display(11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL ApNum%Display(ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL ApNum%Display(Prefix='Signed value of ApNum') PROCEDURE :: Display => ApInt32_Write !> **Type-Bound Function**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = ApNum%GetLength() PROCEDURE :: GetLength => ApInt32_GetLength ! --------------------------------------------------------------------- ! -----                 Generic Interfaces                         ----- ! --------------------------------------------------------------------- !> **Type-Bound Subroutine**: Add <br> !  **Purpose**:  To perform an addition: This = This + Other. <br> !  **Usage**: <br> !   --->    CALL This%Add(Other) GENERIC :: Add => ApInt32_Add_I32 , ApInt32_Add_I64 , & ApInt32_Add_I128 , ApInt32_Add_ApInt32 !> **Type-Bound Subroutine**: Subtract <br> !  **Purpose**:  To perform a subtraction: This = This - Other. <br> !  **Usage**: <br> !   --->    CALL This%Subtract(Other) GENERIC :: Subtract => ApInt32_Subtract_I32 , ApInt32_Subtract_I64 , & ApInt32_Subtract_I128 , ApInt32_Subtract_ApInt32 !> **Type-Bound Subroutine**: Multiply <br> !  **Purpose**:  To perform a multiplication: This = This * Other. <br> !  **Usage**: <br> !   --->    CALL This%Multiply(Other) GENERIC :: Multiply => ApInt32_Times_I32 , ApInt32_Times_I64 , & ApInt32_Times_I128 , ApInt32_Times_ApInt32 !> **Type-Bound Subroutine**: Divide <br> !  **Purpose**:  To perform a division: This = This / Other.  Optionally, !                return the remainder if present. <br> !  **Usage**: <br> !   --->    CALL This%Divide(Other) <br> !   --->    CALL This%Divide(Other, Remainder) GENERIC :: Divide => ApInt32_Over_I32 , ApInt32_Over_I64 , & ApInt32_Over_I128 , ApInt32_Over_ApInt32 !> **Type-Bound Subroutine**: DivMod <br> !  **Purpose**:  To perform a division and return both quotient and remainder. <br> !  **Usage**: <br> !   --->    CALL Numerator%DivMod(Denominator, Quotient, Remainder) GENERIC :: DivMod => ApInt32_DivMod_I32 , ApInt32_DivMod_I64 , & ApInt32_DivMod_I128 , ApInt32_DivMod_ApInt32 ! --------------------------------------------------------------------- END TYPE ApInt32 !** INTERFACE DEFINITIONS: !------------------------------------------------------------ ! type-bound procedure interfaces !------------------------------------------------------------ INTERFACE !------------------------------------------------------------ ! comparison !------------------------------------------------------------ MODULE FUNCTION ApInt32_Compare ( LHS , RHS ) RESULT ( Flag ) !&#94; To compare two ApInt32 numbers (LHS and RHS) and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. CLASS ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tSInt32 :: Flag END FUNCTION ApInt32_Compare !------------------------------------------------------------ ! bitwise !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_LeftShift ( Val , ShiftPos ) !&#94; To perform logical left shift with 0 <= ShiftPos <= 128. CLASS ( ApInt32 ), INTENT ( INOUT ) :: Val tSInt32 , INTENT ( IN ) :: ShiftPos END SUBROUTINE ApInt32_LeftShift !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_RightShift ( Val , ShiftPos ) !&#94; To perform logical right shift with 0 <= ShiftPos <= 128. CLASS ( ApInt32 ), INTENT ( INOUT ) :: Val tSInt32 , INTENT ( IN ) :: ShiftPos END SUBROUTINE ApInt32_RightShift !------------------------------------------------------------ ! arithmetic !------------------------------------------------------------ !------------------------------------------------------------ ! 'Plus' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Increment ( Val ) !&#94; To perform addition: Val = Val + 1. CLASS ( ApInt32 ), INTENT ( INOUT ) :: Val END SUBROUTINE ApInt32_Increment !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Add_ApInt32 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( ApInt32 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Add_ApInt32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Add_I32 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Add_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Add_I64 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Add_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Add_I128 ( This , Other ) !&#94; To perform addition: This = This + Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Add_I128 !------------------------------------------------------------ ! 'Minus' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Decrement ( Val ) !&#94; To perform subtraction: Val = Val - 1. CLASS ( ApInt32 ), INTENT ( INOUT ) :: Val END SUBROUTINE ApInt32_Decrement !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Subtract_ApInt32 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( ApInt32 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Subtract_ApInt32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Subtract_I32 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Subtract_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Subtract_I64 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Subtract_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Subtract_I128 ( This , Other ) !&#94; To perform subtraction: This = This - Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Subtract_I128 !------------------------------------------------------------ ! 'Multiply' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Times_ApInt32 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( ApInt32 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Times_ApInt32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Times_I32 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Times_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Times_I64 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Times_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Times_I128 ( This , Other ) !&#94; To perform multiplication: This = This * Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Times_I128 !------------------------------------------------------------ ! 'Divide' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_DivMod_ApInt32 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( ApInt32 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt32 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_DivMod_ApInt32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_DivMod_I32 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt32 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_DivMod_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_DivMod_I64 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt32 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_DivMod_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_DivMod_I128 ( Dividend , Divisor , Quotient , Remainder ) !&#94; To perform division (Dividend / Divisor) and return both !  the quotient and the remainder. CLASS ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ), INTENT ( OUT ) :: Quotient TYPE ( ApInt32 ), INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_DivMod_I128 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Over_ApInt32 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( ApInt32 ), INTENT ( IN ) :: Other TYPE ( ApInt32 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_Over_ApInt32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Over_I32 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt32 , INTENT ( IN ) :: Other tSInt32 , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_Over_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Over_I64 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This tSInt64 , INTENT ( IN ) :: Other tSInt64 , OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_Over_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Over_I128 ( This , Other , Remainder ) !&#94; To perform division: This = This / Other. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This TYPE ( SInt128 ), INTENT ( IN ) :: Other TYPE ( SInt128 ), OPTIONAL , INTENT ( OUT ) :: Remainder END SUBROUTINE ApInt32_Over_I128 !------------------------------------------------------------ ! 'Other' operations !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_SquareSub ( This ) !&#94; To perform self-multiplication: This = This * This. CLASS ( ApInt32 ), INTENT ( INOUT ) :: This END SUBROUTINE ApInt32_SquareSub !------------------------------------------------------------ ! auxiliary !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_Copy ( Source , Capacity ) RESULT ( Destination ) !&#94; To make a copy of the ApInt32 number. CLASS ( ApInt32 ), INTENT ( IN ) :: Source !! the source number !> capacity (size of magnitude array) of the destination number <br> !  if specified, must be greater than capacity of the source number tIndex , OPTIONAL , INTENT ( IN ) :: Capacity TYPE ( ApInt32 ) :: Destination !! the destination number END FUNCTION ApInt32_Copy !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt32_Write ( Big , Unit , IOStat , IOMsg , ShowComponent , Prefix ) !&#94; To write the ApInt32 number to the screen (or the specified unit). CLASS ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 , OPTIONAL , INTENT ( IN ) :: Unit !! output logical unit tSInt32 , OPTIONAL , INTENT ( OUT ) :: IOStat !! io stat tCharStar , OPTIONAL , INTENT ( OUT ) :: IOMsg !! io message tLogical , OPTIONAL , INTENT ( IN ) :: ShowComponent !&#94; flag indicating whether to write the upper and lower components. <br> ! - If flag is present and true, write components of the object. <br> ! - Otherwise, write the object as a decimal string. tCharStar , OPTIONAL , INTENT ( IN ) :: Prefix !! prefix string END SUBROUTINE ApInt32_Write !------------------------------------------------------------------------------ MODULE FUNCTION ZeroApInt32 () RESULT ( Big ) !&#94; To return the ApInt32 number with value of zero. TYPE ( ApInt32 ) :: Big END FUNCTION ZeroApInt32 !------------------------------------------------------------------------------ MODULE FUNCTION OneApInt32 () RESULT ( Big ) !&#94; To return the ApInt32 number with value of one. TYPE ( ApInt32 ) :: Big END FUNCTION OneApInt32 !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_Is_Zero_II ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt32 number has value of zero or not. CLASS ( ApInt32 ), INTENT ( INOUT ) :: Big tLogical :: Flag END FUNCTION ApInt32_Is_Zero_II !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_Is_One ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt32 number has value of one or not. CLASS ( ApInt32 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt32_Is_One !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_Is_Positive ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt32 number has positive value or not. CLASS ( ApInt32 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt32_Is_Positive !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_Is_Negative ( Big ) RESULT ( Flag ) !&#94; To check whether the ApInt32 number has negative value or not. CLASS ( ApInt32 ), INTENT ( IN ) :: Big tLogical :: Flag END FUNCTION ApInt32_Is_Negative !------------------------------------------------------------------------------ MODULE SUBROUTINE ApInt32_RandNumSub ( BigRnd , Prng , Positive , Length ) !&#94; To generate the ApIn64 number with random value. CLASS ( ApInt32 ), INTENT ( OUT ) :: BigRnd !! the ApInt32 number with random value CLASS ( BaseRNG ), OPTIONAL , TARGET , INTENT ( INOUT ) :: Prng !! pseudo-random number generator tLogical , OPTIONAL , INTENT ( IN ) :: Positive !! flag indicating whether the number has positive value or not tIndex , OPTIONAL , INTENT ( IN ) :: Length !! number indicating the length of magnitude array END SUBROUTINE ApInt32_RandNumSub !------------------------------------------------------------------------------ MODULE FUNCTION ApInt32_GetLength ( Num ) RESULT ( Length ) !&#94; To return the number of digits counted as the ApNum number. CLASS ( ApInt32 ), INTENT ( IN ) :: Num tIndex :: Length !! the number of digits counted END FUNCTION ApInt32_GetLength !------------------------------------------------------------ END INTERFACE !** GENERIC DEFINITIONS: !-------------------------------------------------------------------------- !   assignment !-------------------------------------------------------------------------- INTERFACE ASSIGNMENT ( = ) !&#94; **Operator Overload**: ASSIGNMENT(=) <br> !  **Purpose**:  To convert between the ApInt32 type and a signed integer !       (32-bit, 64-bit, 128-bit or arbitrary-precision integer). <br> !  **Usage**: <br> !   ! convert 64-bit signed integer to the ApInt32 type <br> !   --->    ApNum = I64 <br> !   ! convert the ApInt32 type to 128-bit signed integer <br> !   --->    I128 = ApNum MODULE SUBROUTINE ApInt32_Assign ( This , Other ) !&#94; To make a copy of the *ApInt32* number via an assignment expression. <br> !  *Usage*: This = Other TYPE ( ApInt32 ), INTENT ( OUT ) :: This TYPE ( ApInt32 ), INTENT ( IN ) :: Other END SUBROUTINE ApInt32_Assign !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_From_I32 ( Big , I32 ) !&#94; To convert from a 32-bit signed integer to an ApInt32 number !  via an assignment expression. <br> !  *Usage*: Big = I32 TYPE ( ApInt32 ), INTENT ( OUT ) :: Big tSInt32 , INTENT ( IN ) :: I32 END SUBROUTINE ApInt32_From_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_From_I64 ( Big , I64 ) !&#94; To convert from a 64-bit signed integer to an ApInt32 number !  via an assignment expression. <br> !  *Usage*: Big = I64 TYPE ( ApInt32 ), INTENT ( OUT ) :: Big tSInt64 , INTENT ( IN ) :: I64 END SUBROUTINE ApInt32_From_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_From_I128 ( Big , I128 ) !&#94; To convert from a 128-bit signed integer to an ApInt32 number !  via an assignment expression. <br> !  *Usage*: Big = I128 TYPE ( ApInt32 ), INTENT ( OUT ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 END SUBROUTINE ApInt32_From_I128 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_To_I32 ( I32 , Big ) !&#94; To convert from an ApInt32 number to a 32-bit signed integer !  via an assignment expression. <br> !  *Usage*: I32 = Big tSInt32 , INTENT ( OUT ) :: I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt32_To_I32 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_To_I64 ( I64 , Big ) !&#94; To convert from an ApInt32 number to a 64-bit signed integer !  via an assignment expression. <br> !  *Usage*: I64 = Big tSInt64 , INTENT ( OUT ) :: I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt32_To_I64 !------------------------------------------------------------ MODULE SUBROUTINE ApInt32_To_I128 ( I128 , Big ) !&#94; To convert from an ApInt32 number to a 128-bit signed integer !  via an assignment expression. <br> !  *Usage*: I128 = Big TYPE ( SInt128 ), INTENT ( OUT ) :: I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big END SUBROUTINE ApInt32_To_I128 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   constructor !-------------------------------------------------------------------------- INTERFACE ApInt32 !&#94; **Constructor Interface**: ApInt32 <br> !  **Purpose**:  To construct an ApInt32 number. <br> !  **Usage**: <br> !   ! construct ApNum from a magnitude array <br> !   --->    ApNum = ApInt32(Sign, MagLen, MagArray) <br> !   ! construct ApNum from 64-bit intrinsic integer treated as signed <br> !   --->    ApNum = ApInt32(I64) <br> !   ! construct ApNum from 32-bit intrinsic integer treated as unsigned <br> !   --->    ApNum = ApInt32(Sign, U32) <br> !   ! construct ApNum from 128-bit real number <br> !   --->    ApNum = ApInt32(R128) <br> !   ! construct ApNum from a decimal string <br> !   --->    ApNum = ApInt32('-123456789098765432101122334455667788990012345') MODULE FUNCTION Construct_ApInt32 ( Sign , Length , Digit ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 32-bit integer !  magnitude array and related data. <br> !  *Usage*: ApNum = ApInt32(Sign, MagLen, MagArray) tSInt32 , INTENT ( IN ) :: Sign !! sign of the number tIndex , INTENT ( IN ) :: Length !! length of the magnitude array !> the magnitude of the number given as a 32-bit integer array where !  the first element gives the least significant 32 bits (i.e. little !  endian order) tUInt32 , INTENT ( IN ) :: Digit ( 0 : Length - 1 ) TYPE ( ApInt32 ) :: Big !! the arbitrary-precision integer number END FUNCTION Construct_ApInt32 !------------------------------------------------------------ MODULE FUNCTION Bytes_To_ApInt32 ( Sign , Length , Digit ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 8-bit integer !  magnitude array and related data. <br> !  *Usage*: ApNum = ApInt32(Sign, MagLen, MagArray) tSInt32 , INTENT ( IN ) :: Sign !! sign of the number tIndex , INTENT ( IN ) :: Length !! length of the magnitude array !> the magnitude of the number given as a 8-bit integer array where !  the first element gives the least significant 8 bits (i.e. little !  endian order) tSInt8 , INTENT ( IN ) :: Digit ( 0 : Length - 1 ) TYPE ( ApInt32 ) :: Big !! the arbitrary-precision integer number END FUNCTION Bytes_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION DecString_To_ApInt32 ( cStr , ErrFlag , ErrMsg ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified decimal string. <br> !  *Usage*:  <br> !  ---> ApNum = ApInt32('1234567890987654321011223344') <br> !  ---> ApNum = ApInt32('-987654321012345678900123123', ErrFlag) <br> !  ---> ApNum = ApInt32(NumStr, ErrMsg=Message) <br> !  ---> ApNum = ApInt32(NumStr, ErrFlag, ErrMsg) tCharStar , TARGET , INTENT ( IN ) :: cStr !! character string tLogical , OPTIONAL , INTENT ( OUT ) :: ErrFlag !! true if input is not invalid tCharAlloc , OPTIONAL , INTENT ( OUT ) :: ErrMsg !! message if input is not invalid TYPE ( ApInt32 ) :: Big !! number END FUNCTION DecString_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION U32_To_ApInt32 ( Sign , U32 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 32-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt32(Sign, U32) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number tUInt32 , INTENT ( IN ) :: U32 !! the magnitude of the number treated as unsigned TYPE ( ApInt32 ) :: Big END FUNCTION U32_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION U64_To_ApInt32 ( Sign , U64 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 64-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt32(Sign, U64) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number tUInt64 , INTENT ( IN ) :: U64 !! the magnitude of the number treated as unsigned TYPE ( ApInt32 ) :: Big END FUNCTION U64_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION U128_To_ApInt32 ( Sign , U128 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 128-bit unsigned integer. <br> !  *Usage*: ApNum = ApInt32(Sign, U128) tSInt32 , INTENT ( IN ) :: Sign !! the sign of the number TYPE ( UInt128 ), INTENT ( IN ) :: U128 !! the magnitude of the number treated as unsigned TYPE ( ApInt32 ) :: Big END FUNCTION U128_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION I32_To_ApInt32 ( I32 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 32-bit signed integer. <br> !  *Usage*: ApNum = ApInt32(I32) tSInt32 , INTENT ( IN ) :: I32 !! the 32-bit signed integer TYPE ( ApInt32 ) :: Big END FUNCTION I32_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION I64_To_ApInt32 ( I64 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 64-bit signed integer. <br> !  *Usage*: ApNum = ApInt32(I64) tSInt64 , INTENT ( IN ) :: I64 !! the 64-bit signed integer TYPE ( ApInt32 ) :: Big END FUNCTION I64_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION I128_To_ApInt32 ( I128 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 128-bit signed integer. <br> !  *Usage*: ApNum = ApInt32(I128) TYPE ( SInt128 ), INTENT ( IN ) :: I128 !! the 128-bit signed integer TYPE ( ApInt32 ) :: Big END FUNCTION I128_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION R32_To_ApInt32 ( R32 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 32-bit real number. <br> !  *Usage*: ApNum = ApInt32(R32) tRealSP , INTENT ( IN ) :: R32 !! the 32-bit real number TYPE ( ApInt32 ) :: Big END FUNCTION R32_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION R64_To_ApInt32 ( R64 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 64-bit real number. <br> !  *Usage*: ApNum = ApInt32(R64) tRealDP , INTENT ( IN ) :: R64 !! the 64-bit real number TYPE ( ApInt32 ) :: Big END FUNCTION R64_To_ApInt32 !------------------------------------------------------------ MODULE FUNCTION R128_To_ApInt32 ( R128 ) RESULT ( Big ) !&#94; To construct the *ApInt32* number based on the specified 128-bit real number. <br> !  *Usage*: ApNum = ApInt32(R128) tRealQP , INTENT ( IN ) :: R128 !! the 128-bit real number TYPE ( ApInt32 ) :: Big END FUNCTION R128_To_ApInt32 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   conversion !-------------------------------------------------------------------------- INTERFACE ToBytes !&#94; **Subroutine Interface**: ToBytes <br> !  **Purpose**:  To convert an ApInt32 number to a 8-bit integer magnitude !   array and its sign. <br> !  **Usage**: <br> !   ---> CALL ToBytes(ApNum, MagArray, Sign) MODULE SUBROUTINE Bytes_From_ApInt32 ( Big , Digit , Sign ) !&#94; To convert an ApInt32 number to a 8-bit integer magnitude array and its sign. TYPE ( ApInt32 ), INTENT ( IN ) :: Big !> the magnitude of the number given as a 8-bit integer array where !  the first element gives the least significant 8 bits (i.e. little !  endian order) tSInt8 , ALLOCATABLE , INTENT ( OUT ) :: Digit (:) tSInt32 , OPTIONAL , INTENT ( OUT ) :: Sign !! sign of the number END SUBROUTINE Bytes_From_ApInt32 END INTERFACE INTERFACE ToU32 !&#94; **Function Interface**: ToU32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U32 = ToU32(ApNum) MODULE FUNCTION U32_From_ApInt32 ( Big ) RESULT ( U32 ) !&#94; To convert the ApInt32 number to a 32-bit unsigned integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tUInt32 :: U32 !! a 32-bit integer treated as unsigned END FUNCTION U32_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToU64 !&#94; **Function Interface**: ToU64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U64 = ToU64(ApNum) MODULE FUNCTION U64_From_ApInt32 ( Big ) RESULT ( U64 ) !&#94; To convert the ApInt32 number to a 64-bit unsigned integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tUInt64 :: U64 !! a 64-bit integer treated as unsigned END FUNCTION U64_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToU128 !&#94; **Function Interface**: ToU128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit unsigned integer. <br> !  **Usage**: <br> !   --->    U128 = ToU128(ApNum) MODULE FUNCTION U128_From_ApInt32 ( Big ) RESULT ( U128 ) !&#94; To convert the ApInt32 number to a 128-bit unsigned integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( UInt128 ) :: U128 !! a 128-bit unsigned integer END FUNCTION U128_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToI32 !&#94; **Function Interface**: ToI32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit signed integer. <br> !  **Usage**: <br> !   --->    I32 = ToI32(ApNum) MODULE FUNCTION I32_From_ApInt32 ( Big ) RESULT ( I32 ) !&#94; To convert the ApInt32 number to a 32-bit signed integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 :: I32 !! a 32-bit integer treated as signed END FUNCTION I32_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToI64 !&#94; **Function Interface**: ToI64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit signed integer. <br> !  **Usage**: <br> !   --->    I64 = ToI64(ApNum) MODULE FUNCTION I64_From_ApInt32 ( Big ) RESULT ( I64 ) !&#94; To convert the ApInt32 number to a 64-bit signed integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt64 :: I64 !! a 64-bit integer treated as signed END FUNCTION I64_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToI128 !&#94; **Function Interface**: ToI128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit signed integer. <br> !  **Usage**: <br> !   --->    I128 = ToI128(ApNum) MODULE FUNCTION I128_From_ApInt32 ( Big ) RESULT ( I128 ) !&#94; To convert the ApInt32 number to a 128-bit signed integer. TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( SInt128 ) :: I128 !! a 128-bit signed integer END FUNCTION I128_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToR32 !&#94; **Function Interface**: ToR32 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   32-bit real number. <br> !  **Usage**: <br> !   --->    R32 = ToR32(ApNum) MODULE FUNCTION R32_From_ApInt32 ( Big ) RESULT ( R32 ) !&#94; To convert the ApInt32 number to a 32-bit real number. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tRealSP :: R32 END FUNCTION R32_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToR64 !&#94; **Function Interface**: ToR64 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   64-bit real number. <br> !  **Usage**: <br> !   --->    R64 = ToR64(ApNum) MODULE FUNCTION R64_From_ApInt32 ( Big ) RESULT ( R64 ) !&#94; To convert the ApInt32 number to a 64-bit real number. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tRealDP :: R64 END FUNCTION R64_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToR128 !&#94; **Function Interface**: ToR128 <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to a !   128-bit real number. <br> !  **Usage**: <br> !   --->    R128 = ToR128(ApNum) MODULE FUNCTION R128_From_ApInt32 ( Big ) RESULT ( R128 ) !&#94; To convert the ApInt32 number to a 128-bit real number. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tRealQP :: R128 END FUNCTION R128_From_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE ToDecString !&#94; **Function Interface**: ToDecString <br> !  **Purpose**:  To convert an arbitrary-precision signed integer to !   a decimal string. <br> !  **Usage**: <br> !   --->    Str = ToDecString(ApNum) MODULE FUNCTION DecString_From_ApInt32 ( Big ) RESULT ( Str ) !&#94; To convert an arbitrary-precision signed integer to a decimal string. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tCharAlloc :: Str END FUNCTION DecString_From_ApInt32 !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   comparison !-------------------------------------------------------------------------- INTERFACE OPERATOR ( == ) !&#94; **Operator Overload**: OPERATOR(==) <br> !  **Purpose**:  To check if values of two ApInt32 numbers are equal. !   Return .TRUE. if both values are equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS == RHS <br> !   --->    IF (LHS .EQ. RHS) DoSomething MODULE FUNCTION ApInt32_Equal ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether two ApInt32 numbers are equal. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_Equal !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( /= ) !&#94; **Operator Overload**: OPERATOR(/=) <br> !  **Purpose**:  To check if values of two ApInt32 numbers are NOT equal. !   Return .TRUE. if both values are NOT equal; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS /= RHS <br> !   --->    IF (LHS .NE. RHS) DoSomething MODULE FUNCTION ApInt32_NotEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether two ApInt32 numbers NOT are equal. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_NotEqual !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( < ) !&#94; **Operator Overload**: OPERATOR(<) <br> !  **Purpose**:  To check if the LHS value is less than the RHS value. !   Return .TRUE. if LHS < RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS < RHS <br> !   --->    IF (LHS .LT. RHS) DoSomething MODULE FUNCTION ApInt32_LessThan ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is less than the RHS number. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_LessThan !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( <= ) !&#94; **Operator Overload**: OPERATOR(<=) <br> !  **Purpose**:  To check if the LHS value is less than or equal to the RHS value. !   Return .TRUE. if LHS <= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS <= RHS <br> !   --->    IF (LHS .LE. RHS) DoSomething MODULE FUNCTION ApInt32_LessEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is less than or equal to the RHS number. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_LessEqual !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( > ) !&#94; **Operator Overload**: OPERATOR(>) <br> !  **Purpose**:  To check if the LHS value is greater than the RHS value. !   Return .TRUE. if LHS > RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS > RHS <br> !   --->    IF (LHS .GT. RHS) DoSomething MODULE FUNCTION ApInt32_GreaterThan ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is greater than the RHS number. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_GreaterThan !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( >= ) !&#94; **Operator Overload**: OPERATOR(>=) <br> !  **Purpose**:  To check if the LHS value is greater than or equal to the RHS value. !   Return .TRUE. if LHS >= RHS; otherwise return .FALSE.. <br> !  **Usage**: <br> !   --->    Flag = LHS >= RHS <br> !   --->    IF (LHS .GE. RHS) DoSomething MODULE FUNCTION ApInt32_GreaterEqual ( LHS , RHS ) RESULT ( Flag ) !&#94; To check whether the LHS number is greater than or equal to the RHS number. TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tLogical :: Flag END FUNCTION ApInt32_GreaterEqual !------------------------------------------------------------ END INTERFACE INTERFACE Compare !&#94; **Function Interface**: Compare <br> !  **Purpose**:  To compare two ApInt32 numbers and return <br> !   -1 if LHS < RHS, <br> !    0 if LHS == RHS, or <br> !    1 if LHS > RHS. <br> !  **Usage**: <br> !   --->    Flag = Compare(LHS, RHS) <br> !   --->    IF (Compare(LHS, RHS) /= 0) DoSomething MODULE PROCEDURE ApInt32_Compare !------------------------------------------------------------ END INTERFACE INTERFACE CompareAbs !&#94; **Function Interface**: CompareAbs <br> !  **Purpose**:  To compare the absolute values of two ApInt32 numbers and return <br> !   -1 if ABS(LHS) <  ABS(RHS), <br> !    0 if ABS(LHS) == ABS(RHS), or <br> !    1 if ABS(LHS) >  ABS(RHS). <br> !  **Usage**: <br> !   --->    Flag = CompareAbs(LHS, RHS) <br> !   --->    IF (CompareAbs(LHS, RHS) /= 0) DoSomething MODULE FUNCTION ApInt32_CompareAbs ( LHS , RHS ) RESULT ( Flag ) !&#94; To compare the absolute value of LHS and RHS. <br> ! - Return -1 if ABS(LHS) <  ABS(RHS). <br> ! - Return  0 if ABS(LHS) == ABS(RHS). <br> ! - Return +1 if ABS(LHS) >  ABS(RHS). TYPE ( ApInt32 ), INTENT ( IN ) :: LHS TYPE ( ApInt32 ), INTENT ( IN ) :: RHS tSInt32 :: Flag END FUNCTION ApInt32_CompareAbs !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   arithmetic !-------------------------------------------------------------------------- INTERFACE OPERATOR ( + ) !&#94; **Operator Overload**: OPERATOR(+) <br> !  **Purpose**:  To perform a summation of two signed integers (at least one !                of which is a ApInt32 number) or to add a unary plus sign !                to a ApInt32 number. <br> !  **Usage**: <br> !   --->    OutNum = +InNum <br> !   --->    OutNum = InNum1 + InNum2 MODULE FUNCTION ApInt32_UnaryPlus ( InVal ) RESULT ( OutVal ) !&#94; To return result of the unary plus sign of the ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_UnaryPlus !------------------------------------------------------------ MODULE FUNCTION ApInt32_Plus_ApInt32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = LhsVal + RhsVal. TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Plus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Plus_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I32. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Plus_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Plus_ApInt32 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I32 + Big. tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I32_Plus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Plus_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I64. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Plus_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Plus_ApInt32 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I64 + Big. tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I64_Plus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Plus_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = Big + I128. TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Plus_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Plus_ApInt32 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform addition: OutVal = I128 + Big. TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I128_Plus_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( - ) !&#94; **Operator Overload**: OPERATOR(-) <br> !  **Purpose**:  To perform a subtraction of two signed integers (at least one !                of which is a ApInt32 number) or to negate a ApInt32 number. <br> !  **Usage**: <br> !   --->    OutNum = -InNum <br> !   --->    OutNum = InNum1 - InNum2 MODULE FUNCTION ApInt32_Negate ( InVal ) RESULT ( OutVal ) !&#94; To negate a ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Negate !------------------------------------------------------------ MODULE FUNCTION ApInt32_Minus_ApInt32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = LhsVal - RhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Minus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Minus_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Minus_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Minus_ApInt32 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I32 - Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I32_Minus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Minus_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Minus_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Minus_ApInt32 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I64 - Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I64_Minus_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Minus_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = Big - I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Minus_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Minus_ApInt32 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform subtraction: OutVal = I128 - Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I128_Minus_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( * ) !&#94; **Operator Overload**: OPERATOR( * ) <br> !  **Purpose**:  To perform a multiplication of two signed integers (at least one !                of which is a ApInt32 number). <br> !  **Usage**: <br> !   --->    OutNum = InNum1 * InNum2 MODULE FUNCTION ApInt32_Multiply_ApInt32 ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = LhsVal * RhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Multiply_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Multiply_I32 ( Big , I32 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Multiply_I32 !------------------------------------------------------------ MODULE FUNCTION I32_Multiply_ApInt32 ( I32 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I32 * Big tSInt32 , INTENT ( IN ) :: I32 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I32_Multiply_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Multiply_I64 ( Big , I64 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Multiply_I64 !------------------------------------------------------------ MODULE FUNCTION I64_Multiply_ApInt32 ( I64 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I64 * Big tSInt64 , INTENT ( IN ) :: I64 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I64_Multiply_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Multiply_I128 ( Big , I128 ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = Big * I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Multiply_I128 !------------------------------------------------------------ MODULE FUNCTION I128_Multiply_ApInt32 ( I128 , Big ) RESULT ( OutVal ) !&#94; To perform multiplication: OutVal = I128 * Big TYPE ( SInt128 ), INTENT ( IN ) :: I128 TYPE ( ApInt32 ), INTENT ( IN ) :: Big TYPE ( ApInt32 ) :: OutVal END FUNCTION I128_Multiply_ApInt32 !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( / ) !&#94; **Operator Overload**: OPERATOR(/) <br> !  **Purpose**:  To return the quotient of a division of two signed integers, !                where the dividend (numerator) is a ApInt32 number and the !                divisor (denominator) can be any signed integer. <br> !  **Usage**: <br> !   --->    Quotient = Dividend / Divisor MODULE FUNCTION ApInt32_Divide_ApInt32 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( ApInt32 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Quotient END FUNCTION ApInt32_Divide_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Divide_I32 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Quotient END FUNCTION ApInt32_Divide_I32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Divide_I64 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Quotient END FUNCTION ApInt32_Divide_I64 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Divide_I128 ( Dividend , Divisor ) RESULT ( Quotient ) !&#94; To perform division: Quotient = Dividend / Divisor. TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Quotient END FUNCTION ApInt32_Divide_I128 !------------------------------------------------------------ END INTERFACE INTERFACE MOD !&#94; **Function Interface**: MOD <br> !  **Purpose**:  To return the remainder of a division of two signed integers, !                where the dividend (numerator) is a ApInt32 number and the !                divisor (denominator) can be any signed integer. <br> !  **Usage**: <br> !   --->    Remainder = MOD(Dividend, Divisor) MODULE FUNCTION ApInt32_Mod_ApInt32 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( ApInt32 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Remainder END FUNCTION ApInt32_Mod_ApInt32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Mod_I32 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt32 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Remainder END FUNCTION ApInt32_Mod_I32 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Mod_I64 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend tSInt64 , INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Remainder END FUNCTION ApInt32_Mod_I64 !------------------------------------------------------------ MODULE FUNCTION ApInt32_Mod_I128 ( Dividend , Divisor ) RESULT ( Remainder ) !&#94; To perform modulation:  Remainder = Dividend Mod Divisor TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( SInt128 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Remainder END FUNCTION ApInt32_Mod_I128 !------------------------------------------------------------ END INTERFACE INTERFACE MODULO !&#94; **Function Interface**: MODULO <br> !  **Purpose**:  To compute the modulo of two ApInt32 numbers. <br> !  **Usage**: <br> !   --->    Modulo = MODULO(Dividend, Divisor) MODULE FUNCTION ApInt32_Modulo ( Dividend , Divisor ) RESULT ( Modulo ) !&#94; To compute the modulo of two ApInt32 numbers. TYPE ( ApInt32 ), INTENT ( IN ) :: Dividend TYPE ( ApInt32 ), INTENT ( IN ) :: Divisor TYPE ( ApInt32 ) :: Modulo END FUNCTION ApInt32_Modulo !------------------------------------------------------------ END INTERFACE INTERFACE OPERATOR ( ** ) !&#94; **Operator Overload**: OPERATOR( ** ) <br> !  **Purpose**:  To perform an exponentiation of the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumOut = NumIn**Exp MODULE FUNCTION ApInt32_Power ( BigIn , Exp ) RESULT ( BigOut ) !&#94; To perform an exponentiation: BigOut = BigIn**Exp TYPE ( ApInt32 ), INTENT ( IN ) :: BigIn tSInt32 , INTENT ( IN ) :: Exp TYPE ( ApInt32 ) :: BigOut END FUNCTION ApInt32_Power !------------------------------------------------------------ END INTERFACE INTERFACE SQR !&#94; **Function Interface**: SQR <br> !  **Purpose**:  To compute the square of the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumSqr = SQR(ApNum) MODULE FUNCTION ApInt32_Square ( BigIn ) RESULT ( BigOut ) !&#94; To perform squaring: BigOut = BigIn * BigIn. TYPE ( ApInt32 ), INTENT ( IN ) :: BigIn TYPE ( ApInt32 ) :: BigOut END FUNCTION ApInt32_Square !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   bitwise !-------------------------------------------------------------------------- INTERFACE SHIFTL !&#94; **Function Interface**: SHIFTL <br> !  **Purpose**:  To perform logical left shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    NumOut = SHIFTL(NumIn, 157) MODULE FUNCTION ApInt32_ShiftLeft ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical left shift where ShiftPos is non-negative. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_ShiftLeft !------------------------------------------------------------ END INTERFACE INTERFACE SHIFTR !&#94; **Function Interface**: SHIFTR <br> !  **Purpose**:  To perform logical right shift where ShiftPos is non-negative. <br> !  **Usage**: <br> !   --->    NumOut = SHIFTR(NumIn, 141) MODULE FUNCTION ApInt32_ShiftRight ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical right shift where ShiftPos is non-negative. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_ShiftRight !------------------------------------------------------------ END INTERFACE INTERFACE ISHFT !&#94; **Function Interface**: ISHFT <br> !  **Purpose**:  To perform logical shift of an ApInt32 number. <br> !  **Usage**: <br> !   --->    NumOut = ISHFT(NumIn, 153)    ! a logical left shift by 153 <br> !   --->    NumOut = ISHFT(NumIn, -224)   ! a logical right shift by 224 MODULE FUNCTION ApInt32_LogicalShift ( InVal , ShiftPos ) RESULT ( OutVal ) !&#94; To perform logical shift of an ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: ShiftPos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_LogicalShift !------------------------------------------------------------ END INTERFACE INTERFACE NOT !&#94; **Function Interface**: NOT <br> !  **Purpose**:  To return the bitwise logical complement an ApInt32 number. <br> !  **Usage**: <br> !   --->    NumOut = NOT(NumIn) MODULE FUNCTION ApInt32_Not ( InVal ) RESULT ( OutVal ) !&#94; To return the bitwise logical complement an ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: InVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Not !------------------------------------------------------------ END INTERFACE INTERFACE IOR !&#94; **Function Interface**: IOR <br> !  **Purpose**:  To perform an inclusive OR on corresponding bits of two !                ApInt32 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IOR(NumIn1, NumIn2) MODULE FUNCTION ApInt32_Ior ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform an inclusive OR on corresponding bits of two ApInt32 numbers. TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Ior !------------------------------------------------------------ END INTERFACE INTERFACE IEOR !&#94; **Function Interface**: IEOR <br> !  **Purpose**:  To perform an exclusive OR on corresponding bits of two !                ApInt32 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IEOR(NumIn1, NumIn2) MODULE FUNCTION ApInt32_Ieor ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform an exclusive OR on corresponding bits of two ApInt32 numbers. TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Ieor !------------------------------------------------------------ END INTERFACE INTERFACE IAND !&#94; **Function Interface**: IAND <br> !  **Purpose**:  To perform a logical AND on corresponding bits of two !                ApInt32 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IAND(NumIn1, NumIn2) MODULE FUNCTION ApInt32_Iand ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform a logical AND on corresponding bits of two ApInt32 numbers. TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_Iand !------------------------------------------------------------ END INTERFACE INTERFACE IAND_NOT !&#94; **Function Interface**: IAND_NOT <br> !  **Purpose**:  To perform a bitwise AND and NOT on corresponding bits of two !                ApInt32 numbers. <br> !  **Usage**: <br> !   --->    NumOut = IAND_NOT(NumIn1, NumIn2) <br> !  **Note**: IAND_NOT(NumIn1, NumIn2) is equal to IAND(NumIn1, NOT(NumIn2)). MODULE FUNCTION ApInt32_IandNot ( LhsVal , RhsVal ) RESULT ( OutVal ) !&#94; To perform a bitwise AND and NOT on corresponding bits of two ApInt32 numbers. TYPE ( ApInt32 ), INTENT ( IN ) :: LhsVal TYPE ( ApInt32 ), INTENT ( IN ) :: RhsVal TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_IandNot !------------------------------------------------------------ END INTERFACE INTERFACE LEADZ !&#94; **Function Interface**: LEADZ <br> !  **Purpose**:  To count the number of leading zero bits of the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumLZ = LEADZ(ApNum) MODULE FUNCTION ApInt32_LeadingZeros ( Big ) RESULT ( NumLZ ) !&#94; To count the number of leading zero bits of the ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 :: NumLZ END FUNCTION ApInt32_LeadingZeros !------------------------------------------------------------ END INTERFACE INTERFACE TRAILZ !&#94; **Function Interface**: TRAILZ <br> !  **Purpose**:  To count the number of trailing zero bits of the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumTZ = TRAILZ(ApNum) MODULE FUNCTION ApInt32_TrailingZeros ( Big ) RESULT ( NumTZ ) !&#94; To count the number of trailing zero bits of the ApInt32 number. TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 :: NumTZ END FUNCTION ApInt32_TrailingZeros !------------------------------------------------------------ END INTERFACE INTERFACE POPCNT !&#94; **Function Interface**: POPCNT <br> !  **Purpose**:  To count the number of 1 bits in the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumBits = POPCNT(ApNum) MODULE FUNCTION ApInt32_Count1Bits ( Big ) RESULT ( NumBits ) !&#94; To count the number of 1 bits in the ApInt32 number.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 :: NumBits END FUNCTION ApInt32_Count1Bits !------------------------------------------------------------ END INTERFACE INTERFACE POPPAR !&#94; **Function Interface**: POPPAR <br> !  **Purpose**:  To determine the parity of the ApInt32 number. <br> !  **Usage**: <br> !   --->    NumPar = POPPAR(ApNum) MODULE FUNCTION ApInt32_Parity ( Big ) RESULT ( ParNum ) !&#94; To determine the parity of the ApInt32 number.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 :: ParNum END FUNCTION ApInt32_Parity !------------------------------------------------------------ END INTERFACE INTERFACE IBSET !&#94; **Function Interface**: IBSET <br> !  **Purpose**:  To set the bit at the specified position to 1. <br> !  **Usage**: <br> !   --->    NumOut = IBSET(NumIn, Pos) MODULE FUNCTION ApInt32_SetBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To set the bit at the specified position to 1.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_SetBit !------------------------------------------------------------ END INTERFACE INTERFACE IBCLR !&#94; **Function Interface**: IBCLR <br> !  **Purpose**:  To set the bit at the specified position to 0. <br> !  **Usage**: <br> !   --->    NumOut = IBCLR(NumIn, Pos) MODULE FUNCTION ApInt32_ClearBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To set the bit at the specified position to 0.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_ClearBit !------------------------------------------------------------ END INTERFACE INTERFACE IBCHNG !&#94; **Function Interface**: IBCHNG <br> !  **Purpose**:  To reverse the bit at the specified position. <br> !  **Usage**: <br> !   --->    NumOut = IBCHNG(NumIn, Pos) MODULE FUNCTION ApInt32_FlipBit ( InVal , Pos ) RESULT ( OutVal ) !&#94; To reverse the bit at the specified position.  (For more information, !  see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: InVal tSInt32 , INTENT ( IN ) :: Pos TYPE ( ApInt32 ) :: OutVal END FUNCTION ApInt32_FlipBit !------------------------------------------------------------ END INTERFACE INTERFACE BTEST !&#94; **Function Interface**: BTEST <br> !  **Purpose**:  To check whether the bit at the specified position !                is 0 (False) or 1 (True). <br> !  **Usage**: <br> !   --->    Flag = BTEST(ApNum, Pos) MODULE FUNCTION ApInt32_TestBit ( Big , Pos ) RESULT ( Flag ) !&#94; To check whether the bit at the specified position is 0 (False) or 1 (True). !  (For more information, see detailed explanation of the intrinsic function.) TYPE ( ApInt32 ), INTENT ( IN ) :: Big tSInt32 , INTENT ( IN ) :: Pos tLogical :: Flag END FUNCTION ApInt32_TestBit !------------------------------------------------------------ END INTERFACE !-------------------------------------------------------------------------- !   miscellaneous !-------------------------------------------------------------------------- INTERFACE ABS !&#94; **Function Interface**: ABS <br> !  **Purpose**:  To return the absolute value of the ApInt32 number. <br> !  **Usage**: <br> !   --->    AbsNum = ABS(ApNum) MODULE PROCEDURE ApInt32_Absolute END INTERFACE INTERFACE IsZero !&#94; **Function Interface**: IsZero <br> !  **Purpose**:  To check whether the ApInt32 number has value of zero or not. <br> !  **Usage**: <br> !   --->    Flag = IsZero(ApNum) <br> !   --->    IF (IsZero(ApNum)) DoSomeThing MODULE PROCEDURE ApInt32_Is_Zero END INTERFACE INTERFACE IsOne !&#94; **Function Interface**: IsOne <br> !  **Purpose**:  To check whether the ApInt32 number has value of one or not. <br> !  **Usage**: <br> !   --->    Flag = IsOne(ApNum) <br> !   --->    IF (IsOne(ApNum)) DoSomeThing MODULE PROCEDURE ApInt32_Is_One END INTERFACE INTERFACE IsPositive !&#94; **Function Interface**: IsPositive <br> !  **Purpose**:  To check whether the ApInt32 number has positive value or not. <br> !  **Usage**: <br> !   --->    Flag = IsPositive(ApNum) <br> !   --->    IF (IsPositive(ApNum)) DoSomeThing MODULE PROCEDURE ApInt32_Is_Positive END INTERFACE INTERFACE IsNegative !&#94; **Function Interface**: IsNegative <br> !  **Purpose**:  To check whether the ApInt32 number has negative value or not. <br> !  **Usage**: <br> !   --->    Flag = IsNegative(ApNum) <br> !   --->    IF (IsNegative(ApNum)) DoSomeThing MODULE PROCEDURE ApInt32_Is_Negative END INTERFACE INTERFACE RandNumApInt32 !> **Function Interface**: RandNumApInt32 <br> !  **Purpose**:  To generate and return the ApIn64 number with random value. <br> !  **Usage**: <br> !   ! generate random number with default settings <br> !   --->    ApNum = RandNumApInt32() <br> !   ! generate random number with specified PRNG <br> !   --->    ApNum = RandNumApInt32(PRNG) <br> !   ! generate random number with negative value <br> !   --->    ApNum = RandNumApInt32(Positive=.FALSE.) <br> !   ! generate random number with specified length of magnitude array <br> !   --->    ApNum = RandNumApInt32(Length=MagLen) MODULE FUNCTION ApInt32_Random_Number ( Prng , Positive , Length ) RESULT ( BigRnd ) !&#94; To generate the ApIn64 number with random value. CLASS ( BaseRNG ), OPTIONAL , TARGET , INTENT ( INOUT ) :: Prng !! pseudo-random number generator tLogical , OPTIONAL , INTENT ( IN ) :: Positive !! flag indicating whether the number has positive value or not tIndex , OPTIONAL , INTENT ( IN ) :: Length !! number indicating the length of magnitude array TYPE ( ApInt32 ) :: BigRnd !! the ApInt32 number with random value END FUNCTION ApInt32_Random_Number !------------------------------------------------------------------------------ END INTERFACE INTERFACE Display !&#94; **Subroutine Interface**: Display <br> !  **Purpose**:  To write/display the 'ApInt32' number to the screen (or the specified unit). <br> !  **Usage**: <br> !   ! To display (signed) value of ApNum as a decimal string to the screen <br> !   --->    CALL Display(ApNum) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   --->    CALL Display(ApNum, 11) <br> !   ! To display (signed) value of ApNum as a decimal string to the output logical unit <br> !   with input/output status and message <br> !   --->    CALL Display(ApNum, 11, IOStat, IOMsg) <br> !   ! To display (signed) values of components of ApNum as a decimal string to the screen <br> !   --->    CALL Display(ApNum, ShowComponent=.TRUE.) <br> !   ! To display (signed) value of ApNum as a decimal string to the screen with a prefix string <br> !   --->    CALL Display(ApNum, Prefix='Signed value of ApNum') MODULE PROCEDURE ApInt32_Write END INTERFACE INTERFACE MakeCopy !&#94; **Function Interface**: Copy <br> !  **Purpose**:  To make a copy of the ApInt32 number. <br> !  **Usage**: <br> !   ! make a copy of the ApInt32 number <br> !   --->    DstApNum = MakeCopy(SrcApNum) <br> !   ! make a copy of the ApInt32 number with the specified capacity !   (size of magnitude array) of the destination number <br> !   --->    DstApNum = MakeCopy(SrcApNum, DstCap) MODULE PROCEDURE ApInt32_Copy END INTERFACE INTERFACE GetLength !&#94; **Function Interface**: GetLength <br> !  **Purpose**:  To return the length of the magnitude array (the number of !                digits counted as the ApNum number). <br> !  **Usage**: <br> !   --->    MagLen = GetLength(ApNum) MODULE PROCEDURE ApInt32_GetLength END INTERFACE !-------------------------------------------------------------------------- !** MODULE VARIABLE DECLARATIONS: ! na CONTAINS !** MODULE PROCEDURES (SUBROUTINES OR FUNCTIONS): !****************************************************************************** FUNCTION ApInt32_Is_Zero ( Big ) RESULT ( Flag ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To check whether the number is zero or not. ! ** Technical notes**: !   Zero can have many forms: !   - The most common form is set through ZeroApInt32() where Digit(0) = 0 and Length = 1. !   - If Digit has not yet been allocated or Length is less than 1, the number is also !     considered to be zero. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ApInt32 ), INTENT ( IN ) :: Big tLogical :: Flag !! true if value is zero. !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW IF ( ALLOCATED ( Big % Digit )) THEN IF ( Big % Length >= 1_kIndex ) THEN Flag = ( Big % Length == 1_kIndex ). AND .( Big % Digit ( 0 ) == 0 ) ELSE ! length is less than 1 Flag = TrueVal END IF ELSE ! digit not yet allocated Flag = TrueVal END IF RETURN END FUNCTION ApInt32_Is_Zero !****************************************************************************** FUNCTION ApInt32_Absolute ( Num ) RESULT ( Abs ) !** PURPOSE OF THIS SUBROUTINE: !&#94; To get the absolute value of the specified number. !** SUBROUTINE ARGUMENT DECLARATIONS: TYPE ( ApInt32 ), INTENT ( IN ) :: Num TYPE ( ApInt32 ) :: Abs !** SUBROUTINE INTERNAL VARIABLE DECLARATIONS: ! na !** FLOW Abs = MakeCopy ( Num ) IF ( Abs % Sign < 0 ) Abs % Sign = - Abs % Sign RETURN END FUNCTION ApInt32_Absolute !****************************************************************************** END MODULE MClass_ApInt32 !******************************************************************************","tags":"","loc":"sourcefile\\mclass_apint32.f90.html"}]}